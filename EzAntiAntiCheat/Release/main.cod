; Listing generated by Microsoft (R) Optimizing Compiler Version 19.44.35215.0 

	TITLE	C:\EzAntiAntiCheat\EzAntiAntiCheat\Release\main.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_ServiceInstalled@@3_NA			; g_ServiceInstalled
PUBLIC	?g_hService@@3PAUSC_HANDLE__@@A			; g_hService
PUBLIC	?g_hSCManager@@3PAUSC_HANDLE__@@A		; g_hSCManager
PUBLIC	__Avx2WmemEnabledWeakValue
_BSS	SEGMENT
?g_ServiceInstalled@@3_NA DB 01H DUP (?)		; g_ServiceInstalled
	ALIGN	4

?g_hService@@3PAUSC_HANDLE__@@A DD 01H DUP (?)		; g_hService
?g_hSCManager@@3PAUSC_HANDLE__@@A DD 01H DUP (?)	; g_hSCManager
_BSS	ENDS
;	COMDAT __Avx2WmemEnabledWeakValue
_BSS	SEGMENT
__Avx2WmemEnabledWeakValue DD 01H DUP (?)
_BSS	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_sprintf_s
PUBLIC	_wmemcmp
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAAV?$allocator@_W@2@QA_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Deallocate_for_capacity
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
PUBLIC	?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find
PUBLIC	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
PUBLIC	??_Gruntime_error@std@@UAEPAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
PUBLIC	??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
PUBLIC	??0_System_error@std@@QAE@ABV01@@Z		; std::_System_error::_System_error
PUBLIC	??_G_System_error@std@@UAEPAXI@Z		; std::_System_error::`scalar deleting destructor'
PUBLIC	??1system_error@std@@UAE@XZ			; std::system_error::~system_error
PUBLIC	??0system_error@std@@QAE@ABV01@@Z		; std::system_error::system_error
PUBLIC	??_Gsystem_error@std@@UAEPAXI@Z			; std::system_error::`scalar deleting destructor'
PUBLIC	?name@_Iostream_error_category2@std@@UBEPBDXZ	; std::_Iostream_error_category2::name
PUBLIC	?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category2::message
PUBLIC	??_G_Iostream_error_category2@std@@UAEPAXI@Z	; std::_Iostream_error_category2::`scalar deleting destructor'
PUBLIC	??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>
PUBLIC	??0bad_cast@std@@QAE@XZ				; std::bad_cast::bad_cast
PUBLIC	??1bad_cast@std@@UAE@XZ				; std::bad_cast::~bad_cast
PUBLIC	??0bad_cast@std@@QAE@ABV01@@Z			; std::bad_cast::bad_cast
PUBLIC	??_Gbad_cast@std@@UAEPAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	?_Throw_bad_cast@std@@YAXXZ			; std::_Throw_bad_cast
PUBLIC	??1_Facet_base@std@@UAE@XZ			; std::_Facet_base::~_Facet_base
PUBLIC	??_G_Facet_base@std@@UAEPAXI@Z			; std::_Facet_base::`scalar deleting destructor'
PUBLIC	??0_Locinfo@std@@QAE@PBD@Z			; std::_Locinfo::_Locinfo
PUBLIC	??1_Locinfo@std@@QAE@XZ				; std::_Locinfo::~_Locinfo
PUBLIC	??1?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::~_Yarn<char>
PUBLIC	??1?$_Yarn@_W@std@@QAE@XZ			; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
PUBLIC	?_Incref@facet@locale@std@@UAEXXZ		; std::locale::facet::_Incref
PUBLIC	?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ; std::locale::facet::_Decref
PUBLIC	??1facet@locale@std@@MAE@XZ			; std::locale::facet::~facet
PUBLIC	??_Gfacet@locale@std@@MAEPAXI@Z			; std::locale::facet::`scalar deleting destructor'
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
PUBLIC	?do_always_noconv@codecvt_base@std@@MBE_NXZ	; std::codecvt_base::do_always_noconv
PUBLIC	?do_max_length@codecvt_base@std@@MBEHXZ		; std::codecvt_base::do_max_length
PUBLIC	?do_encoding@codecvt_base@std@@MBEHXZ		; std::codecvt_base::do_encoding
PUBLIC	??_Gcodecvt_base@std@@UAEPAXI@Z			; std::codecvt_base::`scalar deleting destructor'
PUBLIC	??1ctype_base@std@@UAE@XZ			; std::ctype_base::~ctype_base
PUBLIC	??_Gctype_base@std@@UAEPAXI@Z			; std::ctype_base::`scalar deleting destructor'
PUBLIC	??1?$ctype@D@std@@MAE@XZ			; std::ctype<char>::~ctype<char>
PUBLIC	?do_tolower@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_tolower
PUBLIC	?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_tolower
PUBLIC	?do_toupper@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_toupper
PUBLIC	?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_toupper
PUBLIC	?do_widen@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_widen
PUBLIC	?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z	; std::ctype<char>::do_widen
PUBLIC	?do_narrow@?$ctype@D@std@@MBEDDD@Z		; std::ctype<char>::do_narrow
PUBLIC	?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z	; std::ctype<char>::do_narrow
PUBLIC	??_G?$ctype@D@std@@MAEPAXI@Z			; std::ctype<char>::`scalar deleting destructor'
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	??1?$ctype@_W@std@@MAE@XZ			; std::ctype<wchar_t>::~ctype<wchar_t>
PUBLIC	?do_is@?$ctype@_W@std@@MBE_NF_W@Z		; std::ctype<wchar_t>::do_is
PUBLIC	?do_is@?$ctype@_W@std@@MBEPB_WPB_W0PAF@Z	; std::ctype<wchar_t>::do_is
PUBLIC	?do_scan_is@?$ctype@_W@std@@MBEPB_WFPB_W0@Z	; std::ctype<wchar_t>::do_scan_is
PUBLIC	?do_scan_not@?$ctype@_W@std@@MBEPB_WFPB_W0@Z	; std::ctype<wchar_t>::do_scan_not
PUBLIC	?do_tolower@?$ctype@_W@std@@MBE_W_W@Z		; std::ctype<wchar_t>::do_tolower
PUBLIC	?do_tolower@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z	; std::ctype<wchar_t>::do_tolower
PUBLIC	?do_toupper@?$ctype@_W@std@@MBE_W_W@Z		; std::ctype<wchar_t>::do_toupper
PUBLIC	?do_toupper@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z	; std::ctype<wchar_t>::do_toupper
PUBLIC	?do_widen@?$ctype@_W@std@@MBE_WD@Z		; std::ctype<wchar_t>::do_widen
PUBLIC	?do_widen@?$ctype@_W@std@@MBEPBDPBD0PA_W@Z	; std::ctype<wchar_t>::do_widen
PUBLIC	?do_narrow@?$ctype@_W@std@@MBED_WD@Z		; std::ctype<wchar_t>::do_narrow
PUBLIC	?do_narrow@?$ctype@_W@std@@MBEPB_WPB_W0DPAD@Z	; std::ctype<wchar_t>::do_narrow
PUBLIC	??_G?$ctype@_W@std@@MAEPAXI@Z			; std::ctype<wchar_t>::`scalar deleting destructor'
PUBLIC	??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
PUBLIC	??1failure@ios_base@std@@UAE@XZ			; std::ios_base::failure::~failure
PUBLIC	??0failure@ios_base@std@@QAE@ABV012@@Z		; std::ios_base::failure::failure
PUBLIC	??_Gfailure@ios_base@std@@UAEPAXI@Z		; std::ios_base::failure::`scalar deleting destructor'
PUBLIC	?clear@ios_base@std@@QAEXH_N@Z			; std::ios_base::clear
PUBLIC	??1ios_base@std@@UAE@XZ				; std::ios_base::~ios_base
PUBLIC	??_Gios_base@std@@UAEPAXI@Z			; std::ios_base::`scalar deleting destructor'
PUBLIC	??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z		; std::_Fputc<char>
PUBLIC	?SendIoctl@@YA_NKPAXK0K@Z			; SendIoctl
PUBLIC	?RunMenu@@YAXXZ					; RunMenu
PUBLIC	?CleanupOnExit@@YAXXZ				; CleanupOnExit
PUBLIC	?ConsoleHandler@@YGHK@Z				; ConsoleHandler
PUBLIC	?IsSafeWipePath@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IsSafeWipePath
PUBLIC	?IsFileOwnerSystemOrAdmin@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; IsFileOwnerSystemOrAdmin
PUBLIC	?SecureWipeFile@@YAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@T_LARGE_INTEGER@@@Z ; SecureWipeFile
PUBLIC	??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
PUBLIC	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
PUBLIC	?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ; std::basic_ios<char,std::char_traits<char> >::init
PUBLIC	??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >
PUBLIC	??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ios<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >
PUBLIC	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
PUBLIC	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
PUBLIC	??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ostream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
PUBLIC	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
PUBLIC	?ListAndWipeProcess@@YAXXZ			; ListAndWipeProcess
PUBLIC	??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
PUBLIC	?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Tidy
PUBLIC	?_Xlength@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Xlength
PUBLIC	??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
PUBLIC	?_Xlength@?$vector@KV?$allocator@K@std@@@std@@CAXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlength
PUBLIC	?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::setstate
PUBLIC	?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
PUBLIC	??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@H@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::operator<<
PUBLIC	??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::operator<<
PUBLIC	?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush
PUBLIC	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
PUBLIC	?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
PUBLIC	?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_istream<char,std::char_traits<char> >::get
PUBLIC	?ignore@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z ; std::basic_istream<char,std::char_traits<char> >::ignore
PUBLIC	??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_istream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
PUBLIC	?IsSystemAccount@@YA_NXZ			; IsSystemAccount
PUBLIC	?EnsureTestSigningAndDisableSecureBoot@@YA_NXZ	; EnsureTestSigningAndDisableSecureBoot
PUBLIC	?RetrieveAndWriteErrorLog@@YAXXZ		; RetrieveAndWriteErrorLog
PUBLIC	??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
PUBLIC	?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
PUBLIC	?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
PUBLIC	?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Init
PUBLIC	?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
PUBLIC	?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::uflow
PUBLIC	?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
PUBLIC	?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
PUBLIC	?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_streambuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_streambuf<char,std::char_traits<char> >::imbue
PUBLIC	??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
PUBLIC	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
PUBLIC	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
PUBLIC	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
PUBLIC	?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
PUBLIC	?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
PUBLIC	?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::uflow
PUBLIC	?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn
PUBLIC	?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::xsputn
PUBLIC	?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::imbue
PUBLIC	?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init
PUBLIC	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
PUBLIC	?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXABV?$codecvt@DDU_Mbstatet@@@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
PUBLIC	?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
PUBLIC	??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	?ShowErrorPopupIfNeeded@@YAXXZ			; ShowErrorPopupIfNeeded
PUBLIC	??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
PUBLIC	??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
PUBLIC	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
PUBLIC	_main
PUBLIC	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
PUBLIC	??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
PUBLIC	??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z ; std::_Insert_string<wchar_t,std::char_traits<wchar_t>,unsigned int>
PUBLIC	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
PUBLIC	??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_from_iter<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> >,std::nullptr_t>
PUBLIC	??$_Construct@$00PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>
PUBLIC	??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
PUBLIC	??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > >
PUBLIC	??1?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAE@XZ ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::~num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >
PUBLIC	?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
PUBLIC	?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WJ@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
PUBLIC	?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WK@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
PUBLIC	?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_J@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
PUBLIC	?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_K@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
PUBLIC	?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
PUBLIC	?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
PUBLIC	?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBX@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
PUBLIC	?_Ffmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ffmt
PUBLIC	?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Iput
PUBLIC	?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put
PUBLIC	?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep
PUBLIC	??_G?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAEPAXI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`scalar deleting destructor'
PUBLIC	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
PUBLIC	??1?$codecvt@DDU_Mbstatet@@@std@@MAE@XZ		; std::codecvt<char,char,_Mbstatet>::~codecvt<char,char,_Mbstatet>
PUBLIC	?do_always_noconv@?$codecvt@DDU_Mbstatet@@@std@@MBE_NXZ ; std::codecvt<char,char,_Mbstatet>::do_always_noconv
PUBLIC	?do_in@?$codecvt@DDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z ; std::codecvt<char,char,_Mbstatet>::do_in
PUBLIC	?do_out@?$codecvt@DDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z ; std::codecvt<char,char,_Mbstatet>::do_out
PUBLIC	?do_unshift@?$codecvt@DDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PAD1AAPAD@Z ; std::codecvt<char,char,_Mbstatet>::do_unshift
PUBLIC	?do_length@?$codecvt@DDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PBD1I@Z ; std::codecvt<char,char,_Mbstatet>::do_length
PUBLIC	??_G?$codecvt@DDU_Mbstatet@@@std@@MAEPAXI@Z	; std::codecvt<char,char,_Mbstatet>::`scalar deleting destructor'
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z ; std::basic_istream<char,std::char_traits<char> >::_Common_extract_with_num_get<long>
PUBLIC	??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
PUBLIC	??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@AAEPAKQAKABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_reallocate<unsigned long const &>
PUBLIC	??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &>
PUBLIC	??1?$_Tidy_guard@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::~_Tidy_guard<std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >
PUBLIC	??$_Search_vectorized@$$CB_W$$CB_W@std@@YAPB_WQB_W00I@Z ; std::_Search_vectorized<wchar_t const ,wchar_t const >
PUBLIC	??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >
PUBLIC	??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::~num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	??_G?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
PUBLIC	??$_Float_put_desired_precision@O@std@@YAH_JH@Z	; std::_Float_put_desired_precision<long double>
PUBLIC	??$_Fput_v3@$0A@@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@1@V21@AAVios_base@1@_WPBDI_N@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Fput_v3<0>
PUBLIC	??$_Float_put_desired_precision@N@std@@YAH_JH@Z	; std::_Float_put_desired_precision<double>
PUBLIC	??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<wchar_t> >
PUBLIC	?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::numpunct<wchar_t>::_Getcat
PUBLIC	??1?$numpunct@_W@std@@MAE@XZ			; std::numpunct<wchar_t>::~numpunct<wchar_t>
PUBLIC	?do_decimal_point@?$numpunct@_W@std@@MBE_WXZ	; std::numpunct<wchar_t>::do_decimal_point
PUBLIC	?do_thousands_sep@?$numpunct@_W@std@@MBE_WXZ	; std::numpunct<wchar_t>::do_thousands_sep
PUBLIC	?do_grouping@?$numpunct@_W@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<wchar_t>::do_grouping
PUBLIC	?do_falsename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::numpunct<wchar_t>::do_falsename
PUBLIC	?do_truename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::numpunct<wchar_t>::do_truename
PUBLIC	??_G?$numpunct@_W@std@@MAEPAXI@Z		; std::numpunct<wchar_t>::`scalar deleting destructor'
PUBLIC	??1_Reallocation_guard@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Reallocation_guard::~_Reallocation_guard
PUBLIC	??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
PUBLIC	??$_Zero_range@PAE@std@@YAPAEQAE0@Z		; std::_Zero_range<unsigned char *>
PUBLIC	??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>
PUBLIC	??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_fp_with_locale<0>
PUBLIC	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
PUBLIC	??1?$numpunct@D@std@@MAE@XZ			; std::numpunct<char>::~numpunct<char>
PUBLIC	?do_decimal_point@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_decimal_point
PUBLIC	?do_thousands_sep@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_thousands_sep
PUBLIC	?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_grouping
PUBLIC	?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_falsename
PUBLIC	?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_truename
PUBLIC	??_G?$numpunct@D@std@@MAEPAXI@Z			; std::numpunct<char>::`scalar deleting destructor'
PUBLIC	??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z ; std::_Getloctxt<std::istreambuf_iterator<char,std::char_traits<char> >,char>
PUBLIC	??$_Copy_memmove@PAKPAK@std@@YAPAKPAK00@Z	; std::_Copy_memmove<unsigned long *,unsigned long *>
PUBLIC	??$_Find_elem@D$0BL@@std@@YAIAAY0BL@$$CBDD@Z	; std::_Find_elem<char,27>
PUBLIC	??$_Find_elem@D$0BN@@std@@YAIAAY0BN@$$CBDD@Z	; std::_Find_elem<char,29>
PUBLIC	??$_Copy_memmove_tail@PAK@std@@YAPAKQBDQAKII@Z	; std::_Copy_memmove_tail<unsigned long *>
PUBLIC	??$_Reverse_vectorized@$00@std@@YAXPAX0@Z	; std::_Reverse_vectorized<1>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
PUBLIC	??$_Find_vectorized@$$CBDD@std@@YAPBDQBD0D@Z	; std::_Find_vectorized<char const ,char>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??1?$_Tidy_guard@V?$numpunct@_W@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::numpunct<wchar_t> >::~_Tidy_guard<std::numpunct<wchar_t> >
PUBLIC	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z	; std::_Maklocstr<char>
PUBLIC	??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >
PUBLIC	??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z	; std::_Maklocchr<char>
PUBLIC	??_E?$basic_istream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_istream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_ostream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
PUBLIC	??_7_System_error@std@@6B@			; std::_System_error::`vftable'
PUBLIC	??_C@_02LMMGGCAJ@?3?5@				; `string'
PUBLIC	??_7system_error@std@@6B@			; std::system_error::`vftable'
PUBLIC	??_R0?AVsystem_error@std@@@8			; std::system_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
PUBLIC	??_R0?AV_System_error@std@@@8			; std::_System_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
PUBLIC	??_7_Iostream_error_category2@std@@6B@		; std::_Iostream_error_category2::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream@			; `string'
PUBLIC	?_Iostream_error@?4??message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB ; `std::_Iostream_error_category2::message'::`5'::_Iostream_error
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast@			; `string'
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	??_7_Facet_base@std@@6B@			; std::_Facet_base::`vftable'
PUBLIC	??_C@_0BA@ELKIONDK@bad?5locale?5name@		; `string'
PUBLIC	??_C@_05LAPONLG@false@				; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_7facet@locale@std@@6B@			; std::locale::facet::`vftable'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_7codecvt_base@std@@6B@			; std::codecvt_base::`vftable'
PUBLIC	??_7ctype_base@std@@6B@				; std::ctype_base::`vftable'
PUBLIC	??_7?$ctype@D@std@@6B@				; std::ctype<char>::`vftable'
PUBLIC	??_7?$ctype@_W@std@@6B@				; std::ctype<wchar_t>::`vftable'
PUBLIC	??_7failure@ios_base@std@@6B@			; std::ios_base::failure::`vftable'
PUBLIC	??_7ios_base@std@@6B@				; std::ios_base::`vftable'
PUBLIC	??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@	; `string'
PUBLIC	??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@	; `string'
PUBLIC	??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@	; `string'
PUBLIC	__TI5?AVfailure@ios_base@std@@
PUBLIC	__CTA5?AVfailure@ios_base@std@@
PUBLIC	??_R0?AVfailure@ios_base@std@@@8		; std::ios_base::failure `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
PUBLIC	??_C@_1BE@NMFIMKAA@?$AA?2?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?2@ ; `string'
PUBLIC	??_C@_1BG@NCCDOFIB@?$AA?2?$AAs?$AAy?$AAs?$AAt?$AAe?$AAm?$AA3?$AA2?$AA?2@ ; `string'
PUBLIC	??_C@_1DG@CIFNPBMN@?$AA?2?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?2?$AAs?$AAy?$AAs?$AAt?$AAe?$AAm@ ; `string'
PUBLIC	??_C@_1CE@OEHNAGL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1DA@NPPKGKBB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1BC@FOGOLNOF@?$AAS?$AA?9?$AA1?$AA?9?$AA5?$AA?9?$AA1?$AA8@ ; `string'
PUBLIC	??_C@_1BK@KDDKMJBN@?$AAS?$AA?9?$AA1?$AA?9?$AA5?$AA?9?$AA3?$AA2?$AA?9?$AA5?$AA4?$AA4@ ; `string'
PUBLIC	??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ios<char,std::char_traits<char> >::`vftable'
PUBLIC	??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ostream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ostream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_C@_0CD@JHGEGGMB@Failed?5to?5open?5file?5for?5overwri@ ; `string'
PUBLIC	??_C@_0CF@GPLPEJGN@Failed?5to?5write?5random?5data?5to?5@ ; `string'
PUBLIC	??_C@_0BL@KNKFCKIE@Executable?5securely?5wiped?6@ ; `string'
PUBLIC	??_C@_0DB@PHJEDLD@Executable?5wipe?5incomplete?5due?5@ ; `string'
PUBLIC	??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_istream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_istream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_C@_1CE@LGHOJOAP@?$AAE?$AAa?$AAs?$AAy?$AAA?$AAn?$AAt?$AAi?$AAC?$AAh?$AAe?$AAa?$AAt?$AA?4?$AAe@ ; `string'
PUBLIC	??_C@_1CA@FECLNECF@?$AAr?$AAb?$AAx?$AAh?$AAy?$AAp?$AAe?$AAr?$AAi?$AAo?$AAn?$AA?4?$AAe?$AAx?$AAe@ ; `string'
PUBLIC	??_C@_1BA@NHFJGJJ@?$AAv?$AAg?$AAk?$AA?4?$AAe?$AAx?$AAe@ ; `string'
PUBLIC	??_C@_1BK@KHLBIGMC@?$AAV?$AAa?$AAn?$AAg?$AAu?$AAa?$AAr?$AAd?$AA?4?$AAe?$AAx?$AAe@ ; `string'
PUBLIC	??_C@_1CK@DNABAJMK@?$AAR?$AAo?$AAb?$AAl?$AAo?$AAx?$AAP?$AAl?$AAa?$AAy?$AAe?$AAr?$AAB?$AAe?$AAt@ ; `string'
PUBLIC	??_C@_0CD@HMDMDLOM@Failed?5to?5create?5process?5snapsh@ ; `string'
PUBLIC	??_C@_02MNMNLDAI@?$CJ?6@			; `string'
PUBLIC	??_C@_07GOJKIMHK@?5?$CIPID?3?5@			; `string'
PUBLIC	??_C@_02KHOJGJKF@?4?5@				; `string'
PUBLIC	??_C@_0CH@DBEMKEBP@No?5allowed?5anti?9cheat?5processes@ ; `string'
PUBLIC	??_C@_0DF@OBKIMPA@Select?5process?5to?5terminate?5and@ ; `string'
PUBLIC	??_C@_0L@GMIBBJLF@Cancelled?6@			; `string'
PUBLIC	??_C@_13LBAGMAIH@?$AA?6@			; `string'
PUBLIC	??_C@_1FE@ILHKNOOP@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?3?$AA?5?$AAK?$AAi?$AAl?$AAl?$AA?5?$AA?$CG?$AA?5@ ; `string'
PUBLIC	??_C@_1FI@FBPFGPFA@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?3?$AA?5?$AAK?$AAi?$AAl?$AAl?$AA?5?$AA?$CG?$AA?5@ ; `string'
PUBLIC	??_C@_0DC@ILHIMEPI@Failed?5to?5open?5process?5for?5quer@ ; `string'
PUBLIC	??_C@_0BP@GLDIOEL@Failed?5to?5get?5executable?5path?6@ ; `string'
PUBLIC	??_C@_1GI@CANLKDBI@?$AAR?$AAe?$AAf?$AAu?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAt?$AAo?$AA?5?$AAw?$AAi?$AAp@ ; `string'
PUBLIC	??_C@_1HM@HKLAJMNM@?$AAR?$AAe?$AAf?$AAu?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAt?$AAo?$AA?5?$AAw?$AAi?$AAp@ ; `string'
PUBLIC	??_C@_1BC@NNIHPOBO@?$AAT?$AAa?$AAr?$AAg?$AAe?$AAt?$AA?3?$AA?5@ ; `string'
PUBLIC	??_C@_0BN@DJMCJGKF@Failed?5to?5terminate?5process?6@ ; `string'
PUBLIC	??_C@_1CK@HMIPOEEH@?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?5?$AAt?$AAe?$AAr?$AAm?$AAi?$AAn?$AAa@ ; `string'
PUBLIC	??_C@_19PAKAKPNB@?$AA?4?$AAb?$AAa?$AAk@		; `string'
PUBLIC	??_C@_1DK@GGPBFIDJ@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt@ ; `string'
PUBLIC	??_C@_1CC@GKFHONNI@?$AAB?$AAa?$AAc?$AAk?$AAu?$AAp?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAe?$AAd?$AA?3@ ; `string'
PUBLIC	??_C@_0BJ@PGKDKKC@Failed?5to?5get?5file?5size?6@ ; `string'
PUBLIC	??_C@_0BC@BNCCJELM@?60?4?5Exit?6Choice?3?5@	; `string'
PUBLIC	??_C@_0BP@OCJOJNKG@?64?4?5Kill?5?$CG?5Wipe?5Anti?9Cheat?5EXE@ ; `string'
PUBLIC	??_C@_0BO@HCKJMIGK@?63?4?5Create?5Service?5?$CIrequired?$CJ@ ; `string'
PUBLIC	??_C@_0BH@OJMELANK@?62?4?5Disable?5Protection@	; `string'
PUBLIC	??_C@_0BG@JOPEPBBN@?61?4?5Enable?5Protection@	; `string'
PUBLIC	??_C@_0P@NFDEKPFN@Invalid?5input?6@		; `string'
PUBLIC	??_C@_0BE@MMCBKBP@Protection?5enabled?6@	; `string'
PUBLIC	??_C@_0BN@EGKIEGE@Failed?5to?5enable?5protection?6@ ; `string'
PUBLIC	??_C@_0BF@DONBIPBH@Protection?5disabled?6@	; `string'
PUBLIC	??_C@_0BO@DDDAMELB@Failed?5to?5disable?5protection?6@ ; `string'
PUBLIC	??_C@_0CM@HEBMLGBH@Service?5installed?5and?5started?5s@ ; `string'
PUBLIC	??_C@_0CB@ELPLAANP@Failed?5to?5install?1start?5service@ ; `string'
PUBLIC	??_C@_08IEHHMBPO@Exiting?6@			; `string'
PUBLIC	??_C@_0BA@MECFPBGI@Invalid?5choice?6@		; `string'
PUBLIC	??_C@_1GE@KLOHNIPO@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAC@ ; `string'
PUBLIC	??_C@_1CM@DKFPDMAB@?$AAU?$AAE?$AAF?$AAI?$AAS?$AAe?$AAc?$AAu?$AAr?$AAe?$AAB?$AAo?$AAo?$AAt?$AAE@ ; `string'
PUBLIC	??_C@_1GI@HJODJPCN@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAC@ ; `string'
PUBLIC	??_C@_1CG@BLIBLCJE@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AAS?$AAt?$AAa?$AAr?$AAt?$AAO?$AAp?$AAt?$AAi@ ; `string'
PUBLIC	??_C@_1BI@MHOMIIJN@?$AAT?$AAE?$AAS?$AAT?$AAS?$AAI?$AAG?$AAN?$AAI?$AAN?$AAG@ ; `string'
PUBLIC	??_C@_0EL@CNFJKCBJ@Secure?5Boot?5is?5enabled?4?5Please?5@ ; `string'
PUBLIC	??_C@_0DG@HBHIFBKB@Test?5Signing?5is?5not?5enabled?4?5At@ ; `string'
PUBLIC	??_C@_0BM@BMDEHBF@bcdedit?5?1set?5testsigning?5on@ ; `string'
PUBLIC	??_C@_0DG@KGFCFPMJ@Failed?5to?5enable?5test?5signing?4?5@ ; `string'
PUBLIC	??_C@_0EN@FHCHMDNF@Test?5signing?5enabled?4?5Please?5re@ ; `string'
PUBLIC	??_C@_0DG@KKDPEODH@Secure?5Boot?5is?5disabled?5and?5Tes@ ; `string'
PUBLIC	??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_C@_0N@BHIHAFGJ@errorlog?4txt@		; `string'
PUBLIC	??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_C@_0BG@GAEBIAPC@EzAntiAntiCheat?5Error@	; `string'
PUBLIC	??_C@_0GP@OCNKAPGN@A?5kernel?5security?5error?5was?5det@ ; `string'
PUBLIC	??_C@_0EE@PPLMEFMH@https?3?1?1github?4com?1PalorderSoft@ ; `string'
PUBLIC	??_C@_04PMOCAHAA@open@				; `string'
PUBLIC	??_C@_1EA@FPCIDGNJ@?$AAE?$AAz?$AAA?$AAn?$AAt?$AAi?$AAA?$AAn?$AAt?$AAi?$AAC?$AAh?$AAe?$AAa?$AAt@ ; `string'
PUBLIC	??_C@_19BKJMDJK@?$AA?2?$AA?2?$AA?4?$AA?2@	; `string'
PUBLIC	??_C@_0HP@PDHHAOBF@This?5application?5must?5be?5run?5as@ ; `string'
PUBLIC	?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A ; `std::_Immortalize_memcpy_image<std::_Iostream_error_category2>'::`2'::_Static
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	?id@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::id
PUBLIC	??_7?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@6B@ ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`vftable'
PUBLIC	?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A	; std::codecvt<char,char,_Mbstatet>::id
PUBLIC	??_7?$codecvt@DDU_Mbstatet@@@std@@6B@		; std::codecvt<char,char,_Mbstatet>::`vftable'
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
PUBLIC	?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`vftable'
PUBLIC	??_C@_02BBAHNLBA@?$CFp@				; `string'
PUBLIC	??_C@_02CLHGNPPK@Lu@				; `string'
PUBLIC	??_C@_02HIKPPMOK@Ld@				; `string'
PUBLIC	??_C@_02BDDLJJBK@lu@				; `string'
PUBLIC	??_C@_02EAOCLKAK@ld@				; `string'
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_7?$numpunct@_W@std@@6B@			; std::numpunct<wchar_t>::`vftable'
PUBLIC	?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
PUBLIC	?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >::_Psave
PUBLIC	??_C@_02MDKMJEGG@eE@				; `string'
PUBLIC	??_C@_02OOPEBDOJ@pP@				; `string'
PUBLIC	??_C@_01LFCBOECM@?4@				; `string'
PUBLIC	?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<wchar_t> >::_Psave
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	??_7?$numpunct@D@std@@6B@			; std::numpunct<char>::`vftable'
PUBLIC	?_Src@?1???$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>'::`2'::_Src
PUBLIC	?_Src@?1???$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_fp_with_locale<0>'::`2'::_Src
PUBLIC	?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	??_R4ios_base@std@@6B@				; std::ios_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ios<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_istream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ifstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ofstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error@std@@6B@			; std::_System_error::`RTTI Complete Object Locator'
PUBLIC	??_R3_System_error@std@@8			; std::_System_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error@std@@8			; std::_System_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error@std@@8		; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4system_error@std@@6B@			; std::system_error::`RTTI Complete Object Locator'
PUBLIC	??_R3system_error@std@@8			; std::system_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2system_error@std@@8			; std::system_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@system_error@std@@8		; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category2@std@@6B@		; std::_Iostream_error_category2::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category2@std@@@8	; std::_Iostream_error_category2 `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category2@std@@8		; std::_Iostream_error_category2::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category2@std@@8		; std::_Iostream_error_category2::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category2@std@@8	; std::_Iostream_error_category2::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Facet_base@std@@6B@			; std::_Facet_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Facet_base@std@@@8			; std::_Facet_base `RTTI Type Descriptor'
PUBLIC	??_R3_Facet_base@std@@8				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Facet_base@std@@8				; std::_Facet_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Facet_base@std@@8		; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4facet@locale@std@@6B@			; std::locale::facet::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVfacet@locale@std@@@8			; std::locale::facet `RTTI Type Descriptor'
PUBLIC	??_R3facet@locale@std@@8			; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2facet@locale@std@@8			; std::locale::facet::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@facet@locale@std@@8		; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AU_Crt_new_delete@std@@@8			; std::_Crt_new_delete `RTTI Type Descriptor'
PUBLIC	??_R3_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4codecvt_base@std@@6B@			; std::codecvt_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVcodecvt_base@std@@@8			; std::codecvt_base `RTTI Type Descriptor'
PUBLIC	??_R3codecvt_base@std@@8			; std::codecvt_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2codecvt_base@std@@8			; std::codecvt_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@codecvt_base@std@@8		; std::codecvt_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ctype_base@std@@6B@			; std::ctype_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUctype_base@std@@@8			; std::ctype_base `RTTI Type Descriptor'
PUBLIC	??_R3ctype_base@std@@8				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ctype_base@std@@8				; std::ctype_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ctype_base@std@@8			; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ctype@D@std@@6B@				; std::ctype<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$ctype@D@std@@@8			; std::ctype<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$ctype@D@std@@8				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@D@std@@8				; std::ctype<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@D@std@@8			; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ctype@_W@std@@6B@			; std::ctype<wchar_t>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$ctype@_W@std@@@8			; std::ctype<wchar_t> `RTTI Type Descriptor'
PUBLIC	??_R3?$ctype@_W@std@@8				; std::ctype<wchar_t>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@_W@std@@8				; std::ctype<wchar_t>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@_W@std@@8			; std::ctype<wchar_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4failure@ios_base@std@@6B@			; std::ios_base::failure::`RTTI Complete Object Locator'
PUBLIC	??_R3failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@failure@ios_base@std@@8		; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@6B@ ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@8 ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8 ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8 ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8 ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$codecvt@DDU_Mbstatet@@@std@@6B@		; std::codecvt<char,char,_Mbstatet>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$codecvt@DDU_Mbstatet@@@std@@@8	; std::codecvt<char,char,_Mbstatet> `RTTI Type Descriptor'
PUBLIC	??_R3?$codecvt@DDU_Mbstatet@@@std@@8		; std::codecvt<char,char,_Mbstatet>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$codecvt@DDU_Mbstatet@@@std@@8		; std::codecvt<char,char,_Mbstatet>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$codecvt@DDU_Mbstatet@@@std@@8	; std::codecvt<char,char,_Mbstatet>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$numpunct@_W@std@@6B@			; std::numpunct<wchar_t>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$numpunct@_W@std@@@8			; std::numpunct<wchar_t> `RTTI Type Descriptor'
PUBLIC	??_R3?$numpunct@_W@std@@8			; std::numpunct<wchar_t>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$numpunct@_W@std@@8			; std::numpunct<wchar_t>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$numpunct@_W@std@@8		; std::numpunct<wchar_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$numpunct@D@std@@6B@			; std::numpunct<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$numpunct@D@std@@@8			; std::numpunct<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$numpunct@D@std@@8		; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@4202a05f20000000
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_abort:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	___std_terminate:PROC
EXTRN	__invoke_watson:PROC
EXTRN	_towlower:PROC
EXTRN	__errno:PROC
EXTRN	_strcspn:PROC
EXTRN	__imp__CreateFileW@28:PROC
EXTRN	__imp__GetFileSizeEx@8:PROC
EXTRN	__imp__SetEndOfFile@4:PROC
EXTRN	__imp__SetFilePointer@16:PROC
EXTRN	__imp__WriteFile@20:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__DeviceIoControl@32:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__GetCurrentProcess@0:PROC
EXTRN	__imp__TerminateProcess@8:PROC
EXTRN	__imp__OpenProcessToken@12:PROC
EXTRN	__imp__OpenProcess@12:PROC
EXTRN	__imp__GetTokenInformation@20:PROC
EXTRN	__imp__LocalFree@4:PROC
EXTRN	__imp__CopyFileW@12:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp__SetConsoleCtrlHandler@8:PROC
EXTRN	__imp__RegCloseKey@4:PROC
EXTRN	__imp__RegOpenKeyExW@20:PROC
EXTRN	__imp__RegQueryValueExW@24:PROC
EXTRN	__imp__ShellExecuteA@24:PROC
EXTRN	_calloc:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_strtof:PROC
EXTRN	_strtod:PROC
EXTRN	_system:PROC
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	__get_stream_buffer_pointers:PROC
EXTRN	_fclose:PROC
EXTRN	_fflush:PROC
EXTRN	_fgetc:PROC
EXTRN	_fgetpos:PROC
EXTRN	_fputc:PROC
EXTRN	_fread:PROC
EXTRN	_fsetpos:PROC
EXTRN	__fseeki64:PROC
EXTRN	_fwrite:PROC
EXTRN	_setvbuf:PROC
EXTRN	_ungetc:PROC
EXTRN	__lock_file:PROC
EXTRN	__unlock_file:PROC
EXTRN	___stdio_common_vsprintf_s:PROC
EXTRN	_frexp:PROC
EXTRN	___std_reverse_trivially_swappable_1:PROC
EXTRN	___std_find_trivial_1@12:PROC
EXTRN	___std_search_2@16:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?_Xruntime_error@std@@YAXPBD@Z:PROC		; std::_Xruntime_error
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	__imp__GetNamedSecurityInfoW@32:PROC
EXTRN	_ConvertSidToStringSidW@8:PROC
EXTRN	_CreateToolhelp32Snapshot@8:PROC
EXTRN	_Process32FirstW@8:PROC
EXTRN	_Process32NextW@8:PROC
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	??_E_System_error@std@@UAEPAXI@Z:PROC		; std::_System_error::`vector deleting destructor'
EXTRN	??_Esystem_error@std@@UAEPAXI@Z:PROC		; std::system_error::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	??_E_Iostream_error_category2@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category2::`vector deleting destructor'
EXTRN	??_Ebad_cast@std@@UAEPAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	??_E_Facet_base@std@@UAEPAXI@Z:PROC		; std::_Facet_base::`vector deleting destructor'
EXTRN	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	_localeconv:PROC
EXTRN	__Getctype:PROC
EXTRN	__Getcvt:PROC
EXTRN	__Mbrtowc:PROC
EXTRN	__Tolower:PROC
EXTRN	__Toupper:PROC
EXTRN	__Wcrtomb:PROC
EXTRN	__Getwctype:PROC
EXTRN	__Getwctypes:PROC
EXTRN	__Towlower:PROC
EXTRN	__Towupper:PROC
EXTRN	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z:PROC ; std::_Locinfo::_Locinfo_ctor
EXTRN	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z:PROC	; std::_Locinfo::_Locinfo_dtor
EXTRN	??_Efacet@locale@std@@MAEPAXI@Z:PROC		; std::locale::facet::`vector deleting destructor'
EXTRN	?_Init@locale@std@@CAPAV_Locimp@12@_N@Z:PROC	; std::locale::_Init
EXTRN	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN	??_Ecodecvt_base@std@@UAEPAXI@Z:PROC		; std::codecvt_base::`vector deleting destructor'
EXTRN	??_Ectype_base@std@@UAEPAXI@Z:PROC		; std::ctype_base::`vector deleting destructor'
EXTRN	??_E?$ctype@D@std@@MAEPAXI@Z:PROC		; std::ctype<char>::`vector deleting destructor'
EXTRN	??_E?$ctype@_W@std@@MAEPAXI@Z:PROC		; std::ctype<wchar_t>::`vector deleting destructor'
EXTRN	??_Efailure@ios_base@std@@UAEPAXI@Z:PROC	; std::ios_base::failure::`vector deleting destructor'
EXTRN	?_Addstd@ios_base@std@@SAXPAV12@@Z:PROC		; std::ios_base::_Addstd
EXTRN	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z:PROC	; std::ios_base::_Ios_base_dtor
EXTRN	??_Eios_base@std@@UAEPAXI@Z:PROC		; std::ios_base::`vector deleting destructor'
EXTRN	__Stolx:PROC
EXTRN	__Stoulx:PROC
EXTRN	__Stollx:PROC
EXTRN	__Stoullx:PROC
EXTRN	?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z:PROC		; std::_Fiopen
EXTRN	_K32GetModuleFileNameExW@16:PROC
EXTRN	?_Random_device@std@@YAIXZ:PROC			; std::_Random_device
EXTRN	?InstallService@@YA_NXZ:PROC			; InstallService
EXTRN	?UnloadDriver@@YA_NXZ:PROC			; UnloadDriver
EXTRN	??_E?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ios<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ostream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_istream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_filebuf<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAEPAXI@Z:PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`vector deleting destructor'
EXTRN	??_E?$codecvt@DDU_Mbstatet@@@std@@MAEPAXI@Z:PROC ; std::codecvt<char,char,_Mbstatet>::`vector deleting destructor'
EXTRN	??_E?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z:PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`vector deleting destructor'
EXTRN	??_E?$numpunct@_W@std@@MAEPAXI@Z:PROC		; std::numpunct<wchar_t>::`vector deleting destructor'
EXTRN	??_E?$numpunct@D@std@@MAEPAXI@Z:PROC		; std::numpunct<char>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
EXTRN	__dclass:PROC
EXTRN	__ldclass:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	__Avx2WmemEnabled:DWORD
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?_Id_cnt@id@locale@std@@0HA:DWORD		; std::locale::id::_Id_cnt
EXTRN	?id@?$ctype@D@std@@2V0locale@2@A:DWORD		; std::ctype<char>::id
EXTRN	?id@?$ctype@_W@std@@2V0locale@2@A:DWORD		; std::ctype<wchar_t>::id
EXTRN	?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A:BYTE ; std::cin
EXTRN	?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE ; std::cout
EXTRN	?wcout@std@@3V?$basic_ostream@_WU?$char_traits@_W@std@@@1@A:BYTE ; std::wcout
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?allowedExecutables@?1??ListAndWipeProcess@@YAXXZ@4V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@B
_BSS	SEGMENT
?allowedExecutables@?1??ListAndWipeProcess@@YAXXZ@4V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@B DB 0cH DUP (?) ; `ListAndWipeProcess'::`2'::allowedExecutables
_BSS	ENDS
;	COMDAT ?$TSS0@?1??ListAndWipeProcess@@YAXXZ@4HA
_BSS	SEGMENT
?$TSS0@?1??ListAndWipeProcess@@YAXXZ@4HA DD 01H DUP (?)	; `ListAndWipeProcess'::`2'::$TSS0
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::id
_BSS	ENDS
;	COMDAT ?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::codecvt<char,char,_Mbstatet>::id
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
_BSS	ENDS
;	COMDAT ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
;	COMDAT ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
_BSS	SEGMENT
?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A DQ 01H DUP (?) ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::numpunct<wchar_t> >::_Psave
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::numpunct<char> >::_Psave
_BSS	ENDS
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __real@4202a05f20000000
CONST	SEGMENT
__real@4202a05f20000000 DQ 04202a05f20000000r	; 1e+10
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$numpunct@D@std@@8 DD FLAT:??_R0?AV?$numpunct@D@std@@@8 ; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R2?$numpunct@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$numpunct@D@std@@8 ; std::numpunct<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R3?$numpunct@D@std@@8 DD 00H				; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
data$rs	SEGMENT
??_R0?AV?$numpunct@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::numpunct<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$numpunct@D@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT
??_R4?$numpunct@D@std@@6B@ DD 00H			; std::numpunct<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$numpunct@D@std@@@8
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$numpunct@_W@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$numpunct@_W@std@@8 DD FLAT:??_R0?AV?$numpunct@_W@std@@@8 ; std::numpunct<wchar_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$numpunct@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT
??_R2?$numpunct@_W@std@@8 DD FLAT:??_R1A@?0A@EA@?$numpunct@_W@std@@8 ; std::numpunct<wchar_t>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT
??_R3?$numpunct@_W@std@@8 DD 00H			; std::numpunct<wchar_t>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$numpunct@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
data$rs	SEGMENT
??_R0?AV?$numpunct@_W@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::numpunct<wchar_t> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$numpunct@_W@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT
??_R4?$numpunct@_W@std@@6B@ DD 00H			; std::numpunct<wchar_t>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$numpunct@_W@std@@@8
	DD	FLAT:??_R3?$numpunct@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$codecvt@DDU_Mbstatet@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$codecvt@DDU_Mbstatet@@@std@@8 DD FLAT:??_R0?AV?$codecvt@DDU_Mbstatet@@@std@@@8 ; std::codecvt<char,char,_Mbstatet>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$codecvt@DDU_Mbstatet@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$codecvt@DDU_Mbstatet@@@std@@8
rdata$r	SEGMENT
??_R2?$codecvt@DDU_Mbstatet@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$codecvt@DDU_Mbstatet@@@std@@8 ; std::codecvt<char,char,_Mbstatet>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@codecvt_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$codecvt@DDU_Mbstatet@@@std@@8
rdata$r	SEGMENT
??_R3?$codecvt@DDU_Mbstatet@@@std@@8 DD 00H		; std::codecvt<char,char,_Mbstatet>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2?$codecvt@DDU_Mbstatet@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$codecvt@DDU_Mbstatet@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$codecvt@DDU_Mbstatet@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::codecvt<char,char,_Mbstatet> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$codecvt@DDU_Mbstatet@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$codecvt@DDU_Mbstatet@@@std@@6B@
rdata$r	SEGMENT
??_R4?$codecvt@DDU_Mbstatet@@@std@@6B@ DD 00H		; std::codecvt<char,char,_Mbstatet>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$codecvt@DDU_Mbstatet@@@std@@@8
	DD	FLAT:??_R3?$codecvt@DDU_Mbstatet@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD 00H ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@'
	DB	'std@@@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD 00H ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
	DD	FLAT:??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8 DD FLAT:??_R0?AV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@8 ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8 ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8 DD 00H ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@'
	DB	'_W@std@@@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@6B@ DD 00H ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@8
	DD	FLAT:??_R3?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@failure@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@failure@ios_base@std@@8 DD FLAT:??_R0?AVfailure@ios_base@std@@@8 ; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT
??_R2failure@ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@failure@ios_base@std@@8 ; std::ios_base::failure::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@system_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT
??_R3failure@ios_base@std@@8 DD 00H			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT
??_R4failure@ios_base@std@@6B@ DD 00H			; std::ios_base::failure::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ctype@_W@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@_W@std@@8 DD FLAT:??_R0?AV?$ctype@_W@std@@@8 ; std::ctype<wchar_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ctype@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT
??_R2?$ctype@_W@std@@8 DD FLAT:??_R1A@?0A@EA@?$ctype@_W@std@@8 ; std::ctype<wchar_t>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ctype_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT
??_R3?$ctype@_W@std@@8 DD 00H				; std::ctype<wchar_t>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2?$ctype@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
data$rs	SEGMENT
??_R0?AV?$ctype@_W@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype<wchar_t> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ctype@_W@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@_W@std@@6B@ DD 00H				; std::ctype<wchar_t>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ctype@_W@std@@@8
	DD	FLAT:??_R3?$ctype@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ctype@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@D@std@@8 DD FLAT:??_R0?AV?$ctype@D@std@@@8 ; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT
??_R2?$ctype@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$ctype@D@std@@8 ; std::ctype<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ctype_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT
??_R3?$ctype@D@std@@8 DD 00H				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
data$rs	SEGMENT
??_R0?AV?$ctype@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ctype@D@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@D@std@@6B@ DD 00H				; std::ctype<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ctype@D@std@@@8
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ctype_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ctype_base@std@@8 DD FLAT:??_R0?AUctype_base@std@@@8 ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ctype_base@std@@8
rdata$r	SEGMENT
??_R2ctype_base@std@@8 DD FLAT:??_R1A@?0A@EA@ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ctype_base@std@@8
rdata$r	SEGMENT
??_R3ctype_base@std@@8 DD 00H				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
data$rs	SEGMENT
??_R0?AUctype_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUctype_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4ctype_base@std@@6B@
rdata$r	SEGMENT
??_R4ctype_base@std@@6B@ DD 00H				; std::ctype_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUctype_base@std@@@8
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@codecvt_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@codecvt_base@std@@8 DD FLAT:??_R0?AVcodecvt_base@std@@@8 ; std::codecvt_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3codecvt_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2codecvt_base@std@@8
rdata$r	SEGMENT
??_R2codecvt_base@std@@8 DD FLAT:??_R1A@?0A@EA@codecvt_base@std@@8 ; std::codecvt_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3codecvt_base@std@@8
rdata$r	SEGMENT
??_R3codecvt_base@std@@8 DD 00H				; std::codecvt_base::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2codecvt_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVcodecvt_base@std@@@8
data$rs	SEGMENT
??_R0?AVcodecvt_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::codecvt_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVcodecvt_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4codecvt_base@std@@6B@
rdata$r	SEGMENT
??_R4codecvt_base@std@@6B@ DD 00H			; std::codecvt_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVcodecvt_base@std@@@8
	DD	FLAT:??_R3codecvt_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R2_Crt_new_delete@std@@8 DD FLAT:??_R1A@?0A@EA@_Crt_new_delete@std@@8 ; std::_Crt_new_delete::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R3_Crt_new_delete@std@@8 DD 00H			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU_Crt_new_delete@std@@@8
data$rs	SEGMENT
??_R0?AU_Crt_new_delete@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Crt_new_delete `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU_Crt_new_delete@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R13?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@facet@locale@std@@8 DD FLAT:??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT
??_R2facet@locale@std@@8 DD FLAT:??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT
??_R3facet@locale@std@@8 DD 00H				; std::locale::facet::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
data$rs	SEGMENT
??_R0?AVfacet@locale@std@@@8 DD FLAT:??_7type_info@@6B@	; std::locale::facet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfacet@locale@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4facet@locale@std@@6B@
rdata$r	SEGMENT
??_R4facet@locale@std@@6B@ DD 00H			; std::locale::facet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfacet@locale@std@@@8
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Facet_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Facet_base@std@@8 DD FLAT:??_R0?AV_Facet_base@std@@@8 ; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Facet_base@std@@8
rdata$r	SEGMENT
??_R2_Facet_base@std@@8 DD FLAT:??_R1A@?0A@EA@_Facet_base@std@@8 ; std::_Facet_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Facet_base@std@@8
rdata$r	SEGMENT
??_R3_Facet_base@std@@8 DD 00H				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Facet_base@std@@@8
data$rs	SEGMENT
??_R0?AV_Facet_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Facet_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Facet_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4_Facet_base@std@@6B@
rdata$r	SEGMENT
??_R4_Facet_base@std@@6B@ DD 00H			; std::_Facet_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Facet_base@std@@@8
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD FLAT:??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD FLAT:??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 00H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category2@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category2@std@@8 DD FLAT:??_R0?AV_Iostream_error_category2@std@@@8 ; std::_Iostream_error_category2::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category2@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category2@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category2@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category2@std@@8 ; std::_Iostream_error_category2::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category2@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category2@std@@8 DD 00H		; std::_Iostream_error_category2::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Iostream_error_category2@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category2@std@@@8
data$rs	SEGMENT
??_R0?AV_Iostream_error_category2@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category2 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category2@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4_Iostream_error_category2@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category2@std@@6B@ DD 00H		; std::_Iostream_error_category2::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category2@std@@@8
	DD	FLAT:??_R3_Iostream_error_category2@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@system_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@system_error@std@@8 DD FLAT:??_R0?AVsystem_error@std@@@8 ; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2system_error@std@@8
rdata$r	SEGMENT
??_R2system_error@std@@8 DD FLAT:??_R1A@?0A@EA@system_error@std@@8 ; std::system_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3system_error@std@@8
rdata$r	SEGMENT
??_R3system_error@std@@8 DD 00H				; std::system_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4system_error@std@@6B@
rdata$r	SEGMENT
??_R4system_error@std@@6B@ DD 00H			; std::system_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error@std@@8 DD FLAT:??_R0?AV_System_error@std@@@8 ; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error@std@@8
rdata$r	SEGMENT
??_R2_System_error@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error@std@@8 ; std::_System_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error@std@@8
rdata$r	SEGMENT
??_R3_System_error@std@@8 DD 00H			; std::_System_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4_System_error@std@@6B@
rdata$r	SEGMENT
??_R4_System_error@std@@6B@ DD 00H			; std::_System_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$rs	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ofstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	068H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ifstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	070H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	08H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_istream@DU?$char_traits@D@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	018H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ios_base@std@@8
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD 00H	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ios<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
data$rs	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Iosb@H@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
data$rs	SEGMENT
??_R0?AVios_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVios_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4ios_base@std@@6B@
rdata$r	SEGMENT
??_R4ios_base@std@@6B@ DD 00H				; std::ios_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVios_base@std@@@8
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ?_Src@?1???$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z@4QBDB
CONST	SEGMENT
?_Src@?1???$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z@4QBDB DB 030H ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_fp_with_locale<0>'::`2'::_Src
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	02dH
	DB	02bH
	DB	058H
	DB	078H
	DB	050H
	DB	070H
	DB	00H
CONST	ENDS
;	COMDAT ?_Src@?1???$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z@4QBDB
CONST	SEGMENT
?_Src@?1???$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z@4QBDB DB 030H ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>'::`2'::_Src
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	02dH
	DB	02bH
	DB	058H
	DB	078H
	DB	00H
CONST	ENDS
;	COMDAT ??_7?$numpunct@D@std@@6B@
CONST	SEGMENT
??_7?$numpunct@D@std@@6B@ DD FLAT:??_R4?$numpunct@D@std@@6B@ ; std::numpunct<char>::`vftable'
	DD	FLAT:??_E?$numpunct@D@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_decimal_point@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4@
CONST	SEGMENT
??_C@_01LFCBOECM@?4@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OOPEBDOJ@pP@
CONST	SEGMENT
??_C@_02OOPEBDOJ@pP@ DB 'pP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MDKMJEGG@eE@
CONST	SEGMENT
??_C@_02MDKMJEGG@eE@ DB 'eE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7?$numpunct@_W@std@@6B@
CONST	SEGMENT
??_7?$numpunct@_W@std@@6B@ DD FLAT:??_R4?$numpunct@_W@std@@6B@ ; std::numpunct<wchar_t>::`vftable'
	DD	FLAT:??_E?$numpunct@_W@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_decimal_point@?$numpunct@_W@std@@MBE_WXZ
	DD	FLAT:?do_thousands_sep@?$numpunct@_W@std@@MBE_WXZ
	DD	FLAT:?do_grouping@?$numpunct@_W@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_falsename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
	DD	FLAT:?do_truename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
CONST	ENDS
;	COMDAT ??_C@_02EAOCLKAK@ld@
CONST	SEGMENT
??_C@_02EAOCLKAK@ld@ DB 'ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BDDLJJBK@lu@
CONST	SEGMENT
??_C@_02BDDLJJBK@lu@ DB 'lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HIKPPMOK@Ld@
CONST	SEGMENT
??_C@_02HIKPPMOK@Ld@ DB 'Ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CLHGNPPK@Lu@
CONST	SEGMENT
??_C@_02CLHGNPPK@Lu@ DB 'Lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp@
CONST	SEGMENT
??_C@_02BBAHNLBA@?$CFp@ DB '%p', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
CONST	SEGMENT
??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD FLAT:??_R4?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`vftable'
	DD	FLAT:??_E?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
CONST	ENDS
;	COMDAT ??_7?$codecvt@DDU_Mbstatet@@@std@@6B@
CONST	SEGMENT
??_7?$codecvt@DDU_Mbstatet@@@std@@6B@ DD FLAT:??_R4?$codecvt@DDU_Mbstatet@@@std@@6B@ ; std::codecvt<char,char,_Mbstatet>::`vftable'
	DD	FLAT:??_E?$codecvt@DDU_Mbstatet@@@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_always_noconv@?$codecvt@DDU_Mbstatet@@@std@@MBE_NXZ
	DD	FLAT:?do_max_length@codecvt_base@std@@MBEHXZ
	DD	FLAT:?do_encoding@codecvt_base@std@@MBEHXZ
	DD	FLAT:?do_in@?$codecvt@DDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z
	DD	FLAT:?do_out@?$codecvt@DDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z
	DD	FLAT:?do_unshift@?$codecvt@DDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PAD1AAPAD@Z
	DD	FLAT:?do_length@?$codecvt@DDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PBD1I@Z
CONST	ENDS
;	COMDAT ??_7?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@6B@
CONST	SEGMENT
??_7?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@6B@ DD FLAT:??_R4?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@6B@ ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`vftable'
	DD	FLAT:??_E?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBX@Z
	DD	FLAT:?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z
	DD	FLAT:?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z
	DD	FLAT:?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_K@Z
	DD	FLAT:?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_J@Z
	DD	FLAT:?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WK@Z
	DD	FLAT:?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WJ@Z
	DD	FLAT:?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z
CONST	ENDS
;	COMDAT ?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A
_DATA	SEGMENT
?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A DD FLAT:??_7_Iostream_error_category2@std@@6B@ ; `std::_Immortalize_memcpy_image<std::_Iostream_error_category2>'::`2'::_Static
	DD	05H
_DATA	ENDS
;	COMDAT ??_C@_0HP@PDHHAOBF@This?5application?5must?5be?5run?5as@
CONST	SEGMENT
??_C@_0HP@PDHHAOBF@This?5application?5must?5be?5run?5as@ DB 'This applica'
	DB	'tion must be run as NT AUTHORITY\SYSTEM, and disable secure b'
	DB	'oot and enable test signing.', 0aH, 'Press any key to exit...'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_19BKJMDJK@?$AA?2?$AA?2?$AA?4?$AA?2@
CONST	SEGMENT
??_C@_19BKJMDJK@?$AA?2?$AA?2?$AA?4?$AA?2@ DB '\', 00H, '\', 00H, '.', 00H
	DB	'\', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@FPCIDGNJ@?$AAE?$AAz?$AAA?$AAn?$AAt?$AAi?$AAA?$AAn?$AAt?$AAi?$AAC?$AAh?$AAe?$AAa?$AAt@
CONST	SEGMENT
??_C@_1EA@FPCIDGNJ@?$AAE?$AAz?$AAA?$AAn?$AAt?$AAi?$AAA?$AAn?$AAt?$AAi?$AAC?$AAh?$AAe?$AAa?$AAt@ DB 'E'
	DB	00H, 'z', 00H, 'A', 00H, 'n', 00H, 't', 00H, 'i', 00H, 'A', 00H
	DB	'n', 00H, 't', 00H, 'i', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'a'
	DB	00H, 't', 00H, '-', 00H, 'x', 00H, '8', 00H, '6', 00H, '-', 00H
	DB	'R', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 's', 00H, 'e'
	DB	00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04PMOCAHAA@open@
CONST	SEGMENT
??_C@_04PMOCAHAA@open@ DB 'open', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@PPLMEFMH@https?3?1?1github?4com?1PalorderSoft@
CONST	SEGMENT
??_C@_0EE@PPLMEFMH@https?3?1?1github?4com?1PalorderSoft@ DB 'https://gith'
	DB	'ub.com/PalorderSoftWorksOfficial/EzAntiAntiCheat/issues', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GP@OCNKAPGN@A?5kernel?5security?5error?5was?5det@
CONST	SEGMENT
??_C@_0GP@OCNKAPGN@A?5kernel?5security?5error?5was?5det@ DB 'A kernel sec'
	DB	'urity error was detected.', 0aH, 'Please create an issue on o'
	DB	'ur GitHub repository and attach errorlog.txt.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GAEBIAPC@EzAntiAntiCheat?5Error@
CONST	SEGMENT
??_C@_0BG@GAEBIAPC@EzAntiAntiCheat?5Error@ DB 'EzAntiAntiCheat Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`vbtable'
	DD	070H
CONST	ENDS
;	COMDAT ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_0N@BHIHAFGJ@errorlog?4txt@
CONST	SEGMENT
??_C@_0N@BHIHAFGJ@errorlog?4txt@ DB 'errorlog.txt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`vbtable'
	DD	068H
CONST	ENDS
;	COMDAT ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
	DD	FLAT:?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
	DD	FLAT:?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z
	DD	FLAT:?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
	DD	FLAT:?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z
	DD	FLAT:?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0DG@KKDPEODH@Secure?5Boot?5is?5disabled?5and?5Tes@
CONST	SEGMENT
??_C@_0DG@KKDPEODH@Secure?5Boot?5is?5disabled?5and?5Tes@ DB 'Secure Boot '
	DB	'is disabled and Test Signing is enabled.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@FHCHMDNF@Test?5signing?5enabled?4?5Please?5re@
CONST	SEGMENT
??_C@_0EN@FHCHMDNF@Test?5signing?5enabled?4?5Please?5re@ DB 'Test signing'
	DB	' enabled. Please reboot your system for changes to take effec'
	DB	't.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@KGFCFPMJ@Failed?5to?5enable?5test?5signing?4?5@
CONST	SEGMENT
??_C@_0DG@KGFCFPMJ@Failed?5to?5enable?5test?5signing?4?5@ DB 'Failed to e'
	DB	'nable test signing. Run as administrator.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BMDEHBF@bcdedit?5?1set?5testsigning?5on@
CONST	SEGMENT
??_C@_0BM@BMDEHBF@bcdedit?5?1set?5testsigning?5on@ DB 'bcdedit /set tests'
	DB	'igning on', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@HBHIFBKB@Test?5Signing?5is?5not?5enabled?4?5At@
CONST	SEGMENT
??_C@_0DG@HBHIFBKB@Test?5Signing?5is?5not?5enabled?4?5At@ DB 'Test Signin'
	DB	'g is not enabled. Attempting to enable...', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@CNFJKCBJ@Secure?5Boot?5is?5enabled?4?5Please?5@
CONST	SEGMENT
??_C@_0EL@CNFJKCBJ@Secure?5Boot?5is?5enabled?4?5Please?5@ DB 'Secure Boot'
	DB	' is enabled. Please disable it in your UEFI firmware settings'
	DB	'.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@MHOMIIJN@?$AAT?$AAE?$AAS?$AAT?$AAS?$AAI?$AAG?$AAN?$AAI?$AAN?$AAG@
CONST	SEGMENT
??_C@_1BI@MHOMIIJN@?$AAT?$AAE?$AAS?$AAT?$AAS?$AAI?$AAG?$AAN?$AAI?$AAN?$AAG@ DB 'T'
	DB	00H, 'E', 00H, 'S', 00H, 'T', 00H, 'S', 00H, 'I', 00H, 'G', 00H
	DB	'N', 00H, 'I', 00H, 'N', 00H, 'G', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@BLIBLCJE@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AAS?$AAt?$AAa?$AAr?$AAt?$AAO?$AAp?$AAt?$AAi@
CONST	SEGMENT
??_C@_1CG@BLIBLCJE@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AAS?$AAt?$AAa?$AAr?$AAt?$AAO?$AAp?$AAt?$AAi@ DB 'S'
	DB	00H, 'y', 00H, 's', 00H, 't', 00H, 'e', 00H, 'm', 00H, 'S', 00H
	DB	't', 00H, 'a', 00H, 'r', 00H, 't', 00H, 'O', 00H, 'p', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1GI@HJODJPCN@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAC@
CONST	SEGMENT
??_C@_1GI@HJODJPCN@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAC@ DB 'S'
	DB	00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '\', 00H
	DB	'C', 00H, 'u', 00H, 'r', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't'
	DB	00H, 'C', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'o', 00H
	DB	'l', 00H, 'S', 00H, 'e', 00H, 't', 00H, '\', 00H, 'C', 00H, 'o'
	DB	00H, 'n', 00H, 't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, '\', 00H
	DB	'S', 00H, 'y', 00H, 's', 00H, 't', 00H, 'e', 00H, 'm', 00H, 'S'
	DB	00H, 't', 00H, 'a', 00H, 'r', 00H, 't', 00H, 'O', 00H, 'p', 00H
	DB	't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@DKFPDMAB@?$AAU?$AAE?$AAF?$AAI?$AAS?$AAe?$AAc?$AAu?$AAr?$AAe?$AAB?$AAo?$AAo?$AAt?$AAE@
CONST	SEGMENT
??_C@_1CM@DKFPDMAB@?$AAU?$AAE?$AAF?$AAI?$AAS?$AAe?$AAc?$AAu?$AAr?$AAe?$AAB?$AAo?$AAo?$AAt?$AAE@ DB 'U'
	DB	00H, 'E', 00H, 'F', 00H, 'I', 00H, 'S', 00H, 'e', 00H, 'c', 00H
	DB	'u', 00H, 'r', 00H, 'e', 00H, 'B', 00H, 'o', 00H, 'o', 00H, 't'
	DB	00H, 'E', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	'd', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1GE@KLOHNIPO@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAC@
CONST	SEGMENT
??_C@_1GE@KLOHNIPO@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAC@ DB 'S'
	DB	00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, '\', 00H
	DB	'C', 00H, 'u', 00H, 'r', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't'
	DB	00H, 'C', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'o', 00H
	DB	'l', 00H, 'S', 00H, 'e', 00H, 't', 00H, '\', 00H, 'C', 00H, 'o'
	DB	00H, 'n', 00H, 't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, '\', 00H
	DB	'S', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 'B'
	DB	00H, 'o', 00H, 'o', 00H, 't', 00H, '\', 00H, 'S', 00H, 't', 00H
	DB	'a', 00H, 't', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MECFPBGI@Invalid?5choice?6@
CONST	SEGMENT
??_C@_0BA@MECFPBGI@Invalid?5choice?6@ DB 'Invalid choice', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08IEHHMBPO@Exiting?6@
CONST	SEGMENT
??_C@_08IEHHMBPO@Exiting?6@ DB 'Exiting', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@ELPLAANP@Failed?5to?5install?1start?5service@
CONST	SEGMENT
??_C@_0CB@ELPLAANP@Failed?5to?5install?1start?5service@ DB 'Failed to ins'
	DB	'tall/start service', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@HEBMLGBH@Service?5installed?5and?5started?5s@
CONST	SEGMENT
??_C@_0CM@HEBMLGBH@Service?5installed?5and?5started?5s@ DB 'Service insta'
	DB	'lled and started successfully', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DDDAMELB@Failed?5to?5disable?5protection?6@
CONST	SEGMENT
??_C@_0BO@DDDAMELB@Failed?5to?5disable?5protection?6@ DB 'Failed to disab'
	DB	'le protection', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DONBIPBH@Protection?5disabled?6@
CONST	SEGMENT
??_C@_0BF@DONBIPBH@Protection?5disabled?6@ DB 'Protection disabled', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@EGKIEGE@Failed?5to?5enable?5protection?6@
CONST	SEGMENT
??_C@_0BN@EGKIEGE@Failed?5to?5enable?5protection?6@ DB 'Failed to enable '
	DB	'protection', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MMCBKBP@Protection?5enabled?6@
CONST	SEGMENT
??_C@_0BE@MMCBKBP@Protection?5enabled?6@ DB 'Protection enabled', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NFDEKPFN@Invalid?5input?6@
CONST	SEGMENT
??_C@_0P@NFDEKPFN@Invalid?5input?6@ DB 'Invalid input', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JOPEPBBN@?61?4?5Enable?5Protection@
CONST	SEGMENT
??_C@_0BG@JOPEPBBN@?61?4?5Enable?5Protection@ DB 0aH, '1. Enable Protecti'
	DB	'on', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OJMELANK@?62?4?5Disable?5Protection@
CONST	SEGMENT
??_C@_0BH@OJMELANK@?62?4?5Disable?5Protection@ DB 0aH, '2. Disable Protec'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HCKJMIGK@?63?4?5Create?5Service?5?$CIrequired?$CJ@
CONST	SEGMENT
??_C@_0BO@HCKJMIGK@?63?4?5Create?5Service?5?$CIrequired?$CJ@ DB 0aH, '3. '
	DB	'Create Service (required)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OCJOJNKG@?64?4?5Kill?5?$CG?5Wipe?5Anti?9Cheat?5EXE@
CONST	SEGMENT
??_C@_0BP@OCJOJNKG@?64?4?5Kill?5?$CG?5Wipe?5Anti?9Cheat?5EXE@ DB 0aH, '4.'
	DB	' Kill & Wipe Anti-Cheat EXE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BNCCJELM@?60?4?5Exit?6Choice?3?5@
CONST	SEGMENT
??_C@_0BC@BNCCJELM@?60?4?5Exit?6Choice?3?5@ DB 0aH, '0. Exit', 0aH, 'Choi'
	DB	'ce: ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PGKDKKC@Failed?5to?5get?5file?5size?6@
CONST	SEGMENT
??_C@_0BJ@PGKDKKC@Failed?5to?5get?5file?5size?6@ DB 'Failed to get file s'
	DB	'ize', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@GKFHONNI@?$AAB?$AAa?$AAc?$AAk?$AAu?$AAp?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAe?$AAd?$AA?3@
CONST	SEGMENT
??_C@_1CC@GKFHONNI@?$AAB?$AAa?$AAc?$AAk?$AAu?$AAp?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAe?$AAd?$AA?3@ DB 'B'
	DB	00H, 'a', 00H, 'c', 00H, 'k', 00H, 'u', 00H, 'p', 00H, ' ', 00H
	DB	'c', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'd'
	DB	00H, ':', 00H, ' ', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@GGPBFIDJ@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt@
CONST	SEGMENT
??_C@_1DK@GGPBFIDJ@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt@ DB 'F'
	DB	00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, ' ', 00H
	DB	't', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 't', 00H, 'e', 00H, ' ', 00H, 'b', 00H, 'a', 00H, 'c', 00H
	DB	'k', 00H, 'u', 00H, 'p', 00H, ' ', 00H, 'a', 00H, 't', 00H, ':'
	DB	00H, ' ', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_19PAKAKPNB@?$AA?4?$AAb?$AAa?$AAk@
CONST	SEGMENT
??_C@_19PAKAKPNB@?$AA?4?$AAb?$AAa?$AAk@ DB '.', 00H, 'b', 00H, 'a', 00H, 'k'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@HMIPOEEH@?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?5?$AAt?$AAe?$AAr?$AAm?$AAi?$AAn?$AAa@
CONST	SEGMENT
??_C@_1CK@HMIPOEEH@?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?5?$AAt?$AAe?$AAr?$AAm?$AAi?$AAn?$AAa@ DB 'P'
	DB	00H, 'r', 00H, 'o', 00H, 'c', 00H, 'e', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'm', 00H, 'i', 00H, 'n'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, 'd', 00H, ':', 00H, ' ', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DJMCJGKF@Failed?5to?5terminate?5process?6@
CONST	SEGMENT
??_C@_0BN@DJMCJGKF@Failed?5to?5terminate?5process?6@ DB 'Failed to termin'
	DB	'ate process', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@NNIHPOBO@?$AAT?$AAa?$AAr?$AAg?$AAe?$AAt?$AA?3?$AA?5@
CONST	SEGMENT
??_C@_1BC@NNIHPOBO@?$AAT?$AAa?$AAr?$AAg?$AAe?$AAt?$AA?3?$AA?5@ DB 'T', 00H
	DB	'a', 00H, 'r', 00H, 'g', 00H, 'e', 00H, 't', 00H, ':', 00H, ' '
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1HM@HKLAJMNM@?$AAR?$AAe?$AAf?$AAu?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAt?$AAo?$AA?5?$AAw?$AAi?$AAp@
CONST	SEGMENT
??_C@_1HM@HKLAJMNM@?$AAR?$AAe?$AAf?$AAu?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAt?$AAo?$AA?5?$AAw?$AAi?$AAp@ DB 'R'
	DB	00H, 'e', 00H, 'f', 00H, 'u', 00H, 's', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'w', 00H, 'i'
	DB	00H, 'p', 00H, 'e', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l', 00H
	DB	'e', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'o'
	DB	00H, 'w', 00H, 'n', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'b', 00H
	DB	'y', 00H, ' ', 00H, 'S', 00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E'
	DB	00H, 'M', 00H, ' ', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'A', 00H
	DB	'd', 00H, 'm', 00H, 'i', 00H, 'n', 00H, 'i', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, 's', 00H
	DB	':', 00H, ' ', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1GI@CANLKDBI@?$AAR?$AAe?$AAf?$AAu?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAt?$AAo?$AA?5?$AAw?$AAi?$AAp@
CONST	SEGMENT
??_C@_1GI@CANLKDBI@?$AAR?$AAe?$AAf?$AAu?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAt?$AAo?$AA?5?$AAw?$AAi?$AAp@ DB 'R'
	DB	00H, 'e', 00H, 'f', 00H, 'u', 00H, 's', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'w', 00H, 'i'
	DB	00H, 'p', 00H, 'e', 00H, ' ', 00H, 's', 00H, 'y', 00H, 's', 00H
	DB	't', 00H, 'e', 00H, 'm', 00H, ' ', 00H, 'o', 00H, 'r', 00H, ' '
	DB	00H, 'n', 00H, 'o', 00H, 'n', 00H, '-', 00H, 'P', 00H, 'r', 00H
	DB	'o', 00H, 'g', 00H, 'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F'
	DB	00H, 'i', 00H, 'l', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'f', 00H
	DB	'i', 00H, 'l', 00H, 'e', 00H, ':', 00H, ' ', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@GLDIOEL@Failed?5to?5get?5executable?5path?6@
CONST	SEGMENT
??_C@_0BP@GLDIOEL@Failed?5to?5get?5executable?5path?6@ DB 'Failed to get '
	DB	'executable path', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@ILHIMEPI@Failed?5to?5open?5process?5for?5quer@
CONST	SEGMENT
??_C@_0DC@ILHIMEPI@Failed?5to?5open?5process?5for?5quer@ DB 'Failed to op'
	DB	'en process for query and termination', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FI@FBPFGPFA@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?3?$AA?5?$AAK?$AAi?$AAl?$AAl?$AA?5?$AA?$CG?$AA?5@
CONST	SEGMENT
??_C@_1FI@FBPFGPFA@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?3?$AA?5?$AAK?$AAi?$AAl?$AAl?$AA?5?$AA?$CG?$AA?5@ DB 'D'
	DB	00H, 'r', 00H, 'i', 00H, 'v', 00H, 'e', 00H, 'r', 00H, ':', 00H
	DB	' ', 00H, 'K', 00H, 'i', 00H, 'l', 00H, 'l', 00H, ' ', 00H, '&'
	DB	00H, ' ', 00H, 'W', 00H, 'i', 00H, 'p', 00H, 'e', 00H, ' ', 00H
	DB	'r', 00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, 's', 00H, 't'
	DB	00H, ' ', 00H, 'f', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H
	DB	'd', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'P'
	DB	00H, 'I', 00H, 'D', 00H, ' ', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1FE@ILHKNOOP@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?3?$AA?5?$AAK?$AAi?$AAl?$AAl?$AA?5?$AA?$CG?$AA?5@
CONST	SEGMENT
??_C@_1FE@ILHKNOOP@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?3?$AA?5?$AAK?$AAi?$AAl?$AAl?$AA?5?$AA?$CG?$AA?5@ DB 'D'
	DB	00H, 'r', 00H, 'i', 00H, 'v', 00H, 'e', 00H, 'r', 00H, ':', 00H
	DB	' ', 00H, 'K', 00H, 'i', 00H, 'l', 00H, 'l', 00H, ' ', 00H, '&'
	DB	00H, ' ', 00H, 'W', 00H, 'i', 00H, 'p', 00H, 'e', 00H, ' ', 00H
	DB	'r', 00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, 's', 00H, 't'
	DB	00H, ' ', 00H, 's', 00H, 'e', 00H, 'n', 00H, 't', 00H, ' ', 00H
	DB	'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'P', 00H, 'I', 00H, 'D'
	DB	00H, ' ', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_13LBAGMAIH@?$AA?6@
CONST	SEGMENT
??_C@_13LBAGMAIH@?$AA?6@ DB 0aH, 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GMIBBJLF@Cancelled?6@
CONST	SEGMENT
??_C@_0L@GMIBBJLF@Cancelled?6@ DB 'Cancelled', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@OBKIMPA@Select?5process?5to?5terminate?5and@
CONST	SEGMENT
??_C@_0DF@OBKIMPA@Select?5process?5to?5terminate?5and@ DB 'Select process'
	DB	' to terminate and wipe (0 to cancel): ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DBEMKEBP@No?5allowed?5anti?9cheat?5processes@
CONST	SEGMENT
??_C@_0CH@DBEMKEBP@No?5allowed?5anti?9cheat?5processes@ DB 'No allowed an'
	DB	'ti-cheat processes found', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KHOJGJKF@?4?5@
CONST	SEGMENT
??_C@_02KHOJGJKF@?4?5@ DB '. ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07GOJKIMHK@?5?$CIPID?3?5@
CONST	SEGMENT
??_C@_07GOJKIMHK@?5?$CIPID?3?5@ DB ' (PID: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02MNMNLDAI@?$CJ?6@
CONST	SEGMENT
??_C@_02MNMNLDAI@?$CJ?6@ DB ')', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HMDMDLOM@Failed?5to?5create?5process?5snapsh@
CONST	SEGMENT
??_C@_0CD@HMDMDLOM@Failed?5to?5create?5process?5snapsh@ DB 'Failed to cre'
	DB	'ate process snapshot', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@DNABAJMK@?$AAR?$AAo?$AAb?$AAl?$AAo?$AAx?$AAP?$AAl?$AAa?$AAy?$AAe?$AAr?$AAB?$AAe?$AAt@
CONST	SEGMENT
??_C@_1CK@DNABAJMK@?$AAR?$AAo?$AAb?$AAl?$AAo?$AAx?$AAP?$AAl?$AAa?$AAy?$AAe?$AAr?$AAB?$AAe?$AAt@ DB 'R'
	DB	00H, 'o', 00H, 'b', 00H, 'l', 00H, 'o', 00H, 'x', 00H, 'P', 00H
	DB	'l', 00H, 'a', 00H, 'y', 00H, 'e', 00H, 'r', 00H, 'B', 00H, 'e'
	DB	00H, 't', 00H, 'a', 00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@KHLBIGMC@?$AAV?$AAa?$AAn?$AAg?$AAu?$AAa?$AAr?$AAd?$AA?4?$AAe?$AAx?$AAe@
CONST	SEGMENT
??_C@_1BK@KHLBIGMC@?$AAV?$AAa?$AAn?$AAg?$AAu?$AAa?$AAr?$AAd?$AA?4?$AAe?$AAx?$AAe@ DB 'V'
	DB	00H, 'a', 00H, 'n', 00H, 'g', 00H, 'u', 00H, 'a', 00H, 'r', 00H
	DB	'd', 00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@NHFJGJJ@?$AAv?$AAg?$AAk?$AA?4?$AAe?$AAx?$AAe@
CONST	SEGMENT
??_C@_1BA@NHFJGJJ@?$AAv?$AAg?$AAk?$AA?4?$AAe?$AAx?$AAe@ DB 'v', 00H, 'g', 00H
	DB	'k', 00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@FECLNECF@?$AAr?$AAb?$AAx?$AAh?$AAy?$AAp?$AAe?$AAr?$AAi?$AAo?$AAn?$AA?4?$AAe?$AAx?$AAe@
CONST	SEGMENT
??_C@_1CA@FECLNECF@?$AAr?$AAb?$AAx?$AAh?$AAy?$AAp?$AAe?$AAr?$AAi?$AAo?$AAn?$AA?4?$AAe?$AAx?$AAe@ DB 'r'
	DB	00H, 'b', 00H, 'x', 00H, 'h', 00H, 'y', 00H, 'p', 00H, 'e', 00H
	DB	'r', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '.', 00H, 'e', 00H, 'x'
	DB	00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@LGHOJOAP@?$AAE?$AAa?$AAs?$AAy?$AAA?$AAn?$AAt?$AAi?$AAC?$AAh?$AAe?$AAa?$AAt?$AA?4?$AAe@
CONST	SEGMENT
??_C@_1CE@LGHOJOAP@?$AAE?$AAa?$AAs?$AAy?$AAA?$AAn?$AAt?$AAi?$AAC?$AAh?$AAe?$AAa?$AAt?$AA?4?$AAe@ DB 'E'
	DB	00H, 'a', 00H, 's', 00H, 'y', 00H, 'A', 00H, 'n', 00H, 't', 00H
	DB	'i', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'a', 00H, 't', 00H, '.'
	DB	00H, 'e', 00H, 'x', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_istream<char,std::char_traits<char> >::`vbtable'
	DD	018H
CONST	ENDS
;	COMDAT ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_istream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_istream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_0DB@PHJEDLD@Executable?5wipe?5incomplete?5due?5@
CONST	SEGMENT
??_C@_0DB@PHJEDLD@Executable?5wipe?5incomplete?5due?5@ DB 'Executable wip'
	DB	'e incomplete due to write failure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KNKFCKIE@Executable?5securely?5wiped?6@
CONST	SEGMENT
??_C@_0BL@KNKFCKIE@Executable?5securely?5wiped?6@ DB 'Executable securely'
	DB	' wiped', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GPLPEJGN@Failed?5to?5write?5random?5data?5to?5@
CONST	SEGMENT
??_C@_0CF@GPLPEJGN@Failed?5to?5write?5random?5data?5to?5@ DB 'Failed to w'
	DB	'rite random data to file', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JHGEGGMB@Failed?5to?5open?5file?5for?5overwri@
CONST	SEGMENT
??_C@_0CD@JHGEGGMB@Failed?5to?5open?5file?5for?5overwri@ DB 'Failed to op'
	DB	'en file for overwrite', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`vbtable'
	DD	08H
CONST	ENDS
;	COMDAT ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ostream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ios<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_1BK@KDDKMJBN@?$AAS?$AA?9?$AA1?$AA?9?$AA5?$AA?9?$AA3?$AA2?$AA?9?$AA5?$AA4?$AA4@
CONST	SEGMENT
??_C@_1BK@KDDKMJBN@?$AAS?$AA?9?$AA1?$AA?9?$AA5?$AA?9?$AA3?$AA2?$AA?9?$AA5?$AA4?$AA4@ DB 'S'
	DB	00H, '-', 00H, '1', 00H, '-', 00H, '5', 00H, '-', 00H, '3', 00H
	DB	'2', 00H, '-', 00H, '5', 00H, '4', 00H, '4', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@FOGOLNOF@?$AAS?$AA?9?$AA1?$AA?9?$AA5?$AA?9?$AA1?$AA8@
CONST	SEGMENT
??_C@_1BC@FOGOLNOF@?$AAS?$AA?9?$AA1?$AA?9?$AA5?$AA?9?$AA1?$AA8@ DB 'S', 00H
	DB	'-', 00H, '1', 00H, '-', 00H, '5', 00H, '-', 00H, '1', 00H, '8'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@NPPKGKBB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1DA@NPPKGKBB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@OEHNAGL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1CE@OEHNAGL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@CIFNPBMN@?$AA?2?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?2?$AAs?$AAy?$AAs?$AAt?$AAe?$AAm@
CONST	SEGMENT
??_C@_1DG@CIFNPBMN@?$AA?2?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?2?$AAs?$AAy?$AAs?$AAt?$AAe?$AAm@ DB '\'
	DB	00H, 'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H
	DB	's', 00H, '\', 00H, 's', 00H, 'y', 00H, 's', 00H, 't', 00H, 'e'
	DB	00H, 'm', 00H, '3', 00H, '2', 00H, '\', 00H, 'd', 00H, 'r', 00H
	DB	'i', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 's', 00H, '\', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@NCCDOFIB@?$AA?2?$AAs?$AAy?$AAs?$AAt?$AAe?$AAm?$AA3?$AA2?$AA?2@
CONST	SEGMENT
??_C@_1BG@NCCDOFIB@?$AA?2?$AAs?$AAy?$AAs?$AAt?$AAe?$AAm?$AA3?$AA2?$AA?2@ DB '\'
	DB	00H, 's', 00H, 'y', 00H, 's', 00H, 't', 00H, 'e', 00H, 'm', 00H
	DB	'3', 00H, '2', 00H, '\', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@NMFIMKAA@?$AA?2?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?2@
CONST	SEGMENT
??_C@_1BE@NMFIMKAA@?$AA?2?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?2@ DB '\'
	DB	00H, 'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H
	DB	's', 00H, '\', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
xdata$x	SEGMENT
__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20 DD 00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0failure@ios_base@std@@QAE@ABV012@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
data$r	SEGMENT
??_R0?AVfailure@ios_base@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::ios_base::failure `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfailure@ios_base@std@@', 00H
data$r	ENDS
;	COMDAT __CTA5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__CTA5?AVfailure@ios_base@std@@ DD 05H
	DD	FLAT:__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
	DD	FLAT:__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__TI5?AVfailure@ios_base@std@@ DD 00H
	DD	FLAT:??1failure@ios_base@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA5?AVfailure@ios_base@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
CONST	SEGMENT
??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@ DB 'ios_base::eofbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
CONST	SEGMENT
??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@ DB 'ios_base::failbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
CONST	SEGMENT
??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@ DB 'ios_base::badbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7ios_base@std@@6B@
CONST	SEGMENT
??_7ios_base@std@@6B@ DD FLAT:??_R4ios_base@std@@6B@	; std::ios_base::`vftable'
	DD	FLAT:??_Eios_base@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT
??_7failure@ios_base@std@@6B@ DD FLAT:??_R4failure@ios_base@std@@6B@ ; std::ios_base::failure::`vftable'
	DD	FLAT:??_Efailure@ios_base@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7?$ctype@_W@std@@6B@
CONST	SEGMENT
??_7?$ctype@_W@std@@6B@ DD FLAT:??_R4?$ctype@_W@std@@6B@ ; std::ctype<wchar_t>::`vftable'
	DD	FLAT:??_E?$ctype@_W@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_is@?$ctype@_W@std@@MBEPB_WPB_W0PAF@Z
	DD	FLAT:?do_is@?$ctype@_W@std@@MBE_NF_W@Z
	DD	FLAT:?do_scan_is@?$ctype@_W@std@@MBEPB_WFPB_W0@Z
	DD	FLAT:?do_scan_not@?$ctype@_W@std@@MBEPB_WFPB_W0@Z
	DD	FLAT:?do_tolower@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z
	DD	FLAT:?do_tolower@?$ctype@_W@std@@MBE_W_W@Z
	DD	FLAT:?do_toupper@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z
	DD	FLAT:?do_toupper@?$ctype@_W@std@@MBE_W_W@Z
	DD	FLAT:?do_widen@?$ctype@_W@std@@MBEPBDPBD0PA_W@Z
	DD	FLAT:?do_widen@?$ctype@_W@std@@MBE_WD@Z
	DD	FLAT:?do_narrow@?$ctype@_W@std@@MBEPB_WPB_W0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@_W@std@@MBED_WD@Z
CONST	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT
??_7?$ctype@D@std@@6B@ DD FLAT:??_R4?$ctype@D@std@@6B@	; std::ctype<char>::`vftable'
	DD	FLAT:??_E?$ctype@D@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEDDD@Z
CONST	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT
??_7ctype_base@std@@6B@ DD FLAT:??_R4ctype_base@std@@6B@ ; std::ctype_base::`vftable'
	DD	FLAT:??_Ectype_base@std@@UAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_7codecvt_base@std@@6B@
CONST	SEGMENT
??_7codecvt_base@std@@6B@ DD FLAT:??_R4codecvt_base@std@@6B@ ; std::codecvt_base::`vftable'
	DD	FLAT:??_Ecodecvt_base@std@@UAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_always_noconv@codecvt_base@std@@MBE_NXZ
	DD	FLAT:?do_max_length@codecvt_base@std@@MBEHXZ
	DD	FLAT:?do_encoding@codecvt_base@std@@MBEHXZ
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT
??_7facet@locale@std@@6B@ DD FLAT:??_R4facet@locale@std@@6B@ ; std::locale::facet::`vftable'
	DD	FLAT:??_Efacet@locale@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false@
CONST	SEGMENT
??_C@_05LAPONLG@false@ DB 'false', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ELKIONDK@bad?5locale?5name@
CONST	SEGMENT
??_C@_0BA@ELKIONDK@bad?5locale?5name@ DB 'bad locale name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7_Facet_base@std@@6B@
CONST	SEGMENT
??_7_Facet_base@std@@6B@ DD FLAT:??_R4_Facet_base@std@@6B@ ; std::_Facet_base::`vftable'
	DD	FLAT:??_E_Facet_base@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast@ DB 'bad cast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DD FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DD	FLAT:??_Ebad_cast@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ?_Iostream_error@?4??message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB
CONST	SEGMENT
?_Iostream_error@?4??message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB DB 069H ; `std::_Iostream_error_category2::message'::`5'::_Iostream_error
	DB	06fH
	DB	073H
	DB	074H
	DB	072H
	DB	065H
	DB	061H
	DB	06dH
	DB	020H
	DB	073H
	DB	074H
	DB	072H
	DB	065H
	DB	061H
	DB	06dH
	DB	020H
	DB	065H
	DB	072H
	DB	072H
	DB	06fH
	DB	072H
	DB	00H
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream@ DB 'iostream', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category2@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category2@std@@6B@ DD FLAT:??_R4_Iostream_error_category2@std@@6B@ ; std::_Iostream_error_category2::`vftable'
	DD	FLAT:??_E_Iostream_error_category2@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category2@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT __CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0_System_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AV_System_error@std@@@8
data$r	SEGMENT
??_R0?AV_System_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0system_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVsystem_error@std@@@8
data$r	SEGMENT
??_R0?AVsystem_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::system_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVsystem_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_7system_error@std@@6B@
CONST	SEGMENT
??_7system_error@std@@6B@ DD FLAT:??_R4system_error@std@@6B@ ; std::system_error::`vftable'
	DD	FLAT:??_Esystem_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7_System_error@std@@6B@
CONST	SEGMENT
??_7_System_error@std@@6B@ DD FLAT:??_R4_System_error@std@@6B@ ; std::_System_error::`vftable'
	DD	FLAT:??_E_System_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
data$r	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z$0
	DD	00H
	DD	FLAT:___std_terminate
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z$1
__ehfuncinfo$??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$0
__ehfuncinfo$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z$2
__ehfuncinfo$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z$1
__ehfuncinfo$??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z$1
__ehfuncinfo$??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z$0
__ehfuncinfo$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z$2
__ehfuncinfo$??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z$1
__ehfuncinfo$??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Fput_v3@$0A@@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@1@V21@AAVios_base@1@_WPBDI_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Fput_v3@$0A@@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@1@V21@AAVios_base@1@_WPBDI_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Fput_v3@$0A@@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@1@V21@AAVios_base@1@_WPBDI_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Fput_v3@$0A@@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@1@V21@AAVios_base@1@_WPBDI_N@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Fput_v3@$0A@@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@1@V21@AAVios_base@1@_WPBDI_N@Z$3
__ehfuncinfo$??$_Fput_v3@$0A@@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@1@V21@AAVios_base@1@_WPBDI_N@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$_Fput_v3@$0A@@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@1@V21@AAVios_base@1@_WPBDI_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$1
__ehfuncinfo$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_copy@PBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PBV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PBV10@0PAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@PBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PBV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PBV10@0PAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_copy@PBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PBV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PBV10@0PAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@PBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PBV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PBV10@0PAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z$0
__ehfuncinfo$??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z$8 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z$0
__tryblocktable$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z DD 02H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z$8
__ehfuncinfo$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z$2
	DD	01H
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z$3
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0
__ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z$1
__ehfuncinfo$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$3
__ehfuncinfo$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z$0
__ehfuncinfo$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z$0
__ehfuncinfo$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z$1
__ehfuncinfo$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z$1
__ehfuncinfo$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct_n@PBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PBV12@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXI$$QAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct_n@PBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PBV12@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXI$$QAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Construct_n@PBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PBV12@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXI$$QAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@0@Z$1
__ehfuncinfo$??$_Construct_n@PBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PBV12@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXI$$QAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Construct_n@PBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PBV12@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXI$$QAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z$0
__ehfuncinfo$??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z$0
__tryblocktable$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z$5
__unwindtable$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z$1
__ehfuncinfo$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$0
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$2
__ehfuncinfo$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ShowErrorPopupIfNeeded@@YAXXZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?ShowErrorPopupIfNeeded@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ShowErrorPopupIfNeeded@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ShowErrorPopupIfNeeded@@YAXXZ$2
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?ShowErrorPopupIfNeeded@@YAXXZ$3
	DD	02H
	DD	FLAT:__unwindfunclet$?ShowErrorPopupIfNeeded@@YAXXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ShowErrorPopupIfNeeded@@YAXXZ$0
	DD	04H
	DD	FLAT:__unwindfunclet$?ShowErrorPopupIfNeeded@@YAXXZ$1
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ$0
__ehfuncinfo$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z$0
__ehfuncinfo$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$0
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z$2
__ehfuncinfo$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?RetrieveAndWriteErrorLog@@YAXXZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?RetrieveAndWriteErrorLog@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?RetrieveAndWriteErrorLog@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RetrieveAndWriteErrorLog@@YAXXZ$1
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?RetrieveAndWriteErrorLog@@YAXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?RetrieveAndWriteErrorLog@@YAXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RetrieveAndWriteErrorLog@@YAXXZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$0
__tryblocktable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$5
__unwindtable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?ignore@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?ignore@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z$0
__tryblocktable$?ignore@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?ignore@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z$6
__ehfuncinfo$?ignore@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?ignore@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?ignore@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ignore@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ignore@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ignore@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$0
__tryblocktable$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$6
__ehfuncinfo$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ
	DD	01H
	DD	FLAT:__tryblocktable$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$0
__tryblocktable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$4
__unwindtable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$2
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z$0
__ehfuncinfo$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$7 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z DD 01H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$7
__ehfuncinfo$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$2
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$3
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ$12 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ$0
__tryblocktable$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ$12
__unwindtable$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z$7 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z$0
__tryblocktable$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z$7
__ehfuncinfo$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z$3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@H@Z$7 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@H@Z$0
__tryblocktable$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@H@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@H@Z$7
__ehfuncinfo$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@H@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@H@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@H@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@H@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@H@Z$3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$0
__unwindtable$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$2
__ehfuncinfo$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@V?$initializer_list@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@V?$initializer_list@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@V?$initializer_list@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z$1
__ehfuncinfo$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@V?$initializer_list@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@V?$initializer_list@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ListAndWipeProcess@@YAXXZ DD 019930522H
	DD	0fH
	DD	FLAT:__unwindtable$?ListAndWipeProcess@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ListAndWipeProcess@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ListAndWipeProcess@@YAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ListAndWipeProcess@@YAXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ListAndWipeProcess@@YAXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?ListAndWipeProcess@@YAXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?ListAndWipeProcess@@YAXXZ$4
	DD	00H
	DD	FLAT:__unwindfunclet$?ListAndWipeProcess@@YAXXZ$6
	DD	05H
	DD	FLAT:__unwindfunclet$?ListAndWipeProcess@@YAXXZ$27
	DD	06H
	DD	FLAT:__unwindfunclet$?ListAndWipeProcess@@YAXXZ$28
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ListAndWipeProcess@@YAXXZ$7
	DD	08H
	DD	FLAT:__unwindfunclet$?ListAndWipeProcess@@YAXXZ$8
	DD	09H
	DD	FLAT:__unwindfunclet$?ListAndWipeProcess@@YAXXZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$?ListAndWipeProcess@@YAXXZ$10
	DD	0bH
	DD	FLAT:__unwindfunclet$?ListAndWipeProcess@@YAXXZ$11
	DD	0cH
	DD	FLAT:__unwindfunclet$?ListAndWipeProcess@@YAXXZ$31
	DD	0cH
	DD	FLAT:__unwindfunclet$?ListAndWipeProcess@@YAXXZ$12
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$5
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$12 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$0
__tryblocktable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$12
__unwindtable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0
__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2
__ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z$0
__ehfuncinfo$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z$1
__ehfuncinfo$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z$0
__ehfuncinfo$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SecureWipeFile@@YAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@T_LARGE_INTEGER@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SecureWipeFile@@YAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@T_LARGE_INTEGER@@@Z$0
__ehfuncinfo$?SecureWipeFile@@YAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@T_LARGE_INTEGER@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SecureWipeFile@@YAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@T_LARGE_INTEGER@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?IsSafeWipePath@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsSafeWipePath@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z$0
__ehfuncinfo$?IsSafeWipePath@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsSafeWipePath@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SendIoctl@@YA_NKPAXK0K@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SendIoctl@@YA_NKPAXK0K@Z$0
__ehfuncinfo$?SendIoctl@@YA_NKPAXK0K@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SendIoctl@@YA_NKPAXK0K@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_Gios_base@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??_Gios_base@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_Gios_base@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Init@ios_base@std@@IAEXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$?_Init@ios_base@std@@IAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Init@ios_base@std@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1ios_base@std@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z$1
__ehfuncinfo$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$1
__ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0locale@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Locinfo@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0_Locinfo@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0_Locinfo@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0system_error@std@@QAE@Verror_code@1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$0
__ehfuncinfo$??0system_error@std@@QAE@Verror_code@1@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0system_error@std@@QAE@Verror_code@1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$6
__ehfuncinfo$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$1
__ehfuncinfo$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_istream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_istream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_istream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
??_E?$basic_istream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z PROC		; std::_Maklocchr<char>, COMDAT

; 500  : _Elem __CRTDECL _Maklocchr(char _Byte, _Elem*, const _Locinfo::_Cvtvec&) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 501  :     // convert char to _Elem using _Cvtvec
; 502  :     return static_cast<_Elem>(static_cast<unsigned char>(_Byte));

  00003	8a 45 08	 mov	 al, BYTE PTR __Byte$[ebp]

; 503  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ENDP		; std::_Maklocchr<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ PROC	; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >, COMDAT
; _this$ = ecx

; 86   :     _CONSTEXPR20 ~_Tidy_guard() {

  00000	56		 push	 esi

; 87   :         if (_Target) {

  00001	8b 31		 mov	 esi, DWORD PTR [ecx]
  00003	85 f6		 test	 esi, esi
  00005	74 1b		 je	 SHORT $LN6@Tidy_guard
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 202  :         _CSTD free(const_cast<char*>(_Grouping));

  00007	ff 76 08	 push	 DWORD PTR [esi+8]
  0000a	e8 00 00 00 00	 call	 _free

; 203  :         _CSTD free(const_cast<_Elem*>(_Falsename));

  0000f	ff 76 10	 push	 DWORD PTR [esi+16]
  00012	e8 00 00 00 00	 call	 _free

; 204  :         _CSTD free(const_cast<_Elem*>(_Truename));

  00017	ff 76 14	 push	 DWORD PTR [esi+20]
  0001a	e8 00 00 00 00	 call	 _free
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@Tidy_guard:
  00022	5e		 pop	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 90   :     }

  00023	c3		 ret	 0
??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ ENDP	; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT

; 526  : _Elem* __CRTDECL _Maklocstr(const char* _Ptr, _Elem*, const _Locinfo::_Cvtvec&) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 527  :     // convert C string to _Elem sequence using _Cvtvec
; 528  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL11@Maklocstr:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL11@Maklocstr
  00017	56		 push	 esi
  00018	2b c2		 sub	 eax, edx
  0001a	57		 push	 edi

; 529  : 
; 530  :     _Elem* _Ptrdest = static_cast<_Elem*>(_calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__));

  0001b	6a 01		 push	 1
  0001d	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  00020	57		 push	 edi
  00021	e8 00 00 00 00	 call	 _calloc
  00026	8b f0		 mov	 esi, eax
  00028	83 c4 08	 add	 esp, 8

; 531  : 
; 532  :     if (!_Ptrdest) {

  0002b	85 f6		 test	 esi, esi
  0002d	74 17		 je	 SHORT $LN17@Maklocstr

; 534  :     }
; 535  : 
; 536  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

  0002f	85 ff		 test	 edi, edi
  00031	74 0d		 je	 SHORT $LN4@Maklocstr
  00033	57		 push	 edi
  00034	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00037	56		 push	 esi
  00038	e8 00 00 00 00	 call	 _memcpy
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@Maklocstr:

; 537  :         *_Ptrnext = static_cast<_Elem>(static_cast<unsigned char>(*_Ptr));
; 538  :     }
; 539  : 
; 540  :     return _Ptrdest;
; 541  : }

  00040	5f		 pop	 edi
  00041	8b c6		 mov	 eax, esi
  00043	5e		 pop	 esi
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
$LN17@Maklocstr:

; 533  :         _Xbad_alloc();

  00046	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN15@Maklocstr:
  0004b	cc		 int	 3
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$numpunct@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tidy_guard@V?$numpunct@_W@std@@@std@@QAE@XZ PROC	; std::_Tidy_guard<std::numpunct<wchar_t> >::~_Tidy_guard<std::numpunct<wchar_t> >, COMDAT
; _this$ = ecx

; 86   :     _CONSTEXPR20 ~_Tidy_guard() {

  00000	56		 push	 esi

; 87   :         if (_Target) {

  00001	8b 31		 mov	 esi, DWORD PTR [ecx]
  00003	85 f6		 test	 esi, esi
  00005	74 1b		 je	 SHORT $LN6@Tidy_guard
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 202  :         _CSTD free(const_cast<char*>(_Grouping));

  00007	ff 76 08	 push	 DWORD PTR [esi+8]
  0000a	e8 00 00 00 00	 call	 _free

; 203  :         _CSTD free(const_cast<_Elem*>(_Falsename));

  0000f	ff 76 10	 push	 DWORD PTR [esi+16]
  00012	e8 00 00 00 00	 call	 _free

; 204  :         _CSTD free(const_cast<_Elem*>(_Truename));

  00017	ff 76 14	 push	 DWORD PTR [esi+20]
  0001a	e8 00 00 00 00	 call	 _free
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@Tidy_guard:
  00022	5e		 pop	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 90   :     }

  00023	c3		 ret	 0
??1?$_Tidy_guard@V?$numpunct@_W@std@@@std@@QAE@XZ ENDP	; std::_Tidy_guard<std::numpunct<wchar_t> >::~_Tidy_guard<std::numpunct<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 182  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 183  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 185  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 136  :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	0f ae e8	 lfence
  00015	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 186  :         _Throw_bad_array_new_length(); // add overflow
; 187  :     }
; 188  : 
; 189  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  0001a	8b c8		 mov	 ecx, eax

; 136  :         return ::operator new(_Bytes);

  0001c	83 c4 04	 add	 esp, 4

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001f	85 c9		 test	 ecx, ecx
  00021	74 0e		 je	 SHORT $LN9@Allocate_m

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00023	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00026	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00029	0f ae e8	 lfence

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  0002c	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 193  : 
; 194  : #ifdef _DEBUG
; 195  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 196  : #endif // defined(_DEBUG)
; 197  :     return _Ptr;
; 198  : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN9@Allocate_m:

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	6a 00		 push	 0
  00037	6a 00		 push	 0
  00039	6a 00		 push	 0
  0003b	e8 00 00 00 00	 call	 __invoke_watson
$LN7@Allocate_m:
  00040	cc		 int	 3
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Find_vectorized@$$CBDD@std@@YAPBDQBD0D@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 1
??$_Find_vectorized@$$CBDD@std@@YAPBDQBD0D@Z PROC	; std::_Find_vectorized<char const ,char>, COMDAT

; 190  : _Ty* _Find_vectorized(_Ty* const _First, _Ty* const _Last, const _TVal _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 191  :     if constexpr (is_pointer_v<_TVal> || is_null_pointer_v<_TVal>) {
; 192  : #ifdef _WIN64
; 193  :         return const_cast<_Ty*>(
; 194  :             static_cast<const _Ty*>(::__std_find_trivial_8(_First, _Last, reinterpret_cast<uint64_t>(_Val))));
; 195  : #else
; 196  :         return const_cast<_Ty*>(
; 197  :             static_cast<const _Ty*>(::__std_find_trivial_4(_First, _Last, reinterpret_cast<uint32_t>(_Val))));
; 198  : #endif
; 199  :     } else if constexpr (sizeof(_Ty) == 1) {
; 200  :         return const_cast<_Ty*>(

  00003	ff 75 10	 push	 DWORD PTR __Val$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00009	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000c	e8 00 00 00 00	 call	 ___std_find_trivial_1@12

; 201  :             static_cast<const _Ty*>(::__std_find_trivial_1(_First, _Last, static_cast<uint8_t>(_Val))));
; 202  :     } else if constexpr (sizeof(_Ty) == 2) {
; 203  :         return const_cast<_Ty*>(
; 204  :             static_cast<const _Ty*>(::__std_find_trivial_2(_First, _Last, static_cast<uint16_t>(_Val))));
; 205  :     } else if constexpr (sizeof(_Ty) == 4) {
; 206  :         return const_cast<_Ty*>(
; 207  :             static_cast<const _Ty*>(::__std_find_trivial_4(_First, _Last, static_cast<uint32_t>(_Val))));
; 208  :     } else if constexpr (sizeof(_Ty) == 8) {
; 209  :         return const_cast<_Ty*>(
; 210  :             static_cast<const _Ty*>(::__std_find_trivial_8(_First, _Last, static_cast<uint64_t>(_Val))));
; 211  :     } else {
; 212  :         _STL_INTERNAL_STATIC_ASSERT(false); // unexpected size
; 213  :     }
; 214  : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Find_vectorized@$$CBDD@std@@YAPBDQBD0D@Z ENDP	; std::_Find_vectorized<char const ,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits>, COMDAT

; 225  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 226  :     // allocate _Bytes
; 227  :     if (_Bytes == 0) {

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 02		 jne	 SHORT $LN2@Allocate

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
; 254  :         }
; 255  : #endif // defined(_M_IX86) || defined(_M_X64)
; 256  :         return _Traits::_Allocate(_Bytes);
; 257  :     }
; 258  : }

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
$LN2@Allocate:

; 228  :         return nullptr;
; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  0000c	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00011	72 2b		 jb	 SHORT $LN3@Allocate

; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00013	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 185  :     if (_Block_size <= _Bytes) {

  00016	3b c8		 cmp	 ecx, eax
  00018	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 136  :         return ::operator new(_Bytes);

  0001e	51		 push	 ecx
  0001f	0f ae e8	 lfence
  00022	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 189  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00027	8b c8		 mov	 ecx, eax

; 136  :         return ::operator new(_Bytes);

  00029	83 c4 04	 add	 esp, 4

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002c	85 c9		 test	 ecx, ecx
  0002e	74 1a		 je	 SHORT $LN17@Allocate

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00030	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00033	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00036	0f ae e8	 lfence

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00039	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
; 254  :         }
; 255  : #endif // defined(_M_IX86) || defined(_M_X64)
; 256  :         return _Traits::_Allocate(_Bytes);
; 257  :     }
; 258  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN3@Allocate:

; 136  :         return ::operator new(_Bytes);

  0003e	0f ae e8	 lfence
  00041	89 45 08	 mov	 DWORD PTR __Bytes$[ebp], eax

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
; 254  :         }
; 255  : #endif // defined(_M_IX86) || defined(_M_X64)
; 256  :         return _Traits::_Allocate(_Bytes);
; 257  :     }
; 258  : }

  00044	5d		 pop	 ebp

; 136  :         return ::operator new(_Bytes);

  00045	e9 00 00 00 00	 jmp	 ??2@YAPAXI@Z		; operator new
$LN17@Allocate:

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0004a	6a 00		 push	 0
  0004c	6a 00		 push	 0
  0004e	6a 00		 push	 0
  00050	6a 00		 push	 0
  00052	6a 00		 push	 0
  00054	e8 00 00 00 00	 call	 __invoke_watson
$LN15@Allocate:
  00059	cc		 int	 3
??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Reverse_vectorized@$00@std@@YAXPAX0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Reverse_vectorized@$00@std@@YAXPAX0@Z PROC		; std::_Reverse_vectorized<1>, COMDAT

; 155  :     if constexpr (_Nx == 1) {
; 156  :         ::__std_reverse_trivially_swappable_1(_First, _Last);

  00000	e9 00 00 00 00	 jmp	 ___std_reverse_trivially_swappable_1
??$_Reverse_vectorized@$00@std@@YAXPAX0@Z ENDP		; std::_Reverse_vectorized<1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PAK@std@@YAPAKQBDQAKII@Z
_TEXT	SEGMENT
__First_ch$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Byte_count$ = 16					; size = 4
__Object_count$ = 20					; size = 4
??$_Copy_memmove_tail@PAK@std@@YAPAKQBDQAKII@Z PROC	; std::_Copy_memmove_tail<unsigned long *>, COMDAT

; 4747 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4748 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4749 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4750 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4751 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Byte_count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 08	 push	 DWORD PTR __First_ch$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4752 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4753 :         (void) _Object_count;
; 4754 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4755 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 4756 :     } else {
; 4757 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4758 :     }
; 4759 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove_tail@PAK@std@@YAPAKQBDQAKII@Z ENDP	; std::_Copy_memmove_tail<unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??$_Find_elem@D$0BN@@std@@YAIAAY0BN@$$CBDD@Z
_TEXT	SEGMENT
__Base$ = 8						; size = 4
__Ch$ = 12						; size = 1
??$_Find_elem@D$0BN@@std@@YAIAAY0BN@$$CBDD@Z PROC	; std::_Find_elem<char,29>, COMDAT

; 67   : size_t _Find_elem(const _Elem (&_Base)[_Base_size], const _Elem _Ch) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 70   :     return static_cast<size_t>(_STD _Find_unchecked(_Base, _Base + (_Base_size - 1), _Ch) - _Base);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Base$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 200  :         return const_cast<_Ty*>(

  00007	ff 75 0c	 push	 DWORD PTR __Ch$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 70   :     return static_cast<size_t>(_STD _Find_unchecked(_Base, _Base + (_Base_size - 1), _Ch) - _Base);

  0000a	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 200  :         return const_cast<_Ty*>(

  0000d	50		 push	 eax
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 ___std_find_trivial_1@12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 70   :     return static_cast<size_t>(_STD _Find_unchecked(_Base, _Base + (_Base_size - 1), _Ch) - _Base);

  00014	2b c6		 sub	 eax, esi
  00016	5e		 pop	 esi

; 71   : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Find_elem@D$0BN@@std@@YAIAAY0BN@$$CBDD@Z ENDP	; std::_Find_elem<char,29>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??$_Find_elem@D$0BL@@std@@YAIAAY0BL@$$CBDD@Z
_TEXT	SEGMENT
__Base$ = 8						; size = 4
__Ch$ = 12						; size = 1
??$_Find_elem@D$0BL@@std@@YAIAAY0BL@$$CBDD@Z PROC	; std::_Find_elem<char,27>, COMDAT

; 67   : size_t _Find_elem(const _Elem (&_Base)[_Base_size], const _Elem _Ch) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 70   :     return static_cast<size_t>(_STD _Find_unchecked(_Base, _Base + (_Base_size - 1), _Ch) - _Base);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Base$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 200  :         return const_cast<_Ty*>(

  00007	ff 75 0c	 push	 DWORD PTR __Ch$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 70   :     return static_cast<size_t>(_STD _Find_unchecked(_Base, _Base + (_Base_size - 1), _Ch) - _Base);

  0000a	8d 46 1a	 lea	 eax, DWORD PTR [esi+26]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 200  :         return const_cast<_Ty*>(

  0000d	50		 push	 eax
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 ___std_find_trivial_1@12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 70   :     return static_cast<size_t>(_STD _Find_unchecked(_Base, _Base + (_Base_size - 1), _Ch) - _Base);

  00014	2b c6		 sub	 eax, esi
  00016	5e		 pop	 esi

; 71   : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Find_elem@D$0BL@@std@@YAIAAY0BL@$$CBDD@Z ENDP	; std::_Find_elem<char,27>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Copy_memmove@PAKPAK@std@@YAPAKPAK00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAKPAK@std@@YAPAKPAK00@Z PROC		; std::_Copy_memmove<unsigned long *,unsigned long *>, COMDAT

; 4762 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4763 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4764 :     const auto _First_ptr    = _STD _To_address(_First);
; 4765 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4766 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);
; 4767 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4768 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4769 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 4751 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]

; 4762 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  0000a	57		 push	 edi

; 4763 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4764 :     const auto _First_ptr    = _STD _To_address(_First);
; 4765 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4766 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);
; 4767 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4768 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4769 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);

  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax

; 4751 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4752 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4753 :         (void) _Object_count;
; 4754 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4755 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]

; 4770 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 4771 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PAKPAK@std@@YAPAKPAK00@Z ENDP		; std::_Copy_memmove<unsigned long *,unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z
_TEXT	SEGMENT
$T2 = -88						; size = 8
$T3 = -84						; size = 1
__CType$1$ = -80					; size = 4
__Ans$1$ = -76						; size = 4
__Numfields$2$ = -72					; size = 4
__Field$1$ = -68					; size = 4
__Last$GSCopy$1$ = -64					; size = 4
__Ptr$GSCopy$1$ = -60					; size = 4
__Column$1$ = -56					; size = 4
__Str$2$ = -52						; size = 4
__Ptr$1$ = -48						; size = 4
__Prefix$1$ = -41					; size = 1
__Str$ = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Numfields$ = 16					; size = 4
__Ptr$ = 20						; size = 4
__Matching$ = 24					; size = 1
??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z PROC ; std::_Getloctxt<std::istreambuf_iterator<char,std::char_traits<char> >,char>, COMDAT

; 3313 :     _InIt& _First, _InIt& _Last, size_t _Numfields, const _Elem* _Ptr, const _Case_sensitive _Matching) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 45 14	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00031	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]

; 3314 :     // find field at _Ptr that matches longest in [_First, _Last)
; 3315 :     for (size_t _Off = 0; _Ptr[_Off] != _Elem{}; ++_Off) {

  00034	8b 7d 10	 mov	 edi, DWORD PTR __Numfields$[ebp]
  00037	8a 18		 mov	 bl, BYTE PTR [eax]
  00039	89 45 c4	 mov	 DWORD PTR __Ptr$GSCopy$1$[ebp], eax
  0003c	89 4d c0	 mov	 DWORD PTR __Last$GSCopy$1$[ebp], ecx
  0003f	84 db		 test	 bl, bl
  00041	74 1d		 je	 SHORT $LN288@Getloctxt
  00043	8a d3		 mov	 dl, bl
  00045	8b c8		 mov	 ecx, eax
$LL4@Getloctxt:
  00047	3a d3		 cmp	 dl, bl
  00049	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0004c	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0004f	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00052	0f 45 c7	 cmovne	 eax, edi
  00055	8b f8		 mov	 edi, eax
  00057	84 d2		 test	 dl, dl
  00059	75 ec		 jne	 SHORT $LL4@Getloctxt
  0005b	89 45 b8	 mov	 DWORD PTR __Numfields$2$[ebp], eax
  0005e	eb 03		 jmp	 SHORT $LN3@Getloctxt
$LN288@Getloctxt:
  00060	89 7d b8	 mov	 DWORD PTR __Numfields$2$[ebp], edi
$LN3@Getloctxt:

; 3316 :         if (_Ptr[_Off] == _Ptr[0]) {
; 3317 :             ++_Numfields; // add fields with leading mark to initial count
; 3318 :         }
; 3319 :     }
; 3320 : 
; 3321 :     string _Str(_Numfields, '\0'); // one column counter for each field

  00063	6a 00		 push	 0
  00065	57		 push	 edi
  00066	8d 4d d8	 lea	 ecx, DWORD PTR __Str$[ebp]
  00069	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 272  :     locale() noexcept : _Ptr(_Init(true)) {}

  0006e	6a 01		 push	 1
  00070	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00077	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@_N@Z ; std::locale::_Init
  0007c	8b f8		 mov	 edi, eax
  0007e	89 7d ac	 mov	 DWORD PTR $T2[ebp+4], edi

; 3322 :     const ctype<_Elem>& _CType = _STD use_facet<ctype<_Elem>>(locale{});

  00081	8d 45 a8	 lea	 eax, DWORD PTR $T2[ebp]
  00084	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  0008e	83 c4 08	 add	 esp, 8
  00091	89 45 b0	 mov	 DWORD PTR __CType$1$[ebp], eax
  00094	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00098	85 ff		 test	 edi, edi

; 354  :         if (_Ptr) {

  0009a	74 14		 je	 SHORT $LL7@Getloctxt

; 355  :             delete _Ptr->_Decref();

  0009c	8b 17		 mov	 edx, DWORD PTR [edi]
  0009e	8b cf		 mov	 ecx, edi
  000a0	ff 52 08	 call	 DWORD PTR [edx+8]
  000a3	85 c0		 test	 eax, eax
  000a5	74 09		 je	 SHORT $LL7@Getloctxt
  000a7	8b 10		 mov	 edx, DWORD PTR [eax]
  000a9	8b c8		 mov	 ecx, eax
  000ab	6a 01		 push	 1
  000ad	ff 12		 call	 DWORD PTR [edx]
  000af	90		 npad	 1
$LL7@Getloctxt:

; 3326 :         bool _Prefix  = false; // seen at least one valid prefix

  000b0	32 c0		 xor	 al, al
  000b2	c7 45 b4 fe ff
	ff ff		 mov	 DWORD PTR __Ans$1$[ebp], -2 ; fffffffeH
  000b9	33 db		 xor	 ebx, ebx
  000bb	88 45 d7	 mov	 BYTE PTR __Prefix$1$[ebp], al

; 3330 :         for (; _Field < _Numfields; ++_Field) { // test element at _Column in field _Field

  000be	8b 45 ec	 mov	 eax, DWORD PTR __Str$[ebp+20]
  000c1	33 ff		 xor	 edi, edi
  000c3	89 5d bc	 mov	 DWORD PTR __Field$1$[ebp], ebx
  000c6	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR __Column$1$[ebp], 1
  000cd	39 5d b8	 cmp	 DWORD PTR __Numfields$2$[ebp], ebx
  000d0	0f 86 89 02 00
	00		 jbe	 $LN289@Getloctxt
  000d6	8b 4d d8	 mov	 ecx, DWORD PTR __Str$[ebp]
  000d9	89 45 cc	 mov	 DWORD PTR __Str$2$[ebp], eax
  000dc	89 4d d0	 mov	 DWORD PTR __Ptr$1$[ebp], ecx
$LN300@Getloctxt:

; 3331 :             while (_Ptr[_Off] != _Elem{} && _Ptr[_Off] != _Ptr[0]) { // find beginning of field

  000df	8b 55 c4	 mov	 edx, DWORD PTR __Ptr$GSCopy$1$[ebp]
$LL10@Getloctxt:
  000e2	8a 04 3a	 mov	 al, BYTE PTR [edx+edi]
  000e5	84 c0		 test	 al, al
  000e7	74 17		 je	 SHORT $LN12@Getloctxt
  000e9	8a 0a		 mov	 cl, BYTE PTR [edx]
  000eb	0f 1f 44 00 00	 npad	 5
$LL11@Getloctxt:
  000f0	3a c1		 cmp	 al, cl
  000f2	74 09		 je	 SHORT $LN290@Getloctxt
  000f4	8a 44 3a 01	 mov	 al, BYTE PTR [edx+edi+1]

; 3332 :                 ++_Off;

  000f8	47		 inc	 edi
  000f9	84 c0		 test	 al, al
  000fb	75 f3		 jne	 SHORT $LL11@Getloctxt
$LN290@Getloctxt:
  000fd	8b 4d d0	 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
$LN12@Getloctxt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00100	83 7d cc 0f	 cmp	 DWORD PTR __Str$2$[ebp], 15 ; 0000000fH

; 435  :         value_type* _Result = _Bx._Buf;

  00104	8d 45 d8	 lea	 eax, DWORD PTR __Str$[ebp]

; 436  :         if (_Large_mode_engaged()) {

  00107	0f 47 c1	 cmova	 eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 3335 :             if (_Str[_Field] != '\0') {

  0010a	80 3c 18 00	 cmp	 BYTE PTR [eax+ebx], 0
  0010e	74 15		 je	 SHORT $LN14@Getloctxt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00110	83 7d cc 0f	 cmp	 DWORD PTR __Str$2$[ebp], 15 ; 0000000fH

; 435  :         value_type* _Result = _Bx._Buf;

  00114	8d 45 d8	 lea	 eax, DWORD PTR __Str$[ebp]

; 436  :         if (_Large_mode_engaged()) {

  00117	0f 47 c1	 cmova	 eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 3336 :                 _Off += _Str[_Field]; // skip tested columns in field

  0011a	0f be 04 18	 movsx	 eax, BYTE PTR [eax+ebx]
  0011e	03 f8		 add	 edi, eax

; 3337 :             } else if (_Ptr[_Off += _Column] == _Ptr[0]

  00120	e9 b6 01 00 00	 jmp	 $LN297@Getloctxt
$LN14@Getloctxt:

; 3338 :                        || _Ptr[_Off] == _Elem{}) { // matched all of field, save as possible answer

  00125	03 7d c8	 add	 edi, DWORD PTR __Column$1$[ebp]
  00128	8a 04 3a	 mov	 al, BYTE PTR [edx+edi]
  0012b	3a 02		 cmp	 al, BYTE PTR [edx]
  0012d	0f 84 79 01 00
	00		 je	 $LN18@Getloctxt
  00133	84 c0		 test	 al, al
  00135	0f 84 71 01 00
	00		 je	 $LN18@Getloctxt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 437  :         if (!_Got) {

  0013b	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  0013f	75 35		 jne	 SHORT $LN284@Getloctxt

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00141	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00143	85 c9		 test	 ecx, ecx
  00145	74 25		 je	 SHORT $LN129@Getloctxt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00147	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0014a	8b 10		 mov	 edx, DWORD PTR [eax]
  0014c	85 d2		 test	 edx, edx
  0014e	74 0d		 je	 SHORT $LN133@Getloctxt
  00150	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00153	83 38 00	 cmp	 DWORD PTR [eax], 0
  00156	7e 05		 jle	 SHORT $LN133@Getloctxt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00158	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0015b	eb 05		 jmp	 SHORT $LN134@Getloctxt
$LN133@Getloctxt:
  0015d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0015f	ff 50 18	 call	 DWORD PTR [eax+24]
$LN134@Getloctxt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00162	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00165	74 05		 je	 SHORT $LN129@Getloctxt

; 473  :             _Val = traits_type::to_char_type(_Meta);

  00167	88 46 05	 mov	 BYTE PTR [esi+5], al
  0016a	eb 06		 jmp	 SHORT $LN128@Getloctxt
$LN129@Getloctxt:

; 471  :             _Strbuf = nullptr;

  0016c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN128@Getloctxt:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00172	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN284@Getloctxt:

; 441  :         if (!_Right._Got) {

  00176	8b 45 c0	 mov	 eax, DWORD PTR __Last$GSCopy$1$[ebp]
  00179	80 78 04 00	 cmp	 BYTE PTR [eax+4], 0
  0017d	75 3d		 jne	 SHORT $LN120@Getloctxt

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0017f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00181	85 c9		 test	 ecx, ecx
  00183	74 2d		 je	 SHORT $LN275@Getloctxt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00185	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00188	8b 10		 mov	 edx, DWORD PTR [eax]
  0018a	85 d2		 test	 edx, edx
  0018c	74 0d		 je	 SHORT $LN159@Getloctxt
  0018e	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00191	83 38 00	 cmp	 DWORD PTR [eax], 0
  00194	7e 05		 jle	 SHORT $LN159@Getloctxt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00196	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00199	eb 05		 jmp	 SHORT $LN160@Getloctxt
$LN159@Getloctxt:
  0019b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0019d	ff 50 18	 call	 DWORD PTR [eax+24]
$LN160@Getloctxt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  001a0	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  001a3	74 0a		 je	 SHORT $LN292@Getloctxt

; 473  :             _Val = traits_type::to_char_type(_Meta);

  001a5	8b 4d c0	 mov	 ecx, DWORD PTR __Last$GSCopy$1$[ebp]
  001a8	88 41 05	 mov	 BYTE PTR [ecx+5], al
  001ab	8b c1		 mov	 eax, ecx
  001ad	eb 09		 jmp	 SHORT $LN154@Getloctxt
$LN292@Getloctxt:

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  001af	8b 45 c0	 mov	 eax, DWORD PTR __Last$GSCopy$1$[ebp]
$LN275@Getloctxt:

; 471  :             _Strbuf = nullptr;

  001b2	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN154@Getloctxt:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  001b8	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
$LN120@Getloctxt:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  001bc	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001be	8b 00		 mov	 eax, DWORD PTR [eax]
  001c0	85 c9		 test	 ecx, ecx
  001c2	75 14		 jne	 SHORT $LN282@Getloctxt
  001c4	85 c0		 test	 eax, eax
  001c6	75 14		 jne	 SHORT $LN123@Getloctxt
$LN21@Getloctxt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  001c8	83 7d cc 0f	 cmp	 DWORD PTR __Str$2$[ebp], 15 ; 0000000fH

; 435  :         value_type* _Result = _Bx._Buf;

  001cc	8d 55 d8	 lea	 edx, DWORD PTR __Str$[ebp]

; 436  :         if (_Large_mode_engaged()) {

  001cf	0f 47 55 d0	 cmova	 edx, DWORD PTR __Ptr$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 3346 :             } else {

  001d3	e9 e1 00 00 00	 jmp	 $LN299@Getloctxt
$LN282@Getloctxt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  001d8	85 c0		 test	 eax, eax
  001da	75 ec		 jne	 SHORT $LN21@Getloctxt
$LN123@Getloctxt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 3342 :                        || (_Matching == _Case_sensitive::_Yes

  001dc	80 7d 18 01	 cmp	 BYTE PTR __Matching$[ebp], 1
  001e0	8b 45 c4	 mov	 eax, DWORD PTR __Ptr$GSCopy$1$[ebp]
  001e3	8a 1c 38	 mov	 bl, BYTE PTR [eax+edi]
  001e6	75 48		 jne	 SHORT $LN25@Getloctxt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 406  :         if (!_Got) {

  001e8	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  001ec	75 3b		 jne	 SHORT $LN285@Getloctxt

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  001ee	85 c9		 test	 ecx, ecx
  001f0	74 2d		 je	 SHORT $LN194@Getloctxt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  001f2	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  001f5	8b 10		 mov	 edx, DWORD PTR [eax]
  001f7	85 d2		 test	 edx, edx
  001f9	74 0d		 je	 SHORT $LN198@Getloctxt
  001fb	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  001fe	83 38 00	 cmp	 DWORD PTR [eax], 0
  00201	7e 05		 jle	 SHORT $LN198@Getloctxt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00203	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00206	eb 05		 jmp	 SHORT $LN199@Getloctxt
$LN198@Getloctxt:
  00208	8b 01		 mov	 eax, DWORD PTR [ecx]
  0020a	ff 50 18	 call	 DWORD PTR [eax+24]
$LN199@Getloctxt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  0020d	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00210	74 0d		 je	 SHORT $LN194@Getloctxt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 3342 :                        || (_Matching == _Case_sensitive::_Yes

  00212	33 c9		 xor	 ecx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 473  :             _Val = traits_type::to_char_type(_Meta);

  00214	88 46 05	 mov	 BYTE PTR [esi+5], al

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00217	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 3342 :                        || (_Matching == _Case_sensitive::_Yes

  0021b	3a d8		 cmp	 bl, al
  0021d	eb 72		 jmp	 SHORT $LN298@Getloctxt
$LN194@Getloctxt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 471  :             _Strbuf = nullptr;

  0021f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00225	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN285@Getloctxt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 3342 :                        || (_Matching == _Case_sensitive::_Yes

  00229	33 c9		 xor	 ecx, ecx
  0022b	3a 5e 05	 cmp	 bl, BYTE PTR [esi+5]
  0022e	eb 61		 jmp	 SHORT $LN298@Getloctxt
$LN25@Getloctxt:

; 2737 :         return do_tolower(_Ch);

  00230	8b 4d b0	 mov	 ecx, DWORD PTR __CType$1$[ebp]
  00233	53		 push	 ebx
  00234	8b 01		 mov	 eax, DWORD PTR [ecx]
  00236	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00239	ff d0		 call	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 406  :         if (!_Got) {

  0023b	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 2737 :         return do_tolower(_Ch);

  0023f	8a d8		 mov	 bl, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 406  :         if (!_Got) {

  00241	75 37		 jne	 SHORT $LN286@Getloctxt

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00243	8b 16		 mov	 edx, DWORD PTR [esi]
  00245	85 d2		 test	 edx, edx
  00247	74 27		 je	 SHORT $LN225@Getloctxt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00249	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  0024c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0024e	85 c9		 test	 ecx, ecx
  00250	74 0d		 je	 SHORT $LN229@Getloctxt
  00252	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00255	83 38 00	 cmp	 DWORD PTR [eax], 0
  00258	7e 05		 jle	 SHORT $LN229@Getloctxt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0025a	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0025d	eb 07		 jmp	 SHORT $LN230@Getloctxt
$LN229@Getloctxt:
  0025f	8b 02		 mov	 eax, DWORD PTR [edx]
  00261	8b ca		 mov	 ecx, edx
  00263	ff 50 18	 call	 DWORD PTR [eax+24]
$LN230@Getloctxt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00266	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00269	74 05		 je	 SHORT $LN225@Getloctxt

; 473  :             _Val = traits_type::to_char_type(_Meta);

  0026b	88 46 05	 mov	 BYTE PTR [esi+5], al
  0026e	eb 06		 jmp	 SHORT $LN224@Getloctxt
$LN225@Getloctxt:

; 471  :             _Strbuf = nullptr;

  00270	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN224@Getloctxt:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00276	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN286@Getloctxt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 2737 :         return do_tolower(_Ch);

  0027a	8b 4d b0	 mov	 ecx, DWORD PTR __CType$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 414  :         return _Val;

  0027d	8a 46 05	 mov	 al, BYTE PTR [esi+5]
  00280	88 45 ac	 mov	 BYTE PTR $T3[ebp], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 2737 :         return do_tolower(_Ch);

  00283	ff 75 ac	 push	 DWORD PTR $T3[ebp]
  00286	8b 01		 mov	 eax, DWORD PTR [ecx]
  00288	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0028b	ff d0		 call	 eax

; 3342 :                        || (_Matching == _Case_sensitive::_Yes

  0028d	33 c9		 xor	 ecx, ecx
  0028f	3a d8		 cmp	 bl, al
$LN298@Getloctxt:
  00291	8b 5d bc	 mov	 ebx, DWORD PTR __Field$1$[ebp]
  00294	0f 95 c1	 setne	 cl
  00297	85 c9		 test	 ecx, ecx
  00299	0f 85 29 ff ff
	ff		 jne	 $LN21@Getloctxt

; 3347 :                 _Prefix = true; // still a valid prefix

  0029f	8b 55 c4	 mov	 edx, DWORD PTR __Ptr$GSCopy$1$[ebp]
  002a2	b0 01		 mov	 al, 1
  002a4	8b 4d d0	 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
  002a7	88 45 d7	 mov	 BYTE PTR __Prefix$1$[ebp], al
  002aa	eb 32		 jmp	 SHORT $LN8@Getloctxt
$LN18@Getloctxt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  002ac	83 7d cc 0f	 cmp	 DWORD PTR __Str$2$[ebp], 15 ; 0000000fH

; 435  :         value_type* _Result = _Bx._Buf;

  002b0	8d 55 d8	 lea	 edx, DWORD PTR __Str$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 3340 :                 _Ans         = static_cast<int>(_Field); // save answer

  002b3	89 5d b4	 mov	 DWORD PTR __Ans$1$[ebp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 436  :         if (_Large_mode_engaged()) {

  002b6	0f 47 d1	 cmova	 edx, ecx
$LN299@Getloctxt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 3330 :         for (; _Field < _Numfields; ++_Field) { // test element at _Column in field _Field

  002b9	8b 45 c8	 mov	 eax, DWORD PTR __Column$1$[ebp]
  002bc	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  002c1	3b c1		 cmp	 eax, ecx
  002c3	0f b6 c0	 movzx	 eax, al
  002c6	0f 42 c8	 cmovb	 ecx, eax
  002c9	88 0c 1a	 mov	 BYTE PTR [edx+ebx], cl
  002cc	8b 4d d8	 mov	 ecx, DWORD PTR __Str$[ebp]
  002cf	8b 45 ec	 mov	 eax, DWORD PTR __Str$[ebp+20]
  002d2	8b 55 c4	 mov	 edx, DWORD PTR __Ptr$GSCopy$1$[ebp]
  002d5	89 4d d0	 mov	 DWORD PTR __Ptr$1$[ebp], ecx
  002d8	89 45 cc	 mov	 DWORD PTR __Str$2$[ebp], eax
$LN297@Getloctxt:
  002db	8a 45 d7	 mov	 al, BYTE PTR __Prefix$1$[ebp]
$LN8@Getloctxt:
  002de	43		 inc	 ebx
  002df	89 5d bc	 mov	 DWORD PTR __Field$1$[ebp], ebx
  002e2	3b 5d b8	 cmp	 ebx, DWORD PTR __Numfields$2$[ebp]
  002e5	0f 82 f7 fd ff
	ff		 jb	 $LL10@Getloctxt

; 3348 :             }
; 3349 :         }
; 3350 : 
; 3351 :         if (!_Prefix || _First == _Last) {

  002eb	84 c0		 test	 al, al
  002ed	74 75		 je	 SHORT $LN294@Getloctxt
  002ef	ff 75 c0	 push	 DWORD PTR __Last$GSCopy$1$[ebp]
  002f2	56		 push	 esi
  002f3	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
  002f8	83 c4 08	 add	 esp, 8
  002fb	84 c0		 test	 al, al
  002fd	75 65		 jne	 SHORT $LN294@Getloctxt

; 3325 :     for (size_t _Column = 1;; ++_Column, (void) ++_First, _Ans = -1) { // test each element against all viable fields

  002ff	ff 45 c8	 inc	 DWORD PTR __Column$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00302	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00304	85 c9		 test	 ecx, ecx
  00306	74 31		 je	 SHORT $LN96@Getloctxt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00308	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0030b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0030e	74 1b		 je	 SHORT $LN100@Getloctxt
  00310	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00313	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  00315	85 c0		 test	 eax, eax
  00317	7e 12		 jle	 SHORT $LN100@Getloctxt

; 222  :         --*_IGcount;

  00319	48		 dec	 eax
  0031a	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  0031c	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  0031f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00321	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00324	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00326	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  00329	eb 05		 jmp	 SHORT $LN101@Getloctxt
$LN100@Getloctxt:
  0032b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0032d	ff 50 1c	 call	 DWORD PTR [eax+28]
$LN101@Getloctxt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00330	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00333	74 04		 je	 SHORT $LN96@Getloctxt

; 463  :         } else {
; 464  :             _Got = false;

  00335	32 c0		 xor	 al, al
  00337	eb 08		 jmp	 SHORT $LN95@Getloctxt
$LN96@Getloctxt:

; 461  :             _Strbuf = nullptr;

  00339	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 462  :             _Got    = true;

  0033f	b0 01		 mov	 al, 1
$LN95@Getloctxt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 3325 :     for (size_t _Column = 1;; ++_Column, (void) ++_First, _Ans = -1) { // test each element against all viable fields

  00341	8b 4d d0	 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
  00344	33 ff		 xor	 edi, edi
  00346	88 46 04	 mov	 BYTE PTR [esi+4], al
  00349	32 c0		 xor	 al, al
  0034b	33 db		 xor	 ebx, ebx
  0034d	c7 45 b4 ff ff
	ff ff		 mov	 DWORD PTR __Ans$1$[ebp], -1
  00354	88 45 d7	 mov	 BYTE PTR __Prefix$1$[ebp], al
  00357	89 5d bc	 mov	 DWORD PTR __Field$1$[ebp], ebx
  0035a	e9 80 fd ff ff	 jmp	 $LN300@Getloctxt
$LN289@Getloctxt:

; 3330 :         for (; _Field < _Numfields; ++_Field) { // test element at _Column in field _Field

  0035f	8b 55 d8	 mov	 edx, DWORD PTR __Str$[ebp]

; 3348 :             }
; 3349 :         }
; 3350 : 
; 3351 :         if (!_Prefix || _First == _Last) {

  00362	eb 06		 jmp	 SHORT $LN265@Getloctxt
$LN294@Getloctxt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00364	8b 45 cc	 mov	 eax, DWORD PTR __Str$2$[ebp]
  00367	8b 55 d0	 mov	 edx, DWORD PTR __Ptr$1$[ebp]
$LN265@Getloctxt:
  0036a	83 f8 0f	 cmp	 eax, 15			; 0000000fH

; 3083 :         if (_My_data._Large_mode_engaged()) {

  0036d	76 27		 jbe	 SHORT $LN59@Getloctxt

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0036f	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00372	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00374	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0037a	72 10		 jb	 SHORT $LN64@Getloctxt

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0037c	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0037f	83 c1 23	 add	 ecx, 35			; 00000023H
  00382	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00384	83 c0 fc	 add	 eax, -4			; fffffffcH
  00387	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0038a	77 29		 ja	 SHORT $LN302@Getloctxt
$LN64@Getloctxt:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0038c	51		 push	 ecx
  0038d	52		 push	 edx
  0038e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00393	83 c4 08	 add	 esp, 8
$LN59@Getloctxt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 3355 :     return _Ans; // return field number or negative value on failure

  00396	8b 45 b4	 mov	 eax, DWORD PTR __Ans$1$[ebp]

; 3356 : }

  00399	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0039c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003a3	59		 pop	 ecx
  003a4	5f		 pop	 edi
  003a5	5e		 pop	 esi
  003a6	5b		 pop	 ebx
  003a7	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003aa	33 cd		 xor	 ecx, ebp
  003ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003b1	8b e5		 mov	 esp, ebp
  003b3	5d		 pop	 ebp
  003b4	c3		 ret	 0
$LN302@Getloctxt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003b5	6a 00		 push	 0
  003b7	6a 00		 push	 0
  003b9	6a 00		 push	 0
  003bb	6a 00		 push	 0
  003bd	6a 00		 push	 0
  003bf	e8 00 00 00 00	 call	 __invoke_watson
$LN296@Getloctxt:
  003c4	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Str$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z$1:
  00008	8d 4d a8	 lea	 ecx, DWORD PTR $T2[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z ENDP ; std::_Getloctxt<std::istreambuf_iterator<char,std::char_traits<char> >,char>
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$numpunct@D@std@@MAEPAXI@Z PROC			; std::numpunct<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 142  :     __CLR_OR_THIS_CALL ~numpunct() noexcept override {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 202  :         _CSTD free(const_cast<char*>(_Grouping));

  00006	ff 76 08	 push	 DWORD PTR [esi+8]

; 142  :     __CLR_OR_THIS_CALL ~numpunct() noexcept override {

  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@

; 202  :         _CSTD free(const_cast<char*>(_Grouping));

  0000f	e8 00 00 00 00	 call	 _free

; 203  :         _CSTD free(const_cast<_Elem*>(_Falsename));

  00014	ff 76 10	 push	 DWORD PTR [esi+16]
  00017	e8 00 00 00 00	 call	 _free

; 204  :         _CSTD free(const_cast<_Elem*>(_Truename));

  0001c	ff 76 14	 push	 DWORD PTR [esi+20]
  0001f	e8 00 00 00 00	 call	 _free
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH

; 144  :     }

  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0002d	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00031	74 0b		 je	 SHORT $LN13@scalar
  00033	6a 18		 push	 24			; 00000018H
  00035	56		 push	 esi
  00036	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003b	83 c4 08	 add	 esp, 8
$LN13@scalar:
  0003e	8b c6		 mov	 eax, esi
  00040	5e		 pop	 esi
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
??_G?$numpunct@D@std@@MAEPAXI@Z ENDP			; std::numpunct<char>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_truename, COMDAT
; _this$ = ecx

; 196  :     virtual string_type __CLR_OR_THIS_CALL do_truename() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 197  :         return string_type{_Truename};

  00004	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00007	0f 57 c0	 xorps	 xmm0, xmm0
  0000a	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0000b	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  0000e	8b ca		 mov	 ecx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 196  :     virtual string_type __CLR_OR_THIS_CALL do_truename() const {

  00010	57		 push	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00011	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

  00014	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  0001b	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0001e	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LL23@do_truenam:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  00025	8a 01		 mov	 al, BYTE PTR [ecx]
  00027	41		 inc	 ecx
  00028	84 c0		 test	 al, al
  0002a	75 f9		 jne	 SHORT $LL23@do_truenam
  0002c	2b cf		 sub	 ecx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0002e	51		 push	 ecx
  0002f	52		 push	 edx
  00030	8b ce		 mov	 ecx, esi
  00032	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 197  :         return string_type{_Truename};

  00037	5f		 pop	 edi
  00038	8b c6		 mov	 eax, esi
  0003a	5e		 pop	 esi

; 198  :     }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_truename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_falsename, COMDAT
; _this$ = ecx

; 192  :     virtual string_type __CLR_OR_THIS_CALL do_falsename() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 193  :         return string_type{_Falsename};

  00004	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00007	0f 57 c0	 xorps	 xmm0, xmm0
  0000a	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0000b	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  0000e	8b ca		 mov	 ecx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 192  :     virtual string_type __CLR_OR_THIS_CALL do_falsename() const {

  00010	57		 push	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00011	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

  00014	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  0001b	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0001e	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LL23@do_falsena:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  00025	8a 01		 mov	 al, BYTE PTR [ecx]
  00027	41		 inc	 ecx
  00028	84 c0		 test	 al, al
  0002a	75 f9		 jne	 SHORT $LL23@do_falsena
  0002c	2b cf		 sub	 ecx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0002e	51		 push	 ecx
  0002f	52		 push	 edx
  00030	8b ce		 mov	 ecx, esi
  00032	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 193  :         return string_type{_Falsename};

  00037	5f		 pop	 edi
  00038	8b c6		 mov	 eax, esi
  0003a	5e		 pop	 esi

; 194  :     }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_falsename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_grouping, COMDAT
; _this$ = ecx

; 188  :     virtual string __CLR_OR_THIS_CALL do_grouping() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 189  :         return string{_Grouping};

  00004	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00007	0f 57 c0	 xorps	 xmm0, xmm0
  0000a	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0000b	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  0000e	8b ca		 mov	 ecx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 188  :     virtual string __CLR_OR_THIS_CALL do_grouping() const {

  00010	57		 push	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00011	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

  00014	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  0001b	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0001e	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LL23@do_groupin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  00025	8a 01		 mov	 al, BYTE PTR [ecx]
  00027	41		 inc	 ecx
  00028	84 c0		 test	 al, al
  0002a	75 f9		 jne	 SHORT $LL23@do_groupin
  0002c	2b cf		 sub	 ecx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0002e	51		 push	 ecx
  0002f	52		 push	 edx
  00030	8b ce		 mov	 ecx, esi
  00032	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 189  :         return string{_Grouping};

  00037	5f		 pop	 edi
  00038	8b c6		 mov	 eax, esi
  0003a	5e		 pop	 esi

; 190  :     }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_grouping
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_thousands_sep, COMDAT
; _this$ = ecx

; 185  :         return _Kseparator;

  00000	8a 41 0d	 mov	 al, BYTE PTR [ecx+13]

; 186  :     }

  00003	c3		 ret	 0
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_thousands_sep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_decimal_point@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
?do_decimal_point@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_decimal_point, COMDAT
; _this$ = ecx

; 181  :         return _Dp;

  00000	8a 41 0c	 mov	 al, BYTE PTR [ecx+12]

; 182  :     }

  00003	c3		 ret	 0
?do_decimal_point@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_decimal_point
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??1?$numpunct@D@std@@MAE@XZ
_TEXT	SEGMENT
??1?$numpunct@D@std@@MAE@XZ PROC			; std::numpunct<char>::~numpunct<char>, COMDAT
; _this$ = ecx

; 142  :     __CLR_OR_THIS_CALL ~numpunct() noexcept override {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 202  :         _CSTD free(const_cast<char*>(_Grouping));

  00003	ff 76 08	 push	 DWORD PTR [esi+8]

; 142  :     __CLR_OR_THIS_CALL ~numpunct() noexcept override {

  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@

; 202  :         _CSTD free(const_cast<char*>(_Grouping));

  0000c	e8 00 00 00 00	 call	 _free

; 203  :         _CSTD free(const_cast<_Elem*>(_Falsename));

  00011	ff 76 10	 push	 DWORD PTR [esi+16]
  00014	e8 00 00 00 00	 call	 _free

; 204  :         _CSTD free(const_cast<_Elem*>(_Truename));

  00019	ff 76 14	 push	 DWORD PTR [esi+20]
  0001c	e8 00 00 00 00	 call	 _free
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH

; 143  :         _Tidy();
; 144  :     }

  00024	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0002a	5e		 pop	 esi
  0002b	c3		 ret	 0
??1?$numpunct@D@std@@MAE@XZ ENDP			; std::numpunct<char>::~numpunct<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -124						; size = 52
$T3 = -72						; size = 44
__Lock$4 = -28						; size = 4
$T5 = -24						; size = 4
__Psave$1$ = -24					; size = 4
__Lock$6 = -20						; size = 4
$T7 = -20						; size = 4
$T8 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
__Psave_guard$9 = 8					; size = 4
__Guard$10 = 8						; size = 4
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::numpunct<char> >, COMDAT

; 435  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 70	 sub	 esp, 112		; 00000070H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	33 c0		 xor	 eax, eax

; 436  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

  0002a	8d 4d e4	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  0002d	50		 push	 eax
  0002e	89 45 f0	 mov	 DWORD PTR $T8[ebp], eax
  00031	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
  00034	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 91   :             if (_Id == 0) { // still zero, allocate stamp

  00039	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id

; 437  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
  00044	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004b	89 45 e8	 mov	 DWORD PTR __Psave$1$[ebp], eax

; 91   :             if (_Id == 0) { // still zero, allocate stamp

  0004e	85 ff		 test	 edi, edi
  00050	75 2f		 jne	 SHORT $LN11@use_facet

; 92   :                 _BEGIN_LOCK(_LOCK_LOCALE)

  00052	57		 push	 edi
  00053	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$6[ebp]
  00056	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 93   :                 if (_Id == 0) {

  0005b	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A, edi ; std::numpunct<char>::id
  00061	75 10		 jne	 SHORT $LN12@use_facet

; 94   :                     _Id = static_cast<size_t>(++_Id_cnt);

  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00068	40		 inc	 eax
  00069	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  0006e	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A, eax ; std::numpunct<char>::id
$LN12@use_facet:

; 95   :                 }
; 96   :                 _END_LOCK()

  00073	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$6[ebp]
  00076	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0007b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
$LN11@use_facet:

; 377  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  00081	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00084	8d 1c bd 00 00
	00 00		 lea	 ebx, DWORD PTR [edi*4]
  0008b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0008e	3b 79 0c	 cmp	 edi, DWORD PTR [ecx+12]
  00091	73 16		 jae	 SHORT $LN19@use_facet
  00093	0f ae e8	 lfence
  00096	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00099	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0009c	8b 34 03	 mov	 esi, DWORD PTR [ebx+eax]

; 378  :         if (_Facptr || !_Ptr->_Xparent) {

  0009f	85 f6		 test	 esi, esi
  000a1	0f 85 66 01 00
	00		 jne	 $LN109@use_facet
  000a7	eb 02		 jmp	 SHORT $LN125@use_facet
$LN19@use_facet:

; 374  :     }
; 375  : 
; 376  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object
; 377  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  000a9	33 f6		 xor	 esi, esi
$LN125@use_facet:

; 378  :         if (_Facptr || !_Ptr->_Xparent) {

  000ab	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  000af	74 13		 je	 SHORT $LN14@use_facet

; 379  :             return _Facptr; // found facet or not transparent
; 380  :         }
; 381  : 
; 382  :         // look in current locale
; 383  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

  000b1	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 384  :         if (_Id < _Ptr0->_Facetcount) {

  000b6	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  000b9	73 11		 jae	 SHORT $LN126@use_facet

; 385  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

  000bb	0f ae e8	 lfence
  000be	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c1	8b 34 03	 mov	 esi, DWORD PTR [ebx+eax]
$LN14@use_facet:

; 438  : 
; 439  :     const size_t _Id         = _Facet::id._Get_index();
; 440  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);
; 441  : 
; 442  :     if (!_Pf) {

  000c4	85 f6		 test	 esi, esi
  000c6	0f 85 41 01 00
	00		 jne	 $LN109@use_facet
$LN126@use_facet:

; 443  :         if (_Psave) {

  000cc	8b 45 e8	 mov	 eax, DWORD PTR __Psave$1$[ebp]
  000cf	85 c0		 test	 eax, eax
  000d1	74 07		 je	 SHORT $LN3@use_facet

; 444  :             _Pf = _Psave; // lazy facet already allocated

  000d3	8b f0		 mov	 esi, eax

; 445  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

  000d5	e9 33 01 00 00	 jmp	 $LN109@use_facet
$LN3@use_facet:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 136  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->_C_str()), 0, true);

  000da	6a 18		 push	 24			; 00000018H
  000dc	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000e1	8b f0		 mov	 esi, eax
  000e3	83 c4 04	 add	 esp, 4
  000e6	89 75 ec	 mov	 DWORD PTR $T7[ebp], esi
  000e9	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000ed	85 f6		 test	 esi, esi
  000ef	0f 84 e4 00 00
	00		 je	 $LN24@use_facet
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 373  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  000f5	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  000f8	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000fb	85 c9		 test	 ecx, ecx
  000fd	74 0c		 je	 SHORT $LN32@use_facet
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo

; 190  :         return _Myptr ? _Myptr : &_Nul;

  000ff	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00102	85 c0		 test	 eax, eax
  00104	75 0a		 jne	 SHORT $LN33@use_facet
  00106	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 373  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  00109	eb 05		 jmp	 SHORT $LN33@use_facet
$LN32@use_facet:
  0010b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@@
$LN33@use_facet:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 136  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->_C_str()), 0, true);

  00110	50		 push	 eax
  00111	8d 4d 84	 lea	 ecx, DWORD PTR $T2[ebp]
  00114	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00119	b8 01 00 00 00	 mov	 eax, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 143  :             : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs)) // non-atomic initialization

  0011e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 136  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->_C_str()), 0, true);

  00125	89 45 f0	 mov	 DWORD PTR $T8[ebp], eax
  00128	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax

; 129  :     numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false) : locale::facet(_Refs) {

  0012b	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  00132	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo

; 285  :         return localeconv();

  00138	e8 00 00 00 00	 call	 _localeconv

; 281  :         return ::_Getcvt();

  0013d	8d 45 b8	 lea	 eax, DWORD PTR $T3[ebp]
  00140	50		 push	 eax
  00141	e8 00 00 00 00	 call	 __Getcvt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 156  :         _Grouping  = nullptr;

  00146	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 157  :         _Falsename = nullptr;

  0014d	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 158  :         _Truename  = nullptr;

  00154	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 160  :         _Tidy_guard<numpunct> _Guard{this};

  0015b	89 75 08	 mov	 DWORD PTR __Guard$10[ebp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 530  :     _Elem* _Ptrdest = static_cast<_Elem*>(_calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__));

  0015e	6a 01		 push	 1
  00160	6a 01		 push	 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 160  :         _Tidy_guard<numpunct> _Guard{this};

  00162	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 530  :     _Elem* _Ptrdest = static_cast<_Elem*>(_calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__));

  00166	e8 00 00 00 00	 call	 _calloc
  0016b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 531  : 
; 532  :     if (!_Ptrdest) {

  0016e	85 c0		 test	 eax, eax
  00170	0f 84 b3 00 00
	00		 je	 $LN131@use_facet

; 530  :     _Elem* _Ptrdest = static_cast<_Elem*>(_calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__));

  00176	6a 01		 push	 1
  00178	6a 06		 push	 6

; 537  :         *_Ptrnext = static_cast<_Elem>(static_cast<unsigned char>(*_Ptr));

  0017a	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 161  :         _Grouping      = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char*>(nullptr), _Cvt);

  0017d	89 46 08	 mov	 DWORD PTR [esi+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 530  :     _Elem* _Ptrdest = static_cast<_Elem*>(_calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__));

  00180	e8 00 00 00 00	 call	 _calloc
  00185	8b c8		 mov	 ecx, eax
  00187	83 c4 08	 add	 esp, 8

; 531  : 
; 532  :     if (!_Ptrdest) {

  0018a	85 c9		 test	 ecx, ecx
  0018c	0f 84 9c 00 00
	00		 je	 $LN132@use_facet

; 534  :     }
; 535  : 
; 536  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

  00192	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_05LAPONLG@false@
  00197	89 01		 mov	 DWORD PTR [ecx], eax
  00199	66 a1 04 00 00
	00		 mov	 ax, WORD PTR ??_C@_05LAPONLG@false@+4

; 530  :     _Elem* _Ptrdest = static_cast<_Elem*>(_calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__));

  0019f	6a 01		 push	 1
  001a1	6a 05		 push	 5

; 536  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

  001a3	66 89 41 04	 mov	 WORD PTR [ecx+4], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 162  :         _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);

  001a7	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 530  :     _Elem* _Ptrdest = static_cast<_Elem*>(_calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__));

  001aa	e8 00 00 00 00	 call	 _calloc
  001af	8b c8		 mov	 ecx, eax
  001b1	83 c4 08	 add	 esp, 8

; 531  : 
; 532  :     if (!_Ptrdest) {

  001b4	85 c9		 test	 ecx, ecx
  001b6	74 7b		 je	 SHORT $LN133@use_facet

; 534  :     }
; 535  : 
; 536  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

  001b8	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_04LOAJBDKD@true@
  001bd	89 01		 mov	 DWORD PTR [ecx], eax
  001bf	a0 04 00 00 00	 mov	 al, BYTE PTR ??_C@_04LOAJBDKD@true@+4
  001c4	88 41 04	 mov	 BYTE PTR [ecx+4], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 163  :         _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);

  001c7	89 4e 14	 mov	 DWORD PTR [esi+20], ecx

; 164  :         _Guard._Target = nullptr;

  001ca	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Guard$10[ebp], 0

; 165  : 
; 166  :         if (_Isdef) { // apply defaults for required facets
; 167  :             _Dp         = _Maklocchr('.', static_cast<_Elem*>(nullptr), _Cvt);

  001d1	66 c7 46 0c 2e
	2c		 mov	 WORD PTR [esi+12], 11310 ; 00002c2eH

; 136  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->_C_str()), 0, true);

  001d7	eb 02		 jmp	 SHORT $LN25@use_facet
$LN24@use_facet:
  001d9	33 f6		 xor	 esi, esi
$LN25@use_facet:
  001db	f6 45 f0 01	 test	 BYTE PTR $T8[ebp], 1
  001df	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  001e6	74 08		 je	 SHORT $LN29@use_facet
  001e8	8d 4d 84	 lea	 ecx, DWORD PTR $T2[ebp]
  001eb	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN29@use_facet:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  001f0	89 75 08	 mov	 DWORD PTR __Psave_guard$9[ebp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 458  :             _Facet_Register(_Pfmod);

  001f3	56		 push	 esi
  001f4	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  001f8	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register

; 459  : #endif // ^^^ !defined(_M_CEE) ^^^
; 460  : 
; 461  :             _Pfmod->_Incref();

  001fd	8b 16		 mov	 edx, DWORD PTR [esi]
  001ff	83 c4 04	 add	 esp, 4
  00202	8b ce		 mov	 ecx, esi
  00204	ff 52 04	 call	 DWORD PTR [edx+4]

; 462  :             _Facetptr<_Facet>::_Psave = _Psave;

  00207	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::numpunct<char> >::_Psave
$LN109@use_facet:

; 463  :             _Pf                       = _Psave;
; 464  : 
; 465  :             (void) _Psave_guard.release();
; 466  :         }
; 467  :     }
; 468  : 
; 469  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

  0020d	8d 4d e4	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00210	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00215	8b c6		 mov	 eax, esi

; 470  :     _END_LOCK()
; 471  : } // end of use_facet body

  00217	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0021a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00221	59		 pop	 ecx
  00222	5f		 pop	 edi
  00223	5e		 pop	 esi
  00224	5b		 pop	 ebx
  00225	8b e5		 mov	 esp, ebp
  00227	5d		 pop	 ebp
  00228	c3		 ret	 0
$LN131@use_facet:

; 533  :         _Xbad_alloc();

  00229	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN132@use_facet:
  0022e	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN133@use_facet:
  00233	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN128@use_facet:
  00238	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$2:
  00008	6a 18		 push	 24			; 00000018H
  0000a	8b 45 ec	 mov	 eax, DWORD PTR $T7[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00013	83 c4 08	 add	 esp, 8
  00016	c3		 ret	 0
__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$3:
  00017	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0001a	83 e0 01	 and	 eax, 1
  0001d	0f 84 0c 00 00
	00		 je	 $LN28@use_facet
  00023	83 65 e8 fe	 and	 DWORD PTR $T5[ebp], -2	; fffffffeH
  00027	8d 4d 84	 lea	 ecx, DWORD PTR $T2[ebp]
  0002a	e9 00 00 00 00	 jmp	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN28@use_facet:
  0002f	c3		 ret	 0
__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$4:
  00030	8b 4d ec	 mov	 ecx, DWORD PTR $T7[ebp]
  00033	e9 00 00 00 00	 jmp	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$6:
  00038	8d 4d 08	 lea	 ecx, DWORD PTR __Guard$10[ebp]
  0003b	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >
__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$1:
  00040	8d 4d 08	 lea	 ecx, DWORD PTR __Psave_guard$9[ebp]
  00043	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
  00048	cc		 int	 3
  00049	cc		 int	 3
  0004a	cc		 int	 3
  0004b	cc		 int	 3
  0004c	cc		 int	 3
__ehhandler$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z:
  0004d	90		 npad	 1
  0004e	90		 npad	 1
  0004f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00053	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00056	8b 4a 80	 mov	 ecx, DWORD PTR [edx-128]
  00059	33 c8		 xor	 ecx, eax
  0005b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00060	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
  00065	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::numpunct<char> >
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z
_TEXT	SEGMENT
__Last$GSCopy$1$ = -152					; size = 4
tv9647 = -148						; size = 4
__Groups$2$ = -144					; size = 4
__Groups$1$ = -140					; size = 4
__Upper_exp_wc$1$ = -134				; size = 1
__Lower_exp_wc$1$ = -133				; size = 1
__Power_of_rep_base$1$ = -132				; size = 4
__Significant$1$ = -128					; size = 4
__Offset_digit_end$1$ = -124				; size = 4
__Exp_rep_abs_bound$1$ = -124				; size = 4
__Exponent_part_abs$1$ = -124				; size = 4
__Groups_arr_idx$1$ = -120				; size = 4
$T2 = -120						; size = 1
__Seendigit$ = -120					; size = 1
__Ch$ = -120						; size = 1
__Negative_sign$1$ = -114				; size = 1
__Positive_sign$1$ = -113				; size = 1
__Punct_fac$1$ = -112					; size = 4
$T3 = -112						; size = 1
tv9654 = -112						; size = 4
$T4 = -112						; size = 1
__Exponent_part$1$ = -112				; size = 4
__Rev_begin$1$ = -112					; size = 4
__Zero_wc$1$ = -105					; size = 1
__Ptr$1$ = -104						; size = 4
__Kseparator$1$ = -100					; size = 1
__Exponent_part_negative$1$ = -100			; size = 1
__Bad_grouping$1$ = -99					; size = 1
__Seendigit$1$ = -98					; size = 1
__Seendigit$3$ = -98					; size = 1
__Parse_hex$1$ = -97					; size = 1
__Grouping$ = -96					; size = 24
__Groups$5 = -72					; size = 24
__Atoms$ = -48						; size = 29
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Ac$ = 8						; size = 4
__Max_sig_dig$ = 12					; size = 4
__First$ = 16						; size = 4
__Last$ = 20						; size = 4
__Loc$ = 24						; size = 4
??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_fp_with_locale<0>, COMDAT

; 805  :         char* const _Ac, const int _Max_sig_dig, _InIt& _First, _InIt& _Last, const locale& _Loc) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b 45 14	 mov	 eax, DWORD PTR __Last$[ebp]
  00031	8b 75 18	 mov	 esi, DWORD PTR __Loc$[ebp]
  00034	8b 5d 08	 mov	 ebx, DWORD PTR __Ac$[ebp]
  00037	8b 7d 10	 mov	 edi, DWORD PTR __First$[ebp]

; 806  :         // get floating-point field from [_First, _Last) into _Ac
; 807  :         char* _Ptr = _Ac;
; 808  : 
; 809  :         constexpr size_t _Offset_dec_digit_end = 10;
; 810  :         constexpr size_t _Offset_hex_digit_end = 22;
; 811  :         constexpr size_t _Offset_neg_sign      = 22;
; 812  :         constexpr size_t _Offset_pos_sign      = 23;
; 813  :         constexpr size_t _Offset_upper_x       = 24;
; 814  :         constexpr size_t _Offset_lower_x       = 25;
; 815  :         constexpr size_t _Offset_upper_p       = 26;
; 816  :         constexpr size_t _Offset_lower_p       = 27;
; 817  :         constexpr size_t _Offset_upper_e       = 14;
; 818  :         constexpr size_t _Offset_lower_e       = 20;
; 819  :         static constexpr char _Src[]           = "0123456789ABCDEFabcdef-+XxPp";
; 820  :         _Elem _Atoms[sizeof(_Src)];
; 821  :         const auto& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Loc);

  0003a	56		 push	 esi
  0003b	89 5d 98	 mov	 DWORD PTR __Ptr$1$[ebp], ebx
  0003e	89 85 68 ff ff
	ff		 mov	 DWORD PTR __Last$GSCopy$1$[ebp], eax
  00044	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  00049	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 2760 :         return do_widen(_First, _Last, _Dest);

  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00051	8d 4d d0	 lea	 ecx, DWORD PTR __Atoms$[ebp]
  00054	51		 push	 ecx
  00055	68 1d 00 00 00	 push	 OFFSET ?_Src@?1???$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z@4QBDB+29
  0005a	68 00 00 00 00	 push	 OFFSET ?_Src@?1???$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_fp_with_locale<0>'::`2'::_Src
  0005f	8b c8		 mov	 ecx, eax
  00061	ff d2		 call	 edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 824  :         const _Elem _Positive_sign = _Atoms[_Offset_pos_sign];

  00063	8a 45 e7	 mov	 al, BYTE PTR __Atoms$[ebp+23]
  00066	88 45 8f	 mov	 BYTE PTR __Positive_sign$1$[ebp], al

; 825  :         const _Elem _Negative_sign = _Atoms[_Offset_neg_sign];

  00069	8a 45 e6	 mov	 al, BYTE PTR __Atoms$[ebp+22]
  0006c	88 45 8e	 mov	 BYTE PTR __Negative_sign$1$[ebp], al

; 826  :         const _Elem _Zero_wc       = _Atoms[0];

  0006f	8a 45 d0	 mov	 al, BYTE PTR __Atoms$[ebp]

; 827  : 
; 828  :         const auto& _Punct_fac  = _STD use_facet<numpunct<_Elem>>(_Loc);

  00072	56		 push	 esi
  00073	88 45 97	 mov	 BYTE PTR __Zero_wc$1$[ebp], al
  00076	e8 00 00 00 00	 call	 ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
  0007b	8b d8		 mov	 ebx, eax
  0007d	83 c4 04	 add	 esp, 4

; 108  :         return do_grouping();

  00080	8d 45 a0	 lea	 eax, DWORD PTR __Grouping$[ebp]

; 827  : 
; 828  :         const auto& _Punct_fac  = _STD use_facet<numpunct<_Elem>>(_Loc);

  00083	89 5d 90	 mov	 DWORD PTR __Punct_fac$1$[ebp], ebx

; 108  :         return do_grouping();

  00086	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00088	50		 push	 eax
  00089	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0008c	8b cb		 mov	 ecx, ebx
  0008e	ff d2		 call	 edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2494 :         return _Mypair._Myval2._Mysize == 0;

  00090	83 7d b0 00	 cmp	 DWORD PTR __Grouping$[ebp+16], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 829  :         const string _Grouping  = _Punct_fac.grouping();

  00094	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 830  :         const _Elem _Kseparator = _Grouping.empty() ? _Elem{} : _Punct_fac.thousands_sep();

  0009b	75 43		 jne	 SHORT $LN106@Parse_fp_w
  0009d	32 db		 xor	 bl, bl
  0009f	88 5d 9c	 mov	 BYTE PTR __Kseparator$1$[ebp], bl

; 831  : 
; 832  :         bool _Bad_grouping = false;

  000a2	88 5d 9d	 mov	 BYTE PTR __Bad_grouping$1$[ebp], bl
$LN2494@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 437  :         if (!_Got) {

  000a5	8b b5 68 ff ff
	ff		 mov	 esi, DWORD PTR __Last$GSCopy$1$[ebp]
$LN2480@Parse_fp_w:
  000ab	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  000af	0f 85 8c 01 00
	00		 jne	 $LN1806@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  000b5	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000b7	85 c9		 test	 ecx, ecx
  000b9	0f 84 78 01 00
	00		 je	 $LN1816@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  000bf	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  000c2	8b 10		 mov	 edx, DWORD PTR [eax]
  000c4	85 d2		 test	 edx, edx
  000c6	0f 84 5c 01 00
	00		 je	 $LN1820@Parse_fp_w
  000cc	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  000cf	83 38 00	 cmp	 DWORD PTR [eax], 0
  000d2	0f 8e 50 01 00
	00		 jle	 $LN1820@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  000d8	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  000db	e9 4d 01 00 00	 jmp	 $LN1821@Parse_fp_w
$LN106@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 104  :         return do_thousands_sep();

  000e0	8b 03		 mov	 eax, DWORD PTR [ebx]
  000e2	8b cb		 mov	 ecx, ebx
  000e4	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  000e7	ff d0		 call	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2494 :         return _Mypair._Myval2._Mysize == 0;

  000e9	83 7d b0 00	 cmp	 DWORD PTR __Grouping$[ebp+16], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 830  :         const _Elem _Kseparator = _Grouping.empty() ? _Elem{} : _Punct_fac.thousands_sep();

  000ed	8a d8		 mov	 bl, al
  000ef	88 5d 9c	 mov	 BYTE PTR __Kseparator$1$[ebp], bl

; 831  : 
; 832  :         bool _Bad_grouping = false;

  000f2	c6 45 9d 00	 mov	 BYTE PTR __Bad_grouping$1$[ebp], 0

; 833  : 
; 834  :         // skip leading separators before the sign
; 835  :         if (!_Grouping.empty()) {

  000f6	74 ad		 je	 SHORT $LN2494@Parse_fp_w
  000f8	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000fa	8b b5 68 ff ff
	ff		 mov	 esi, DWORD PTR __Last$GSCopy$1$[ebp]
$LL2@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 437  :         if (!_Got) {

  00100	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  00104	75 33		 jne	 SHORT $LN2273@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00106	85 c9		 test	 ecx, ecx
  00108	74 25		 je	 SHORT $LN1155@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  0010a	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0010d	8b 10		 mov	 edx, DWORD PTR [eax]
  0010f	85 d2		 test	 edx, edx
  00111	74 0d		 je	 SHORT $LN1159@Parse_fp_w
  00113	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00116	83 38 00	 cmp	 DWORD PTR [eax], 0
  00119	7e 05		 jle	 SHORT $LN1159@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0011b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0011e	eb 05		 jmp	 SHORT $LN1160@Parse_fp_w
$LN1159@Parse_fp_w:
  00120	8b 01		 mov	 eax, DWORD PTR [ecx]
  00122	ff 50 18	 call	 DWORD PTR [eax+24]
$LN1160@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00125	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00128	74 05		 je	 SHORT $LN1155@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  0012a	88 47 05	 mov	 BYTE PTR [edi+5], al
  0012d	eb 06		 jmp	 SHORT $LN1154@Parse_fp_w
$LN1155@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  0012f	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN1154@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00135	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN2273@Parse_fp_w:

; 441  :         if (!_Right._Got) {

  00139	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  0013d	75 35		 jne	 SHORT $LN2407@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0013f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00141	85 c9		 test	 ecx, ecx
  00143	74 25		 je	 SHORT $LN1181@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00145	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00148	8b 10		 mov	 edx, DWORD PTR [eax]
  0014a	85 d2		 test	 edx, edx
  0014c	74 0d		 je	 SHORT $LN1185@Parse_fp_w
  0014e	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00151	83 38 00	 cmp	 DWORD PTR [eax], 0
  00154	7e 05		 jle	 SHORT $LN1185@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00156	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00159	eb 05		 jmp	 SHORT $LN1186@Parse_fp_w
$LN1185@Parse_fp_w:
  0015b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0015d	ff 50 18	 call	 DWORD PTR [eax+24]
$LN1186@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00160	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00163	74 05		 je	 SHORT $LN1181@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00165	88 46 05	 mov	 BYTE PTR [esi+5], al
  00168	eb 06		 jmp	 SHORT $LN1180@Parse_fp_w
$LN1181@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  0016a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1180@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00170	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN2407@Parse_fp_w:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  00174	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00176	8b 06		 mov	 eax, DWORD PTR [esi]
  00178	85 c9		 test	 ecx, ecx
  0017a	75 0a		 jne	 SHORT $LN2371@Parse_fp_w
  0017c	85 c0		 test	 eax, eax
  0017e	0f 84 27 ff ff
	ff		 je	 $LN2480@Parse_fp_w
  00184	eb 08		 jmp	 SHORT $LN2276@Parse_fp_w
$LN2371@Parse_fp_w:
  00186	85 c0		 test	 eax, eax
  00188	0f 85 1d ff ff
	ff		 jne	 $LN2480@Parse_fp_w
$LN2276@Parse_fp_w:

; 406  :         if (!_Got) {

  0018e	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  00192	75 33		 jne	 SHORT $LN2408@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00194	85 c9		 test	 ecx, ecx
  00196	74 25		 je	 SHORT $LN1210@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00198	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0019b	8b 10		 mov	 edx, DWORD PTR [eax]
  0019d	85 d2		 test	 edx, edx
  0019f	74 0d		 je	 SHORT $LN1214@Parse_fp_w
  001a1	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  001a4	83 38 00	 cmp	 DWORD PTR [eax], 0
  001a7	7e 05		 jle	 SHORT $LN1214@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  001a9	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  001ac	eb 05		 jmp	 SHORT $LN1215@Parse_fp_w
$LN1214@Parse_fp_w:
  001ae	8b 01		 mov	 eax, DWORD PTR [ecx]
  001b0	ff 50 18	 call	 DWORD PTR [eax+24]
$LN1215@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  001b3	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  001b6	74 05		 je	 SHORT $LN1210@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  001b8	88 47 05	 mov	 BYTE PTR [edi+5], al
  001bb	eb 06		 jmp	 SHORT $LN1209@Parse_fp_w
$LN1210@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  001bd	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN1209@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  001c3	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN2408@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 836  :             while (_First != _Last && *_First == _Kseparator) {

  001c7	38 5f 05	 cmp	 BYTE PTR [edi+5], bl
  001ca	0f 85 db fe ff
	ff		 jne	 $LN2480@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  001d0	8b 0f		 mov	 ecx, DWORD PTR [edi]
  001d2	85 c9		 test	 ecx, ecx
  001d4	74 3d		 je	 SHORT $LN1238@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  001d6	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  001d9	83 38 00	 cmp	 DWORD PTR [eax], 0
  001dc	74 1b		 je	 SHORT $LN1242@Parse_fp_w
  001de	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  001e1	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  001e3	85 c0		 test	 eax, eax
  001e5	7e 12		 jle	 SHORT $LN1242@Parse_fp_w

; 222  :         --*_IGcount;

  001e7	48		 dec	 eax
  001e8	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  001ea	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  001ed	8b 11		 mov	 edx, DWORD PTR [ecx]
  001ef	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  001f2	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  001f4	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  001f7	eb 05		 jmp	 SHORT $LN1243@Parse_fp_w
$LN1242@Parse_fp_w:
  001f9	8b 01		 mov	 eax, DWORD PTR [ecx]
  001fb	ff 50 1c	 call	 DWORD PTR [eax+28]
$LN1243@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  001fe	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00201	74 10		 je	 SHORT $LN1238@Parse_fp_w

; 464  :             _Got = false;

  00203	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00205	32 c0		 xor	 al, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 838  :                 _Bad_grouping = true;

  00207	88 47 04	 mov	 BYTE PTR [edi+4], al
  0020a	c6 45 9d 01	 mov	 BYTE PTR __Bad_grouping$1$[ebp], 1

; 839  :             }

  0020e	e9 ed fe ff ff	 jmp	 $LL2@Parse_fp_w
$LN1238@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 462  :             _Got    = true;

  00213	b0 01		 mov	 al, 1
  00215	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  0021b	33 c9		 xor	 ecx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 838  :                 _Bad_grouping = true;

  0021d	88 47 04	 mov	 BYTE PTR [edi+4], al
  00220	88 45 9d	 mov	 BYTE PTR __Bad_grouping$1$[ebp], al

; 839  :             }

  00223	e9 d8 fe ff ff	 jmp	 $LL2@Parse_fp_w
$LN1820@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00228	8b 01		 mov	 eax, DWORD PTR [ecx]
  0022a	ff 50 18	 call	 DWORD PTR [eax+24]
$LN1821@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  0022d	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00230	74 05		 je	 SHORT $LN1816@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00232	88 47 05	 mov	 BYTE PTR [edi+5], al
  00235	eb 06		 jmp	 SHORT $LN1815@Parse_fp_w
$LN1816@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  00237	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN1815@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  0023d	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN1806@Parse_fp_w:

; 441  :         if (!_Right._Got) {

  00241	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  00245	75 35		 jne	 SHORT $LN1807@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00247	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00249	85 c9		 test	 ecx, ecx
  0024b	74 25		 je	 SHORT $LN1842@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  0024d	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00250	8b 10		 mov	 edx, DWORD PTR [eax]
  00252	85 d2		 test	 edx, edx
  00254	74 0d		 je	 SHORT $LN2409@Parse_fp_w
  00256	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00259	83 38 00	 cmp	 DWORD PTR [eax], 0
  0025c	7e 05		 jle	 SHORT $LN2409@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0025e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00261	eb 05		 jmp	 SHORT $LN1847@Parse_fp_w
$LN2409@Parse_fp_w:
  00263	8b 01		 mov	 eax, DWORD PTR [ecx]
  00265	ff 50 18	 call	 DWORD PTR [eax+24]
$LN1847@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00268	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0026b	74 05		 je	 SHORT $LN1842@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  0026d	88 46 05	 mov	 BYTE PTR [esi+5], al
  00270	eb 06		 jmp	 SHORT $LN1841@Parse_fp_w
$LN1842@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  00272	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1841@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00278	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN1807@Parse_fp_w:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  0027c	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0027e	8b 06		 mov	 eax, DWORD PTR [esi]
  00280	85 c9		 test	 ecx, ecx
  00282	75 0a		 jne	 SHORT $LN2370@Parse_fp_w
  00284	85 c0		 test	 eax, eax
  00286	0f 84 f1 00 00
	00		 je	 $LN38@Parse_fp_w
  0028c	eb 08		 jmp	 SHORT $LN2280@Parse_fp_w
$LN2370@Parse_fp_w:
  0028e	85 c0		 test	 eax, eax
  00290	0f 85 e7 00 00
	00		 jne	 $LN38@Parse_fp_w
$LN2280@Parse_fp_w:

; 406  :         if (!_Got) {

  00296	8a 57 04	 mov	 dl, BYTE PTR [edi+4]
  00299	84 d2		 test	 dl, dl
  0029b	75 35		 jne	 SHORT $LN1965@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0029d	85 c9		 test	 ecx, ecx
  0029f	74 25		 je	 SHORT $LN1970@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  002a1	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  002a4	8b 10		 mov	 edx, DWORD PTR [eax]
  002a6	85 d2		 test	 edx, edx
  002a8	74 0d		 je	 SHORT $LN1974@Parse_fp_w
  002aa	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  002ad	83 38 00	 cmp	 DWORD PTR [eax], 0
  002b0	7e 05		 jle	 SHORT $LN1974@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  002b2	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  002b5	eb 05		 jmp	 SHORT $LN1975@Parse_fp_w
$LN1974@Parse_fp_w:
  002b7	8b 01		 mov	 eax, DWORD PTR [ecx]
  002b9	ff 50 18	 call	 DWORD PTR [eax+24]
$LN1975@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  002bc	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  002bf	74 05		 je	 SHORT $LN1970@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  002c1	88 47 05	 mov	 BYTE PTR [edi+5], al
  002c4	eb 06		 jmp	 SHORT $LN1969@Parse_fp_w
$LN1970@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  002c6	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN1969@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  002cc	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
  002d0	b2 01		 mov	 dl, 1
$LN1965@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 843  :             if (*_First == _Positive_sign) { // gather plus sign

  002d2	8a 47 05	 mov	 al, BYTE PTR [edi+5]
  002d5	3a 45 8f	 cmp	 al, BYTE PTR __Positive_sign$1$[ebp]
  002d8	75 51		 jne	 SHORT $LN36@Parse_fp_w

; 844  :                 *_Ptr++ = '+';

  002da	8b 45 98	 mov	 eax, DWORD PTR __Ptr$1$[ebp]
  002dd	c6 00 2b	 mov	 BYTE PTR [eax], 43	; 0000002bH
  002e0	40		 inc	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  002e1	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 844  :                 *_Ptr++ = '+';

  002e3	89 45 98	 mov	 DWORD PTR __Ptr$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  002e6	85 c9		 test	 ecx, ecx
  002e8	74 34		 je	 SHORT $LN2481@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  002ea	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  002ed	83 38 00	 cmp	 DWORD PTR [eax], 0
  002f0	74 1b		 je	 SHORT $LN2412@Parse_fp_w
  002f2	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  002f5	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  002f7	85 c0		 test	 eax, eax
  002f9	7e 12		 jle	 SHORT $LN2412@Parse_fp_w

; 222  :         --*_IGcount;

  002fb	48		 dec	 eax
  002fc	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  002fe	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00301	8b 11		 mov	 edx, DWORD PTR [ecx]
  00303	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00306	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00308	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  0030b	eb 05		 jmp	 SHORT $LN2063@Parse_fp_w
$LN2412@Parse_fp_w:
  0030d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0030f	ff 50 1c	 call	 DWORD PTR [eax+28]
$LN2063@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00312	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00315	74 07		 je	 SHORT $LN2481@Parse_fp_w

; 464  :             _Got = false;

  00317	32 c0		 xor	 al, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 846  :             } else if (*_First == _Negative_sign) { // gather minus sign

  00319	88 47 04	 mov	 BYTE PTR [edi+4], al
  0031c	eb 5f		 jmp	 SHORT $LN38@Parse_fp_w
$LN2481@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 462  :             _Got    = true;

  0031e	b0 01		 mov	 al, 1
  00320	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 846  :             } else if (*_First == _Negative_sign) { // gather minus sign

  00326	88 47 04	 mov	 BYTE PTR [edi+4], al
  00329	eb 52		 jmp	 SHORT $LN38@Parse_fp_w
$LN36@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 406  :         if (!_Got) {

  0032b	84 d2		 test	 dl, dl
  0032d	75 38		 jne	 SHORT $LN2025@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0032f	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00331	85 c9		 test	 ecx, ecx
  00333	74 25		 je	 SHORT $LN2410@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00335	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00338	8b 10		 mov	 edx, DWORD PTR [eax]
  0033a	85 d2		 test	 edx, edx
  0033c	74 0d		 je	 SHORT $LN2411@Parse_fp_w
  0033e	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00341	83 38 00	 cmp	 DWORD PTR [eax], 0
  00344	7e 05		 jle	 SHORT $LN2411@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00346	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00349	eb 05		 jmp	 SHORT $LN2035@Parse_fp_w
$LN2411@Parse_fp_w:
  0034b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0034d	ff 50 18	 call	 DWORD PTR [eax+24]
$LN2035@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00350	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00353	74 05		 je	 SHORT $LN2410@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00355	88 47 05	 mov	 BYTE PTR [edi+5], al
  00358	eb 09		 jmp	 SHORT $LN2029@Parse_fp_w
$LN2410@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  0035a	8a 47 05	 mov	 al, BYTE PTR [edi+5]
  0035d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN2029@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00363	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN2025@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 846  :             } else if (*_First == _Negative_sign) { // gather minus sign

  00367	3a 45 8e	 cmp	 al, BYTE PTR __Negative_sign$1$[ebp]
  0036a	75 11		 jne	 SHORT $LN38@Parse_fp_w

; 847  :                 *_Ptr++ = '-';

  0036c	8b 45 98	 mov	 eax, DWORD PTR __Ptr$1$[ebp]

; 848  :                 ++_First;

  0036f	8b cf		 mov	 ecx, edi
  00371	c6 00 2d	 mov	 BYTE PTR [eax], 45	; 0000002dH
  00374	40		 inc	 eax
  00375	89 45 98	 mov	 DWORD PTR __Ptr$1$[ebp], eax
  00378	e8 00 00 00 00	 call	 ??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
$LN38@Parse_fp_w:

; 849  :             }
; 850  :         }
; 851  : 
; 852  :         *_Ptr++ = '0'; // backstop carries from sticky bit

  0037d	8b 45 98	 mov	 eax, DWORD PTR __Ptr$1$[ebp]

; 853  : 
; 854  :         bool _Parse_hex                = false;
; 855  :         bool _Seendigit                = false; // seen a digit in input

  00380	32 ff		 xor	 bh, bh
  00382	c6 45 9f 00	 mov	 BYTE PTR __Parse_hex$1$[ebp], 0
  00386	88 7d 9e	 mov	 BYTE PTR __Seendigit$1$[ebp], bh
  00389	88 7d 88	 mov	 BYTE PTR __Seendigit$[ebp], bh
  0038c	c6 00 30	 mov	 BYTE PTR [eax], 48	; 00000030H
  0038f	40		 inc	 eax
  00390	89 45 98	 mov	 DWORD PTR __Ptr$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 437  :         if (!_Got) {

  00393	38 7f 04	 cmp	 BYTE PTR [edi+4], bh
  00396	75 35		 jne	 SHORT $LN1882@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00398	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0039a	85 c9		 test	 ecx, ecx
  0039c	74 25		 je	 SHORT $LN1892@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  0039e	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  003a1	8b 10		 mov	 edx, DWORD PTR [eax]
  003a3	85 d2		 test	 edx, edx
  003a5	74 0d		 je	 SHORT $LN2413@Parse_fp_w
  003a7	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  003aa	83 38 00	 cmp	 DWORD PTR [eax], 0
  003ad	7e 05		 jle	 SHORT $LN2413@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  003af	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  003b2	eb 05		 jmp	 SHORT $LN1897@Parse_fp_w
$LN2413@Parse_fp_w:
  003b4	8b 01		 mov	 eax, DWORD PTR [ecx]
  003b6	ff 50 18	 call	 DWORD PTR [eax+24]
$LN1897@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  003b9	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  003bc	74 05		 je	 SHORT $LN1892@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  003be	88 47 05	 mov	 BYTE PTR [edi+5], al
  003c1	eb 06		 jmp	 SHORT $LN1891@Parse_fp_w
$LN1892@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  003c3	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN1891@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  003c9	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN1882@Parse_fp_w:

; 441  :         if (!_Right._Got) {

  003cd	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  003d1	75 35		 jne	 SHORT $LN1883@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  003d3	8b 0e		 mov	 ecx, DWORD PTR [esi]
  003d5	85 c9		 test	 ecx, ecx
  003d7	74 25		 je	 SHORT $LN2287@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  003d9	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  003dc	8b 10		 mov	 edx, DWORD PTR [eax]
  003de	85 d2		 test	 edx, edx
  003e0	74 0d		 je	 SHORT $LN1922@Parse_fp_w
  003e2	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  003e5	83 38 00	 cmp	 DWORD PTR [eax], 0
  003e8	7e 05		 jle	 SHORT $LN1922@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  003ea	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  003ed	eb 05		 jmp	 SHORT $LN1923@Parse_fp_w
$LN1922@Parse_fp_w:
  003ef	8b 01		 mov	 eax, DWORD PTR [ecx]
  003f1	ff 50 18	 call	 DWORD PTR [eax+24]
$LN1923@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  003f4	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  003f7	74 05		 je	 SHORT $LN2287@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  003f9	88 46 05	 mov	 BYTE PTR [esi+5], al
  003fc	eb 06		 jmp	 SHORT $LN1917@Parse_fp_w
$LN2287@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  003fe	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1917@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00404	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN1883@Parse_fp_w:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  00408	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0040a	8b 06		 mov	 eax, DWORD PTR [esi]
  0040c	85 c9		 test	 ecx, ecx
  0040e	75 0a		 jne	 SHORT $LN2369@Parse_fp_w
  00410	85 c0		 test	 eax, eax
  00412	0f 84 8a 01 00
	00		 je	 $LN42@Parse_fp_w
  00418	eb 08		 jmp	 SHORT $LN2284@Parse_fp_w
$LN2369@Parse_fp_w:
  0041a	85 c0		 test	 eax, eax
  0041c	0f 85 80 01 00
	00		 jne	 $LN42@Parse_fp_w
$LN2284@Parse_fp_w:

; 406  :         if (!_Got) {

  00422	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  00426	75 33		 jne	 SHORT $LN2414@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00428	85 c9		 test	 ecx, ecx
  0042a	74 25		 je	 SHORT $LN2290@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  0042c	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0042f	8b 10		 mov	 edx, DWORD PTR [eax]
  00431	85 d2		 test	 edx, edx
  00433	74 0d		 je	 SHORT $LN2005@Parse_fp_w
  00435	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00438	83 38 00	 cmp	 DWORD PTR [eax], 0
  0043b	7e 05		 jle	 SHORT $LN2005@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0043d	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00440	eb 05		 jmp	 SHORT $LN2006@Parse_fp_w
$LN2005@Parse_fp_w:
  00442	8b 01		 mov	 eax, DWORD PTR [ecx]
  00444	ff 50 18	 call	 DWORD PTR [eax+24]
$LN2006@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00447	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0044a	74 05		 je	 SHORT $LN2290@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  0044c	88 47 05	 mov	 BYTE PTR [edi+5], al
  0044f	eb 06		 jmp	 SHORT $LN2000@Parse_fp_w
$LN2290@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  00451	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN2000@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00457	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN2414@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 857  :         if (_First != _Last && *_First == _Zero_wc) {

  0045b	8a 45 97	 mov	 al, BYTE PTR __Zero_wc$1$[ebp]
  0045e	38 47 05	 cmp	 BYTE PTR [edi+5], al
  00461	0f 85 3b 01 00
	00		 jne	 $LN42@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00467	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00469	85 c9		 test	 ecx, ecx
  0046b	74 5c		 je	 SHORT $LN2145@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  0046d	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00470	83 38 00	 cmp	 DWORD PTR [eax], 0
  00473	74 1b		 je	 SHORT $LN2149@Parse_fp_w
  00475	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00478	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  0047a	85 c0		 test	 eax, eax
  0047c	7e 12		 jle	 SHORT $LN2149@Parse_fp_w

; 222  :         --*_IGcount;

  0047e	48		 dec	 eax
  0047f	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  00481	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00484	8b 11		 mov	 edx, DWORD PTR [ecx]
  00486	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00489	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0048b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  0048e	eb 05		 jmp	 SHORT $LN2150@Parse_fp_w
$LN2149@Parse_fp_w:
  00490	8b 01		 mov	 eax, DWORD PTR [ecx]
  00492	ff 50 1c	 call	 DWORD PTR [eax+28]
$LN2150@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00495	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00498	74 2f		 je	 SHORT $LN2145@Parse_fp_w

; 464  :             _Got = false;

  0049a	c6 47 04 00	 mov	 BYTE PTR [edi+4], 0

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0049e	8b 0f		 mov	 ecx, DWORD PTR [edi]
  004a0	85 c9		 test	 ecx, ecx
  004a2	74 25		 je	 SHORT $LN2145@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  004a4	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  004a7	8b 10		 mov	 edx, DWORD PTR [eax]
  004a9	85 d2		 test	 edx, edx
  004ab	74 0d		 je	 SHORT $LN2095@Parse_fp_w
  004ad	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  004b0	83 38 00	 cmp	 DWORD PTR [eax], 0
  004b3	7e 05		 jle	 SHORT $LN2095@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  004b5	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  004b8	eb 05		 jmp	 SHORT $LN2096@Parse_fp_w
$LN2095@Parse_fp_w:
  004ba	8b 01		 mov	 eax, DWORD PTR [ecx]
  004bc	ff 50 18	 call	 DWORD PTR [eax+24]
$LN2096@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  004bf	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  004c2	74 05		 je	 SHORT $LN2145@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  004c4	88 47 05	 mov	 BYTE PTR [edi+5], al
  004c7	eb 06		 jmp	 SHORT $LN2090@Parse_fp_w
$LN2145@Parse_fp_w:

; 441  :         if (!_Right._Got) {

  004c9	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN2090@Parse_fp_w:
  004cf	b0 01		 mov	 al, 1
  004d1	88 47 04	 mov	 BYTE PTR [edi+4], al
  004d4	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  004d8	75 35		 jne	 SHORT $LN2082@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  004da	8b 0e		 mov	 ecx, DWORD PTR [esi]
  004dc	85 c9		 test	 ecx, ecx
  004de	74 25		 je	 SHORT $LN2117@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  004e0	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  004e3	8b 10		 mov	 edx, DWORD PTR [eax]
  004e5	85 d2		 test	 edx, edx
  004e7	74 0d		 je	 SHORT $LN2121@Parse_fp_w
  004e9	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  004ec	83 38 00	 cmp	 DWORD PTR [eax], 0
  004ef	7e 05		 jle	 SHORT $LN2121@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  004f1	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  004f4	eb 05		 jmp	 SHORT $LN2122@Parse_fp_w
$LN2121@Parse_fp_w:
  004f6	8b 01		 mov	 eax, DWORD PTR [ecx]
  004f8	ff 50 18	 call	 DWORD PTR [eax+24]
$LN2122@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  004fb	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  004fe	74 05		 je	 SHORT $LN2117@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00500	88 46 05	 mov	 BYTE PTR [esi+5], al
  00503	eb 06		 jmp	 SHORT $LN2116@Parse_fp_w
$LN2117@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  00505	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN2116@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  0050b	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN2082@Parse_fp_w:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  0050f	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00511	8b 06		 mov	 eax, DWORD PTR [esi]
  00513	85 c9		 test	 ecx, ecx
  00515	75 24		 jne	 SHORT $LN2368@Parse_fp_w
  00517	85 c0		 test	 eax, eax
  00519	74 24		 je	 SHORT $LN2385@Parse_fp_w
$LN40@Parse_fp_w:

; 406  :         if (!_Got) {

  0051b	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  0051f	75 4e		 jne	 SHORT $LN2415@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00521	85 c9		 test	 ecx, ecx
  00523	74 40		 je	 SHORT $LN2171@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00525	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00528	8b 10		 mov	 edx, DWORD PTR [eax]
  0052a	85 d2		 test	 edx, edx
  0052c	74 28		 je	 SHORT $LN2175@Parse_fp_w
  0052e	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00531	83 38 00	 cmp	 DWORD PTR [eax], 0
  00534	7e 20		 jle	 SHORT $LN2175@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00536	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00539	eb 20		 jmp	 SHORT $LN2176@Parse_fp_w
$LN2368@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  0053b	85 c0		 test	 eax, eax
  0053d	74 dc		 je	 SHORT $LN40@Parse_fp_w
$LN2385@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 860  :                 *_Ptr = '\0';

  0053f	8b 5d 98	 mov	 ebx, DWORD PTR __Ptr$1$[ebp]

; 861  :                 return {10, _Bad_grouping};

  00542	0f b6 45 9d	 movzx	 eax, BYTE PTR __Bad_grouping$1$[ebp]
  00546	66 c1 e0 08	 shl	 ax, 8
  0054a	66 83 c8 0a	 or	 ax, 10			; 0000000aH
  0054e	c6 03 00	 mov	 BYTE PTR [ebx], 0
  00551	e9 04 13 00 00	 jmp	 $LN120@Parse_fp_w
$LN2175@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00556	8b 01		 mov	 eax, DWORD PTR [ecx]
  00558	ff 50 18	 call	 DWORD PTR [eax+24]
$LN2176@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  0055b	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0055e	74 05		 je	 SHORT $LN2171@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00560	88 47 05	 mov	 BYTE PTR [edi+5], al
  00563	eb 06		 jmp	 SHORT $LN2170@Parse_fp_w
$LN2171@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  00565	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN2170@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  0056b	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN2415@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 864  :             if (*_First == _Atoms[_Offset_lower_x] || *_First == _Atoms[_Offset_upper_x]) { // 0x or 0X

  0056f	8a 47 05	 mov	 al, BYTE PTR [edi+5]
  00572	3a 45 e9	 cmp	 al, BYTE PTR __Atoms$[ebp+25]
  00575	74 16		 je	 SHORT $LN43@Parse_fp_w
  00577	8b cf		 mov	 ecx, edi
  00579	e8 00 00 00 00	 call	 ??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
  0057e	3a 45 e8	 cmp	 al, BYTE PTR __Atoms$[ebp+24]
  00581	74 0a		 je	 SHORT $LN43@Parse_fp_w

; 868  :             } else {
; 869  :                 _Seendigit = true;

  00583	b2 01		 mov	 dl, 1
  00585	88 55 9e	 mov	 BYTE PTR __Seendigit$1$[ebp], dl
  00588	88 55 88	 mov	 BYTE PTR __Seendigit$[ebp], dl

; 870  :                 ++_Initial_dec_leading_zero;

  0058b	eb 15		 jmp	 SHORT $LN42@Parse_fp_w
$LN43@Parse_fp_w:

; 865  :                 _Parse_hex = true;
; 866  :                 ++_First; // discard 0x or 0X for further parsing

  0058d	8b cf		 mov	 ecx, edi
  0058f	c6 45 9f 01	 mov	 BYTE PTR __Parse_hex$1$[ebp], 1
  00593	e8 00 00 00 00	 call	 ??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++

; 867  :                 *_Ptr++ = 'x';

  00598	8b 45 98	 mov	 eax, DWORD PTR __Ptr$1$[ebp]
  0059b	c6 00 78	 mov	 BYTE PTR [eax], 120	; 00000078H
  0059e	40		 inc	 eax
  0059f	89 45 98	 mov	 DWORD PTR __Ptr$1$[ebp], eax
$LN42@Parse_fp_w:

; 871  :             }
; 872  :         }
; 873  : 
; 874  :         bool _Has_unaccumulated_digits = false;

  005a2	32 c0		 xor	 al, al

; 875  :         int _Significant               = 0; // number of significant digits

  005a4	c7 45 80 00 00
	00 00		 mov	 DWORD PTR __Significant$1$[ebp], 0

; 878  :         const size_t _Offset_digit_end = _Parse_hex ? _Offset_hex_digit_end : _Offset_dec_digit_end;

  005ab	80 7d 9f 00	 cmp	 BYTE PTR __Parse_hex$1$[ebp], 0
  005af	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  005b4	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv9647[ebp], eax
  005ba	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  005bf	0f 45 c1	 cmovne	 eax, ecx
  005c2	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __Power_of_rep_base$1$[ebp], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2494 :         return _Mypair._Myval2._Mysize == 0;

  005cc	83 7d b0 00	 cmp	 DWORD PTR __Grouping$[ebp+16], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 878  :         const size_t _Offset_digit_end = _Parse_hex ? _Offset_hex_digit_end : _Offset_dec_digit_end;

  005d0	89 45 84	 mov	 DWORD PTR __Offset_digit_end$1$[ebp], eax

; 879  :         if (_Grouping.empty()) {

  005d3	0f 85 79 01 00
	00		 jne	 $LL7@Parse_fp_w
  005d9	8b d8		 mov	 ebx, eax
  005db	0f 1f 44 00 00	 npad	 5
$LL6@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 437  :         if (!_Got) {

  005e0	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  005e4	75 35		 jne	 SHORT $LN1643@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  005e6	8b 0f		 mov	 ecx, DWORD PTR [edi]
  005e8	85 c9		 test	 ecx, ecx
  005ea	74 25		 je	 SHORT $LN1653@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  005ec	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  005ef	8b 10		 mov	 edx, DWORD PTR [eax]
  005f1	85 d2		 test	 edx, edx
  005f3	74 0d		 je	 SHORT $LN1657@Parse_fp_w
  005f5	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  005f8	83 38 00	 cmp	 DWORD PTR [eax], 0
  005fb	7e 05		 jle	 SHORT $LN1657@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  005fd	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00600	eb 05		 jmp	 SHORT $LN1658@Parse_fp_w
$LN1657@Parse_fp_w:
  00602	8b 01		 mov	 eax, DWORD PTR [ecx]
  00604	ff 50 18	 call	 DWORD PTR [eax+24]
$LN1658@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00607	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0060a	74 05		 je	 SHORT $LN1653@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  0060c	88 47 05	 mov	 BYTE PTR [edi+5], al
  0060f	eb 06		 jmp	 SHORT $LN1652@Parse_fp_w
$LN1653@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  00611	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN1652@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00617	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN1643@Parse_fp_w:

; 441  :         if (!_Right._Got) {

  0061b	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  0061f	75 35		 jne	 SHORT $LN1644@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00621	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00623	85 c9		 test	 ecx, ecx
  00625	74 25		 je	 SHORT $LN2305@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00627	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0062a	8b 10		 mov	 edx, DWORD PTR [eax]
  0062c	85 d2		 test	 edx, edx
  0062e	74 0d		 je	 SHORT $LN1683@Parse_fp_w
  00630	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00633	83 38 00	 cmp	 DWORD PTR [eax], 0
  00636	7e 05		 jle	 SHORT $LN1683@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00638	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0063b	eb 05		 jmp	 SHORT $LN1684@Parse_fp_w
$LN1683@Parse_fp_w:
  0063d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0063f	ff 50 18	 call	 DWORD PTR [eax+24]
$LN1684@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00642	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00645	74 05		 je	 SHORT $LN2305@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00647	88 46 05	 mov	 BYTE PTR [esi+5], al
  0064a	eb 06		 jmp	 SHORT $LN1678@Parse_fp_w
$LN2305@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  0064c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1678@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00652	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN1644@Parse_fp_w:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  00656	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00658	8b 06		 mov	 eax, DWORD PTR [esi]
  0065a	85 c9		 test	 ecx, ecx
  0065c	75 0a		 jne	 SHORT $LN2367@Parse_fp_w
  0065e	85 c0		 test	 eax, eax
  00660	0f 84 52 06 00
	00		 je	 $LN1453@Parse_fp_w
  00666	eb 08		 jmp	 SHORT $LN2306@Parse_fp_w
$LN2367@Parse_fp_w:
  00668	85 c0		 test	 eax, eax
  0066a	0f 85 48 06 00
	00		 jne	 $LN1453@Parse_fp_w
$LN2306@Parse_fp_w:

; 406  :         if (!_Got) {

  00670	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  00674	75 33		 jne	 SHORT $LN2416@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00676	85 c9		 test	 ecx, ecx
  00678	74 25		 je	 SHORT $LN1485@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  0067a	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0067d	8b 10		 mov	 edx, DWORD PTR [eax]
  0067f	85 d2		 test	 edx, edx
  00681	74 0d		 je	 SHORT $LN1489@Parse_fp_w
  00683	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00686	83 38 00	 cmp	 DWORD PTR [eax], 0
  00689	7e 05		 jle	 SHORT $LN1489@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0068b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0068e	eb 05		 jmp	 SHORT $LN1490@Parse_fp_w
$LN1489@Parse_fp_w:
  00690	8b 01		 mov	 eax, DWORD PTR [ecx]
  00692	ff 50 18	 call	 DWORD PTR [eax+24]
$LN1490@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00695	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00698	74 05		 je	 SHORT $LN1485@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  0069a	88 47 05	 mov	 BYTE PTR [edi+5], al
  0069d	eb 06		 jmp	 SHORT $LN1484@Parse_fp_w
$LN1485@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  0069f	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN1484@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  006a5	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN2416@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 6127 :             const auto _Result    = _STD _Find_vectorized(_First_ptr, _STD _To_address(_Last), _Val);

  006a9	8a 47 05	 mov	 al, BYTE PTR [edi+5]
  006ac	88 45 88	 mov	 BYTE PTR $T2[ebp], al

; 200  :         return const_cast<_Ty*>(

  006af	8d 45 ec	 lea	 eax, DWORD PTR __Atoms$[ebp+28]
  006b2	ff 75 88	 push	 DWORD PTR $T2[ebp]
  006b5	50		 push	 eax
  006b6	8d 45 d0	 lea	 eax, DWORD PTR __Atoms$[ebp]
  006b9	50		 push	 eax
  006ba	e8 00 00 00 00	 call	 ___std_find_trivial_1@12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 70   :     return static_cast<size_t>(_STD _Find_unchecked(_Base, _Base + (_Base_size - 1), _Ch) - _Base);

  006bf	8d 4d d0	 lea	 ecx, DWORD PTR __Atoms$[ebp]
  006c2	2b c1		 sub	 eax, ecx

; 880  :             for (size_t _Idx; _First != _Last && (_Idx = _STD _Find_elem(_Atoms, *_First)) < _Offset_digit_end;

  006c4	3b c3		 cmp	 eax, ebx
  006c6	0f 83 ec 05 00
	00		 jae	 $LN1453@Parse_fp_w

; 882  :                 if (_Significant >= _Max_sig_dig) {

  006cc	8b 55 80	 mov	 edx, DWORD PTR __Significant$1$[ebp]
  006cf	3b 55 0c	 cmp	 edx, DWORD PTR __Max_sig_dig$[ebp]
  006d2	7c 14		 jl	 SHORT $LN46@Parse_fp_w

; 883  :                     ++_Power_of_rep_base; // just scale by 10 or 16

  006d4	ff 85 7c ff ff
	ff		 inc	 DWORD PTR __Power_of_rep_base$1$[ebp]

; 884  :                     if (_Idx > 0) {

  006da	85 c0		 test	 eax, eax
  006dc	74 25		 je	 SHORT $LN4@Parse_fp_w

; 885  :                         _Has_unaccumulated_digits = true;

  006de	b0 01		 mov	 al, 1
  006e0	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv9647[ebp], eax

; 886  :                     }

  006e6	eb 1b		 jmp	 SHORT $LN4@Parse_fp_w
$LN46@Parse_fp_w:

; 887  :                 } else if (_Idx != 0 || _Significant != 0) { // save a significant digit

  006e8	85 c0		 test	 eax, eax
  006ea	75 04		 jne	 SHORT $LN50@Parse_fp_w
  006ec	85 d2		 test	 edx, edx
  006ee	74 13		 je	 SHORT $LN4@Parse_fp_w
$LN50@Parse_fp_w:

; 888  :                     *_Ptr++ = _Src[_Idx];

  006f0	8b 4d 98	 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
  006f3	8a 80 00 00 00
	00		 mov	 al, BYTE PTR ?_Src@?1???$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z@4QBDB[eax]
  006f9	88 01		 mov	 BYTE PTR [ecx], al
  006fb	41		 inc	 ecx

; 889  :                     ++_Significant;

  006fc	42		 inc	 edx
  006fd	89 4d 98	 mov	 DWORD PTR __Ptr$1$[ebp], ecx
  00700	89 55 80	 mov	 DWORD PTR __Significant$1$[ebp], edx
$LN4@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00703	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 881  :                 _Seendigit = true, (void) ++_First) {

  00705	c6 45 9e 01	 mov	 BYTE PTR __Seendigit$1$[ebp], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00709	85 c9		 test	 ecx, ecx
  0070b	74 36		 je	 SHORT $LN1742@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  0070d	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00710	83 38 00	 cmp	 DWORD PTR [eax], 0
  00713	74 1b		 je	 SHORT $LN1746@Parse_fp_w
  00715	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00718	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  0071a	85 c0		 test	 eax, eax
  0071c	7e 12		 jle	 SHORT $LN1746@Parse_fp_w

; 222  :         --*_IGcount;

  0071e	48		 dec	 eax
  0071f	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  00721	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00724	8b 11		 mov	 edx, DWORD PTR [ecx]
  00726	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00729	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0072b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  0072e	eb 05		 jmp	 SHORT $LN1747@Parse_fp_w
$LN1746@Parse_fp_w:
  00730	8b 01		 mov	 eax, DWORD PTR [ecx]
  00732	ff 50 1c	 call	 DWORD PTR [eax+28]
$LN1747@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00735	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00738	74 09		 je	 SHORT $LN1742@Parse_fp_w

; 464  :             _Got = false;

  0073a	c6 47 04 00	 mov	 BYTE PTR [edi+4], 0
  0073e	e9 9d fe ff ff	 jmp	 $LL6@Parse_fp_w
$LN1742@Parse_fp_w:

; 461  :             _Strbuf = nullptr;

  00743	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 462  :             _Got    = true;

  00749	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1

; 463  :         } else {

  0074d	e9 8e fe ff ff	 jmp	 $LL6@Parse_fp_w
$LL7@Parse_fp_w:

; 437  :         if (!_Got) {

  00752	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  00756	75 35		 jne	 SHORT $LN1288@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00758	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0075a	85 c9		 test	 ecx, ecx
  0075c	74 25		 je	 SHORT $LN1298@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  0075e	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00761	8b 10		 mov	 edx, DWORD PTR [eax]
  00763	85 d2		 test	 edx, edx
  00765	74 0d		 je	 SHORT $LN1302@Parse_fp_w
  00767	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0076a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0076d	7e 05		 jle	 SHORT $LN1302@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0076f	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00772	eb 05		 jmp	 SHORT $LN1303@Parse_fp_w
$LN1302@Parse_fp_w:
  00774	8b 01		 mov	 eax, DWORD PTR [ecx]
  00776	ff 50 18	 call	 DWORD PTR [eax+24]
$LN1303@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00779	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0077c	74 05		 je	 SHORT $LN1298@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  0077e	88 47 05	 mov	 BYTE PTR [edi+5], al
  00781	eb 06		 jmp	 SHORT $LN1297@Parse_fp_w
$LN1298@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  00783	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN1297@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00789	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN1288@Parse_fp_w:

; 441  :         if (!_Right._Got) {

  0078d	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  00791	75 35		 jne	 SHORT $LN1289@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00793	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00795	85 c9		 test	 ecx, ecx
  00797	74 25		 je	 SHORT $LN2294@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00799	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0079c	8b 10		 mov	 edx, DWORD PTR [eax]
  0079e	85 d2		 test	 edx, edx
  007a0	74 0d		 je	 SHORT $LN1328@Parse_fp_w
  007a2	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  007a5	83 38 00	 cmp	 DWORD PTR [eax], 0
  007a8	7e 05		 jle	 SHORT $LN1328@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  007aa	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  007ad	eb 05		 jmp	 SHORT $LN1329@Parse_fp_w
$LN1328@Parse_fp_w:
  007af	8b 01		 mov	 eax, DWORD PTR [ecx]
  007b1	ff 50 18	 call	 DWORD PTR [eax+24]
$LN1329@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  007b4	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  007b7	74 05		 je	 SHORT $LN2294@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  007b9	88 46 05	 mov	 BYTE PTR [esi+5], al
  007bc	eb 06		 jmp	 SHORT $LN1323@Parse_fp_w
$LN2294@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  007be	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1323@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  007c4	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN1289@Parse_fp_w:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  007c8	8b 0f		 mov	 ecx, DWORD PTR [edi]
  007ca	8b 06		 mov	 eax, DWORD PTR [esi]
  007cc	85 c9		 test	 ecx, ecx
  007ce	75 65		 jne	 SHORT $LN2366@Parse_fp_w
  007d0	85 c0		 test	 eax, eax
  007d2	75 65		 jne	 SHORT $LN2293@Parse_fp_w
$LN1293@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 899  :             string _Groups(1, _Initial_dec_leading_zero); // Groups are detected in the reversed order of _Groups.

  007d4	ff 75 88	 push	 DWORD PTR __Seendigit$[ebp]
  007d7	8d 4d b8	 lea	 ecx, DWORD PTR __Groups$5[ebp]
  007da	6a 01		 push	 1
  007dc	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 900  :             size_t _Groups_arr_idx = 0;

  007e1	8b 45 cc	 mov	 eax, DWORD PTR __Groups$5[ebp+20]
  007e4	33 db		 xor	 ebx, ebx
  007e6	89 85 74 ff ff
	ff		 mov	 DWORD PTR __Groups$1$[ebp], eax
  007ec	8b 45 b8	 mov	 eax, DWORD PTR __Groups$5[ebp]
  007ef	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  007f3	89 85 70 ff ff
	ff		 mov	 DWORD PTR __Groups$2$[ebp], eax
  007f9	0f 1f 80 00 00
	00 00		 npad	 7
$LL11@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 437  :         if (!_Got) {

  00800	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  00804	0f 85 de 00 00
	00		 jne	 $LN1554@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0080a	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0080c	85 c9		 test	 ecx, ecx
  0080e	0f 84 ca 00 00
	00		 je	 $LN1564@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00814	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00817	8b 10		 mov	 edx, DWORD PTR [eax]
  00819	85 d2		 test	 edx, edx
  0081b	0f 84 ae 00 00
	00		 je	 $LN1568@Parse_fp_w
  00821	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00824	83 38 00	 cmp	 DWORD PTR [eax], 0
  00827	0f 8e a2 00 00
	00		 jle	 $LN1568@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0082d	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00830	e9 9f 00 00 00	 jmp	 $LN1569@Parse_fp_w
$LN2366@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  00835	85 c0		 test	 eax, eax
  00837	75 9b		 jne	 SHORT $LN1293@Parse_fp_w
$LN2293@Parse_fp_w:

; 406  :         if (!_Got) {

  00839	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  0083d	75 33		 jne	 SHORT $LN2418@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0083f	85 c9		 test	 ecx, ecx
  00841	74 25		 je	 SHORT $LN1353@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00843	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00846	8b 10		 mov	 edx, DWORD PTR [eax]
  00848	85 d2		 test	 edx, edx
  0084a	74 0d		 je	 SHORT $LN1357@Parse_fp_w
  0084c	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0084f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00852	7e 05		 jle	 SHORT $LN1357@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00854	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00857	eb 05		 jmp	 SHORT $LN1358@Parse_fp_w
$LN1357@Parse_fp_w:
  00859	8b 01		 mov	 eax, DWORD PTR [ecx]
  0085b	ff 50 18	 call	 DWORD PTR [eax+24]
$LN1358@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  0085e	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00861	74 05		 je	 SHORT $LN1353@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00863	88 47 05	 mov	 BYTE PTR [edi+5], al
  00866	eb 06		 jmp	 SHORT $LN1352@Parse_fp_w
$LN1353@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  00868	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN1352@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  0086e	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN2418@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 894  :             while (_First != _Last && *_First == _Kseparator) {

  00872	38 5f 05	 cmp	 BYTE PTR [edi+5], bl
  00875	0f 85 59 ff ff
	ff		 jne	 $LN1293@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  0087b	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0087d	85 c9		 test	 ecx, ecx
  0087f	74 3b		 je	 SHORT $LN1381@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00881	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00884	83 38 00	 cmp	 DWORD PTR [eax], 0
  00887	74 1b		 je	 SHORT $LN2417@Parse_fp_w
  00889	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0088c	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  0088e	85 c0		 test	 eax, eax
  00890	7e 12		 jle	 SHORT $LN2417@Parse_fp_w

; 222  :         --*_IGcount;

  00892	48		 dec	 eax
  00893	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  00895	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00898	8b 11		 mov	 edx, DWORD PTR [ecx]
  0089a	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0089d	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0089f	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  008a2	eb 05		 jmp	 SHORT $LN1386@Parse_fp_w
$LN2417@Parse_fp_w:
  008a4	8b 01		 mov	 eax, DWORD PTR [ecx]
  008a6	ff 50 1c	 call	 DWORD PTR [eax+28]
$LN1386@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  008a9	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  008ac	74 0e		 je	 SHORT $LN1381@Parse_fp_w

; 464  :             _Got = false;

  008ae	32 c0		 xor	 al, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 896  :                 _Bad_grouping = true;

  008b0	c6 45 9d 01	 mov	 BYTE PTR __Bad_grouping$1$[ebp], 1
  008b4	88 47 04	 mov	 BYTE PTR [edi+4], al

; 897  :             }

  008b7	e9 96 fe ff ff	 jmp	 $LL7@Parse_fp_w
$LN1381@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 462  :             _Got    = true;

  008bc	b0 01		 mov	 al, 1
  008be	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 896  :                 _Bad_grouping = true;

  008c4	88 47 04	 mov	 BYTE PTR [edi+4], al
  008c7	88 45 9d	 mov	 BYTE PTR __Bad_grouping$1$[ebp], al

; 897  :             }

  008ca	e9 83 fe ff ff	 jmp	 $LL7@Parse_fp_w
$LN1568@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  008cf	8b 01		 mov	 eax, DWORD PTR [ecx]
  008d1	ff 50 18	 call	 DWORD PTR [eax+24]
$LN1569@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  008d4	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  008d7	74 05		 je	 SHORT $LN1564@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  008d9	88 47 05	 mov	 BYTE PTR [edi+5], al
  008dc	eb 06		 jmp	 SHORT $LN1563@Parse_fp_w
$LN1564@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  008de	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN1563@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  008e4	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN1554@Parse_fp_w:

; 441  :         if (!_Right._Got) {

  008e8	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  008ec	75 35		 jne	 SHORT $LN1555@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  008ee	8b 0e		 mov	 ecx, DWORD PTR [esi]
  008f0	85 c9		 test	 ecx, ecx
  008f2	74 25		 je	 SHORT $LN1590@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  008f4	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  008f7	8b 10		 mov	 edx, DWORD PTR [eax]
  008f9	85 d2		 test	 edx, edx
  008fb	74 0d		 je	 SHORT $LN1594@Parse_fp_w
  008fd	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00900	83 38 00	 cmp	 DWORD PTR [eax], 0
  00903	7e 05		 jle	 SHORT $LN1594@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00905	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00908	eb 05		 jmp	 SHORT $LN1595@Parse_fp_w
$LN1594@Parse_fp_w:
  0090a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0090c	ff 50 18	 call	 DWORD PTR [eax+24]
$LN1595@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  0090f	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00912	74 05		 je	 SHORT $LN1590@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00914	88 46 05	 mov	 BYTE PTR [esi+5], al
  00917	eb 06		 jmp	 SHORT $LN1589@Parse_fp_w
$LN1590@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  00919	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1589@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  0091f	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN1555@Parse_fp_w:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  00923	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00925	8b 06		 mov	 eax, DWORD PTR [esi]
  00927	85 c9		 test	 ecx, ecx
  00929	75 33		 jne	 SHORT $LN2365@Parse_fp_w
  0092b	85 c0		 test	 eax, eax
  0092d	75 33		 jne	 SHORT $LN2301@Parse_fp_w
$LN1559@Parse_fp_w:
  0092f	89 5d 88	 mov	 DWORD PTR __Groups_arr_idx$1$[ebp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 929  :             if (_Groups_arr_idx != 0) {

  00932	85 db		 test	 ebx, ebx
  00934	0f 84 b9 01 00
	00		 je	 $LN2399@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  0093a	83 bd 74 ff ff
	ff 0f		 cmp	 DWORD PTR __Groups$1$[ebp], 15 ; 0000000fH

; 435  :         value_type* _Result = _Bx._Buf;

  00941	8d 45 b8	 lea	 eax, DWORD PTR __Groups$5[ebp]

; 436  :         if (_Large_mode_engaged()) {

  00944	0f 47 85 70 ff
	ff ff		 cmova	 eax, DWORD PTR __Groups$2$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 930  :                 if (_Groups[_Groups_arr_idx] > '\0') {

  0094b	80 3c 18 00	 cmp	 BYTE PTR [eax+ebx], 0
  0094f	0f 8e 9a 01 00
	00		 jle	 $LN64@Parse_fp_w

; 931  :                     ++_Groups_arr_idx; // add trailing group to group count

  00955	43		 inc	 ebx
  00956	89 5d 88	 mov	 DWORD PTR __Groups_arr_idx$1$[ebp], ebx

; 932  :                 } else {

  00959	e9 95 01 00 00	 jmp	 $LN2399@Parse_fp_w
$LN2365@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  0095e	85 c0		 test	 eax, eax
  00960	75 cd		 jne	 SHORT $LN1559@Parse_fp_w
$LN2301@Parse_fp_w:

; 406  :         if (!_Got) {

  00962	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  00966	75 33		 jne	 SHORT $LN2419@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00968	85 c9		 test	 ecx, ecx
  0096a	74 25		 je	 SHORT $LN1526@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  0096c	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0096f	8b 10		 mov	 edx, DWORD PTR [eax]
  00971	85 d2		 test	 edx, edx
  00973	74 0d		 je	 SHORT $LN1530@Parse_fp_w
  00975	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00978	83 38 00	 cmp	 DWORD PTR [eax], 0
  0097b	7e 05		 jle	 SHORT $LN1530@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0097d	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00980	eb 05		 jmp	 SHORT $LN1531@Parse_fp_w
$LN1530@Parse_fp_w:
  00982	8b 01		 mov	 eax, DWORD PTR [ecx]
  00984	ff 50 18	 call	 DWORD PTR [eax+24]
$LN1531@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00987	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0098a	74 05		 je	 SHORT $LN1526@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  0098c	88 47 05	 mov	 BYTE PTR [edi+5], al
  0098f	eb 06		 jmp	 SHORT $LN1525@Parse_fp_w
$LN1526@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  00991	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN1525@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00997	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN2419@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 903  :                 const size_t _Idx = _STD _Find_elem(_Atoms, *_First);

  0099b	8a 47 05	 mov	 al, BYTE PTR [edi+5]
  0099e	88 45 88	 mov	 BYTE PTR __Ch$[ebp], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 200  :         return const_cast<_Ty*>(

  009a1	8d 45 ec	 lea	 eax, DWORD PTR __Atoms$[ebp+28]
  009a4	ff 75 88	 push	 DWORD PTR __Ch$[ebp]
  009a7	50		 push	 eax
  009a8	8d 45 d0	 lea	 eax, DWORD PTR __Atoms$[ebp]
  009ab	50		 push	 eax
  009ac	e8 00 00 00 00	 call	 ___std_find_trivial_1@12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 70   :     return static_cast<size_t>(_STD _Find_unchecked(_Base, _Base + (_Base_size - 1), _Ch) - _Base);

  009b1	8d 4d d0	 lea	 ecx, DWORD PTR __Atoms$[ebp]
  009b4	2b c1		 sub	 eax, ecx

; 904  :                 if (_Idx < _Offset_digit_end) { // got a digit, add to group size

  009b6	3b 45 84	 cmp	 eax, DWORD PTR __Offset_digit_end$1$[ebp]
  009b9	73 68		 jae	 SHORT $LN51@Parse_fp_w

; 905  :                     _Seendigit = true;
; 906  :                     if (_Significant >= _Max_sig_dig) {

  009bb	8b 4d 80	 mov	 ecx, DWORD PTR __Significant$1$[ebp]
  009be	c6 45 9e 01	 mov	 BYTE PTR __Seendigit$1$[ebp], 1
  009c2	3b 4d 0c	 cmp	 ecx, DWORD PTR __Max_sig_dig$[ebp]
  009c5	7c 14		 jl	 SHORT $LN53@Parse_fp_w

; 907  :                         ++_Power_of_rep_base; // just scale by 10 or 16

  009c7	ff 85 7c ff ff
	ff		 inc	 DWORD PTR __Power_of_rep_base$1$[ebp]

; 908  :                         if (_Idx > 0) {

  009cd	85 c0		 test	 eax, eax
  009cf	74 25		 je	 SHORT $LN56@Parse_fp_w

; 909  :                             _Has_unaccumulated_digits = true;

  009d1	b0 01		 mov	 al, 1
  009d3	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv9647[ebp], eax

; 910  :                         }

  009d9	eb 1b		 jmp	 SHORT $LN56@Parse_fp_w
$LN53@Parse_fp_w:

; 911  :                     } else if (_Idx != 0 || _Significant != 0) { // save a significant digit

  009db	85 c0		 test	 eax, eax
  009dd	75 04		 jne	 SHORT $LN57@Parse_fp_w
  009df	85 c9		 test	 ecx, ecx
  009e1	74 13		 je	 SHORT $LN56@Parse_fp_w
$LN57@Parse_fp_w:

; 912  :                         *_Ptr++ = _Src[_Idx];

  009e3	8b 55 98	 mov	 edx, DWORD PTR __Ptr$1$[ebp]
  009e6	8a 80 00 00 00
	00		 mov	 al, BYTE PTR ?_Src@?1???$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z@4QBDB[eax]
  009ec	88 02		 mov	 BYTE PTR [edx], al
  009ee	42		 inc	 edx

; 913  :                         ++_Significant;

  009ef	41		 inc	 ecx
  009f0	89 55 98	 mov	 DWORD PTR __Ptr$1$[ebp], edx
  009f3	89 4d 80	 mov	 DWORD PTR __Significant$1$[ebp], ecx
$LN56@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  009f6	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR __Groups$1$[ebp]

; 435  :         value_type* _Result = _Bx._Buf;

  009fc	8d 45 b8	 lea	 eax, DWORD PTR __Groups$5[ebp]

; 436  :         if (_Large_mode_engaged()) {

  009ff	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR __Groups$2$[ebp]

; 453  :         return _Myres > _Small_string_capacity;

  00a05	83 fa 0f	 cmp	 edx, 15			; 0000000fH

; 436  :         if (_Large_mode_engaged()) {

  00a08	0f 47 c1	 cmova	 eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 916  :                     if (_Groups[_Groups_arr_idx] != CHAR_MAX) {

  00a0b	80 3c 18 7f	 cmp	 BYTE PTR [eax+ebx], 127	; 0000007fH
  00a0f	0f 84 8f 00 00
	00		 je	 $LN9@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00a15	83 fa 0f	 cmp	 edx, 15			; 0000000fH

; 435  :         value_type* _Result = _Bx._Buf;

  00a18	8d 45 b8	 lea	 eax, DWORD PTR __Groups$5[ebp]

; 436  :         if (_Large_mode_engaged()) {

  00a1b	0f 47 c1	 cmova	 eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 917  :                         ++_Groups[_Groups_arr_idx];

  00a1e	fe 04 18	 inc	 BYTE PTR [eax+ebx]

; 919  :                 } else if (*_First != _Kseparator) {

  00a21	eb 6f		 jmp	 SHORT $LN2499@Parse_fp_w
$LN51@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 406  :         if (!_Got) {

  00a23	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  00a27	75 35		 jne	 SHORT $LN2420@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00a29	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00a2b	85 c9		 test	 ecx, ecx
  00a2d	74 25		 je	 SHORT $LN1768@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00a2f	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00a32	8b 10		 mov	 edx, DWORD PTR [eax]
  00a34	85 d2		 test	 edx, edx
  00a36	74 0d		 je	 SHORT $LN1772@Parse_fp_w
  00a38	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00a3b	83 38 00	 cmp	 DWORD PTR [eax], 0
  00a3e	7e 05		 jle	 SHORT $LN1772@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00a40	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00a43	eb 05		 jmp	 SHORT $LN1773@Parse_fp_w
$LN1772@Parse_fp_w:
  00a45	8b 01		 mov	 eax, DWORD PTR [ecx]
  00a47	ff 50 18	 call	 DWORD PTR [eax+24]
$LN1773@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00a4a	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00a4d	74 05		 je	 SHORT $LN1768@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00a4f	88 47 05	 mov	 BYTE PTR [edi+5], al
  00a52	eb 06		 jmp	 SHORT $LN1767@Parse_fp_w
$LN1768@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  00a54	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN1767@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00a5a	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN2420@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 919  :                 } else if (*_First != _Kseparator) {

  00a5e	8a 45 9c	 mov	 al, BYTE PTR __Kseparator$1$[ebp]
  00a61	38 47 05	 cmp	 BYTE PTR [edi+5], al
  00a64	0f 85 c5 fe ff
	ff		 jne	 $LN1559@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00a6a	83 bd 74 ff ff
	ff 0f		 cmp	 DWORD PTR __Groups$1$[ebp], 15 ; 0000000fH

; 435  :         value_type* _Result = _Bx._Buf;

  00a71	8d 45 b8	 lea	 eax, DWORD PTR __Groups$5[ebp]

; 436  :         if (_Large_mode_engaged()) {

  00a74	0f 47 85 70 ff
	ff ff		 cmova	 eax, DWORD PTR __Groups$2$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 921  :                 } else if (_Groups[_Groups_arr_idx] == '\0') {

  00a7b	80 3c 18 00	 cmp	 BYTE PTR [eax+ebx], 0
  00a7f	75 06		 jne	 SHORT $LN61@Parse_fp_w

; 922  :                     _Bad_grouping = true; // adjacent separators, fail

  00a81	c6 45 9d 01	 mov	 BYTE PTR __Bad_grouping$1$[ebp], 1

; 923  :                 } else { // add a new group to _Groups string

  00a85	eb 1d		 jmp	 SHORT $LN9@Parse_fp_w
$LN61@Parse_fp_w:

; 924  :                     _Groups.push_back('\0');

  00a87	6a 00		 push	 0
  00a89	8d 4d b8	 lea	 ecx, DWORD PTR __Groups$5[ebp]
  00a8c	e8 00 00 00 00	 call	 ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back

; 925  :                     ++_Groups_arr_idx;

  00a91	43		 inc	 ebx
$LN2499@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00a92	8b 45 cc	 mov	 eax, DWORD PTR __Groups$5[ebp+20]
  00a95	89 85 74 ff ff
	ff		 mov	 DWORD PTR __Groups$1$[ebp], eax
  00a9b	8b 45 b8	 mov	 eax, DWORD PTR __Groups$5[ebp]
  00a9e	89 85 70 ff ff
	ff		 mov	 DWORD PTR __Groups$2$[ebp], eax
$LN9@Parse_fp_w:
  00aa4	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00aa6	85 c9		 test	 ecx, ecx
  00aa8	74 36		 je	 SHORT $LN1618@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00aaa	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00aad	83 38 00	 cmp	 DWORD PTR [eax], 0
  00ab0	74 1b		 je	 SHORT $LN1622@Parse_fp_w
  00ab2	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00ab5	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  00ab7	85 c0		 test	 eax, eax
  00ab9	7e 12		 jle	 SHORT $LN1622@Parse_fp_w

; 222  :         --*_IGcount;

  00abb	48		 dec	 eax
  00abc	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  00abe	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00ac1	8b 11		 mov	 edx, DWORD PTR [ecx]
  00ac3	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00ac6	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00ac8	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  00acb	eb 05		 jmp	 SHORT $LN1623@Parse_fp_w
$LN1622@Parse_fp_w:
  00acd	8b 01		 mov	 eax, DWORD PTR [ecx]
  00acf	ff 50 1c	 call	 DWORD PTR [eax+28]
$LN1623@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00ad2	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00ad5	74 09		 je	 SHORT $LN1618@Parse_fp_w

; 464  :             _Got = false;

  00ad7	c6 47 04 00	 mov	 BYTE PTR [edi+4], 0
  00adb	e9 20 fd ff ff	 jmp	 $LL11@Parse_fp_w
$LN1618@Parse_fp_w:

; 461  :             _Strbuf = nullptr;

  00ae0	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 462  :             _Got    = true;

  00ae6	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1

; 463  :         } else {

  00aea	e9 11 fd ff ff	 jmp	 $LL11@Parse_fp_w
$LN64@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 933  :                     _Bad_grouping = true; // trailing separator, fail

  00aef	c6 45 9d 01	 mov	 BYTE PTR __Bad_grouping$1$[ebp], 1
$LN2399@Parse_fp_w:
  00af3	8a 5d 9c	 mov	 bl, BYTE PTR __Kseparator$1$[ebp]
$LL12@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 437  :         if (!_Got) {

  00af6	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  00afa	75 35		 jne	 SHORT $LN733@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00afc	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00afe	85 c9		 test	 ecx, ecx
  00b00	74 25		 je	 SHORT $LN743@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00b02	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00b05	8b 10		 mov	 edx, DWORD PTR [eax]
  00b07	85 d2		 test	 edx, edx
  00b09	74 0d		 je	 SHORT $LN2422@Parse_fp_w
  00b0b	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00b0e	83 38 00	 cmp	 DWORD PTR [eax], 0
  00b11	7e 05		 jle	 SHORT $LN2422@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00b13	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00b16	eb 05		 jmp	 SHORT $LN748@Parse_fp_w
$LN2422@Parse_fp_w:
  00b18	8b 01		 mov	 eax, DWORD PTR [ecx]
  00b1a	ff 50 18	 call	 DWORD PTR [eax+24]
$LN748@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00b1d	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00b20	74 05		 je	 SHORT $LN743@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00b22	88 47 05	 mov	 BYTE PTR [edi+5], al
  00b25	eb 06		 jmp	 SHORT $LN742@Parse_fp_w
$LN743@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  00b27	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN742@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00b2d	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN733@Parse_fp_w:

; 441  :         if (!_Right._Got) {

  00b31	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  00b35	75 35		 jne	 SHORT $LN734@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00b37	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00b39	85 c9		 test	 ecx, ecx
  00b3b	74 25		 je	 SHORT $LN2424@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00b3d	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00b40	8b 10		 mov	 edx, DWORD PTR [eax]
  00b42	85 d2		 test	 edx, edx
  00b44	74 0d		 je	 SHORT $LN773@Parse_fp_w
  00b46	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00b49	83 38 00	 cmp	 DWORD PTR [eax], 0
  00b4c	7e 05		 jle	 SHORT $LN773@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00b4e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00b51	eb 05		 jmp	 SHORT $LN774@Parse_fp_w
$LN773@Parse_fp_w:
  00b53	8b 01		 mov	 eax, DWORD PTR [ecx]
  00b55	ff 50 18	 call	 DWORD PTR [eax+24]
$LN774@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00b58	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00b5b	74 05		 je	 SHORT $LN2424@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00b5d	88 46 05	 mov	 BYTE PTR [esi+5], al
  00b60	eb 06		 jmp	 SHORT $LN768@Parse_fp_w
$LN2424@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  00b62	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN768@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00b68	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN734@Parse_fp_w:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  00b6c	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00b6e	8b 06		 mov	 eax, DWORD PTR [esi]
  00b70	85 c9		 test	 ecx, ecx
  00b72	0f 85 8c 00 00
	00		 jne	 $LN2364@Parse_fp_w
  00b78	85 c0		 test	 eax, eax
  00b7a	0f 85 8c 00 00
	00		 jne	 $LN2304@Parse_fp_w
$LN738@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00b80	83 7d b4 0f	 cmp	 DWORD PTR __Grouping$[ebp+20], 15 ; 0000000fH

; 444  :         const value_type* _Result = _Bx._Buf;

  00b84	8d 4d a0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 944  :             const char* const _Grouping_end = _Grouping_iter + _Grouping.size();

  00b87	8b 75 b0	 mov	 esi, DWORD PTR __Grouping$[ebp+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

  00b8a	0f 47 4d a0	 cmova	 ecx, DWORD PTR __Grouping$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 945  :             char _Current_grouping_count    = '\0';

  00b8e	32 d2		 xor	 dl, dl

; 946  :             while (!_Bad_grouping && _Groups_arr_idx > 0) {

  00b90	8a 75 9d	 mov	 dh, BYTE PTR __Bad_grouping$1$[ebp]
  00b93	03 f1		 add	 esi, ecx
  00b95	8b 5d 88	 mov	 ebx, DWORD PTR __Groups_arr_idx$1$[ebp]
  00b98	84 f6		 test	 dh, dh
  00b9a	0f 85 06 01 00
	00		 jne	 $LN15@Parse_fp_w
$LL14@Parse_fp_w:
  00ba0	85 db		 test	 ebx, ebx
  00ba2	0f 84 fe 00 00
	00		 je	 $LN15@Parse_fp_w

; 947  :                 if (_Grouping_iter != _Grouping_end) { // keep the last value when _Grouping is exhausted

  00ba8	3b ce		 cmp	 ecx, esi
  00baa	74 02		 je	 SHORT $LN66@Parse_fp_w

; 948  :                     _Current_grouping_count = *_Grouping_iter; // assign the variable at least once

  00bac	8a 11		 mov	 dl, BYTE PTR [ecx]
$LN66@Parse_fp_w:

; 949  :                     ++_Grouping_iter;
; 950  :                 }
; 951  : 
; 952  :                 --_Groups_arr_idx;

  00bae	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00bb1	0f 44 c1	 cmove	 eax, ecx
  00bb4	4b		 dec	 ebx
  00bb5	8b c8		 mov	 ecx, eax

; 954  :                     && ((_Groups_arr_idx > 0 && _Groups[_Groups_arr_idx] != _Current_grouping_count)

  00bb7	84 d2		 test	 dl, dl
  00bb9	7e 40		 jle	 SHORT $LN67@Parse_fp_w
  00bbb	80 fa 7f	 cmp	 dl, 127			; 0000007fH
  00bbe	74 3b		 je	 SHORT $LN67@Parse_fp_w
  00bc0	85 db		 test	 ebx, ebx
  00bc2	74 1e		 je	 SHORT $LN2501@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00bc4	83 bd 74 ff ff
	ff 0f		 cmp	 DWORD PTR __Groups$1$[ebp], 15 ; 0000000fH

; 435  :         value_type* _Result = _Bx._Buf;

  00bcb	8d 45 b8	 lea	 eax, DWORD PTR __Groups$5[ebp]

; 436  :         if (_Large_mode_engaged()) {

  00bce	0f 47 85 70 ff
	ff ff		 cmova	 eax, DWORD PTR __Groups$2$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 954  :                     && ((_Groups_arr_idx > 0 && _Groups[_Groups_arr_idx] != _Current_grouping_count)

  00bd5	38 14 18	 cmp	 BYTE PTR [eax+ebx], dl
  00bd8	0f 85 c4 00 00
	00		 jne	 $LN68@Parse_fp_w
  00bde	85 db		 test	 ebx, ebx
  00be0	75 19		 jne	 SHORT $LN67@Parse_fp_w
$LN2501@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00be2	83 bd 74 ff ff
	ff 0f		 cmp	 DWORD PTR __Groups$1$[ebp], 15 ; 0000000fH

; 435  :         value_type* _Result = _Bx._Buf;

  00be9	8d 45 b8	 lea	 eax, DWORD PTR __Groups$5[ebp]

; 436  :         if (_Large_mode_engaged()) {

  00bec	0f 47 85 70 ff
	ff ff		 cmova	 eax, DWORD PTR __Groups$2$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 954  :                     && ((_Groups_arr_idx > 0 && _Groups[_Groups_arr_idx] != _Current_grouping_count)

  00bf3	38 10		 cmp	 BYTE PTR [eax], dl
  00bf5	0f 8f a7 00 00
	00		 jg	 $LN68@Parse_fp_w
$LN67@Parse_fp_w:

; 946  :             while (!_Bad_grouping && _Groups_arr_idx > 0) {

  00bfb	84 f6		 test	 dh, dh
  00bfd	74 a1		 je	 SHORT $LL14@Parse_fp_w
  00bff	e9 a2 00 00 00	 jmp	 $LN15@Parse_fp_w
$LN2364@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  00c04	85 c0		 test	 eax, eax
  00c06	0f 85 74 ff ff
	ff		 jne	 $LN738@Parse_fp_w
$LN2304@Parse_fp_w:

; 406  :         if (!_Got) {

  00c0c	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  00c10	75 33		 jne	 SHORT $LN2423@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00c12	85 c9		 test	 ecx, ecx
  00c14	74 25		 je	 SHORT $LN798@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00c16	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00c19	8b 10		 mov	 edx, DWORD PTR [eax]
  00c1b	85 d2		 test	 edx, edx
  00c1d	74 0d		 je	 SHORT $LN802@Parse_fp_w
  00c1f	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00c22	83 38 00	 cmp	 DWORD PTR [eax], 0
  00c25	7e 05		 jle	 SHORT $LN802@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00c27	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00c2a	eb 05		 jmp	 SHORT $LN803@Parse_fp_w
$LN802@Parse_fp_w:
  00c2c	8b 01		 mov	 eax, DWORD PTR [ecx]
  00c2e	ff 50 18	 call	 DWORD PTR [eax+24]
$LN803@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00c31	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00c34	74 05		 je	 SHORT $LN798@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00c36	88 47 05	 mov	 BYTE PTR [edi+5], al
  00c39	eb 06		 jmp	 SHORT $LN797@Parse_fp_w
$LN798@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  00c3b	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN797@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00c41	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN2423@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 938  :             while (_First != _Last && *_First == _Kseparator) {

  00c45	38 5f 05	 cmp	 BYTE PTR [edi+5], bl
  00c48	0f 85 32 ff ff
	ff		 jne	 $LN738@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00c4e	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00c50	85 c9		 test	 ecx, ecx
  00c52	74 3b		 je	 SHORT $LN826@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00c54	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00c57	83 38 00	 cmp	 DWORD PTR [eax], 0
  00c5a	74 1b		 je	 SHORT $LN2421@Parse_fp_w
  00c5c	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00c5f	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  00c61	85 c0		 test	 eax, eax
  00c63	7e 12		 jle	 SHORT $LN2421@Parse_fp_w

; 222  :         --*_IGcount;

  00c65	48		 dec	 eax
  00c66	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  00c68	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00c6b	8b 11		 mov	 edx, DWORD PTR [ecx]
  00c6d	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00c70	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00c72	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  00c75	eb 05		 jmp	 SHORT $LN831@Parse_fp_w
$LN2421@Parse_fp_w:
  00c77	8b 01		 mov	 eax, DWORD PTR [ecx]
  00c79	ff 50 1c	 call	 DWORD PTR [eax+28]
$LN831@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00c7c	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00c7f	74 0e		 je	 SHORT $LN826@Parse_fp_w

; 464  :             _Got = false;

  00c81	32 c0		 xor	 al, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 940  :                 _Bad_grouping = true;

  00c83	c6 45 9d 01	 mov	 BYTE PTR __Bad_grouping$1$[ebp], 1
  00c87	88 47 04	 mov	 BYTE PTR [edi+4], al

; 941  :             }

  00c8a	e9 67 fe ff ff	 jmp	 $LL12@Parse_fp_w
$LN826@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 462  :             _Got    = true;

  00c8f	b0 01		 mov	 al, 1
  00c91	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 940  :                 _Bad_grouping = true;

  00c97	88 47 04	 mov	 BYTE PTR [edi+4], al
  00c9a	88 45 9d	 mov	 BYTE PTR __Bad_grouping$1$[ebp], al

; 941  :             }

  00c9d	e9 54 fe ff ff	 jmp	 $LL12@Parse_fp_w
$LN68@Parse_fp_w:

; 955  :                         || (_Groups_arr_idx == 0 && _Groups[_Groups_arr_idx] > _Current_grouping_count))) {
; 956  :                     _Bad_grouping = true; // bad group size, fail

  00ca2	c6 45 9d 01	 mov	 BYTE PTR __Bad_grouping$1$[ebp], 1
$LN15@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1383 :         _Tidy_deallocate();

  00ca6	8d 4d b8	 lea	 ecx, DWORD PTR __Groups$5[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 960  :         }

  00ca9	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1383 :         _Tidy_deallocate();

  00cad	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  00cb2	8b b5 68 ff ff
	ff		 mov	 esi, DWORD PTR __Last$GSCopy$1$[ebp]
$LN1453@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 962  :         if (_Parse_hex && _Seendigit && _Significant == 0) {

  00cb8	8a 5d 9f	 mov	 bl, BYTE PTR __Parse_hex$1$[ebp]
  00cbb	84 db		 test	 bl, bl
  00cbd	74 16		 je	 SHORT $LN70@Parse_fp_w
  00cbf	80 7d 9e 00	 cmp	 BYTE PTR __Seendigit$1$[ebp], 0
  00cc3	74 10		 je	 SHORT $LN70@Parse_fp_w
  00cc5	83 7d 80 00	 cmp	 DWORD PTR __Significant$1$[ebp], 0
  00cc9	75 0a		 jne	 SHORT $LN70@Parse_fp_w

; 963  :             // the condition is true when all of the digits after the 'x' and before the decimal point are zero
; 964  :             *_Ptr++ = '0'; // save at least one leading digit for hex

  00ccb	8b 45 98	 mov	 eax, DWORD PTR __Ptr$1$[ebp]
  00cce	c6 00 30	 mov	 BYTE PTR [eax], 48	; 00000030H
  00cd1	40		 inc	 eax
  00cd2	89 45 98	 mov	 DWORD PTR __Ptr$1$[ebp], eax
$LN70@Parse_fp_w:

; 967  :         const char _Decimal_point = (_CSTD localeconv())->decimal_point[0];

  00cd5	e8 00 00 00 00	 call	 _localeconv
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 437  :         if (!_Got) {

  00cda	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 967  :         const char _Decimal_point = (_CSTD localeconv())->decimal_point[0];

  00cde	8b 00		 mov	 eax, DWORD PTR [eax]
  00ce0	8a 38		 mov	 bh, BYTE PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 437  :         if (!_Got) {

  00ce2	75 35		 jne	 SHORT $LN1081@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00ce4	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00ce6	85 c9		 test	 ecx, ecx
  00ce8	74 25		 je	 SHORT $LN1091@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00cea	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00ced	8b 10		 mov	 edx, DWORD PTR [eax]
  00cef	85 d2		 test	 edx, edx
  00cf1	74 0d		 je	 SHORT $LN1095@Parse_fp_w
  00cf3	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00cf6	83 38 00	 cmp	 DWORD PTR [eax], 0
  00cf9	7e 05		 jle	 SHORT $LN1095@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00cfb	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00cfe	eb 05		 jmp	 SHORT $LN1096@Parse_fp_w
$LN1095@Parse_fp_w:
  00d00	8b 01		 mov	 eax, DWORD PTR [ecx]
  00d02	ff 50 18	 call	 DWORD PTR [eax+24]
$LN1096@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00d05	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00d08	74 05		 je	 SHORT $LN1091@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00d0a	88 47 05	 mov	 BYTE PTR [edi+5], al
  00d0d	eb 06		 jmp	 SHORT $LN1090@Parse_fp_w
$LN1091@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  00d0f	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN1090@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00d15	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN1081@Parse_fp_w:

; 441  :         if (!_Right._Got) {

  00d19	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  00d1d	75 35		 jne	 SHORT $LN1082@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00d1f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00d21	85 c9		 test	 ecx, ecx
  00d23	74 25		 je	 SHORT $LN2311@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00d25	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00d28	8b 10		 mov	 edx, DWORD PTR [eax]
  00d2a	85 d2		 test	 edx, edx
  00d2c	74 0d		 je	 SHORT $LN1121@Parse_fp_w
  00d2e	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00d31	83 38 00	 cmp	 DWORD PTR [eax], 0
  00d34	7e 05		 jle	 SHORT $LN1121@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00d36	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00d39	eb 05		 jmp	 SHORT $LN1122@Parse_fp_w
$LN1121@Parse_fp_w:
  00d3b	8b 01		 mov	 eax, DWORD PTR [ecx]
  00d3d	ff 50 18	 call	 DWORD PTR [eax+24]
$LN1122@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00d40	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00d43	74 05		 je	 SHORT $LN2311@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00d45	88 46 05	 mov	 BYTE PTR [esi+5], al
  00d48	eb 06		 jmp	 SHORT $LN1116@Parse_fp_w
$LN2311@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  00d4a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1116@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00d50	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN1082@Parse_fp_w:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  00d54	83 3f 00	 cmp	 DWORD PTR [edi], 0
  00d57	8b 06		 mov	 eax, DWORD PTR [esi]
  00d59	75 0a		 jne	 SHORT $LN2363@Parse_fp_w
  00d5b	85 c0		 test	 eax, eax
  00d5d	0f 84 a7 00 00
	00		 je	 $LN1706@Parse_fp_w
  00d63	eb 08		 jmp	 SHORT $LN2310@Parse_fp_w
$LN2363@Parse_fp_w:
  00d65	85 c0		 test	 eax, eax
  00d67	0f 85 9d 00 00
	00		 jne	 $LN1706@Parse_fp_w
$LN2310@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 100  :         return do_decimal_point();

  00d6d	8b 4d 90	 mov	 ecx, DWORD PTR __Punct_fac$1$[ebp]
  00d70	8b 01		 mov	 eax, DWORD PTR [ecx]
  00d72	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00d75	ff d0		 call	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 406  :         if (!_Got) {

  00d77	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 100  :         return do_decimal_point();

  00d7b	8a d8		 mov	 bl, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 406  :         if (!_Got) {

  00d7d	75 37		 jne	 SHORT $LN2425@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00d7f	8b 17		 mov	 edx, DWORD PTR [edi]
  00d81	85 d2		 test	 edx, edx
  00d83	74 27		 je	 SHORT $LN1419@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00d85	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  00d88	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00d8a	85 c9		 test	 ecx, ecx
  00d8c	74 0d		 je	 SHORT $LN2426@Parse_fp_w
  00d8e	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00d91	83 38 00	 cmp	 DWORD PTR [eax], 0
  00d94	7e 05		 jle	 SHORT $LN2426@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00d96	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00d99	eb 07		 jmp	 SHORT $LN1424@Parse_fp_w
$LN2426@Parse_fp_w:
  00d9b	8b 02		 mov	 eax, DWORD PTR [edx]
  00d9d	8b ca		 mov	 ecx, edx
  00d9f	ff 50 18	 call	 DWORD PTR [eax+24]
$LN1424@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00da2	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00da5	74 05		 je	 SHORT $LN1419@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00da7	88 47 05	 mov	 BYTE PTR [edi+5], al
  00daa	eb 06		 jmp	 SHORT $LN1418@Parse_fp_w
$LN1419@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  00dac	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN1418@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00db2	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN2425@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 968  :         if (_First != _Last && *_First == _Punct_fac.decimal_point()) { // add .

  00db6	38 5f 05	 cmp	 BYTE PTR [edi+5], bl
  00db9	75 4c		 jne	 SHORT $LN2496@Parse_fp_w

; 969  :             *_Ptr++ = _Decimal_point;

  00dbb	8b 45 98	 mov	 eax, DWORD PTR __Ptr$1$[ebp]
  00dbe	88 38		 mov	 BYTE PTR [eax], bh
  00dc0	40		 inc	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00dc1	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 969  :             *_Ptr++ = _Decimal_point;

  00dc3	89 45 98	 mov	 DWORD PTR __Ptr$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00dc6	85 c9		 test	 ecx, ecx
  00dc8	74 33		 je	 SHORT $LN1707@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00dca	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00dcd	83 38 00	 cmp	 DWORD PTR [eax], 0
  00dd0	74 1b		 je	 SHORT $LN2427@Parse_fp_w
  00dd2	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00dd5	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  00dd7	85 c0		 test	 eax, eax
  00dd9	7e 12		 jle	 SHORT $LN2427@Parse_fp_w

; 222  :         --*_IGcount;

  00ddb	48		 dec	 eax
  00ddc	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  00dde	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00de1	8b 11		 mov	 edx, DWORD PTR [ecx]
  00de3	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00de6	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00de8	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  00deb	eb 05		 jmp	 SHORT $LN1712@Parse_fp_w
$LN2427@Parse_fp_w:
  00ded	8b 01		 mov	 eax, DWORD PTR [ecx]
  00def	ff 50 1c	 call	 DWORD PTR [eax+28]
$LN1712@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00df2	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00df5	74 06		 je	 SHORT $LN1707@Parse_fp_w

; 464  :             _Got = false;

  00df7	c6 47 04 00	 mov	 BYTE PTR [edi+4], 0
  00dfb	eb 0a		 jmp	 SHORT $LN2496@Parse_fp_w
$LN1707@Parse_fp_w:

; 461  :             _Strbuf = nullptr;

  00dfd	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 462  :             _Got    = true;

  00e03	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN2496@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 973  :         if (_Significant == 0) { // 0000. so far

  00e07	8a 5d 9f	 mov	 bl, BYTE PTR __Parse_hex$1$[ebp]
$LN1706@Parse_fp_w:
  00e0a	83 7d 80 00	 cmp	 DWORD PTR __Significant$1$[ebp], 0
  00e0e	0f 85 8c 00 00
	00		 jne	 $LL21@Parse_fp_w
  00e14	8a 5d 97	 mov	 bl, BYTE PTR __Zero_wc$1$[ebp]
$LL18@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 437  :         if (!_Got) {

  00e17	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  00e1b	75 35		 jne	 SHORT $LN938@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00e1d	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00e1f	85 c9		 test	 ecx, ecx
  00e21	74 25		 je	 SHORT $LN948@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00e23	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00e26	8b 10		 mov	 edx, DWORD PTR [eax]
  00e28	85 d2		 test	 edx, edx
  00e2a	74 0d		 je	 SHORT $LN952@Parse_fp_w
  00e2c	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00e2f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00e32	7e 05		 jle	 SHORT $LN952@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00e34	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00e37	eb 05		 jmp	 SHORT $LN953@Parse_fp_w
$LN952@Parse_fp_w:
  00e39	8b 01		 mov	 eax, DWORD PTR [ecx]
  00e3b	ff 50 18	 call	 DWORD PTR [eax+24]
$LN953@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00e3e	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00e41	74 05		 je	 SHORT $LN948@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00e43	88 47 05	 mov	 BYTE PTR [edi+5], al
  00e46	eb 06		 jmp	 SHORT $LN947@Parse_fp_w
$LN948@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  00e48	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN947@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00e4e	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN938@Parse_fp_w:

; 441  :         if (!_Right._Got) {

  00e52	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  00e56	75 35		 jne	 SHORT $LN939@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00e58	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00e5a	85 c9		 test	 ecx, ecx
  00e5c	74 25		 je	 SHORT $LN974@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00e5e	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00e61	8b 10		 mov	 edx, DWORD PTR [eax]
  00e63	85 d2		 test	 edx, edx
  00e65	74 0d		 je	 SHORT $LN978@Parse_fp_w
  00e67	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00e6a	83 38 00	 cmp	 DWORD PTR [eax], 0
  00e6d	7e 05		 jle	 SHORT $LN978@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00e6f	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00e72	eb 05		 jmp	 SHORT $LN979@Parse_fp_w
$LN978@Parse_fp_w:
  00e74	8b 01		 mov	 eax, DWORD PTR [ecx]
  00e76	ff 50 18	 call	 DWORD PTR [eax+24]
$LN979@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00e79	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00e7c	74 05		 je	 SHORT $LN974@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00e7e	88 46 05	 mov	 BYTE PTR [esi+5], al
  00e81	eb 06		 jmp	 SHORT $LN973@Parse_fp_w
$LN974@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  00e83	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN973@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00e89	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN939@Parse_fp_w:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  00e8d	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00e8f	8b 06		 mov	 eax, DWORD PTR [esi]
  00e91	85 c9		 test	 ecx, ecx
  00e93	75 40		 jne	 SHORT $LN2362@Parse_fp_w
  00e95	85 c0		 test	 eax, eax
  00e97	75 40		 jne	 SHORT $LN2315@Parse_fp_w
$LN2493@Parse_fp_w:
  00e99	8a 5d 9f	 mov	 bl, BYTE PTR __Parse_hex$1$[ebp]
  00e9c	0f 1f 40 00	 npad	 4
$LL21@Parse_fp_w:

; 437  :         if (!_Got) {

  00ea0	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  00ea4	0f 85 db 00 00
	00		 jne	 $LN526@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00eaa	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00eac	85 c9		 test	 ecx, ecx
  00eae	0f 84 c7 00 00
	00		 je	 $LN536@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00eb4	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00eb7	8b 10		 mov	 edx, DWORD PTR [eax]
  00eb9	85 d2		 test	 edx, edx
  00ebb	0f 84 ab 00 00
	00		 je	 $LN540@Parse_fp_w
  00ec1	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00ec4	83 38 00	 cmp	 DWORD PTR [eax], 0
  00ec7	0f 8e 9f 00 00
	00		 jle	 $LN540@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00ecd	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00ed0	e9 9c 00 00 00	 jmp	 $LN541@Parse_fp_w
$LN2362@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  00ed5	85 c0		 test	 eax, eax
  00ed7	75 c0		 jne	 SHORT $LN2493@Parse_fp_w
$LN2315@Parse_fp_w:

; 406  :         if (!_Got) {

  00ed9	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  00edd	75 33		 jne	 SHORT $LN2429@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00edf	85 c9		 test	 ecx, ecx
  00ee1	74 25		 je	 SHORT $LN910@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00ee3	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00ee6	8b 10		 mov	 edx, DWORD PTR [eax]
  00ee8	85 d2		 test	 edx, edx
  00eea	74 0d		 je	 SHORT $LN914@Parse_fp_w
  00eec	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00eef	83 38 00	 cmp	 DWORD PTR [eax], 0
  00ef2	7e 05		 jle	 SHORT $LN914@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00ef4	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00ef7	eb 05		 jmp	 SHORT $LN915@Parse_fp_w
$LN914@Parse_fp_w:
  00ef9	8b 01		 mov	 eax, DWORD PTR [ecx]
  00efb	ff 50 18	 call	 DWORD PTR [eax+24]
$LN915@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00efe	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00f01	74 05		 je	 SHORT $LN910@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00f03	88 47 05	 mov	 BYTE PTR [edi+5], al
  00f06	eb 06		 jmp	 SHORT $LN909@Parse_fp_w
$LN910@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  00f08	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN909@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00f0e	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN2429@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 974  :             for (; _First != _Last && *_First == _Zero_wc; _Seendigit = true, (void) ++_First) {

  00f12	38 5f 05	 cmp	 BYTE PTR [edi+5], bl
  00f15	75 82		 jne	 SHORT $LN2493@Parse_fp_w

; 975  :                 --_Power_of_rep_base; // count leading fraction zeros without storing digits into buffer

  00f17	ff 8d 7c ff ff
	ff		 dec	 DWORD PTR __Power_of_rep_base$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00f1d	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 974  :             for (; _First != _Last && *_First == _Zero_wc; _Seendigit = true, (void) ++_First) {

  00f1f	c6 45 9e 01	 mov	 BYTE PTR __Seendigit$1$[ebp], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00f23	85 c9		 test	 ecx, ecx
  00f25	74 36		 je	 SHORT $LN2428@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00f27	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00f2a	83 38 00	 cmp	 DWORD PTR [eax], 0
  00f2d	74 1b		 je	 SHORT $LN1060@Parse_fp_w
  00f2f	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00f32	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  00f34	85 c0		 test	 eax, eax
  00f36	7e 12		 jle	 SHORT $LN1060@Parse_fp_w

; 222  :         --*_IGcount;

  00f38	48		 dec	 eax
  00f39	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  00f3b	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00f3e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00f40	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00f43	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00f45	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  00f48	eb 05		 jmp	 SHORT $LN1061@Parse_fp_w
$LN1060@Parse_fp_w:
  00f4a	8b 01		 mov	 eax, DWORD PTR [ecx]
  00f4c	ff 50 1c	 call	 DWORD PTR [eax+28]
$LN1061@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00f4f	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00f52	74 09		 je	 SHORT $LN2428@Parse_fp_w

; 464  :             _Got = false;

  00f54	c6 47 04 00	 mov	 BYTE PTR [edi+4], 0
  00f58	e9 ba fe ff ff	 jmp	 $LL18@Parse_fp_w
$LN2428@Parse_fp_w:

; 461  :             _Strbuf = nullptr;

  00f5d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 462  :             _Got    = true;

  00f63	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1

; 463  :         } else {

  00f67	e9 ab fe ff ff	 jmp	 $LL18@Parse_fp_w
$LN540@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00f6c	8b 01		 mov	 eax, DWORD PTR [ecx]
  00f6e	ff 50 18	 call	 DWORD PTR [eax+24]
$LN541@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00f71	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00f74	74 05		 je	 SHORT $LN536@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00f76	88 47 05	 mov	 BYTE PTR [edi+5], al
  00f79	eb 06		 jmp	 SHORT $LN535@Parse_fp_w
$LN536@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  00f7b	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN535@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00f81	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN526@Parse_fp_w:

; 441  :         if (!_Right._Got) {

  00f85	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  00f89	75 35		 jne	 SHORT $LN527@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00f8b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00f8d	85 c9		 test	 ecx, ecx
  00f8f	74 25		 je	 SHORT $LN562@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00f91	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00f94	8b 10		 mov	 edx, DWORD PTR [eax]
  00f96	85 d2		 test	 edx, edx
  00f98	74 0d		 je	 SHORT $LN566@Parse_fp_w
  00f9a	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00f9d	83 38 00	 cmp	 DWORD PTR [eax], 0
  00fa0	7e 05		 jle	 SHORT $LN566@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00fa2	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00fa5	eb 05		 jmp	 SHORT $LN567@Parse_fp_w
$LN566@Parse_fp_w:
  00fa7	8b 01		 mov	 eax, DWORD PTR [ecx]
  00fa9	ff 50 18	 call	 DWORD PTR [eax+24]
$LN567@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00fac	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00faf	74 05		 je	 SHORT $LN562@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00fb1	88 46 05	 mov	 BYTE PTR [esi+5], al
  00fb4	eb 06		 jmp	 SHORT $LN561@Parse_fp_w
$LN562@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  00fb6	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN561@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00fbc	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN527@Parse_fp_w:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  00fc0	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00fc2	8b 06		 mov	 eax, DWORD PTR [esi]
  00fc4	85 c9		 test	 ecx, ecx
  00fc6	0f 85 b8 00 00
	00		 jne	 $LN2361@Parse_fp_w
  00fcc	85 c0		 test	 eax, eax
  00fce	0f 85 b8 00 00
	00		 jne	 $LN2317@Parse_fp_w
$LN531@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 989  :         if (_Has_unaccumulated_digits) { // increment last digit in memory of those lost

  00fd4	80 bd 6c ff ff
	ff 00		 cmp	 BYTE PTR tv9647[ebp], 0
  00fdb	74 32		 je	 SHORT $LN77@Parse_fp_w

; 990  :             char& _Last_got_digit = _Ptr[-1] == _Decimal_point ? _Ptr[-2] : _Ptr[-1];

  00fdd	8b 45 98	 mov	 eax, DWORD PTR __Ptr$1$[ebp]
  00fe0	8a 48 ff	 mov	 cl, BYTE PTR [eax-1]
  00fe3	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  00fe6	3a cf		 cmp	 cl, bh
  00fe8	75 06		 jne	 SHORT $LN109@Parse_fp_w
  00fea	8a 48 fe	 mov	 cl, BYTE PTR [eax-2]
  00fed	8d 50 fe	 lea	 edx, DWORD PTR [eax-2]
$LN109@Parse_fp_w:

; 991  :             if (_Last_got_digit == '0' || _Last_got_digit == (_Parse_hex ? '8' : '5')) {

  00ff0	80 f9 30	 cmp	 cl, 48			; 00000030H
  00ff3	74 16		 je	 SHORT $LN78@Parse_fp_w
  00ff5	84 db		 test	 bl, bl
  00ff7	c7 45 90 38 00
	00 00		 mov	 DWORD PTR tv9654[ebp], 56 ; 00000038H
  00ffe	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  01003	0f 45 45 90	 cmovne	 eax, DWORD PTR tv9654[ebp]
  01007	3a c8		 cmp	 cl, al
  01009	75 04		 jne	 SHORT $LN77@Parse_fp_w
$LN78@Parse_fp_w:

; 992  :                 ++_Last_got_digit;

  0100b	fe c1		 inc	 cl
  0100d	88 0a		 mov	 BYTE PTR [edx], cl
$LN77@Parse_fp_w:

; 993  :             }
; 994  :         }
; 995  : 
; 996  :         const _Elem _Lower_exp_wc = _Atoms[_Parse_hex ? _Offset_lower_p : _Offset_lower_e]; // 'e' for dec, 'p' for hex

  0100f	84 db		 test	 bl, bl

; 997  :         const _Elem _Upper_exp_wc = _Atoms[_Parse_hex ? _Offset_upper_p : _Offset_upper_e]; // 'E' for dec, 'P' for hex
; 998  : 
; 999  :         bool _Exponent_part_negative = false;

  01011	c6 45 9c 00	 mov	 BYTE PTR __Exponent_part_negative$1$[ebp], 0
  01015	b9 1b 00 00 00	 mov	 ecx, 27			; 0000001bH
  0101a	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0101f	0f 45 c1	 cmovne	 eax, ecx
  01022	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH
  01027	8a 44 05 d0	 mov	 al, BYTE PTR __Atoms$[ebp+eax]
  0102b	88 85 7b ff ff
	ff		 mov	 BYTE PTR __Lower_exp_wc$1$[ebp], al
  01031	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
  01036	0f 45 c1	 cmovne	 eax, ecx

; 1000 :         ptrdiff_t _Exponent_part     = 0;

  01039	33 db		 xor	 ebx, ebx
  0103b	89 5d 90	 mov	 DWORD PTR __Exponent_part$1$[ebp], ebx
  0103e	8a 44 05 d0	 mov	 al, BYTE PTR __Atoms$[ebp+eax]
  01042	88 85 7a ff ff
	ff		 mov	 BYTE PTR __Upper_exp_wc$1$[ebp], al

; 1002 :             && (*_First == _Lower_exp_wc || *_First == _Upper_exp_wc)) { // collect exponent

  01048	38 5d 9e	 cmp	 BYTE PTR __Seendigit$1$[ebp], bl
  0104b	0f 84 07 08 00
	00		 je	 $LN2360@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 437  :         if (!_Got) {

  01051	38 5f 04	 cmp	 BYTE PTR [edi+4], bl
  01054	0f 85 29 01 00
	00		 jne	 $LN437@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0105a	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0105c	85 c9		 test	 ecx, ecx
  0105e	0f 84 19 01 00
	00		 je	 $LN447@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  01064	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  01067	8b 10		 mov	 edx, DWORD PTR [eax]
  01069	85 d2		 test	 edx, edx
  0106b	0f 84 fd 00 00
	00		 je	 $LN451@Parse_fp_w
  01071	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  01074	39 18		 cmp	 DWORD PTR [eax], ebx
  01076	0f 8e f2 00 00
	00		 jle	 $LN451@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0107c	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0107f	e9 ef 00 00 00	 jmp	 $LN452@Parse_fp_w
$LN2361@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  01084	85 c0		 test	 eax, eax
  01086	0f 85 48 ff ff
	ff		 jne	 $LN531@Parse_fp_w
$LN2317@Parse_fp_w:

; 406  :         if (!_Got) {

  0108c	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  01090	75 33		 jne	 SHORT $LN2431@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  01092	85 c9		 test	 ecx, ecx
  01094	74 25		 je	 SHORT $LN345@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  01096	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  01099	8b 10		 mov	 edx, DWORD PTR [eax]
  0109b	85 d2		 test	 edx, edx
  0109d	74 0d		 je	 SHORT $LN349@Parse_fp_w
  0109f	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  010a2	83 38 00	 cmp	 DWORD PTR [eax], 0
  010a5	7e 05		 jle	 SHORT $LN349@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  010a7	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  010aa	eb 05		 jmp	 SHORT $LN350@Parse_fp_w
$LN349@Parse_fp_w:
  010ac	8b 01		 mov	 eax, DWORD PTR [ecx]
  010ae	ff 50 18	 call	 DWORD PTR [eax+24]
$LN350@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  010b1	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  010b4	74 05		 je	 SHORT $LN345@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  010b6	88 47 05	 mov	 BYTE PTR [edi+5], al
  010b9	eb 06		 jmp	 SHORT $LN344@Parse_fp_w
$LN345@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  010bb	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN344@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  010c1	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN2431@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 6127 :             const auto _Result    = _STD _Find_vectorized(_First_ptr, _STD _To_address(_Last), _Val);

  010c5	8a 47 05	 mov	 al, BYTE PTR [edi+5]
  010c8	88 45 90	 mov	 BYTE PTR $T3[ebp], al

; 200  :         return const_cast<_Ty*>(

  010cb	8d 45 ec	 lea	 eax, DWORD PTR __Atoms$[ebp+28]
  010ce	ff 75 90	 push	 DWORD PTR $T3[ebp]
  010d1	50		 push	 eax
  010d2	8d 45 d0	 lea	 eax, DWORD PTR __Atoms$[ebp]
  010d5	50		 push	 eax
  010d6	e8 00 00 00 00	 call	 ___std_find_trivial_1@12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 70   :     return static_cast<size_t>(_STD _Find_unchecked(_Base, _Base + (_Base_size - 1), _Ch) - _Base);

  010db	8d 4d d0	 lea	 ecx, DWORD PTR __Atoms$[ebp]
  010de	2b c1		 sub	 eax, ecx

; 976  :             }
; 977  :         }
; 978  : 
; 979  :         for (size_t _Idx; _First != _Last && (_Idx = _STD _Find_elem(_Atoms, *_First)) < _Offset_digit_end;

  010e0	3b 45 84	 cmp	 eax, DWORD PTR __Offset_digit_end$1$[ebp]
  010e3	0f 83 eb fe ff
	ff		 jae	 $LN531@Parse_fp_w

; 981  :             if (_Significant < _Max_sig_dig) { // save a significant fraction digit

  010e9	8b 4d 80	 mov	 ecx, DWORD PTR __Significant$1$[ebp]
  010ec	3b 4d 0c	 cmp	 ecx, DWORD PTR __Max_sig_dig$[ebp]
  010ef	7d 15		 jge	 SHORT $LN73@Parse_fp_w

; 982  :                 *_Ptr++ = _Src[_Idx];

  010f1	8b 55 98	 mov	 edx, DWORD PTR __Ptr$1$[ebp]
  010f4	8a 80 00 00 00
	00		 mov	 al, BYTE PTR ?_Src@?1???$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z@4QBDB[eax]
  010fa	88 02		 mov	 BYTE PTR [edx], al
  010fc	42		 inc	 edx

; 983  :                 ++_Significant;

  010fd	41		 inc	 ecx
  010fe	89 55 98	 mov	 DWORD PTR __Ptr$1$[ebp], edx
  01101	89 4d 80	 mov	 DWORD PTR __Significant$1$[ebp], ecx
  01104	eb 19		 jmp	 SHORT $LN19@Parse_fp_w
$LN73@Parse_fp_w:

; 984  :             } else if (_Idx > 0) {

  01106	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv9647[ebp]
  0110c	85 c0		 test	 eax, eax
  0110e	0f b6 c9	 movzx	 ecx, cl
  01111	b8 01 00 00 00	 mov	 eax, 1
  01116	0f 45 c8	 cmovne	 ecx, eax
  01119	89 8d 6c ff ff
	ff		 mov	 DWORD PTR tv9647[ebp], ecx
$LN19@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  0111f	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 980  :             _Seendigit = true, (void) ++_First) {

  01121	c6 45 9e 01	 mov	 BYTE PTR __Seendigit$1$[ebp], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  01125	85 c9		 test	 ecx, ecx
  01127	74 36		 je	 SHORT $LN590@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  01129	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0112c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0112f	74 1b		 je	 SHORT $LN2430@Parse_fp_w
  01131	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  01134	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  01136	85 c0		 test	 eax, eax
  01138	7e 12		 jle	 SHORT $LN2430@Parse_fp_w

; 222  :         --*_IGcount;

  0113a	48		 dec	 eax
  0113b	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  0113d	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  01140	8b 11		 mov	 edx, DWORD PTR [ecx]
  01142	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  01145	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  01147	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  0114a	eb 05		 jmp	 SHORT $LN595@Parse_fp_w
$LN2430@Parse_fp_w:
  0114c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0114e	ff 50 1c	 call	 DWORD PTR [eax+28]
$LN595@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  01151	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  01154	74 09		 je	 SHORT $LN590@Parse_fp_w

; 464  :             _Got = false;

  01156	c6 47 04 00	 mov	 BYTE PTR [edi+4], 0
  0115a	e9 41 fd ff ff	 jmp	 $LL21@Parse_fp_w
$LN590@Parse_fp_w:

; 461  :             _Strbuf = nullptr;

  0115f	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 462  :             _Got    = true;

  01165	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1

; 463  :         } else {

  01169	e9 32 fd ff ff	 jmp	 $LL21@Parse_fp_w
$LN451@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0116e	8b 01		 mov	 eax, DWORD PTR [ecx]
  01170	ff 50 18	 call	 DWORD PTR [eax+24]
$LN452@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  01173	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  01176	74 05		 je	 SHORT $LN447@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  01178	88 47 05	 mov	 BYTE PTR [edi+5], al
  0117b	eb 02		 jmp	 SHORT $LN446@Parse_fp_w
$LN447@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  0117d	89 1f		 mov	 DWORD PTR [edi], ebx
$LN446@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  0117f	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN437@Parse_fp_w:

; 441  :         if (!_Right._Got) {

  01183	38 5e 04	 cmp	 BYTE PTR [esi+4], bl
  01186	75 30		 jne	 SHORT $LN438@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  01188	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0118a	85 c9		 test	 ecx, ecx
  0118c	74 24		 je	 SHORT $LN473@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  0118e	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  01191	8b 10		 mov	 edx, DWORD PTR [eax]
  01193	85 d2		 test	 edx, edx
  01195	74 0c		 je	 SHORT $LN477@Parse_fp_w
  01197	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0119a	39 18		 cmp	 DWORD PTR [eax], ebx
  0119c	7e 05		 jle	 SHORT $LN477@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0119e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  011a1	eb 05		 jmp	 SHORT $LN478@Parse_fp_w
$LN477@Parse_fp_w:
  011a3	8b 01		 mov	 eax, DWORD PTR [ecx]
  011a5	ff 50 18	 call	 DWORD PTR [eax+24]
$LN478@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  011a8	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  011ab	74 05		 je	 SHORT $LN473@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  011ad	88 46 05	 mov	 BYTE PTR [esi+5], al
  011b0	eb 02		 jmp	 SHORT $LN472@Parse_fp_w
$LN473@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  011b2	89 1e		 mov	 DWORD PTR [esi], ebx
$LN472@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  011b4	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN438@Parse_fp_w:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  011b8	8b 0f		 mov	 ecx, DWORD PTR [edi]
  011ba	8b 06		 mov	 eax, DWORD PTR [esi]
  011bc	85 c9		 test	 ecx, ecx
  011be	75 0a		 jne	 SHORT $LN2359@Parse_fp_w
  011c0	85 c0		 test	 eax, eax
  011c2	0f 84 1d 04 00
	00		 je	 $LN89@Parse_fp_w
  011c8	eb 08		 jmp	 SHORT $LN2321@Parse_fp_w
$LN2359@Parse_fp_w:
  011ca	85 c0		 test	 eax, eax
  011cc	0f 85 13 04 00
	00		 jne	 $LN89@Parse_fp_w
$LN2321@Parse_fp_w:

; 406  :         if (!_Got) {

  011d2	8a 57 04	 mov	 dl, BYTE PTR [edi+4]
  011d5	84 d2		 test	 dl, dl
  011d7	75 30		 jne	 SHORT $LN611@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  011d9	85 c9		 test	 ecx, ecx
  011db	74 24		 je	 SHORT $LN616@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  011dd	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  011e0	8b 10		 mov	 edx, DWORD PTR [eax]
  011e2	85 d2		 test	 edx, edx
  011e4	74 0c		 je	 SHORT $LN620@Parse_fp_w
  011e6	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  011e9	39 18		 cmp	 DWORD PTR [eax], ebx
  011eb	7e 05		 jle	 SHORT $LN620@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  011ed	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  011f0	eb 05		 jmp	 SHORT $LN621@Parse_fp_w
$LN620@Parse_fp_w:
  011f2	8b 01		 mov	 eax, DWORD PTR [ecx]
  011f4	ff 50 18	 call	 DWORD PTR [eax+24]
$LN621@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  011f7	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  011fa	74 05		 je	 SHORT $LN616@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  011fc	88 47 05	 mov	 BYTE PTR [edi+5], al
  011ff	eb 02		 jmp	 SHORT $LN615@Parse_fp_w
$LN616@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  01201	89 1f		 mov	 DWORD PTR [edi], ebx
$LN615@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  01203	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
  01207	b2 01		 mov	 dl, 1
$LN611@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1002 :             && (*_First == _Lower_exp_wc || *_First == _Upper_exp_wc)) { // collect exponent

  01209	8a 47 05	 mov	 al, BYTE PTR [edi+5]
  0120c	3a 85 7b ff ff
	ff		 cmp	 al, BYTE PTR __Lower_exp_wc$1$[ebp]
  01212	74 43		 je	 SHORT $LN80@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 406  :         if (!_Got) {

  01214	84 d2		 test	 dl, dl
  01216	75 33		 jne	 SHORT $LN847@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  01218	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0121a	85 c9		 test	 ecx, ecx
  0121c	74 24		 je	 SHORT $LN2432@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  0121e	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  01221	8b 10		 mov	 edx, DWORD PTR [eax]
  01223	85 d2		 test	 edx, edx
  01225	74 0c		 je	 SHORT $LN856@Parse_fp_w
  01227	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0122a	39 18		 cmp	 DWORD PTR [eax], ebx
  0122c	7e 05		 jle	 SHORT $LN856@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0122e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  01231	eb 05		 jmp	 SHORT $LN857@Parse_fp_w
$LN856@Parse_fp_w:
  01233	8b 01		 mov	 eax, DWORD PTR [ecx]
  01235	ff 50 18	 call	 DWORD PTR [eax+24]
$LN857@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  01238	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0123b	74 05		 je	 SHORT $LN2432@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  0123d	88 47 05	 mov	 BYTE PTR [edi+5], al
  01240	eb 05		 jmp	 SHORT $LN851@Parse_fp_w
$LN2432@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  01242	8a 47 05	 mov	 al, BYTE PTR [edi+5]
  01245	89 1f		 mov	 DWORD PTR [edi], ebx
$LN851@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  01247	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN847@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1002 :             && (*_First == _Lower_exp_wc || *_First == _Upper_exp_wc)) { // collect exponent

  0124b	3a 85 7a ff ff
	ff		 cmp	 al, BYTE PTR __Upper_exp_wc$1$[ebp]
  01251	0f 85 8e 03 00
	00		 jne	 $LN89@Parse_fp_w
$LN80@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  01257	8b 0f		 mov	 ecx, DWORD PTR [edi]
  01259	85 c9		 test	 ecx, ecx
  0125b	74 5e		 je	 SHORT $LN708@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  0125d	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  01260	39 18		 cmp	 DWORD PTR [eax], ebx
  01262	74 1b		 je	 SHORT $LN712@Parse_fp_w
  01264	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  01267	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  01269	85 c0		 test	 eax, eax
  0126b	7e 12		 jle	 SHORT $LN712@Parse_fp_w

; 222  :         --*_IGcount;

  0126d	48		 dec	 eax
  0126e	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  01270	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  01273	8b 11		 mov	 edx, DWORD PTR [ecx]
  01275	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  01278	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0127a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  0127d	eb 05		 jmp	 SHORT $LN713@Parse_fp_w
$LN712@Parse_fp_w:
  0127f	8b 01		 mov	 eax, DWORD PTR [ecx]
  01281	ff 50 1c	 call	 DWORD PTR [eax+28]
$LN713@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  01284	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  01287	74 32		 je	 SHORT $LN708@Parse_fp_w

; 464  :             _Got = false;

  01289	88 5f 04	 mov	 BYTE PTR [edi+4], bl
  0128c	32 c0		 xor	 al, al

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0128e	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 464  :             _Got = false;

  01290	88 45 9e	 mov	 BYTE PTR __Seendigit$3$[ebp], al

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  01293	85 c9		 test	 ecx, ecx
  01295	74 29		 je	 SHORT $LN654@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  01297	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0129a	8b 10		 mov	 edx, DWORD PTR [eax]
  0129c	85 d2		 test	 edx, edx
  0129e	74 0c		 je	 SHORT $LN658@Parse_fp_w
  012a0	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  012a3	39 18		 cmp	 DWORD PTR [eax], ebx
  012a5	7e 05		 jle	 SHORT $LN658@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  012a7	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  012aa	eb 05		 jmp	 SHORT $LN659@Parse_fp_w
$LN658@Parse_fp_w:
  012ac	8b 01		 mov	 eax, DWORD PTR [ecx]
  012ae	ff 50 18	 call	 DWORD PTR [eax+24]
$LN659@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  012b1	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  012b4	74 0a		 je	 SHORT $LN654@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  012b6	88 47 05	 mov	 BYTE PTR [edi+5], al
  012b9	eb 07		 jmp	 SHORT $LN653@Parse_fp_w
$LN708@Parse_fp_w:

; 462  :             _Got    = true;

  012bb	32 c0		 xor	 al, al
  012bd	88 45 9e	 mov	 BYTE PTR __Seendigit$3$[ebp], al
$LN654@Parse_fp_w:

; 441  :         if (!_Right._Got) {

  012c0	89 1f		 mov	 DWORD PTR [edi], ebx
$LN653@Parse_fp_w:
  012c2	b0 01		 mov	 al, 1
  012c4	88 47 04	 mov	 BYTE PTR [edi+4], al
  012c7	38 5e 04	 cmp	 BYTE PTR [esi+4], bl
  012ca	75 30		 jne	 SHORT $LN645@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  012cc	8b 0e		 mov	 ecx, DWORD PTR [esi]
  012ce	85 c9		 test	 ecx, ecx
  012d0	74 24		 je	 SHORT $LN2326@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  012d2	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  012d5	8b 10		 mov	 edx, DWORD PTR [eax]
  012d7	85 d2		 test	 edx, edx
  012d9	74 0c		 je	 SHORT $LN684@Parse_fp_w
  012db	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  012de	39 18		 cmp	 DWORD PTR [eax], ebx
  012e0	7e 05		 jle	 SHORT $LN684@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  012e2	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  012e5	eb 05		 jmp	 SHORT $LN685@Parse_fp_w
$LN684@Parse_fp_w:
  012e7	8b 01		 mov	 eax, DWORD PTR [ecx]
  012e9	ff 50 18	 call	 DWORD PTR [eax+24]
$LN685@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  012ec	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  012ef	74 05		 je	 SHORT $LN2326@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  012f1	88 46 05	 mov	 BYTE PTR [esi+5], al
  012f4	eb 02		 jmp	 SHORT $LN679@Parse_fp_w
$LN2326@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  012f6	89 1e		 mov	 DWORD PTR [esi], ebx
$LN679@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  012f8	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN645@Parse_fp_w:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  012fc	8b 0f		 mov	 ecx, DWORD PTR [edi]
  012fe	8b 06		 mov	 eax, DWORD PTR [esi]
  01300	85 c9		 test	 ecx, ecx
  01302	75 0a		 jne	 SHORT $LN2358@Parse_fp_w
  01304	85 c0		 test	 eax, eax
  01306	0f 84 0b 01 00
	00		 je	 $LN2403@Parse_fp_w
  0130c	eb 08		 jmp	 SHORT $LN2324@Parse_fp_w
$LN2358@Parse_fp_w:
  0130e	85 c0		 test	 eax, eax
  01310	0f 85 01 01 00
	00		 jne	 $LN2403@Parse_fp_w
$LN2324@Parse_fp_w:

; 406  :         if (!_Got) {

  01316	8a 57 04	 mov	 dl, BYTE PTR [edi+4]
  01319	84 d2		 test	 dl, dl
  0131b	75 30		 jne	 SHORT $LN876@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0131d	85 c9		 test	 ecx, ecx
  0131f	74 24		 je	 SHORT $LN881@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  01321	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  01324	8b 10		 mov	 edx, DWORD PTR [eax]
  01326	85 d2		 test	 edx, edx
  01328	74 0c		 je	 SHORT $LN885@Parse_fp_w
  0132a	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0132d	39 18		 cmp	 DWORD PTR [eax], ebx
  0132f	7e 05		 jle	 SHORT $LN885@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  01331	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  01334	eb 05		 jmp	 SHORT $LN886@Parse_fp_w
$LN885@Parse_fp_w:
  01336	8b 01		 mov	 eax, DWORD PTR [ecx]
  01338	ff 50 18	 call	 DWORD PTR [eax+24]
$LN886@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  0133b	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0133e	74 05		 je	 SHORT $LN881@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  01340	88 47 05	 mov	 BYTE PTR [edi+5], al
  01343	eb 02		 jmp	 SHORT $LN880@Parse_fp_w
$LN881@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  01345	89 1f		 mov	 DWORD PTR [edi], ebx
$LN880@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  01347	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
  0134b	b2 01		 mov	 dl, 1
$LN876@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1008 :                 if (*_First == _Positive_sign) { // gather plus sign

  0134d	8a 47 05	 mov	 al, BYTE PTR [edi+5]
  01350	3a 45 8f	 cmp	 al, BYTE PTR __Positive_sign$1$[ebp]
  01353	75 45		 jne	 SHORT $LN82@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  01355	8b 0f		 mov	 ecx, DWORD PTR [edi]
  01357	85 c9		 test	 ecx, ecx
  01359	74 36		 je	 SHORT $LN1002@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  0135b	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0135e	39 18		 cmp	 DWORD PTR [eax], ebx
  01360	74 1b		 je	 SHORT $LN2434@Parse_fp_w
  01362	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  01365	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  01367	85 c0		 test	 eax, eax
  01369	7e 12		 jle	 SHORT $LN2434@Parse_fp_w

; 222  :         --*_IGcount;

  0136b	48		 dec	 eax
  0136c	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  0136e	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  01371	8b 11		 mov	 edx, DWORD PTR [ecx]
  01373	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  01376	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  01378	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  0137b	eb 05		 jmp	 SHORT $LN1007@Parse_fp_w
$LN2434@Parse_fp_w:
  0137d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0137f	ff 50 1c	 call	 DWORD PTR [eax+28]
$LN1007@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  01382	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  01385	74 0a		 je	 SHORT $LN1002@Parse_fp_w

; 464  :             _Got = false;

  01387	32 c0		 xor	 al, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1010 :                 } else if (*_First == _Negative_sign) { // gather minus sign

  01389	88 47 04	 mov	 BYTE PTR [edi+4], al
  0138c	e9 86 00 00 00	 jmp	 $LN2403@Parse_fp_w
$LN1002@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 462  :             _Got    = true;

  01391	b0 01		 mov	 al, 1
  01393	89 1f		 mov	 DWORD PTR [edi], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1010 :                 } else if (*_First == _Negative_sign) { // gather minus sign

  01395	88 47 04	 mov	 BYTE PTR [edi+4], al
  01398	eb 7d		 jmp	 SHORT $LN2403@Parse_fp_w
$LN82@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 406  :         if (!_Got) {

  0139a	84 d2		 test	 dl, dl
  0139c	75 33		 jne	 SHORT $LN1023@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0139e	8b 0f		 mov	 ecx, DWORD PTR [edi]
  013a0	85 c9		 test	 ecx, ecx
  013a2	74 24		 je	 SHORT $LN2433@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  013a4	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  013a7	8b 10		 mov	 edx, DWORD PTR [eax]
  013a9	85 d2		 test	 edx, edx
  013ab	74 0c		 je	 SHORT $LN1032@Parse_fp_w
  013ad	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  013b0	39 18		 cmp	 DWORD PTR [eax], ebx
  013b2	7e 05		 jle	 SHORT $LN1032@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  013b4	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  013b7	eb 05		 jmp	 SHORT $LN1033@Parse_fp_w
$LN1032@Parse_fp_w:
  013b9	8b 01		 mov	 eax, DWORD PTR [ecx]
  013bb	ff 50 18	 call	 DWORD PTR [eax+24]
$LN1033@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  013be	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  013c1	74 05		 je	 SHORT $LN2433@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  013c3	88 47 05	 mov	 BYTE PTR [edi+5], al
  013c6	eb 05		 jmp	 SHORT $LN1027@Parse_fp_w
$LN2433@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  013c8	8a 47 05	 mov	 al, BYTE PTR [edi+5]
  013cb	89 1f		 mov	 DWORD PTR [edi], ebx
$LN1027@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  013cd	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN1023@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1010 :                 } else if (*_First == _Negative_sign) { // gather minus sign

  013d1	3a 45 8e	 cmp	 al, BYTE PTR __Negative_sign$1$[ebp]
  013d4	75 41		 jne	 SHORT $LN2403@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  013d6	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1011 :                     _Exponent_part_negative = true;

  013d8	c6 45 9c 01	 mov	 BYTE PTR __Exponent_part_negative$1$[ebp], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  013dc	85 c9		 test	 ecx, ecx
  013de	74 31		 je	 SHORT $LN1263@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  013e0	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  013e3	39 18		 cmp	 DWORD PTR [eax], ebx
  013e5	74 1b		 je	 SHORT $LN1267@Parse_fp_w
  013e7	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  013ea	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  013ec	85 c0		 test	 eax, eax
  013ee	7e 12		 jle	 SHORT $LN1267@Parse_fp_w

; 222  :         --*_IGcount;

  013f0	48		 dec	 eax
  013f1	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  013f3	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  013f6	8b 11		 mov	 edx, DWORD PTR [ecx]
  013f8	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  013fb	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  013fd	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  01400	eb 05		 jmp	 SHORT $LN1268@Parse_fp_w
$LN1267@Parse_fp_w:
  01402	8b 01		 mov	 eax, DWORD PTR [ecx]
  01404	ff 50 1c	 call	 DWORD PTR [eax+28]
$LN1268@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  01407	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  0140a	74 05		 je	 SHORT $LN1263@Parse_fp_w

; 464  :             _Got = false;

  0140c	88 5f 04	 mov	 BYTE PTR [edi+4], bl
  0140f	eb 06		 jmp	 SHORT $LN2403@Parse_fp_w
$LN1263@Parse_fp_w:

; 461  :             _Strbuf = nullptr;

  01411	89 1f		 mov	 DWORD PTR [edi], ebx

; 462  :             _Got    = true;

  01413	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN2403@Parse_fp_w:
  01417	8a 5d 97	 mov	 bl, BYTE PTR __Zero_wc$1$[ebp]
  0141a	66 0f 1f 44 00
	00		 npad	 6
$LL24@Parse_fp_w:

; 437  :         if (!_Got) {

  01420	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  01424	75 35		 jne	 SHORT $LN373@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  01426	8b 0f		 mov	 ecx, DWORD PTR [edi]
  01428	85 c9		 test	 ecx, ecx
  0142a	74 25		 je	 SHORT $LN383@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  0142c	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0142f	8b 10		 mov	 edx, DWORD PTR [eax]
  01431	85 d2		 test	 edx, edx
  01433	74 0d		 je	 SHORT $LN387@Parse_fp_w
  01435	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  01438	83 38 00	 cmp	 DWORD PTR [eax], 0
  0143b	7e 05		 jle	 SHORT $LN387@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0143d	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  01440	eb 05		 jmp	 SHORT $LN388@Parse_fp_w
$LN387@Parse_fp_w:
  01442	8b 01		 mov	 eax, DWORD PTR [ecx]
  01444	ff 50 18	 call	 DWORD PTR [eax+24]
$LN388@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  01447	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0144a	74 05		 je	 SHORT $LN383@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  0144c	88 47 05	 mov	 BYTE PTR [edi+5], al
  0144f	eb 06		 jmp	 SHORT $LN382@Parse_fp_w
$LN383@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  01451	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN382@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  01457	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN373@Parse_fp_w:

; 441  :         if (!_Right._Got) {

  0145b	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  0145f	75 35		 jne	 SHORT $LN374@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  01461	8b 0e		 mov	 ecx, DWORD PTR [esi]
  01463	85 c9		 test	 ecx, ecx
  01465	74 25		 je	 SHORT $LN2330@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  01467	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0146a	8b 10		 mov	 edx, DWORD PTR [eax]
  0146c	85 d2		 test	 edx, edx
  0146e	74 0d		 je	 SHORT $LN413@Parse_fp_w
  01470	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  01473	83 38 00	 cmp	 DWORD PTR [eax], 0
  01476	7e 05		 jle	 SHORT $LN413@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  01478	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0147b	eb 05		 jmp	 SHORT $LN414@Parse_fp_w
$LN413@Parse_fp_w:
  0147d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0147f	ff 50 18	 call	 DWORD PTR [eax+24]
$LN414@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  01482	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  01485	74 05		 je	 SHORT $LN2330@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  01487	88 46 05	 mov	 BYTE PTR [esi+5], al
  0148a	eb 06		 jmp	 SHORT $LN408@Parse_fp_w
$LN2330@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  0148c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN408@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  01492	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN374@Parse_fp_w:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  01496	8b 0f		 mov	 ecx, DWORD PTR [edi]
  01498	8b 06		 mov	 eax, DWORD PTR [esi]
  0149a	85 c9		 test	 ecx, ecx
  0149c	75 3c		 jne	 SHORT $LN2357@Parse_fp_w
  0149e	85 c0		 test	 eax, eax
  014a0	75 3c		 jne	 SHORT $LN2329@Parse_fp_w
$LN378@Parse_fp_w:
  014a2	8b 5d 90	 mov	 ebx, DWORD PTR __Exponent_part$1$[ebp]
$LL27@Parse_fp_w:

; 437  :         if (!_Got) {

  014a5	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  014a9	0f 85 d5 00 00
	00		 jne	 $LN214@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  014af	8b 0f		 mov	 ecx, DWORD PTR [edi]
  014b1	85 c9		 test	 ecx, ecx
  014b3	0f 84 c1 00 00
	00		 je	 $LN224@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  014b9	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  014bc	8b 10		 mov	 edx, DWORD PTR [eax]
  014be	85 d2		 test	 edx, edx
  014c0	0f 84 a5 00 00
	00		 je	 $LN228@Parse_fp_w
  014c6	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  014c9	83 38 00	 cmp	 DWORD PTR [eax], 0
  014cc	0f 8e 99 00 00
	00		 jle	 $LN228@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  014d2	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  014d5	e9 96 00 00 00	 jmp	 $LN229@Parse_fp_w
$LN2357@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  014da	85 c0		 test	 eax, eax
  014dc	75 c4		 jne	 SHORT $LN378@Parse_fp_w
$LN2329@Parse_fp_w:

; 406  :         if (!_Got) {

  014de	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  014e2	75 33		 jne	 SHORT $LN2436@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  014e4	85 c9		 test	 ecx, ecx
  014e6	74 25		 je	 SHORT $LN304@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  014e8	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  014eb	8b 10		 mov	 edx, DWORD PTR [eax]
  014ed	85 d2		 test	 edx, edx
  014ef	74 0d		 je	 SHORT $LN308@Parse_fp_w
  014f1	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  014f4	83 38 00	 cmp	 DWORD PTR [eax], 0
  014f7	7e 05		 jle	 SHORT $LN308@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  014f9	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  014fc	eb 05		 jmp	 SHORT $LN309@Parse_fp_w
$LN308@Parse_fp_w:
  014fe	8b 01		 mov	 eax, DWORD PTR [ecx]
  01500	ff 50 18	 call	 DWORD PTR [eax+24]
$LN309@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  01503	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  01506	74 05		 je	 SHORT $LN304@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  01508	88 47 05	 mov	 BYTE PTR [edi+5], al
  0150b	eb 06		 jmp	 SHORT $LN303@Parse_fp_w
$LN304@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  0150d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN303@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  01513	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN2436@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1016 :             for (; _First != _Last && *_First == _Zero_wc; ++_First) { // strip leading zeros

  01517	38 5f 05	 cmp	 BYTE PTR [edi+5], bl
  0151a	75 86		 jne	 SHORT $LN378@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  0151c	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1017 :                 _Seendigit = true;

  0151e	c6 45 9e 01	 mov	 BYTE PTR __Seendigit$3$[ebp], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  01522	85 c9		 test	 ecx, ecx
  01524	74 36		 je	 SHORT $LN2435@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  01526	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  01529	83 38 00	 cmp	 DWORD PTR [eax], 0
  0152c	74 1b		 je	 SHORT $LN505@Parse_fp_w
  0152e	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  01531	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  01533	85 c0		 test	 eax, eax
  01535	7e 12		 jle	 SHORT $LN505@Parse_fp_w

; 222  :         --*_IGcount;

  01537	48		 dec	 eax
  01538	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  0153a	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  0153d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0153f	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  01542	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  01544	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  01547	eb 05		 jmp	 SHORT $LN506@Parse_fp_w
$LN505@Parse_fp_w:
  01549	8b 01		 mov	 eax, DWORD PTR [ecx]
  0154b	ff 50 1c	 call	 DWORD PTR [eax+28]
$LN506@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  0154e	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  01551	74 09		 je	 SHORT $LN2435@Parse_fp_w

; 464  :             _Got = false;

  01553	c6 47 04 00	 mov	 BYTE PTR [edi+4], 0
  01557	e9 c4 fe ff ff	 jmp	 $LL24@Parse_fp_w
$LN2435@Parse_fp_w:

; 461  :             _Strbuf = nullptr;

  0155c	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 462  :             _Got    = true;

  01562	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1

; 463  :         } else {

  01566	e9 b5 fe ff ff	 jmp	 $LL24@Parse_fp_w
$LN228@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0156b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0156d	ff 50 18	 call	 DWORD PTR [eax+24]
$LN229@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  01570	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  01573	74 05		 je	 SHORT $LN224@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  01575	88 47 05	 mov	 BYTE PTR [edi+5], al
  01578	eb 06		 jmp	 SHORT $LN223@Parse_fp_w
$LN224@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  0157a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN223@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  01580	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN214@Parse_fp_w:

; 441  :         if (!_Right._Got) {

  01584	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  01588	75 35		 jne	 SHORT $LN215@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0158a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0158c	85 c9		 test	 ecx, ecx
  0158e	74 25		 je	 SHORT $LN250@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  01590	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  01593	8b 10		 mov	 edx, DWORD PTR [eax]
  01595	85 d2		 test	 edx, edx
  01597	74 0d		 je	 SHORT $LN254@Parse_fp_w
  01599	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0159c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0159f	7e 05		 jle	 SHORT $LN254@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  015a1	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  015a4	eb 05		 jmp	 SHORT $LN255@Parse_fp_w
$LN254@Parse_fp_w:
  015a6	8b 01		 mov	 eax, DWORD PTR [ecx]
  015a8	ff 50 18	 call	 DWORD PTR [eax+24]
$LN255@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  015ab	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  015ae	74 05		 je	 SHORT $LN250@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  015b0	88 46 05	 mov	 BYTE PTR [esi+5], al
  015b3	eb 06		 jmp	 SHORT $LN249@Parse_fp_w
$LN250@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  015b5	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN249@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  015bb	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN215@Parse_fp_w:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  015bf	8b 0f		 mov	 ecx, DWORD PTR [edi]
  015c1	8b 06		 mov	 eax, DWORD PTR [esi]
  015c3	85 c9		 test	 ecx, ecx
  015c5	0f 85 df 00 00
	00		 jne	 $LN2356@Parse_fp_w
  015cb	85 c0		 test	 eax, eax
  015cd	0f 85 df 00 00
	00		 jne	 $LN218@Parse_fp_w
$LN219@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1031 :             if (_Exponent_part_negative) {

  015d3	80 7d 9c 00	 cmp	 BYTE PTR __Exponent_part_negative$1$[ebp], 0
  015d7	74 02		 je	 SHORT $LN88@Parse_fp_w

; 1032 :                 _Exponent_part = -_Exponent_part;

  015d9	f7 db		 neg	 ebx
$LN88@Parse_fp_w:

; 1033 :             }
; 1034 :         }
; 1035 : 
; 1036 :         if (!_Seendigit) {

  015db	80 7d 9e 00	 cmp	 BYTE PTR __Seendigit$3$[ebp], 0
  015df	0f 84 73 02 00
	00		 je	 $LN2360@Parse_fp_w
$LN89@Parse_fp_w:

; 1038 :         }
; 1039 : 
; 1040 :         constexpr int _Dec_exp_abs_bound = 1100; // slightly greater than 324 + 768
; 1041 :         constexpr int _Hex_exp_abs_bound = 4200; // slightly greater than 1074 + 768 * 4
; 1042 : 
; 1043 :         const ptrdiff_t _Exp_abs_bound     = _Parse_hex ? _Hex_exp_abs_bound : _Dec_exp_abs_bound;

  015e5	8a 4d 9f	 mov	 cl, BYTE PTR __Parse_hex$1$[ebp]
  015e8	b8 4c 04 00 00	 mov	 eax, 1100		; 0000044cH

; 1044 :         const ptrdiff_t _Exp_rep_abs_bound = _Parse_hex ? _Hex_exp_abs_bound / 4 : _Dec_exp_abs_bound;
; 1045 : 
; 1046 :         // basically _Exponent_part = _STD clamp(-_Exp_abs_bound,
; 1047 :         //     _Exponent_part + _Parse_hex ? _Power_of_rep_base * 4 : _Power_of_rep_base, _Exp_abs_bound)
; 1048 :         // but need to defend overflowing
; 1049 :         for (ptrdiff_t _Power_of_rep_adjusted = _Power_of_rep_base;;) {

  015ed	8b b5 7c ff ff
	ff		 mov	 esi, DWORD PTR __Power_of_rep_base$1$[ebp]
  015f3	84 c9		 test	 cl, cl
  015f5	8b f8		 mov	 edi, eax
  015f7	ba 68 10 00 00	 mov	 edx, 4200		; 00001068H
  015fc	0f 45 fa	 cmovne	 edi, edx
  015ff	ba 1a 04 00 00	 mov	 edx, 1050		; 0000041aH
  01604	0f 45 c2	 cmovne	 eax, edx
  01607	89 45 84	 mov	 DWORD PTR __Exp_rep_abs_bound$1$[ebp], eax
  0160a	66 0f 1f 44 00
	00		 npad	 6
$LL30@Parse_fp_w:

; 1050 :             if (_Exponent_part >= 0 && _Power_of_rep_adjusted >= 0
; 1051 :                 && (_Exponent_part >= _Exp_abs_bound || _Power_of_rep_adjusted >= _Exp_rep_abs_bound)) {

  01610	85 db		 test	 ebx, ebx
  01612	78 16		 js	 SHORT $LN2502@Parse_fp_w
  01614	85 f6		 test	 esi, esi
  01616	78 10		 js	 SHORT $LN90@Parse_fp_w
  01618	3b df		 cmp	 ebx, edi
  0161a	0f 8d 72 01 00
	00		 jge	 $LN92@Parse_fp_w
  01620	3b f0		 cmp	 esi, eax
  01622	0f 8d 6a 01 00
	00		 jge	 $LN92@Parse_fp_w
$LN90@Parse_fp_w:

; 1052 :                 _Exponent_part = _Exp_abs_bound;
; 1053 :                 break;
; 1054 :             } else if (_Exponent_part <= 0 && _Power_of_rep_adjusted <= 0
; 1055 :                        && (_Exponent_part <= -_Exp_abs_bound || _Power_of_rep_adjusted <= -_Exp_rep_abs_bound)) {

  01628	85 db		 test	 ebx, ebx
$LN2502@Parse_fp_w:
  0162a	7f 1a		 jg	 SHORT $LN93@Parse_fp_w
  0162c	85 f6		 test	 esi, esi
  0162e	7f 16		 jg	 SHORT $LN93@Parse_fp_w
  01630	8b cf		 mov	 ecx, edi
  01632	f7 d9		 neg	 ecx
  01634	3b d9		 cmp	 ebx, ecx
  01636	0f 8e 54 01 00
	00		 jle	 $LN95@Parse_fp_w
  0163c	f7 d8		 neg	 eax
  0163e	3b f0		 cmp	 esi, eax
  01640	0f 8e 4a 01 00
	00		 jle	 $LN95@Parse_fp_w
$LN93@Parse_fp_w:

; 1057 :                 break;
; 1058 :             } else if (_STD abs(_Exponent_part) <= _Exp_abs_bound
; 1059 :                        && _STD abs(_Power_of_rep_adjusted) <= _Exp_rep_abs_bound) {

  01646	8b c3		 mov	 eax, ebx
  01648	99		 cdq
  01649	8b c8		 mov	 ecx, eax
  0164b	33 ca		 xor	 ecx, edx
  0164d	2b ca		 sub	 ecx, edx
  0164f	3b cf		 cmp	 ecx, edi
  01651	7f 10		 jg	 SHORT $LN96@Parse_fp_w
  01653	8b c6		 mov	 eax, esi
  01655	99		 cdq
  01656	33 c2		 xor	 eax, edx
  01658	2b c2		 sub	 eax, edx
  0165a	3b 45 84	 cmp	 eax, DWORD PTR __Exp_rep_abs_bound$1$[ebp]
  0165d	0f 8e 34 01 00
	00		 jle	 $LN2218@Parse_fp_w
$LN96@Parse_fp_w:

; 1065 :                     _Exponent_part = -_Exp_abs_bound;
; 1066 :                 }
; 1067 :                 break;
; 1068 :             } else {
; 1069 :                 // only enters once:
; 1070 :                 // _Exponent_part and _Power_of_rep_base are of different signedness, but at least one is large
; 1071 :                 const ptrdiff_t _Exponent_part_preadjustment_round_up =

  01663	80 7d 9f 00	 cmp	 BYTE PTR __Parse_hex$1$[ebp], 0
  01667	74 0e		 je	 SHORT $LN113@Parse_fp_w
  01669	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  0166c	99		 cdq
  0166d	83 e2 03	 and	 edx, 3
  01670	8d 0c 02	 lea	 ecx, DWORD PTR [edx+eax]
  01673	c1 f9 02	 sar	 ecx, 2
  01676	41		 inc	 ecx
$LN113@Parse_fp_w:

; 1072 :                     _Parse_hex ? (_STD abs(_Exponent_part) - 1) / 4 + 1 : _STD abs(_Exponent_part);
; 1073 :                 const ptrdiff_t _Exp_rep_adjustment =

  01677	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR __Power_of_rep_base$1$[ebp]
  0167d	99		 cdq
  0167e	33 c2		 xor	 eax, edx
  01680	2b c2		 sub	 eax, edx
  01682	3b c1		 cmp	 eax, ecx
  01684	0f 4c c8	 cmovl	 ecx, eax

; 1074 :                     (_STD min)(_Exponent_part_preadjustment_round_up, _STD abs(_Power_of_rep_base));
; 1075 : 
; 1076 :                 if (_Exponent_part >= 0) {

  01687	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  0168e	85 db		 test	 ebx, ebx
  01690	0f 88 e6 00 00
	00		 js	 $LN101@Parse_fp_w

; 1077 :                     _Exponent_part -= _Parse_hex ? _Exp_rep_adjustment * 4 : _Exp_rep_adjustment;

  01696	80 7d 9f 00	 cmp	 BYTE PTR __Parse_hex$1$[ebp], 0
  0169a	75 02		 jne	 SHORT $LN115@Parse_fp_w
  0169c	8b c1		 mov	 eax, ecx
$LN115@Parse_fp_w:
  0169e	2b d8		 sub	 ebx, eax

; 1078 :                     _Power_of_rep_adjusted += _Exp_rep_adjustment;
; 1079 :                 } else {

  016a0	8b 45 84	 mov	 eax, DWORD PTR __Exp_rep_abs_bound$1$[ebp]
  016a3	03 f1		 add	 esi, ecx
  016a5	e9 66 ff ff ff	 jmp	 $LL30@Parse_fp_w
$LN2356@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  016aa	85 c0		 test	 eax, eax
  016ac	0f 85 21 ff ff
	ff		 jne	 $LN219@Parse_fp_w
$LN218@Parse_fp_w:

; 406  :         if (!_Got) {

  016b2	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  016b6	75 33		 jne	 SHORT $LN2437@Parse_fp_w

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  016b8	85 c9		 test	 ecx, ecx
  016ba	74 25		 je	 SHORT $LN186@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  016bc	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  016bf	8b 10		 mov	 edx, DWORD PTR [eax]
  016c1	85 d2		 test	 edx, edx
  016c3	74 0d		 je	 SHORT $LN190@Parse_fp_w
  016c5	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  016c8	83 38 00	 cmp	 DWORD PTR [eax], 0
  016cb	7e 05		 jle	 SHORT $LN190@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  016cd	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  016d0	eb 05		 jmp	 SHORT $LN191@Parse_fp_w
$LN190@Parse_fp_w:
  016d2	8b 01		 mov	 eax, DWORD PTR [ecx]
  016d4	ff 50 18	 call	 DWORD PTR [eax+24]
$LN191@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  016d7	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  016da	74 05		 je	 SHORT $LN186@Parse_fp_w

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  016dc	88 47 05	 mov	 BYTE PTR [edi+5], al
  016df	eb 06		 jmp	 SHORT $LN185@Parse_fp_w
$LN186@Parse_fp_w:

; 471  :             _Strbuf = nullptr;

  016e1	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN185@Parse_fp_w:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  016e7	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN2437@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 6127 :             const auto _Result    = _STD _Find_vectorized(_First_ptr, _STD _To_address(_Last), _Val);

  016eb	8a 47 05	 mov	 al, BYTE PTR [edi+5]
  016ee	88 45 90	 mov	 BYTE PTR $T4[ebp], al

; 200  :         return const_cast<_Ty*>(

  016f1	8d 45 ec	 lea	 eax, DWORD PTR __Atoms$[ebp+28]
  016f4	ff 75 90	 push	 DWORD PTR $T4[ebp]
  016f7	50		 push	 eax
  016f8	8d 45 d0	 lea	 eax, DWORD PTR __Atoms$[ebp]
  016fb	50		 push	 eax
  016fc	e8 00 00 00 00	 call	 ___std_find_trivial_1@12

; 6129 :                 return _Result;

  01701	8b c8		 mov	 ecx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 70   :     return static_cast<size_t>(_STD _Find_unchecked(_Base, _Base + (_Base_size - 1), _Ch) - _Base);

  01703	8d 45 d0	 lea	 eax, DWORD PTR __Atoms$[ebp]
  01706	2b c8		 sub	 ecx, eax

; 1018 :             }
; 1019 : 
; 1020 :             for (size_t _Idx; _First != _Last && (_Idx = _STD _Find_elem(_Atoms, *_First)) < _Offset_dec_digit_end;

  01708	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0170b	0f 83 c2 fe ff
	ff		 jae	 $LN219@Parse_fp_w

; 1022 :                 if (_Exponent_part < PTRDIFF_MAX / 10
; 1023 :                     || (_Exponent_part == PTRDIFF_MAX / 10

  01711	81 fb cc cc cc
	0c		 cmp	 ebx, 214748364		; 0cccccccH
  01717	7c 0e		 jl	 SHORT $LN87@Parse_fp_w
  01719	75 05		 jne	 SHORT $LN85@Parse_fp_w
  0171b	83 f9 07	 cmp	 ecx, 7
  0171e	7e 07		 jle	 SHORT $LN87@Parse_fp_w
$LN85@Parse_fp_w:

; 1026 :                 } else {
; 1027 :                     _Exponent_part = PTRDIFF_MAX; // saturated

  01720	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  01725	eb 06		 jmp	 SHORT $LN25@Parse_fp_w
$LN87@Parse_fp_w:

; 1024 :                         && static_cast<ptrdiff_t>(_Idx) <= PTRDIFF_MAX % 10)) { // save a significant exponent digit
; 1025 :                     _Exponent_part = _Exponent_part * 10 + static_cast<ptrdiff_t>(_Idx);

  01727	8d 04 9b	 lea	 eax, DWORD PTR [ebx+ebx*4]
  0172a	8d 1c 41	 lea	 ebx, DWORD PTR [ecx+eax*2]
$LN25@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  0172d	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1021 :                 _Seendigit = true, (void) ++_First) {

  0172f	c6 45 9e 01	 mov	 BYTE PTR __Seendigit$3$[ebp], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  01733	85 c9		 test	 ecx, ecx
  01735	74 36		 je	 SHORT $LN278@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  01737	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0173a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0173d	74 1b		 je	 SHORT $LN282@Parse_fp_w
  0173f	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  01742	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  01744	85 c0		 test	 eax, eax
  01746	7e 12		 jle	 SHORT $LN282@Parse_fp_w

; 222  :         --*_IGcount;

  01748	48		 dec	 eax
  01749	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  0174b	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  0174e	8b 11		 mov	 edx, DWORD PTR [ecx]
  01750	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  01753	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  01755	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  01758	eb 05		 jmp	 SHORT $LN283@Parse_fp_w
$LN282@Parse_fp_w:
  0175a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0175c	ff 50 1c	 call	 DWORD PTR [eax+28]
$LN283@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  0175f	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  01762	74 09		 je	 SHORT $LN278@Parse_fp_w

; 464  :             _Got = false;

  01764	c6 47 04 00	 mov	 BYTE PTR [edi+4], 0
  01768	e9 38 fd ff ff	 jmp	 $LL27@Parse_fp_w
$LN278@Parse_fp_w:

; 461  :             _Strbuf = nullptr;

  0176d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 462  :             _Got    = true;

  01773	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1

; 463  :         } else {

  01777	e9 29 fd ff ff	 jmp	 $LL27@Parse_fp_w
$LN101@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1080 :                     _Exponent_part += _Parse_hex ? _Exp_rep_adjustment * 4 : _Exp_rep_adjustment;

  0177c	80 7d 9f 00	 cmp	 BYTE PTR __Parse_hex$1$[ebp], 0
  01780	75 02		 jne	 SHORT $LN117@Parse_fp_w
  01782	8b c1		 mov	 eax, ecx
$LN117@Parse_fp_w:
  01784	03 d8		 add	 ebx, eax
  01786	8b 45 84	 mov	 eax, DWORD PTR __Exp_rep_abs_bound$1$[ebp]

; 1081 :                     _Power_of_rep_adjusted -= _Exp_rep_adjustment;

  01789	2b f1		 sub	 esi, ecx
  0178b	e9 80 fe ff ff	 jmp	 $LL30@Parse_fp_w
$LN95@Parse_fp_w:

; 1056 :                 _Exponent_part = -_Exp_abs_bound;

  01790	8b f9		 mov	 edi, ecx
$LN92@Parse_fp_w:

; 1086 :         if (_Exponent_part != 0) {

  01792	8a 4d 9f	 mov	 cl, BYTE PTR __Parse_hex$1$[ebp]
  01795	eb 1b		 jmp	 SHORT $LN100@Parse_fp_w
$LN2218@Parse_fp_w:

; 1060 :                 // _Exponent_part and _Power_of_rep_base are of different signedness, both of which are small enough
; 1061 :                 _Exponent_part += _Parse_hex ? _Power_of_rep_adjusted * 4 : _Power_of_rep_adjusted;

  01797	8a 4d 9f	 mov	 cl, BYTE PTR __Parse_hex$1$[ebp]
  0179a	84 c9		 test	 cl, cl
  0179c	74 03		 je	 SHORT $LN111@Parse_fp_w
  0179e	c1 e6 02	 shl	 esi, 2
$LN111@Parse_fp_w:
  017a1	03 de		 add	 ebx, esi

; 1062 :                 if (_Exponent_part > _Exp_abs_bound) {

  017a3	3b df		 cmp	 ebx, edi
  017a5	7f 0b		 jg	 SHORT $LN100@Parse_fp_w

; 1063 :                     _Exponent_part = _Exp_abs_bound;
; 1064 :                 } else if (_Exponent_part < -_Exp_abs_bound) {

  017a7	8b c7		 mov	 eax, edi
  017a9	8b fb		 mov	 edi, ebx
  017ab	f7 d8		 neg	 eax
  017ad	3b d8		 cmp	 ebx, eax
  017af	0f 4c f8	 cmovl	 edi, eax
$LN100@Parse_fp_w:

; 1086 :         if (_Exponent_part != 0) {

  017b2	85 ff		 test	 edi, edi
  017b4	74 7e		 je	 SHORT $LN2495@Parse_fp_w

; 1087 :             *_Ptr++ = _Parse_hex ? 'p' : 'e';

  017b6	84 c9		 test	 cl, cl
  017b8	b8 65 00 00 00	 mov	 eax, 101		; 00000065H
  017bd	8b 4d 98	 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
  017c0	ba 70 00 00 00	 mov	 edx, 112		; 00000070H
  017c5	0f 45 c2	 cmovne	 eax, edx
  017c8	88 01		 mov	 BYTE PTR [ecx], al
  017ca	41		 inc	 ecx
  017cb	89 4d 98	 mov	 DWORD PTR __Ptr$1$[ebp], ecx

; 1088 :             if (_Exponent_part < 0) {

  017ce	85 ff		 test	 edi, edi
  017d0	79 07		 jns	 SHORT $LN104@Parse_fp_w

; 1089 :                 *_Ptr++ = '-';

  017d2	c6 01 2d	 mov	 BYTE PTR [ecx], 45	; 0000002dH
  017d5	41		 inc	 ecx
  017d6	89 4d 98	 mov	 DWORD PTR __Ptr$1$[ebp], ecx
$LN104@Parse_fp_w:

; 1090 :             }
; 1091 : 
; 1092 :             char* const _Rev_begin = _Ptr;

  017d9	8b f1		 mov	 esi, ecx

; 1093 :             for (ptrdiff_t _Exponent_part_abs = _STD abs(_Exponent_part); _Exponent_part_abs != 0;

  017db	8b c7		 mov	 eax, edi
  017dd	99		 cdq
  017de	8b c8		 mov	 ecx, eax
  017e0	89 75 90	 mov	 DWORD PTR __Rev_begin$1$[ebp], esi
  017e3	33 ca		 xor	 ecx, edx
  017e5	2b ca		 sub	 ecx, edx
  017e7	89 4d 84	 mov	 DWORD PTR __Exponent_part_abs$1$[ebp], ecx
  017ea	74 39		 je	 SHORT $LN32@Parse_fp_w
  017ec	8b 75 98	 mov	 esi, DWORD PTR __Ptr$1$[ebp]
  017ef	90		 npad	 1
$LL33@Parse_fp_w:

; 1094 :                 _Exponent_part_abs /= 10) {
; 1095 :                 *_Ptr++ = static_cast<char>('0' + _Exponent_part_abs % 10);

  017f0	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  017f5	f7 e9		 imul	 ecx
  017f7	c1 fa 02	 sar	 edx, 2
  017fa	8b da		 mov	 ebx, edx
  017fc	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  017ff	03 da		 add	 ebx, edx
  01801	8a c3		 mov	 al, bl
  01803	8a cb		 mov	 cl, bl
  01805	c0 e0 02	 shl	 al, 2
  01808	02 c8		 add	 cl, al
  0180a	8b 45 84	 mov	 eax, DWORD PTR __Exponent_part_abs$1$[ebp]
  0180d	02 c9		 add	 cl, cl
  0180f	2a c1		 sub	 al, cl
  01811	8b cb		 mov	 ecx, ebx
  01813	04 30		 add	 al, 48			; 00000030H
  01815	89 4d 84	 mov	 DWORD PTR __Exponent_part_abs$1$[ebp], ecx
  01818	88 06		 mov	 BYTE PTR [esi], al
  0181a	46		 inc	 esi
  0181b	85 c9		 test	 ecx, ecx
  0181d	75 d1		 jne	 SHORT $LL33@Parse_fp_w
  0181f	89 75 98	 mov	 DWORD PTR __Ptr$1$[ebp], esi
  01822	8b 75 90	 mov	 esi, DWORD PTR __Rev_begin$1$[ebp]
$LN32@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 156  :         ::__std_reverse_trivially_swappable_1(_First, _Last);

  01825	8b 5d 98	 mov	 ebx, DWORD PTR __Ptr$1$[ebp]
  01828	53		 push	 ebx
  01829	56		 push	 esi
  0182a	e8 00 00 00 00	 call	 ___std_reverse_trivially_swappable_1
  0182f	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1086 :         if (_Exponent_part != 0) {

  01832	eb 03		 jmp	 SHORT $LN156@Parse_fp_w
$LN2495@Parse_fp_w:
  01834	8b 5d 98	 mov	 ebx, DWORD PTR __Ptr$1$[ebp]
$LN156@Parse_fp_w:

; 1101 :         return {static_cast<int8_t>(_Parse_hex ? 16 : 10), _Bad_grouping};

  01837	80 7d 9f 00	 cmp	 BYTE PTR __Parse_hex$1$[ebp], 0
  0183b	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  01840	c6 03 00	 mov	 BYTE PTR [ebx], 0
  01843	bb 0a 00 00 00	 mov	 ebx, 10			; 0000000aH
  01848	0f 45 d8	 cmovne	 ebx, eax
  0184b	0f b6 45 9d	 movzx	 eax, BYTE PTR __Bad_grouping$1$[ebp]
  0184f	66 c1 e0 08	 shl	 ax, 8
  01853	66 0b d8	 or	 bx, ax
  01856	eb 05		 jmp	 SHORT $LN121@Parse_fp_w
$LN2360@Parse_fp_w:

; 1037 :             return {0, false};

  01858	33 c0		 xor	 eax, eax
$LN120@Parse_fp_w:
  0185a	66 8b d8	 mov	 bx, ax
$LN121@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  0185d	8b 4d b4	 mov	 ecx, DWORD PTR __Grouping$[ebp+20]
  01860	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3083 :         if (_My_data._Large_mode_engaged()) {

  01863	76 28		 jbe	 SHORT $LN142@Parse_fp_w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  01865	8b 55 a0	 mov	 edx, DWORD PTR __Grouping$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  01868	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  01869	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0186b	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  01871	72 10		 jb	 SHORT $LN147@Parse_fp_w

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  01873	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  01876	83 c1 23	 add	 ecx, 35			; 00000023H
  01879	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0187b	83 c0 fc	 add	 eax, -4			; fffffffcH
  0187e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  01881	77 29		 ja	 SHORT $LN2504@Parse_fp_w
$LN147@Parse_fp_w:

; 289  :         ::operator delete(_Ptr, _Bytes);

  01883	51		 push	 ecx
  01884	52		 push	 edx
  01885	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0188a	83 c4 08	 add	 esp, 8
$LN142@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1101 :         return {static_cast<int8_t>(_Parse_hex ? 16 : 10), _Bad_grouping};

  0188d	66 8b c3	 mov	 ax, bx

; 1102 :     }

  01890	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01893	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0189a	59		 pop	 ecx
  0189b	5f		 pop	 edi
  0189c	5e		 pop	 esi
  0189d	5b		 pop	 ebx
  0189e	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  018a1	33 cd		 xor	 ecx, ebp
  018a3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  018a8	8b e5		 mov	 esp, ebp
  018aa	5d		 pop	 ebp
  018ab	c3		 ret	 0
$LN2504@Parse_fp_w:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  018ac	6a 00		 push	 0
  018ae	6a 00		 push	 0
  018b0	6a 00		 push	 0
  018b2	6a 00		 push	 0
  018b4	6a 00		 push	 0
  018b6	e8 00 00 00 00	 call	 __invoke_watson
$LN2498@Parse_fp_w:
  018bb	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z$0:
  00000	8d 4d a0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z$1:
  00008	8d 4d b8	 lea	 ecx, DWORD PTR __Groups$5[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 8a 64 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-156]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_fp_with_locale<0>
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z
_TEXT	SEGMENT
$T2 = -144						; size = 1
__Pe$1$ = -140						; size = 4
tv5513 = -136						; size = 4
__Old_capacity$1$ = -132				; size = 4
__Dlen$1$ = -128					; size = 4
__Last$GSCopy$1$ = -124					; size = 4
__New_ptr$1$ = -120					; size = 4
__Loc$GSCopy$1$ = -120					; size = 4
__Ptr$1$ = -116						; size = 4
__Groups_arr_idx$1$ = -112				; size = 4
__Groups$1$ = -108					; size = 4
__Nonzero$1$ = -101					; size = 1
__Ptr$1$ = -100						; size = 4
__Ac$GSCopy$1$ = -100					; size = 4
tv5679 = -96						; size = 1
__Seendigit$1$ = -95					; size = 1
__Bad_grouping$1$ = -94					; size = 1
__Kseparator$1$ = -93					; size = 1
__Grouping$ = -92					; size = 24
__Groups$ = -68						; size = 24
__Atoms$ = -44						; size = 27
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Ac$ = 8						; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Basefield$ = 20					; size = 4
__Loc$ = 24						; size = 4
??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>, COMDAT

; 659  :         char* const _Ac, _InIt& _First, _InIt& _Last, ios_base::fmtflags _Basefield, const locale& _Loc) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b 45 08	 mov	 eax, DWORD PTR __Ac$[ebp]
  00030	8b 75 0c	 mov	 esi, DWORD PTR __First$[ebp]
  00033	89 45 9c	 mov	 DWORD PTR __Ac$GSCopy$1$[ebp], eax
  00036	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	89 45 84	 mov	 DWORD PTR __Last$GSCopy$1$[ebp], eax
  0003c	8b 45 18	 mov	 eax, DWORD PTR __Loc$[ebp]

; 660  :         // get integer field from [_First, _Last) into _Ac
; 661  :         const auto& _Punct_fac  = _STD use_facet<numpunct<_Elem>>(_Loc);

  0003f	50		 push	 eax
  00040	89 45 88	 mov	 DWORD PTR __Loc$GSCopy$1$[ebp], eax
  00043	e8 00 00 00 00	 call	 ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
  00048	8b f8		 mov	 edi, eax
  0004a	83 c4 04	 add	 esp, 4

; 108  :         return do_grouping();

  0004d	8d 45 a4	 lea	 eax, DWORD PTR __Grouping$[ebp]
  00050	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00052	50		 push	 eax
  00053	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00056	8b cf		 mov	 ecx, edi
  00058	ff d2		 call	 edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2494 :         return _Mypair._Myval2._Mysize == 0;

  0005a	83 7d b4 00	 cmp	 DWORD PTR __Grouping$[ebp+16], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 662  :         const string _Grouping  = _Punct_fac.grouping();

  0005e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 663  :         const _Elem _Kseparator = _Grouping.empty() ? _Elem{} : _Punct_fac.thousands_sep();

  00065	75 06		 jne	 SHORT $LN53@Parse_int_
  00067	c6 45 a3 00	 mov	 BYTE PTR __Kseparator$1$[ebp], 0
  0006b	eb 0c		 jmp	 SHORT $LN54@Parse_int_
$LN53@Parse_int_:

; 104  :         return do_thousands_sep();

  0006d	8b 07		 mov	 eax, DWORD PTR [edi]
  0006f	8b cf		 mov	 ecx, edi
  00071	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00074	ff d0		 call	 eax

; 663  :         const _Elem _Kseparator = _Grouping.empty() ? _Elem{} : _Punct_fac.thousands_sep();

  00076	88 45 a3	 mov	 BYTE PTR __Kseparator$1$[ebp], al
$LN54@Parse_int_:

; 664  : 
; 665  :         constexpr int _Numget_signoff = 22;
; 666  :         constexpr int _Numget_xoff    = 24;
; 667  :         static constexpr char _Src[]  = "0123456789ABCDEFabcdef-+Xx";
; 668  :         _Elem _Atoms[sizeof(_Src)];
; 669  :         const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Loc);

  00079	ff 75 88	 push	 DWORD PTR __Loc$GSCopy$1$[ebp]
  0007c	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  00081	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 2760 :         return do_widen(_First, _Last, _Dest);

  00084	8b 08		 mov	 ecx, DWORD PTR [eax]
  00086	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00089	8d 4d d4	 lea	 ecx, DWORD PTR __Atoms$[ebp]
  0008c	51		 push	 ecx
  0008d	68 1b 00 00 00	 push	 OFFSET ?_Src@?1???$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z@4QBDB+27
  00092	68 00 00 00 00	 push	 OFFSET ?_Src@?1???$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>'::`2'::_Src
  00097	8b c8		 mov	 ecx, eax
  00099	ff d2		 call	 edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 675  :         if (_Kseparator != _Elem{}) {

  0009b	8b 7d 84	 mov	 edi, DWORD PTR __Last$GSCopy$1$[ebp]
  0009e	32 d2		 xor	 dl, dl
  000a0	88 55 a2	 mov	 BYTE PTR __Bad_grouping$1$[ebp], dl
  000a3	38 55 a3	 cmp	 BYTE PTR __Kseparator$1$[ebp], dl
  000a6	0f 84 88 00 00
	00		 je	 $LN304@Parse_int_
  000ac	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000ae	66 90		 npad	 2
$LL2@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 437  :         if (!_Got) {

  000b0	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  000b4	75 35		 jne	 SHORT $LN1218@Parse_int_

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  000b6	85 c9		 test	 ecx, ecx
  000b8	74 27		 je	 SHORT $LN309@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  000ba	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  000bd	8b 10		 mov	 edx, DWORD PTR [eax]
  000bf	85 d2		 test	 edx, edx
  000c1	74 0d		 je	 SHORT $LN313@Parse_int_
  000c3	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  000c6	83 38 00	 cmp	 DWORD PTR [eax], 0
  000c9	7e 05		 jle	 SHORT $LN313@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  000cb	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  000ce	eb 07		 jmp	 SHORT $LN314@Parse_int_
$LN313@Parse_int_:
  000d0	8b 01		 mov	 eax, DWORD PTR [ecx]
  000d2	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  000d5	ff d0		 call	 eax
$LN314@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  000d7	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  000da	74 05		 je	 SHORT $LN309@Parse_int_

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  000dc	88 46 05	 mov	 BYTE PTR [esi+5], al
  000df	eb 06		 jmp	 SHORT $LN308@Parse_int_
$LN309@Parse_int_:

; 471  :             _Strbuf = nullptr;

  000e1	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN308@Parse_int_:

; 476  :         _Got = true;

  000e7	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN1218@Parse_int_:

; 441  :         if (!_Right._Got) {

  000eb	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  000ef	75 37		 jne	 SHORT $LN1255@Parse_int_

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  000f1	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000f3	85 c9		 test	 ecx, ecx
  000f5	74 27		 je	 SHORT $LN335@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  000f7	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  000fa	8b 10		 mov	 edx, DWORD PTR [eax]
  000fc	85 d2		 test	 edx, edx
  000fe	74 0d		 je	 SHORT $LN339@Parse_int_
  00100	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00103	83 38 00	 cmp	 DWORD PTR [eax], 0
  00106	7e 05		 jle	 SHORT $LN339@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00108	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0010b	eb 07		 jmp	 SHORT $LN340@Parse_int_
$LN339@Parse_int_:
  0010d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0010f	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00112	ff d0		 call	 eax
$LN340@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00114	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00117	74 05		 je	 SHORT $LN335@Parse_int_

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00119	88 47 05	 mov	 BYTE PTR [edi+5], al
  0011c	eb 06		 jmp	 SHORT $LN334@Parse_int_
$LN335@Parse_int_:

; 471  :             _Strbuf = nullptr;

  0011e	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN334@Parse_int_:

; 476  :         _Got = true;

  00124	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN1255@Parse_int_:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  00128	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0012a	8b 07		 mov	 eax, DWORD PTR [edi]
  0012c	85 c9		 test	 ecx, ecx
  0012e	75 42		 jne	 SHORT $LN1249@Parse_int_
  00130	85 c0		 test	 eax, eax
  00132	75 42		 jne	 SHORT $LN1221@Parse_int_
$LN304@Parse_int_:

; 437  :         if (!_Got) {

  00134	8a 46 04	 mov	 al, BYTE PTR [esi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 682  :         char* _Ptr = _Ac;

  00137	8b 4d 9c	 mov	 ecx, DWORD PTR __Ac$GSCopy$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 437  :         if (!_Got) {

  0013a	8a d0		 mov	 dl, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 682  :         char* _Ptr = _Ac;

  0013c	89 4d 8c	 mov	 DWORD PTR __Ptr$1$[ebp], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 437  :         if (!_Got) {

  0013f	84 c0		 test	 al, al
  00141	0f 85 ef 00 00
	00		 jne	 $LN702@Parse_int_

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00147	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00149	85 c9		 test	 ecx, ecx
  0014b	0f 84 d7 00 00
	00		 je	 $LN712@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00151	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00154	8b 10		 mov	 edx, DWORD PTR [eax]
  00156	85 d2		 test	 edx, edx
  00158	0f 84 b9 00 00
	00		 je	 $LN716@Parse_int_
  0015e	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00161	83 38 00	 cmp	 DWORD PTR [eax], 0
  00164	0f 8e ad 00 00
	00		 jle	 $LN716@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0016a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0016d	e9 ac 00 00 00	 jmp	 $LN717@Parse_int_
$LN1249@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  00172	85 c0		 test	 eax, eax
  00174	75 be		 jne	 SHORT $LN304@Parse_int_
$LN1221@Parse_int_:

; 406  :         if (!_Got) {

  00176	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  0017a	75 35		 jne	 SHORT $LN1256@Parse_int_

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0017c	85 c9		 test	 ecx, ecx
  0017e	74 27		 je	 SHORT $LN393@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00180	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00183	8b 10		 mov	 edx, DWORD PTR [eax]
  00185	85 d2		 test	 edx, edx
  00187	74 0d		 je	 SHORT $LN397@Parse_int_
  00189	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0018c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0018f	7e 05		 jle	 SHORT $LN397@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00191	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00194	eb 07		 jmp	 SHORT $LN398@Parse_int_
$LN397@Parse_int_:
  00196	8b 01		 mov	 eax, DWORD PTR [ecx]
  00198	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0019b	ff d0		 call	 eax
$LN398@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  0019d	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  001a0	74 05		 je	 SHORT $LN393@Parse_int_

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  001a2	88 46 05	 mov	 BYTE PTR [esi+5], al
  001a5	eb 06		 jmp	 SHORT $LN392@Parse_int_
$LN393@Parse_int_:

; 471  :             _Strbuf = nullptr;

  001a7	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN392@Parse_int_:

; 476  :         _Got = true;

  001ad	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN1256@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 676  :             while (_First != _Last && *_First == _Kseparator) {

  001b1	8a 45 a3	 mov	 al, BYTE PTR __Kseparator$1$[ebp]
  001b4	38 46 05	 cmp	 BYTE PTR [esi+5], al
  001b7	0f 85 77 ff ff
	ff		 jne	 $LN304@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  001bd	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001bf	85 c9		 test	 ecx, ecx
  001c1	74 3f		 je	 SHORT $LN446@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  001c3	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  001c6	83 38 00	 cmp	 DWORD PTR [eax], 0
  001c9	74 1b		 je	 SHORT $LN450@Parse_int_
  001cb	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  001ce	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  001d0	85 c0		 test	 eax, eax
  001d2	7e 12		 jle	 SHORT $LN450@Parse_int_

; 222  :         --*_IGcount;

  001d4	48		 dec	 eax
  001d5	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  001d7	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  001da	8b 11		 mov	 edx, DWORD PTR [ecx]
  001dc	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  001df	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  001e1	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  001e4	eb 07		 jmp	 SHORT $LN451@Parse_int_
$LN450@Parse_int_:
  001e6	8b 01		 mov	 eax, DWORD PTR [ecx]
  001e8	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  001eb	ff d0		 call	 eax
$LN451@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  001ed	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  001f0	74 10		 je	 SHORT $LN446@Parse_int_

; 464  :             _Got = false;

  001f2	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001f4	32 c0		 xor	 al, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 678  :                 _Bad_grouping = true;

  001f6	88 46 04	 mov	 BYTE PTR [esi+4], al
  001f9	c6 45 a2 01	 mov	 BYTE PTR __Bad_grouping$1$[ebp], 1

; 679  :             }

  001fd	e9 ae fe ff ff	 jmp	 $LL2@Parse_int_
$LN446@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 462  :             _Got    = true;

  00202	b0 01		 mov	 al, 1
  00204	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0020a	33 c9		 xor	 ecx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 678  :                 _Bad_grouping = true;

  0020c	88 46 04	 mov	 BYTE PTR [esi+4], al
  0020f	88 45 a2	 mov	 BYTE PTR __Bad_grouping$1$[ebp], al

; 679  :             }

  00212	e9 99 fe ff ff	 jmp	 $LL2@Parse_int_
$LN716@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00217	8b 01		 mov	 eax, DWORD PTR [ecx]
  00219	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0021c	ff d0		 call	 eax
$LN717@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  0021e	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00221	74 05		 je	 SHORT $LN712@Parse_int_

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00223	88 46 05	 mov	 BYTE PTR [esi+5], al
  00226	eb 06		 jmp	 SHORT $LN711@Parse_int_
$LN712@Parse_int_:

; 471  :             _Strbuf = nullptr;

  00228	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN711@Parse_int_:

; 476  :         _Got = true;

  0022e	b0 01		 mov	 al, 1
  00230	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
  00234	8a d0		 mov	 dl, al
$LN702@Parse_int_:

; 441  :         if (!_Right._Got) {

  00236	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  0023a	75 3c		 jne	 SHORT $LN703@Parse_int_

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0023c	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0023e	85 c9		 test	 ecx, ecx
  00240	74 27		 je	 SHORT $LN738@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00242	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00245	8b 10		 mov	 edx, DWORD PTR [eax]
  00247	85 d2		 test	 edx, edx
  00249	74 0d		 je	 SHORT $LN742@Parse_int_
  0024b	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0024e	83 38 00	 cmp	 DWORD PTR [eax], 0
  00251	7e 05		 jle	 SHORT $LN742@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00253	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00256	eb 07		 jmp	 SHORT $LN743@Parse_int_
$LN742@Parse_int_:
  00258	8b 01		 mov	 eax, DWORD PTR [ecx]
  0025a	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0025d	ff d0		 call	 eax
$LN743@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  0025f	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00262	74 05		 je	 SHORT $LN738@Parse_int_

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00264	88 47 05	 mov	 BYTE PTR [edi+5], al
  00267	eb 06		 jmp	 SHORT $LN737@Parse_int_
$LN738@Parse_int_:

; 471  :             _Strbuf = nullptr;

  00269	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN737@Parse_int_:

; 476  :         _Got = true;

  0026f	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
  00273	8a 46 04	 mov	 al, BYTE PTR [esi+4]
  00276	8a d0		 mov	 dl, al
$LN703@Parse_int_:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  00278	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0027a	85 c9		 test	 ecx, ecx
  0027c	75 26		 jne	 SHORT $LN1248@Parse_int_
  0027e	39 0f		 cmp	 DWORD PTR [edi], ecx
  00280	0f 84 50 01 00
	00		 je	 $LN1089@Parse_int_
$LN1272@Parse_int_:

; 406  :         if (!_Got) {

  00286	84 d2		 test	 dl, dl
  00288	75 4b		 jne	 SHORT $LN1224@Parse_int_

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0028a	85 c9		 test	 ecx, ecx
  0028c	74 39		 je	 SHORT $LN829@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  0028e	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00291	8b 10		 mov	 edx, DWORD PTR [eax]
  00293	85 d2		 test	 edx, edx
  00295	74 19		 je	 SHORT $LN833@Parse_int_
  00297	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0029a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0029d	7e 11		 jle	 SHORT $LN833@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0029f	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  002a2	eb 13		 jmp	 SHORT $LN834@Parse_int_
$LN1248@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  002a4	83 3f 00	 cmp	 DWORD PTR [edi], 0
  002a7	74 dd		 je	 SHORT $LN1272@Parse_int_
  002a9	8a c2		 mov	 al, dl
  002ab	e9 26 01 00 00	 jmp	 $LN1089@Parse_int_
$LN833@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  002b0	8b 01		 mov	 eax, DWORD PTR [ecx]
  002b2	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  002b5	ff d0		 call	 eax
$LN834@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  002b7	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  002ba	74 0b		 je	 SHORT $LN829@Parse_int_

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  002bc	88 46 05	 mov	 BYTE PTR [esi+5], al

; 476  :         _Got = true;

  002bf	b0 01		 mov	 al, 1
  002c1	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
  002c5	eb 10		 jmp	 SHORT $LN824@Parse_int_
$LN829@Parse_int_:

; 471  :             _Strbuf = nullptr;

  002c7	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 476  :         _Got = true;

  002cd	b0 01		 mov	 al, 1
  002cf	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
  002d3	eb 02		 jmp	 SHORT $LN824@Parse_int_
$LN1224@Parse_int_:
  002d5	8a c2		 mov	 al, dl
$LN824@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 685  :             if (*_First == _Atoms[_Numget_signoff + 1]) { // gather plus sign

  002d7	8a 4e 05	 mov	 cl, BYTE PTR [esi+5]
  002da	3a 4d eb	 cmp	 cl, BYTE PTR __Atoms$[ebp+23]
  002dd	75 5b		 jne	 SHORT $LN16@Parse_int_

; 686  :                 *_Ptr++ = '+';

  002df	8b 45 9c	 mov	 eax, DWORD PTR __Ac$GSCopy$1$[ebp]
  002e2	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  002e5	c6 00 2b	 mov	 BYTE PTR [eax], 43	; 0000002bH
  002e8	89 4d 8c	 mov	 DWORD PTR __Ptr$1$[ebp], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  002eb	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002ed	85 c9		 test	 ecx, ecx
  002ef	74 39		 je	 SHORT $LN1036@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  002f1	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  002f4	83 38 00	 cmp	 DWORD PTR [eax], 0
  002f7	74 1b		 je	 SHORT $LN1040@Parse_int_
  002f9	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  002fc	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  002fe	85 c0		 test	 eax, eax
  00300	7e 12		 jle	 SHORT $LN1040@Parse_int_

; 222  :         --*_IGcount;

  00302	48		 dec	 eax
  00303	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  00305	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00308	8b 11		 mov	 edx, DWORD PTR [ecx]
  0030a	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0030d	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0030f	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  00312	eb 07		 jmp	 SHORT $LN1041@Parse_int_
$LN1040@Parse_int_:
  00314	8b 01		 mov	 eax, DWORD PTR [ecx]
  00316	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00319	ff d0		 call	 eax
$LN1041@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  0031b	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  0031e	74 0a		 je	 SHORT $LN1036@Parse_int_

; 464  :             _Got = false;

  00320	32 c0		 xor	 al, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 688  :             } else if (*_First == _Atoms[_Numget_signoff]) { // gather minus sign

  00322	88 46 04	 mov	 BYTE PTR [esi+4], al
  00325	e9 ac 00 00 00	 jmp	 $LN1089@Parse_int_
$LN1036@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 462  :             _Got    = true;

  0032a	b0 01		 mov	 al, 1
  0032c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 688  :             } else if (*_First == _Atoms[_Numget_signoff]) { // gather minus sign

  00332	88 46 04	 mov	 BYTE PTR [esi+4], al
  00335	e9 9c 00 00 00	 jmp	 $LN1089@Parse_int_
$LN16@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 406  :         if (!_Got) {

  0033a	84 c0		 test	 al, al
  0033c	75 3e		 jne	 SHORT $LN1259@Parse_int_

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0033e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00340	85 c9		 test	 ecx, ecx
  00342	74 29		 je	 SHORT $LN1257@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00344	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00347	8b 10		 mov	 edx, DWORD PTR [eax]
  00349	85 d2		 test	 edx, edx
  0034b	74 0d		 je	 SHORT $LN1066@Parse_int_
  0034d	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00350	83 38 00	 cmp	 DWORD PTR [eax], 0
  00353	7e 05		 jle	 SHORT $LN1066@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00355	0f b6 0a	 movzx	 ecx, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00358	eb 09		 jmp	 SHORT $LN1067@Parse_int_
$LN1066@Parse_int_:
  0035a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0035c	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0035f	ff d0		 call	 eax
  00361	8b c8		 mov	 ecx, eax
$LN1067@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00363	83 f9 ff	 cmp	 ecx, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00366	74 05		 je	 SHORT $LN1257@Parse_int_

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00368	88 4e 05	 mov	 BYTE PTR [esi+5], cl
  0036b	eb 09		 jmp	 SHORT $LN1061@Parse_int_
$LN1257@Parse_int_:

; 471  :             _Strbuf = nullptr;

  0036d	8a 4e 05	 mov	 cl, BYTE PTR [esi+5]
  00370	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1061@Parse_int_:

; 476  :         _Got = true;

  00376	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
  0037a	b0 01		 mov	 al, 1
$LN1259@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 688  :             } else if (*_First == _Atoms[_Numget_signoff]) { // gather minus sign

  0037c	3a 4d ea	 cmp	 cl, BYTE PTR __Atoms$[ebp+22]
  0037f	75 55		 jne	 SHORT $LN1089@Parse_int_

; 689  :                 *_Ptr++ = '-';

  00381	8b 45 9c	 mov	 eax, DWORD PTR __Ac$GSCopy$1$[ebp]
  00384	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00387	c6 00 2d	 mov	 BYTE PTR [eax], 45	; 0000002dH
  0038a	89 4d 8c	 mov	 DWORD PTR __Ptr$1$[ebp], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  0038d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0038f	85 c9		 test	 ecx, ecx
  00391	74 37		 je	 SHORT $LN1090@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00393	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00396	83 38 00	 cmp	 DWORD PTR [eax], 0
  00399	74 1b		 je	 SHORT $LN1094@Parse_int_
  0039b	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0039e	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  003a0	85 c0		 test	 eax, eax
  003a2	7e 12		 jle	 SHORT $LN1094@Parse_int_

; 222  :         --*_IGcount;

  003a4	48		 dec	 eax
  003a5	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  003a7	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  003aa	8b 11		 mov	 edx, DWORD PTR [ecx]
  003ac	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  003af	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  003b1	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  003b4	eb 07		 jmp	 SHORT $LN1095@Parse_int_
$LN1094@Parse_int_:
  003b6	8b 01		 mov	 eax, DWORD PTR [ecx]
  003b8	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  003bb	ff d0		 call	 eax
$LN1095@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  003bd	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  003c0	74 08		 je	 SHORT $LN1090@Parse_int_

; 464  :             _Got = false;

  003c2	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  003c6	32 c0		 xor	 al, al
  003c8	eb 0c		 jmp	 SHORT $LN1089@Parse_int_
$LN1090@Parse_int_:

; 461  :             _Strbuf = nullptr;

  003ca	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 462  :             _Got    = true;

  003d0	b0 01		 mov	 al, 1
  003d2	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN1089@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 695  :         if (_Kseparator != _Elem{}) {

  003d6	80 7d a3 00	 cmp	 BYTE PTR __Kseparator$1$[ebp], 0
  003da	0f 84 84 00 00
	00		 je	 $LN228@Parse_int_
$LL4@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 437  :         if (!_Got) {

  003e0	84 c0		 test	 al, al
  003e2	75 37		 jne	 SHORT $LN1260@Parse_int_

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  003e4	8b 0e		 mov	 ecx, DWORD PTR [esi]
  003e6	85 c9		 test	 ecx, ecx
  003e8	74 27		 je	 SHORT $LN233@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  003ea	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  003ed	8b 10		 mov	 edx, DWORD PTR [eax]
  003ef	85 d2		 test	 edx, edx
  003f1	74 0d		 je	 SHORT $LN237@Parse_int_
  003f3	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  003f6	83 38 00	 cmp	 DWORD PTR [eax], 0
  003f9	7e 05		 jle	 SHORT $LN237@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  003fb	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  003fe	eb 07		 jmp	 SHORT $LN238@Parse_int_
$LN237@Parse_int_:
  00400	8b 01		 mov	 eax, DWORD PTR [ecx]
  00402	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00405	ff d0		 call	 eax
$LN238@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00407	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0040a	74 05		 je	 SHORT $LN233@Parse_int_

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  0040c	88 46 05	 mov	 BYTE PTR [esi+5], al
  0040f	eb 06		 jmp	 SHORT $LN232@Parse_int_
$LN233@Parse_int_:

; 471  :             _Strbuf = nullptr;

  00411	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN232@Parse_int_:

; 476  :         _Got = true;

  00417	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN1260@Parse_int_:

; 441  :         if (!_Right._Got) {

  0041b	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  0041f	75 37		 jne	 SHORT $LN224@Parse_int_

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00421	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00423	85 c9		 test	 ecx, ecx
  00425	74 27		 je	 SHORT $LN259@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00427	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0042a	8b 10		 mov	 edx, DWORD PTR [eax]
  0042c	85 d2		 test	 edx, edx
  0042e	74 0d		 je	 SHORT $LN263@Parse_int_
  00430	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00433	83 38 00	 cmp	 DWORD PTR [eax], 0
  00436	7e 05		 jle	 SHORT $LN263@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00438	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0043b	eb 07		 jmp	 SHORT $LN264@Parse_int_
$LN263@Parse_int_:
  0043d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0043f	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00442	ff d0		 call	 eax
$LN264@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00444	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00447	74 05		 je	 SHORT $LN259@Parse_int_

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00449	88 47 05	 mov	 BYTE PTR [edi+5], al
  0044c	eb 06		 jmp	 SHORT $LN258@Parse_int_
$LN259@Parse_int_:

; 471  :             _Strbuf = nullptr;

  0044e	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN258@Parse_int_:

; 476  :         _Got = true;

  00454	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN224@Parse_int_:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  00458	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0045a	8b 07		 mov	 eax, DWORD PTR [edi]
  0045c	85 c9		 test	 ecx, ecx
  0045e	75 20		 jne	 SHORT $LN1247@Parse_int_
  00460	85 c0		 test	 eax, eax
  00462	75 20		 jne	 SHORT $LN1229@Parse_int_
$LN228@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 702  :         _Basefield &= ios_base::basefield;

  00464	8b 45 14	 mov	 eax, DWORD PTR __Basefield$[ebp]
  00467	25 00 0e 00 00	 and	 eax, 3584		; 00000e00H

; 703  : 
; 704  :         int8_t _Base;
; 705  :         if (_Basefield == ios_base::oct) {

  0046c	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  00471	0f 85 a6 00 00
	00		 jne	 $LN20@Parse_int_

; 706  :             _Base = 8;

  00477	c6 45 14 08	 mov	 BYTE PTR __Basefield$[ebp], 8
  0047b	e9 b6 00 00 00	 jmp	 $LN24@Parse_int_
$LN1247@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  00480	85 c0		 test	 eax, eax
  00482	75 e0		 jne	 SHORT $LN228@Parse_int_
$LN1229@Parse_int_:

; 406  :         if (!_Got) {

  00484	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  00488	75 35		 jne	 SHORT $LN1261@Parse_int_

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0048a	85 c9		 test	 ecx, ecx
  0048c	74 27		 je	 SHORT $LN364@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  0048e	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00491	8b 10		 mov	 edx, DWORD PTR [eax]
  00493	85 d2		 test	 edx, edx
  00495	74 0d		 je	 SHORT $LN368@Parse_int_
  00497	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0049a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0049d	7e 05		 jle	 SHORT $LN368@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0049f	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  004a2	eb 07		 jmp	 SHORT $LN369@Parse_int_
$LN368@Parse_int_:
  004a4	8b 01		 mov	 eax, DWORD PTR [ecx]
  004a6	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  004a9	ff d0		 call	 eax
$LN369@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  004ab	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  004ae	74 05		 je	 SHORT $LN364@Parse_int_

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  004b0	88 46 05	 mov	 BYTE PTR [esi+5], al
  004b3	eb 06		 jmp	 SHORT $LN363@Parse_int_
$LN364@Parse_int_:

; 471  :             _Strbuf = nullptr;

  004b5	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN363@Parse_int_:

; 476  :         _Got = true;

  004bb	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN1261@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 696  :             while (_First != _Last && *_First == _Kseparator) {

  004bf	8a 45 a3	 mov	 al, BYTE PTR __Kseparator$1$[ebp]
  004c2	38 46 05	 cmp	 BYTE PTR [esi+5], al
  004c5	75 9d		 jne	 SHORT $LN228@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  004c7	8b 0e		 mov	 ecx, DWORD PTR [esi]
  004c9	85 c9		 test	 ecx, ecx
  004cb	74 3d		 je	 SHORT $LN421@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  004cd	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  004d0	83 38 00	 cmp	 DWORD PTR [eax], 0
  004d3	74 1b		 je	 SHORT $LN1258@Parse_int_
  004d5	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  004d8	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  004da	85 c0		 test	 eax, eax
  004dc	7e 12		 jle	 SHORT $LN1258@Parse_int_

; 222  :         --*_IGcount;

  004de	48		 dec	 eax
  004df	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  004e1	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  004e4	8b 11		 mov	 edx, DWORD PTR [ecx]
  004e6	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  004e9	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  004eb	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  004ee	eb 07		 jmp	 SHORT $LN426@Parse_int_
$LN1258@Parse_int_:
  004f0	8b 01		 mov	 eax, DWORD PTR [ecx]
  004f2	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  004f5	ff d0		 call	 eax
$LN426@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  004f7	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  004fa	74 0e		 je	 SHORT $LN421@Parse_int_

; 464  :             _Got = false;

  004fc	32 c0		 xor	 al, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 698  :                 _Bad_grouping = true;

  004fe	c6 45 a2 01	 mov	 BYTE PTR __Bad_grouping$1$[ebp], 1
  00502	88 46 04	 mov	 BYTE PTR [esi+4], al

; 699  :             }

  00505	e9 d6 fe ff ff	 jmp	 $LL4@Parse_int_
$LN421@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 462  :             _Got    = true;

  0050a	b0 01		 mov	 al, 1
  0050c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 698  :                 _Bad_grouping = true;

  00512	88 46 04	 mov	 BYTE PTR [esi+4], al
  00515	88 45 a2	 mov	 BYTE PTR __Bad_grouping$1$[ebp], al

; 699  :             }

  00518	e9 c3 fe ff ff	 jmp	 $LL4@Parse_int_
$LN20@Parse_int_:

; 707  :         } else if (_Basefield == ios_base::hex) {

  0051d	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  00522	75 06		 jne	 SHORT $LN22@Parse_int_

; 708  :             _Base = 16;

  00524	c6 45 14 10	 mov	 BYTE PTR __Basefield$[ebp], 16 ; 00000010H
  00528	eb 0c		 jmp	 SHORT $LN24@Parse_int_
$LN22@Parse_int_:

; 709  :         } else if (_Basefield == ios_base::_Fmtzero) {

  0052a	f7 d8		 neg	 eax
  0052c	1a c0		 sbb	 al, al
  0052e	25 0a ff ff ff	 and	 eax, -246		; ffffff0aH
  00533	89 45 14	 mov	 DWORD PTR __Basefield$[ebp], eax
$LN24@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 437  :         if (!_Got) {

  00536	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 715  :         bool _Seendigit = false; // seen a digit in input

  0053a	c6 45 a1 00	 mov	 BYTE PTR __Seendigit$1$[ebp], 0

; 716  :         bool _Nonzero   = false; // seen a nonzero digit in input

  0053e	c6 45 9b 00	 mov	 BYTE PTR __Nonzero$1$[ebp], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 437  :         if (!_Got) {

  00542	75 37		 jne	 SHORT $LN636@Parse_int_

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00544	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00546	85 c9		 test	 ecx, ecx
  00548	74 27		 je	 SHORT $LN646@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  0054a	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0054d	8b 10		 mov	 edx, DWORD PTR [eax]
  0054f	85 d2		 test	 edx, edx
  00551	74 0d		 je	 SHORT $LN650@Parse_int_
  00553	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00556	83 38 00	 cmp	 DWORD PTR [eax], 0
  00559	7e 05		 jle	 SHORT $LN650@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0055b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0055e	eb 07		 jmp	 SHORT $LN651@Parse_int_
$LN650@Parse_int_:
  00560	8b 01		 mov	 eax, DWORD PTR [ecx]
  00562	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00565	ff d0		 call	 eax
$LN651@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00567	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0056a	74 05		 je	 SHORT $LN646@Parse_int_

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  0056c	88 46 05	 mov	 BYTE PTR [esi+5], al
  0056f	eb 06		 jmp	 SHORT $LN645@Parse_int_
$LN646@Parse_int_:

; 471  :             _Strbuf = nullptr;

  00571	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN645@Parse_int_:

; 476  :         _Got = true;

  00577	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN636@Parse_int_:

; 441  :         if (!_Right._Got) {

  0057b	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  0057f	75 37		 jne	 SHORT $LN637@Parse_int_

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00581	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00583	85 c9		 test	 ecx, ecx
  00585	74 27		 je	 SHORT $LN672@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00587	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0058a	8b 10		 mov	 edx, DWORD PTR [eax]
  0058c	85 d2		 test	 edx, edx
  0058e	74 0d		 je	 SHORT $LN676@Parse_int_
  00590	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00593	83 38 00	 cmp	 DWORD PTR [eax], 0
  00596	7e 05		 jle	 SHORT $LN676@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00598	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0059b	eb 07		 jmp	 SHORT $LN677@Parse_int_
$LN676@Parse_int_:
  0059d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0059f	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  005a2	ff d0		 call	 eax
$LN677@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  005a4	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  005a7	74 05		 je	 SHORT $LN672@Parse_int_

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  005a9	88 47 05	 mov	 BYTE PTR [edi+5], al
  005ac	eb 06		 jmp	 SHORT $LN671@Parse_int_
$LN672@Parse_int_:

; 471  :             _Strbuf = nullptr;

  005ae	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN671@Parse_int_:

; 476  :         _Got = true;

  005b4	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN637@Parse_int_:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  005b8	8b 0e		 mov	 ecx, DWORD PTR [esi]
  005ba	8b 07		 mov	 eax, DWORD PTR [edi]
  005bc	85 c9		 test	 ecx, ecx
  005be	75 3a		 jne	 SHORT $LN1246@Parse_int_
  005c0	85 c0		 test	 eax, eax
  005c2	75 3a		 jne	 SHORT $LN1232@Parse_int_
$LN1280@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 731  :         const auto _Dlen = static_cast<size_t>(_Base == 0 || _Base == 10 ? 10 : _Base == 8 ? 8 : 16 + 6);

  005c4	8b 4d 14	 mov	 ecx, DWORD PTR __Basefield$[ebp]
$LN31@Parse_int_:
  005c7	88 4d a0	 mov	 BYTE PTR tv5679[ebp], cl
  005ca	8a c1		 mov	 al, cl
  005cc	84 c9		 test	 cl, cl
  005ce	0f 84 49 02 00
	00		 je	 $LN55@Parse_int_
  005d4	8a 55 a1	 mov	 dl, BYTE PTR __Seendigit$1$[ebp]
  005d7	88 55 a1	 mov	 BYTE PTR __Seendigit$1$[ebp], dl
  005da	80 f9 0a	 cmp	 cl, 10			; 0000000aH
  005dd	0f 84 3a 02 00
	00		 je	 $LN55@Parse_int_
$LN1273@Parse_int_:
  005e3	b8 08 00 00 00	 mov	 eax, 8
  005e8	ba 16 00 00 00	 mov	 edx, 22			; 00000016H
  005ed	3a c8		 cmp	 cl, al
  005ef	0f 44 d0	 cmove	 edx, eax
  005f2	89 55 80	 mov	 DWORD PTR __Dlen$1$[ebp], edx
  005f5	e9 32 02 00 00	 jmp	 $LN56@Parse_int_
$LN1246@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  005fa	85 c0		 test	 eax, eax
  005fc	75 c6		 jne	 SHORT $LN1280@Parse_int_
$LN1232@Parse_int_:

; 406  :         if (!_Got) {

  005fe	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  00602	75 35		 jne	 SHORT $LN1262@Parse_int_

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00604	85 c9		 test	 ecx, ecx
  00606	74 27		 je	 SHORT $LN858@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00608	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0060b	8b 10		 mov	 edx, DWORD PTR [eax]
  0060d	85 d2		 test	 edx, edx
  0060f	74 0d		 je	 SHORT $LN862@Parse_int_
  00611	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00614	83 38 00	 cmp	 DWORD PTR [eax], 0
  00617	7e 05		 jle	 SHORT $LN862@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00619	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0061c	eb 07		 jmp	 SHORT $LN863@Parse_int_
$LN862@Parse_int_:
  0061e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00620	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00623	ff d0		 call	 eax
$LN863@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00625	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00628	74 05		 je	 SHORT $LN858@Parse_int_

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  0062a	88 46 05	 mov	 BYTE PTR [esi+5], al
  0062d	eb 06		 jmp	 SHORT $LN857@Parse_int_
$LN858@Parse_int_:

; 471  :             _Strbuf = nullptr;

  0062f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN857@Parse_int_:

; 476  :         _Got = true;

  00635	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN1262@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 718  :         if (_First != _Last && *_First == _Atoms[0]) { // leading zero, look for 0x, 0X

  00639	8a 46 05	 mov	 al, BYTE PTR [esi+5]
  0063c	3a 45 d4	 cmp	 al, BYTE PTR __Atoms$[ebp]
  0063f	75 83		 jne	 SHORT $LN1280@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00641	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 719  :             _Seendigit = true;

  00643	c6 45 a1 01	 mov	 BYTE PTR __Seendigit$1$[ebp], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00647	85 c9		 test	 ecx, ecx
  00649	74 60		 je	 SHORT $LN1011@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  0064b	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0064e	83 38 00	 cmp	 DWORD PTR [eax], 0
  00651	74 1b		 je	 SHORT $LN1015@Parse_int_
  00653	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00656	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  00658	85 c0		 test	 eax, eax
  0065a	7e 12		 jle	 SHORT $LN1015@Parse_int_

; 222  :         --*_IGcount;

  0065c	48		 dec	 eax
  0065d	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  0065f	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00662	8b 11		 mov	 edx, DWORD PTR [ecx]
  00664	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00667	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00669	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  0066c	eb 07		 jmp	 SHORT $LN1016@Parse_int_
$LN1015@Parse_int_:
  0066e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00670	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00673	ff d0		 call	 eax
$LN1016@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00675	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00678	74 31		 je	 SHORT $LN1011@Parse_int_

; 464  :             _Got = false;

  0067a	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0067e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00680	85 c9		 test	 ecx, ecx
  00682	74 27		 je	 SHORT $LN1011@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00684	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00687	8b 10		 mov	 edx, DWORD PTR [eax]
  00689	85 d2		 test	 edx, edx
  0068b	74 0d		 je	 SHORT $LN961@Parse_int_
  0068d	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00690	83 38 00	 cmp	 DWORD PTR [eax], 0
  00693	7e 05		 jle	 SHORT $LN961@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00695	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00698	eb 07		 jmp	 SHORT $LN962@Parse_int_
$LN961@Parse_int_:
  0069a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0069c	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0069f	ff d0		 call	 eax
$LN962@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  006a1	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  006a4	74 05		 je	 SHORT $LN1011@Parse_int_

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  006a6	88 46 05	 mov	 BYTE PTR [esi+5], al
  006a9	eb 06		 jmp	 SHORT $LN956@Parse_int_
$LN1011@Parse_int_:

; 441  :         if (!_Right._Got) {

  006ab	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN956@Parse_int_:
  006b1	b0 01		 mov	 al, 1
  006b3	88 46 04	 mov	 BYTE PTR [esi+4], al
  006b6	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  006ba	75 37		 jne	 SHORT $LN948@Parse_int_

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  006bc	8b 0f		 mov	 ecx, DWORD PTR [edi]
  006be	85 c9		 test	 ecx, ecx
  006c0	74 27		 je	 SHORT $LN983@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  006c2	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  006c5	8b 10		 mov	 edx, DWORD PTR [eax]
  006c7	85 d2		 test	 edx, edx
  006c9	74 0d		 je	 SHORT $LN987@Parse_int_
  006cb	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  006ce	83 38 00	 cmp	 DWORD PTR [eax], 0
  006d1	7e 05		 jle	 SHORT $LN987@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  006d3	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  006d6	eb 07		 jmp	 SHORT $LN988@Parse_int_
$LN987@Parse_int_:
  006d8	8b 01		 mov	 eax, DWORD PTR [ecx]
  006da	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  006dd	ff d0		 call	 eax
$LN988@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  006df	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  006e2	74 05		 je	 SHORT $LN983@Parse_int_

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  006e4	88 47 05	 mov	 BYTE PTR [edi+5], al
  006e7	eb 06		 jmp	 SHORT $LN982@Parse_int_
$LN983@Parse_int_:

; 471  :             _Strbuf = nullptr;

  006e9	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN982@Parse_int_:

; 476  :         _Got = true;

  006ef	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN948@Parse_int_:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  006f3	8b 0e		 mov	 ecx, DWORD PTR [esi]
  006f5	8b 07		 mov	 eax, DWORD PTR [edi]
  006f7	85 c9		 test	 ecx, ecx
  006f9	75 1c		 jne	 SHORT $LN1245@Parse_int_
  006fb	85 c0		 test	 eax, eax
  006fd	75 1c		 jne	 SHORT $LN951@Parse_int_
$LN27@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 726  :             } else if (_Base == 0) {

  006ff	8b 4d 14	 mov	 ecx, DWORD PTR __Basefield$[ebp]
  00702	84 c9		 test	 cl, cl
  00704	0f 85 bd fe ff
	ff		 jne	 $LN31@Parse_int_

; 727  :                 _Base = 8;

  0070a	b1 08		 mov	 cl, 8
  0070c	89 4d 14	 mov	 DWORD PTR __Basefield$[ebp], ecx
  0070f	88 4d a0	 mov	 BYTE PTR tv5679[ebp], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 476  :         _Got = true;

  00712	e9 cc fe ff ff	 jmp	 $LN1273@Parse_int_
$LN1245@Parse_int_:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  00717	85 c0		 test	 eax, eax
  00719	75 e4		 jne	 SHORT $LN27@Parse_int_
$LN951@Parse_int_:

; 406  :         if (!_Got) {

  0071b	8a 56 04	 mov	 dl, BYTE PTR [esi+4]
  0071e	84 d2		 test	 dl, dl
  00720	75 37		 jne	 SHORT $LN1111@Parse_int_

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00722	85 c9		 test	 ecx, ecx
  00724	74 27		 je	 SHORT $LN1116@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00726	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00729	8b 10		 mov	 edx, DWORD PTR [eax]
  0072b	85 d2		 test	 edx, edx
  0072d	74 0d		 je	 SHORT $LN1120@Parse_int_
  0072f	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00732	83 38 00	 cmp	 DWORD PTR [eax], 0
  00735	7e 05		 jle	 SHORT $LN1120@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00737	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0073a	eb 07		 jmp	 SHORT $LN1121@Parse_int_
$LN1120@Parse_int_:
  0073c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0073e	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00741	ff d0		 call	 eax
$LN1121@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00743	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00746	74 05		 je	 SHORT $LN1116@Parse_int_

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00748	88 46 05	 mov	 BYTE PTR [esi+5], al
  0074b	eb 06		 jmp	 SHORT $LN1115@Parse_int_
$LN1116@Parse_int_:

; 471  :             _Strbuf = nullptr;

  0074d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1115@Parse_int_:

; 476  :         _Got = true;

  00753	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
  00757	b2 01		 mov	 dl, 1
$LN1111@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 722  :                 && (_Base == 0 || _Base == 16)) {

  00759	8a 46 05	 mov	 al, BYTE PTR [esi+5]
  0075c	3a 45 ed	 cmp	 al, BYTE PTR __Atoms$[ebp+25]
  0075f	74 47		 je	 SHORT $LN29@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 406  :         if (!_Got) {

  00761	84 d2		 test	 dl, dl
  00763	75 3a		 jne	 SHORT $LN1265@Parse_int_

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00765	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00767	85 c9		 test	 ecx, ecx
  00769	74 27		 je	 SHORT $LN1263@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  0076b	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0076e	8b 10		 mov	 edx, DWORD PTR [eax]
  00770	85 d2		 test	 edx, edx
  00772	74 0d		 je	 SHORT $LN1264@Parse_int_
  00774	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00777	83 38 00	 cmp	 DWORD PTR [eax], 0
  0077a	7e 05		 jle	 SHORT $LN1264@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0077c	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0077f	eb 07		 jmp	 SHORT $LN1175@Parse_int_
$LN1264@Parse_int_:
  00781	8b 01		 mov	 eax, DWORD PTR [ecx]
  00783	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00786	ff d0		 call	 eax
$LN1175@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00788	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0078b	74 05		 je	 SHORT $LN1263@Parse_int_

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  0078d	88 46 05	 mov	 BYTE PTR [esi+5], al
  00790	eb 09		 jmp	 SHORT $LN1169@Parse_int_
$LN1263@Parse_int_:

; 471  :             _Strbuf = nullptr;

  00792	8a 46 05	 mov	 al, BYTE PTR [esi+5]
  00795	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1169@Parse_int_:

; 476  :         _Got = true;

  0079b	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN1265@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 722  :                 && (_Base == 0 || _Base == 16)) {

  0079f	3a 45 ec	 cmp	 al, BYTE PTR __Atoms$[ebp+24]
  007a2	0f 85 57 ff ff
	ff		 jne	 $LN27@Parse_int_
$LN29@Parse_int_:
  007a8	8b 4d 14	 mov	 ecx, DWORD PTR __Basefield$[ebp]
  007ab	84 c9		 test	 cl, cl
  007ad	74 09		 je	 SHORT $LN30@Parse_int_
  007af	80 f9 10	 cmp	 cl, 16			; 00000010H
  007b2	0f 85 0f fe ff
	ff		 jne	 $LN31@Parse_int_
$LN30@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  007b8	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 723  :                 _Base      = 16;

  007ba	c6 45 14 10	 mov	 BYTE PTR __Basefield$[ebp], 16 ; 00000010H

; 724  :                 _Seendigit = false;

  007be	c6 45 a1 00	 mov	 BYTE PTR __Seendigit$1$[ebp], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  007c2	85 c9		 test	 ecx, ecx
  007c4	74 40		 je	 SHORT $LN1144@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  007c6	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  007c9	83 38 00	 cmp	 DWORD PTR [eax], 0
  007cc	74 1b		 je	 SHORT $LN1148@Parse_int_
  007ce	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  007d1	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  007d3	85 c0		 test	 eax, eax
  007d5	7e 12		 jle	 SHORT $LN1148@Parse_int_

; 222  :         --*_IGcount;

  007d7	48		 dec	 eax
  007d8	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  007da	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  007dd	8b 11		 mov	 edx, DWORD PTR [ecx]
  007df	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  007e2	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  007e4	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  007e7	eb 07		 jmp	 SHORT $LN1149@Parse_int_
$LN1148@Parse_int_:
  007e9	8b 01		 mov	 eax, DWORD PTR [ecx]
  007eb	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  007ee	ff d0		 call	 eax
$LN1149@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  007f0	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  007f3	74 11		 je	 SHORT $LN1144@Parse_int_

; 424  :     }

  007f5	8b 4d 14	 mov	 ecx, DWORD PTR __Basefield$[ebp]

; 464  :             _Got = false;

  007f8	32 c0		 xor	 al, al

; 424  :     }

  007fa	88 46 04	 mov	 BYTE PTR [esi+4], al
  007fd	c6 45 a0 10	 mov	 BYTE PTR tv5679[ebp], 16 ; 00000010H
  00801	e9 dd fd ff ff	 jmp	 $LN1273@Parse_int_
$LN1144@Parse_int_:
  00806	8b 4d 14	 mov	 ecx, DWORD PTR __Basefield$[ebp]

; 462  :             _Got    = true;

  00809	b0 01		 mov	 al, 1
  0080b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 424  :     }

  00811	88 46 04	 mov	 BYTE PTR [esi+4], al
  00814	c6 45 a0 10	 mov	 BYTE PTR tv5679[ebp], 16 ; 00000010H
  00818	e9 c6 fd ff ff	 jmp	 $LN1273@Parse_int_
$LN55@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 731  :         const auto _Dlen = static_cast<size_t>(_Base == 0 || _Base == 10 ? 10 : _Base == 8 ? 8 : 16 + 6);

  0081d	8a c8		 mov	 cl, al
  0081f	c7 45 80 0a 00
	00 00		 mov	 DWORD PTR __Dlen$1$[ebp], 10 ; 0000000aH
  00826	89 4d 14	 mov	 DWORD PTR __Basefield$[ebp], ecx
  00829	88 45 a0	 mov	 BYTE PTR tv5679[ebp], al
$LN56@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 493  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  0082c	0f b6 4d a1	 movzx	 ecx, BYTE PTR __Seendigit$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 891  :             _My_data._Myres  = _Small_string_capacity;

  00830	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH
  00835	89 45 94	 mov	 DWORD PTR __Groups$1$[ebp], eax
  00838	0f 57 c0	 xorps	 xmm0, xmm0
  0083b	89 45 d0	 mov	 DWORD PTR __Groups$[ebp+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 493  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  0083e	8b c1		 mov	 eax, ecx
  00840	66 c1 e1 08	 shl	 cx, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00844	0f 11 45 bc	 movups	 XMMWORD PTR __Groups$[ebp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 493  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  00848	66 0b c8	 or	 cx, ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 890  :             _My_data._Mysize = _Count;

  0084b	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR __Groups$[ebp+16], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 493  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  00852	88 4d bc	 mov	 BYTE PTR __Groups$[ebp], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 895  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  00855	c6 45 bd 00	 mov	 BYTE PTR __Groups$[ebp+1], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 735  :         for (char* const _Pe = &_Ac[_Max_int_dig - 1]; _First != _Last; ++_First) { // look for digits and separators

  00859	8b 45 9c	 mov	 eax, DWORD PTR __Ac$GSCopy$1$[ebp]
  0085c	83 c0 1f	 add	 eax, 31			; 0000001fH
  0085f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00863	89 85 74 ff ff
	ff		 mov	 DWORD PTR __Pe$1$[ebp], eax
  00869	8b 45 bc	 mov	 eax, DWORD PTR __Groups$[ebp]
  0086c	c7 45 90 00 00
	00 00		 mov	 DWORD PTR __Groups_arr_idx$1$[ebp], 0
  00873	89 45 9c	 mov	 DWORD PTR __Ptr$1$[ebp], eax
$LL8@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 437  :         if (!_Got) {

  00876	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  0087a	75 37		 jne	 SHORT $LN471@Parse_int_

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0087c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0087e	85 c9		 test	 ecx, ecx
  00880	74 27		 je	 SHORT $LN481@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00882	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00885	8b 10		 mov	 edx, DWORD PTR [eax]
  00887	85 d2		 test	 edx, edx
  00889	74 0d		 je	 SHORT $LN485@Parse_int_
  0088b	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0088e	83 38 00	 cmp	 DWORD PTR [eax], 0
  00891	7e 05		 jle	 SHORT $LN485@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00893	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00896	eb 07		 jmp	 SHORT $LN486@Parse_int_
$LN485@Parse_int_:
  00898	8b 01		 mov	 eax, DWORD PTR [ecx]
  0089a	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0089d	ff d0		 call	 eax
$LN486@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  0089f	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  008a2	74 05		 je	 SHORT $LN481@Parse_int_

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  008a4	88 46 05	 mov	 BYTE PTR [esi+5], al
  008a7	eb 06		 jmp	 SHORT $LN480@Parse_int_
$LN481@Parse_int_:

; 471  :             _Strbuf = nullptr;

  008a9	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN480@Parse_int_:

; 476  :         _Got = true;

  008af	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN471@Parse_int_:

; 441  :         if (!_Right._Got) {

  008b3	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  008b7	75 37		 jne	 SHORT $LN472@Parse_int_

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  008b9	8b 0f		 mov	 ecx, DWORD PTR [edi]
  008bb	85 c9		 test	 ecx, ecx
  008bd	74 27		 je	 SHORT $LN507@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  008bf	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  008c2	8b 10		 mov	 edx, DWORD PTR [eax]
  008c4	85 d2		 test	 edx, edx
  008c6	74 0d		 je	 SHORT $LN511@Parse_int_
  008c8	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  008cb	83 38 00	 cmp	 DWORD PTR [eax], 0
  008ce	7e 05		 jle	 SHORT $LN511@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  008d0	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  008d3	eb 07		 jmp	 SHORT $LN512@Parse_int_
$LN511@Parse_int_:
  008d5	8b 01		 mov	 eax, DWORD PTR [ecx]
  008d7	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  008da	ff d0		 call	 eax
$LN512@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  008dc	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  008df	74 05		 je	 SHORT $LN507@Parse_int_

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  008e1	88 47 05	 mov	 BYTE PTR [edi+5], al
  008e4	eb 06		 jmp	 SHORT $LN506@Parse_int_
$LN507@Parse_int_:

; 471  :             _Strbuf = nullptr;

  008e6	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN506@Parse_int_:

; 476  :         _Got = true;

  008ec	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN472@Parse_int_:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  008f0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  008f2	8b 07		 mov	 eax, DWORD PTR [edi]
  008f4	85 c9		 test	 ecx, ecx
  008f6	75 30		 jne	 SHORT $LN1244@Parse_int_
  008f8	85 c0		 test	 eax, eax
  008fa	75 30		 jne	 SHORT $LN475@Parse_int_
$LN1283@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 758  :         if (_Groups_arr_idx != 0) {

  008fc	8a 75 a3	 mov	 dh, BYTE PTR __Kseparator$1$[ebp]
$LN1208@Parse_int_:
  008ff	8b 4d 90	 mov	 ecx, DWORD PTR __Groups_arr_idx$1$[ebp]
  00902	85 c9		 test	 ecx, ecx
  00904	0f 84 c3 02 00
	00		 je	 $LN44@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  0090a	83 7d 94 0f	 cmp	 DWORD PTR __Groups$1$[ebp], 15 ; 0000000fH

; 435  :         value_type* _Result = _Bx._Buf;

  0090e	8d 45 bc	 lea	 eax, DWORD PTR __Groups$[ebp]

; 436  :         if (_Large_mode_engaged()) {

  00911	0f 47 45 9c	 cmova	 eax, DWORD PTR __Ptr$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 759  :             if (_Groups[_Groups_arr_idx] > '\0') {

  00915	80 3c 08 00	 cmp	 BYTE PTR [eax+ecx], 0
  00919	0f 8e a9 02 00
	00		 jle	 $LN43@Parse_int_

; 760  :                 ++_Groups_arr_idx; // add trailing group to group count

  0091f	41		 inc	 ecx
  00920	89 4d 90	 mov	 DWORD PTR __Groups_arr_idx$1$[ebp], ecx

; 761  :             } else {

  00923	e9 a5 02 00 00	 jmp	 $LN44@Parse_int_
$LN1244@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  00928	85 c0		 test	 eax, eax
  0092a	75 d0		 jne	 SHORT $LN1283@Parse_int_
$LN475@Parse_int_:

; 406  :         if (!_Got) {

  0092c	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  00930	75 35		 jne	 SHORT $LN1266@Parse_int_

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00932	85 c9		 test	 ecx, ecx
  00934	74 27		 je	 SHORT $LN195@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00936	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00939	8b 10		 mov	 edx, DWORD PTR [eax]
  0093b	85 d2		 test	 edx, edx
  0093d	74 0d		 je	 SHORT $LN199@Parse_int_
  0093f	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00942	83 38 00	 cmp	 DWORD PTR [eax], 0
  00945	7e 05		 jle	 SHORT $LN199@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00947	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0094a	eb 07		 jmp	 SHORT $LN200@Parse_int_
$LN199@Parse_int_:
  0094c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0094e	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00951	ff d0		 call	 eax
$LN200@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00953	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00956	74 05		 je	 SHORT $LN195@Parse_int_

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00958	88 46 05	 mov	 BYTE PTR [esi+5], al
  0095b	eb 06		 jmp	 SHORT $LN194@Parse_int_
$LN195@Parse_int_:

; 471  :             _Strbuf = nullptr;

  0095d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN194@Parse_int_:

; 476  :         _Got = true;

  00963	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN1266@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 6127 :             const auto _Result    = _STD _Find_vectorized(_First_ptr, _STD _To_address(_Last), _Val);

  00967	8a 46 05	 mov	 al, BYTE PTR [esi+5]
  0096a	88 85 70 ff ff
	ff		 mov	 BYTE PTR $T2[ebp], al

; 200  :         return const_cast<_Ty*>(

  00970	8d 45 ee	 lea	 eax, DWORD PTR __Atoms$[ebp+26]
  00973	ff b5 70 ff ff
	ff		 push	 DWORD PTR $T2[ebp]
  00979	50		 push	 eax
  0097a	8d 45 d4	 lea	 eax, DWORD PTR __Atoms$[ebp]
  0097d	50		 push	 eax
  0097e	e8 00 00 00 00	 call	 ___std_find_trivial_1@12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 70   :     return static_cast<size_t>(_STD _Find_unchecked(_Base, _Base + (_Base_size - 1), _Ch) - _Base);

  00983	8d 4d d4	 lea	 ecx, DWORD PTR __Atoms$[ebp]
  00986	2b c1		 sub	 eax, ecx

; 736  :             size_t _Idx = _STD _Find_elem(_Atoms, *_First);
; 737  :             if (_Idx < _Dlen) { // got a digit, characterize it and add to group size

  00988	3b 45 80	 cmp	 eax, DWORD PTR __Dlen$1$[ebp]
  0098b	73 5e		 jae	 SHORT $LN32@Parse_int_

; 738  :                 *_Ptr = _Src[_Idx];
; 739  :                 if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe) {

  0098d	80 7d 9b 00	 cmp	 BYTE PTR __Nonzero$1$[ebp], 0
  00991	8b 4d 8c	 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
  00994	8a 80 00 00 00
	00		 mov	 al, BYTE PTR ?_Src@?1???$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@2@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z@4QBDB[eax]
  0099a	88 01		 mov	 BYTE PTR [ecx], al
  0099c	75 04		 jne	 SHORT $LN35@Parse_int_
  0099e	3c 30		 cmp	 al, 48			; 00000030H
  009a0	74 10		 je	 SHORT $LN34@Parse_int_
$LN35@Parse_int_:
  009a2	3b 8d 74 ff ff
	ff		 cmp	 ecx, DWORD PTR __Pe$1$[ebp]
  009a8	73 08		 jae	 SHORT $LN34@Parse_int_

; 740  :                     ++_Ptr;

  009aa	41		 inc	 ecx

; 741  :                     _Nonzero = true;

  009ab	c6 45 9b 01	 mov	 BYTE PTR __Nonzero$1$[ebp], 1
  009af	89 4d 8c	 mov	 DWORD PTR __Ptr$1$[ebp], ecx
$LN34@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  009b2	8b 55 94	 mov	 edx, DWORD PTR __Groups$1$[ebp]

; 435  :         value_type* _Result = _Bx._Buf;

  009b5	8d 45 bc	 lea	 eax, DWORD PTR __Groups$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 745  :                 if (_Groups[_Groups_arr_idx] != CHAR_MAX) {

  009b8	8b 4d 90	 mov	 ecx, DWORD PTR __Groups_arr_idx$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  009bb	83 fa 0f	 cmp	 edx, 15			; 0000000fH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 744  :                 _Seendigit = true;

  009be	c6 45 a1 01	 mov	 BYTE PTR __Seendigit$1$[ebp], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 436  :         if (_Large_mode_engaged()) {

  009c2	0f 47 45 9c	 cmova	 eax, DWORD PTR __Ptr$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 745  :                 if (_Groups[_Groups_arr_idx] != CHAR_MAX) {

  009c6	80 3c 08 7f	 cmp	 BYTE PTR [eax+ecx], 127	; 0000007fH
  009ca	0f 84 ab 01 00
	00		 je	 $LN6@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  009d0	83 fa 0f	 cmp	 edx, 15			; 0000000fH

; 435  :         value_type* _Result = _Bx._Buf;

  009d3	8d 45 bc	 lea	 eax, DWORD PTR __Groups$[ebp]

; 436  :         if (_Large_mode_engaged()) {

  009d6	0f 47 45 9c	 cmova	 eax, DWORD PTR __Ptr$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 746  :                     ++_Groups[_Groups_arr_idx];

  009da	fe 04 08	 inc	 BYTE PTR [eax+ecx]

; 747  :                 }

  009dd	8b 45 d0	 mov	 eax, DWORD PTR __Groups$[ebp+20]
  009e0	89 45 94	 mov	 DWORD PTR __Groups$1$[ebp], eax
  009e3	8b 45 bc	 mov	 eax, DWORD PTR __Groups$[ebp]
  009e6	e9 8d 01 00 00	 jmp	 $LN1291@Parse_int_
$LN32@Parse_int_:

; 748  :             } else if (_Kseparator == _Elem{} || *_First != _Kseparator) {

  009eb	8a 75 a3	 mov	 dh, BYTE PTR __Kseparator$1$[ebp]
  009ee	84 f6		 test	 dh, dh
  009f0	0f 84 09 ff ff
	ff		 je	 $LN1208@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 406  :         if (!_Got) {

  009f6	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  009fa	75 3a		 jne	 SHORT $LN1267@Parse_int_

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  009fc	8b 0e		 mov	 ecx, DWORD PTR [esi]
  009fe	85 c9		 test	 ecx, ecx
  00a00	74 27		 je	 SHORT $LN581@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00a02	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00a05	8b 10		 mov	 edx, DWORD PTR [eax]
  00a07	85 d2		 test	 edx, edx
  00a09	74 0d		 je	 SHORT $LN585@Parse_int_
  00a0b	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00a0e	83 38 00	 cmp	 DWORD PTR [eax], 0
  00a11	7e 05		 jle	 SHORT $LN585@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00a13	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00a16	eb 07		 jmp	 SHORT $LN586@Parse_int_
$LN585@Parse_int_:
  00a18	8b 01		 mov	 eax, DWORD PTR [ecx]
  00a1a	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00a1d	ff d0		 call	 eax
$LN586@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00a1f	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00a22	74 05		 je	 SHORT $LN581@Parse_int_

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00a24	88 46 05	 mov	 BYTE PTR [esi+5], al
  00a27	eb 06		 jmp	 SHORT $LN580@Parse_int_
$LN581@Parse_int_:

; 471  :             _Strbuf = nullptr;

  00a29	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN580@Parse_int_:
  00a2f	8a 75 a3	 mov	 dh, BYTE PTR __Kseparator$1$[ebp]

; 476  :         _Got = true;

  00a32	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN1267@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 748  :             } else if (_Kseparator == _Elem{} || *_First != _Kseparator) {

  00a36	38 76 05	 cmp	 BYTE PTR [esi+5], dh
  00a39	0f 85 c0 fe ff
	ff		 jne	 $LN1208@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00a3f	8b 55 94	 mov	 edx, DWORD PTR __Groups$1$[ebp]

; 435  :         value_type* _Result = _Bx._Buf;

  00a42	8d 45 bc	 lea	 eax, DWORD PTR __Groups$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 750  :             } else if (_Groups[_Groups_arr_idx] == '\0') {

  00a45	8b 4d 90	 mov	 ecx, DWORD PTR __Groups_arr_idx$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00a48	83 fa 0f	 cmp	 edx, 15			; 0000000fH

; 436  :         if (_Large_mode_engaged()) {

  00a4b	0f 47 45 9c	 cmova	 eax, DWORD PTR __Ptr$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 750  :             } else if (_Groups[_Groups_arr_idx] == '\0') {

  00a4f	80 3c 08 00	 cmp	 BYTE PTR [eax+ecx], 0
  00a53	75 09		 jne	 SHORT $LN40@Parse_int_

; 751  :                 _Bad_grouping = true; // adjacent separators, fail

  00a55	c6 45 a2 01	 mov	 BYTE PTR __Bad_grouping$1$[ebp], 1

; 752  :             } else { // add a new group to _Groups string

  00a59	e9 1d 01 00 00	 jmp	 $LN6@Parse_int_
$LN40@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00a5e	8b 7d cc	 mov	 edi, DWORD PTR __Groups$[ebp+16]
  00a61	3b fa		 cmp	 edi, edx

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

  00a63	73 24		 jae	 SHORT $LN882@Parse_int_

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  00a65	8d 47 01	 lea	 eax, DWORD PTR [edi+1]

; 453  :         return _Myres > _Small_string_capacity;

  00a68	83 fa 0f	 cmp	 edx, 15			; 0000000fH

; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  00a6b	89 45 cc	 mov	 DWORD PTR __Groups$[ebp+16], eax

; 435  :         value_type* _Result = _Bx._Buf;

  00a6e	8d 45 bc	 lea	 eax, DWORD PTR __Groups$[ebp]

; 436  :         if (_Large_mode_engaged()) {

  00a71	0f 47 45 9c	 cmova	 eax, DWORD PTR __Ptr$1$[ebp]

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

  00a75	66 c7 04 38 00
	00		 mov	 WORD PTR [eax+edi], 0

; 2298 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());
; 2299 :             return;

  00a7b	8b 45 d0	 mov	 eax, DWORD PTR __Groups$[ebp+20]
  00a7e	89 45 94	 mov	 DWORD PTR __Groups$1$[ebp], eax
  00a81	8b 45 bc	 mov	 eax, DWORD PTR __Groups$[ebp]
  00a84	e9 e9 00 00 00	 jmp	 $LN1286@Parse_int_
$LN882@Parse_int_:

; 3028 :         const size_type _Old_size = _My_data._Mysize;

  00a89	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00a8e	2b c7		 sub	 eax, edi

; 3029 :         if (max_size() - _Old_size < _Size_increase) {

  00a90	83 f8 01	 cmp	 eax, 1
  00a93	0f 82 11 03 00
	00		 jb	 $LN1209@Parse_int_

; 3031 :         }
; 3032 : 
; 3033 :         const size_type _New_size     = _Old_size + _Size_increase;

  00a99	8d 47 01	 lea	 eax, DWORD PTR [edi+1]

; 3034 :         const size_type _Old_capacity = _My_data._Myres;

  00a9c	89 95 7c ff ff
	ff		 mov	 DWORD PTR __Old_capacity$1$[ebp], edx

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

  00aa2	83 c8 0f	 or	 eax, 15			; 0000000fH
  00aa5	89 45 94	 mov	 DWORD PTR __Groups$1$[ebp], eax
  00aa8	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00aad	76 07		 jbe	 SHORT $LN900@Parse_int_

; 2980 :             return _Max;

  00aaf	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  00ab4	eb 21		 jmp	 SHORT $LN1287@Parse_int_
$LN900@Parse_int_:

; 2981 :         }
; 2982 : 
; 2983 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00ab6	8b ca		 mov	 ecx, edx
  00ab8	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00abd	d1 e9		 shr	 ecx, 1
  00abf	2b c1		 sub	 eax, ecx
  00ac1	3b d0		 cmp	 edx, eax
  00ac3	76 07		 jbe	 SHORT $LN901@Parse_int_

; 2984 :             return _Max;

  00ac5	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  00aca	eb 0b		 jmp	 SHORT $LN1287@Parse_int_
$LN901@Parse_int_:

; 2985 :         }
; 2986 : 
; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00acc	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  00acf	8b 4d 94	 mov	 ecx, DWORD PTR __Groups$1$[ebp]
  00ad2	3b c8		 cmp	 ecx, eax
  00ad4	0f 42 c8	 cmovb	 ecx, eax
$LN1287@Parse_int_:

; 825  :         ++_Capacity; // Take null terminator into consideration

  00ad7	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00ada	89 4d 94	 mov	 DWORD PTR __Groups$1$[ebp], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00add	50		 push	 eax
  00ade	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3041 :         _My_data._Mysize      = _New_size;

  00ae3	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  00ae6	89 45 88	 mov	 DWORD PTR __New_ptr$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00ae9	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3041 :         _My_data._Mysize      = _New_size;

  00aec	89 4d cc	 mov	 DWORD PTR __Groups$[ebp+16], ecx

; 3042 :         _My_data._Myres       = _New_capacity;
; 3043 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 3044 :         if (_Old_capacity > _Small_string_capacity) {

  00aef	83 bd 7c ff ff
	ff 0f		 cmp	 DWORD PTR __Old_capacity$1$[ebp], 15 ; 0000000fH
  00af6	8b 4d 94	 mov	 ecx, DWORD PTR __Groups$1$[ebp]
  00af9	89 4d d0	 mov	 DWORD PTR __Groups$[ebp+20], ecx
  00afc	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  00aff	89 8d 78 ff ff
	ff		 mov	 DWORD PTR tv5513[ebp], ecx
  00b05	57		 push	 edi
  00b06	76 4c		 jbe	 SHORT $LN893@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00b08	8b 7d 9c	 mov	 edi, DWORD PTR __Ptr$1$[ebp]
  00b0b	57		 push	 edi
  00b0c	50		 push	 eax
  00b0d	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2307 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

  00b12	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv5513[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00b18	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00b1b	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR __Old_capacity$1$[ebp]
  00b21	41		 inc	 ecx

; 2307 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

  00b22	66 c7 00 00 00	 mov	 WORD PTR [eax], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00b27	8b c7		 mov	 eax, edi

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00b29	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00b2f	72 14		 jb	 SHORT $LN931@Parse_int_

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00b31	8b 78 fc	 mov	 edi, DWORD PTR [eax-4]
  00b34	83 c1 23	 add	 ecx, 35			; 00000023H
  00b37	2b c7		 sub	 eax, edi

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00b39	83 c0 fc	 add	 eax, -4			; fffffffcH
  00b3c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00b3f	0f 87 6a 02 00
	00		 ja	 $LN116@Parse_int_
$LN931@Parse_int_:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00b45	51		 push	 ecx
  00b46	57		 push	 edi
  00b47	0f ae e8	 lfence
  00b4a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00b4f	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3049 :         } else {

  00b52	eb 18		 jmp	 SHORT $LN1288@Parse_int_
$LN893@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00b54	8d 4d bc	 lea	 ecx, DWORD PTR __Groups$[ebp]
  00b57	51		 push	 ecx
  00b58	50		 push	 eax
  00b59	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2307 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

  00b5e	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv5513[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00b64	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2307 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

  00b67	66 c7 00 00 00	 mov	 WORD PTR [eax], 0
$LN1288@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 754  :                 ++_Groups_arr_idx;

  00b6c	8b 45 88	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
  00b6f	89 45 bc	 mov	 DWORD PTR __Groups$[ebp], eax
$LN1286@Parse_int_:
  00b72	ff 45 90	 inc	 DWORD PTR __Groups_arr_idx$1$[ebp]
  00b75	8b 7d 84	 mov	 edi, DWORD PTR __Last$GSCopy$1$[ebp]
$LN1291@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00b78	89 45 9c	 mov	 DWORD PTR __Ptr$1$[ebp], eax
$LN6@Parse_int_:
  00b7b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00b7d	85 c9		 test	 ecx, ecx
  00b7f	74 38		 je	 SHORT $LN545@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00b81	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00b84	83 38 00	 cmp	 DWORD PTR [eax], 0
  00b87	74 1b		 je	 SHORT $LN549@Parse_int_
  00b89	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00b8c	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  00b8e	85 c0		 test	 eax, eax
  00b90	7e 12		 jle	 SHORT $LN549@Parse_int_

; 222  :         --*_IGcount;

  00b92	48		 dec	 eax
  00b93	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  00b95	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00b98	8b 11		 mov	 edx, DWORD PTR [ecx]
  00b9a	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00b9d	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00b9f	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  00ba2	eb 07		 jmp	 SHORT $LN550@Parse_int_
$LN549@Parse_int_:
  00ba4	8b 01		 mov	 eax, DWORD PTR [ecx]
  00ba6	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00ba9	ff d0		 call	 eax
$LN550@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00bab	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00bae	74 09		 je	 SHORT $LN545@Parse_int_

; 464  :             _Got = false;

  00bb0	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  00bb4	e9 bd fc ff ff	 jmp	 $LL8@Parse_int_
$LN545@Parse_int_:

; 461  :             _Strbuf = nullptr;

  00bb9	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 462  :             _Got    = true;

  00bbf	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1

; 463  :         } else {

  00bc3	e9 ae fc ff ff	 jmp	 $LL8@Parse_int_
$LN43@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 762  :                 _Bad_grouping = true; // trailing separator, fail

  00bc8	b2 01		 mov	 dl, 1
  00bca	88 55 a2	 mov	 BYTE PTR __Bad_grouping$1$[ebp], dl
$LN44@Parse_int_:

; 763  :             }
; 764  :         }
; 765  : 
; 766  :         // skip trailing separators
; 767  :         if (_Kseparator != _Elem{}) {

  00bcd	84 f6		 test	 dh, dh
  00bcf	0f 84 b1 00 00
	00		 je	 $LN10@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 495  :     return !(_Left == _Right);

  00bd5	57		 push	 edi
  00bd6	56		 push	 esi
  00bd7	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
  00bdc	83 c4 08	 add	 esp, 8
  00bdf	84 c0		 test	 al, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 768  :             while (_First != _Last && *_First == _Kseparator) {

  00be1	0f 85 9f 00 00
	00		 jne	 $LN10@Parse_int_
$LL9@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 406  :         if (!_Got) {

  00be7	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  00beb	75 37		 jne	 SHORT $LN1238@Parse_int_

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00bed	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00bef	85 c9		 test	 ecx, ecx
  00bf1	74 27		 je	 SHORT $LN131@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00bf3	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00bf6	8b 10		 mov	 edx, DWORD PTR [eax]
  00bf8	85 d2		 test	 edx, edx
  00bfa	74 0d		 je	 SHORT $LN135@Parse_int_
  00bfc	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00bff	83 38 00	 cmp	 DWORD PTR [eax], 0
  00c02	7e 05		 jle	 SHORT $LN135@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00c04	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00c07	eb 07		 jmp	 SHORT $LN136@Parse_int_
$LN135@Parse_int_:
  00c09	8b 01		 mov	 eax, DWORD PTR [ecx]
  00c0b	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00c0e	ff d0		 call	 eax
$LN136@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00c10	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00c13	74 05		 je	 SHORT $LN131@Parse_int_

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00c15	88 46 05	 mov	 BYTE PTR [esi+5], al
  00c18	eb 06		 jmp	 SHORT $LN130@Parse_int_
$LN131@Parse_int_:

; 471  :             _Strbuf = nullptr;

  00c1a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN130@Parse_int_:

; 476  :         _Got = true;

  00c20	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN1238@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 768  :             while (_First != _Last && *_First == _Kseparator) {

  00c24	8a 45 a3	 mov	 al, BYTE PTR __Kseparator$1$[ebp]
  00c27	38 46 05	 cmp	 BYTE PTR [esi+5], al
  00c2a	75 5a		 jne	 SHORT $LN10@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00c2c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00c2e	85 c9		 test	 ecx, ecx
  00c30	74 33		 je	 SHORT $LN159@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00c32	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00c35	83 38 00	 cmp	 DWORD PTR [eax], 0
  00c38	74 1b		 je	 SHORT $LN1268@Parse_int_
  00c3a	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00c3d	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  00c3f	85 c0		 test	 eax, eax
  00c41	7e 12		 jle	 SHORT $LN1268@Parse_int_

; 222  :         --*_IGcount;

  00c43	48		 dec	 eax
  00c44	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  00c46	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00c49	8b 11		 mov	 edx, DWORD PTR [ecx]
  00c4b	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00c4e	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00c50	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  00c53	eb 07		 jmp	 SHORT $LN164@Parse_int_
$LN1268@Parse_int_:
  00c55	8b 01		 mov	 eax, DWORD PTR [ecx]
  00c57	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00c5a	ff d0		 call	 eax
$LN164@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00c5c	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00c5f	74 04		 je	 SHORT $LN159@Parse_int_

; 464  :             _Got = false;

  00c61	32 c0		 xor	 al, al
  00c63	eb 08		 jmp	 SHORT $LN158@Parse_int_
$LN159@Parse_int_:

; 461  :             _Strbuf = nullptr;

  00c65	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 462  :             _Got    = true;

  00c6b	b0 01		 mov	 al, 1
$LN158@Parse_int_:

; 495  :     return !(_Left == _Right);

  00c6d	57		 push	 edi
  00c6e	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 770  :                 _Bad_grouping = true;

  00c6f	88 46 04	 mov	 BYTE PTR [esi+4], al
  00c72	c6 45 a2 01	 mov	 BYTE PTR __Bad_grouping$1$[ebp], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 495  :     return !(_Left == _Right);

  00c76	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
  00c7b	83 c4 08	 add	 esp, 8
  00c7e	84 c0		 test	 al, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 768  :             while (_First != _Last && *_First == _Kseparator) {

  00c80	0f 84 61 ff ff
	ff		 je	 $LL9@Parse_int_
$LN10@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00c86	83 7d b8 0f	 cmp	 DWORD PTR __Grouping$[ebp+20], 15 ; 0000000fH

; 444  :         const value_type* _Result = _Bx._Buf;

  00c8a	8d 55 a4	 lea	 edx, DWORD PTR __Grouping$[ebp]

; 445  :         if (_Large_mode_engaged()) {

  00c8d	8b 7d a4	 mov	 edi, DWORD PTR __Grouping$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 775  :         const char* const _Grouping_end = _Grouping_iter + _Grouping.size();

  00c90	8b 75 b4	 mov	 esi, DWORD PTR __Grouping$[ebp+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

  00c93	0f 47 d7	 cmova	 edx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 776  :         for (char _Current_grouping_count = '\0'; _Seendigit && !_Bad_grouping && _Groups_arr_idx > 0;) {

  00c96	32 c9		 xor	 cl, cl
  00c98	03 f2		 add	 esi, edx
  00c9a	38 4d a1	 cmp	 BYTE PTR __Seendigit$1$[ebp], cl
  00c9d	0f 84 7d 00 00
	00		 je	 $LN1269@Parse_int_
  00ca3	8b 7d 90	 mov	 edi, DWORD PTR __Groups_arr_idx$1$[ebp]
  00ca6	8a 45 a2	 mov	 al, BYTE PTR __Bad_grouping$1$[ebp]
  00ca9	0f 1f 80 00 00
	00 00		 npad	 7
$LL13@Parse_int_:
  00cb0	84 c0		 test	 al, al
  00cb2	75 49		 jne	 SHORT $LN50@Parse_int_
  00cb4	85 ff		 test	 edi, edi
  00cb6	74 45		 je	 SHORT $LN50@Parse_int_

; 777  :             if (_Grouping_iter != _Grouping_end) { // keep the last value when _Grouping is exhausted

  00cb8	3b d6		 cmp	 edx, esi
  00cba	74 03		 je	 SHORT $LN46@Parse_int_

; 778  :                 _Current_grouping_count = *_Grouping_iter; // if _Grouping is empty, '\0' is used

  00cbc	8a 0a		 mov	 cl, BYTE PTR [edx]

; 779  :                 ++_Grouping_iter;

  00cbe	42		 inc	 edx
$LN46@Parse_int_:

; 780  :             }
; 781  : 
; 782  :             --_Groups_arr_idx;

  00cbf	4f		 dec	 edi

; 784  :                 && ((_Groups_arr_idx > 0 && _Groups[_Groups_arr_idx] != _Current_grouping_count)

  00cc0	84 c9		 test	 cl, cl
  00cc2	7e ec		 jle	 SHORT $LL13@Parse_int_
  00cc4	80 f9 7f	 cmp	 cl, 127			; 0000007fH
  00cc7	74 e7		 je	 SHORT $LL13@Parse_int_
  00cc9	85 ff		 test	 edi, edi
  00ccb	74 17		 je	 SHORT $LN1290@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00ccd	83 7d 94 0f	 cmp	 DWORD PTR __Groups$1$[ebp], 15 ; 0000000fH

; 435  :         value_type* _Result = _Bx._Buf;

  00cd1	8d 45 bc	 lea	 eax, DWORD PTR __Groups$[ebp]

; 436  :         if (_Large_mode_engaged()) {

  00cd4	0f 47 45 9c	 cmova	 eax, DWORD PTR __Ptr$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 784  :                 && ((_Groups_arr_idx > 0 && _Groups[_Groups_arr_idx] != _Current_grouping_count)

  00cd8	38 0c 38	 cmp	 BYTE PTR [eax+edi], cl
  00cdb	75 19		 jne	 SHORT $LN48@Parse_int_
  00cdd	8a 45 a2	 mov	 al, BYTE PTR __Bad_grouping$1$[ebp]
  00ce0	85 ff		 test	 edi, edi
  00ce2	75 cc		 jne	 SHORT $LL13@Parse_int_
$LN1290@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00ce4	83 7d 94 0f	 cmp	 DWORD PTR __Groups$1$[ebp], 15 ; 0000000fH

; 435  :         value_type* _Result = _Bx._Buf;

  00ce8	8d 45 bc	 lea	 eax, DWORD PTR __Groups$[ebp]

; 436  :         if (_Large_mode_engaged()) {

  00ceb	0f 47 45 9c	 cmova	 eax, DWORD PTR __Ptr$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 784  :                 && ((_Groups_arr_idx > 0 && _Groups[_Groups_arr_idx] != _Current_grouping_count)

  00cef	38 08		 cmp	 BYTE PTR [eax], cl
  00cf1	8a 45 a2	 mov	 al, BYTE PTR __Bad_grouping$1$[ebp]
  00cf4	7e ba		 jle	 SHORT $LL13@Parse_int_
$LN48@Parse_int_:

; 785  :                     || (_Groups_arr_idx == 0 && _Groups[_Groups_arr_idx] > _Current_grouping_count))) {
; 786  :                 _Bad_grouping = true; // bad group size, fail

  00cf6	b0 01		 mov	 al, 1
  00cf8	88 45 a2	 mov	 BYTE PTR __Bad_grouping$1$[ebp], al
  00cfb	eb b3		 jmp	 SHORT $LL13@Parse_int_
$LN50@Parse_int_:

; 793  :         }
; 794  : 
; 795  :         if (!_Nonzero) {

  00cfd	80 7d 9b 00	 cmp	 BYTE PTR __Nonzero$1$[ebp], 0
  00d01	8b 7d a4	 mov	 edi, DWORD PTR __Grouping$[ebp]
  00d04	8b 4d 8c	 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
  00d07	75 04		 jne	 SHORT $LN51@Parse_int_

; 796  :             *_Ptr++ = '0'; // zero field, replace stripped zero(s)

  00d09	c6 01 30	 mov	 BYTE PTR [ecx], 48	; 00000030H
  00d0c	41		 inc	 ecx
$LN51@Parse_int_:

; 800  :         return {_Base, _Bad_grouping};

  00d0d	0f b6 f0	 movzx	 esi, al
  00d10	0f b6 45 a0	 movzx	 eax, BYTE PTR tv5679[ebp]
  00d14	66 c1 e6 08	 shl	 si, 8
  00d18	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00d1b	66 0b f0	 or	 si, ax
  00d1e	eb 08		 jmp	 SHORT $LN59@Parse_int_
$LN1269@Parse_int_:

; 787  :             }
; 788  :             // group size okay, advance to next test
; 789  :         }
; 790  : 
; 791  :         if (!_Seendigit) {
; 792  :             return {static_cast<int8_t>(~_Base), false};

  00d20	8b 45 14	 mov	 eax, DWORD PTR __Basefield$[ebp]
  00d23	f6 d0		 not	 al
  00d25	0f b6 f0	 movzx	 esi, al
$LN59@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00d28	8b 45 94	 mov	 eax, DWORD PTR __Groups$1$[ebp]
  00d2b	83 f8 0f	 cmp	 eax, 15			; 0000000fH

; 3083 :         if (_My_data._Large_mode_engaged()) {

  00d2e	76 2d		 jbe	 SHORT $LN80@Parse_int_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00d30	8b 55 9c	 mov	 edx, DWORD PTR __Ptr$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00d33	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00d36	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00d38	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00d3e	72 10		 jb	 SHORT $LN85@Parse_int_

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00d40	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00d43	83 c1 23	 add	 ecx, 35			; 00000023H
  00d46	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00d48	83 c0 fc	 add	 eax, -4			; fffffffcH
  00d4b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00d4e	77 5f		 ja	 SHORT $LN116@Parse_int_
$LN85@Parse_int_:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00d50	51		 push	 ecx
  00d51	52		 push	 edx
  00d52	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00d57	8b 7d a4	 mov	 edi, DWORD PTR __Grouping$[ebp]
  00d5a	83 c4 08	 add	 esp, 8
$LN80@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00d5d	8b 45 b8	 mov	 eax, DWORD PTR __Grouping$[ebp+20]
  00d60	83 f8 0f	 cmp	 eax, 15			; 0000000fH

; 3083 :         if (_My_data._Large_mode_engaged()) {

  00d63	76 27		 jbe	 SHORT $LN112@Parse_int_

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00d65	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00d68	8b c7		 mov	 eax, edi

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00d6a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00d70	72 10		 jb	 SHORT $LN117@Parse_int_

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00d72	8b 78 fc	 mov	 edi, DWORD PTR [eax-4]
  00d75	83 c1 23	 add	 ecx, 35			; 00000023H
  00d78	2b c7		 sub	 eax, edi

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00d7a	83 c0 fc	 add	 eax, -4			; fffffffcH
  00d7d	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00d80	77 2d		 ja	 SHORT $LN116@Parse_int_
$LN117@Parse_int_:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00d82	51		 push	 ecx
  00d83	57		 push	 edi
  00d84	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00d89	83 c4 08	 add	 esp, 8
$LN112@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 800  :         return {_Base, _Bad_grouping};

  00d8c	66 8b c6	 mov	 ax, si

; 801  :     }

  00d8f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00d92	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00d99	59		 pop	 ecx
  00d9a	5f		 pop	 edi
  00d9b	5e		 pop	 esi
  00d9c	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d9f	33 cd		 xor	 ecx, ebp
  00da1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00da6	8b e5		 mov	 esp, ebp
  00da8	5d		 pop	 ebp
  00da9	c3		 ret	 0
$LN1209@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3030 :             _Xlen_string(); // result too long

  00daa	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN116@Parse_int_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00daf	6a 00		 push	 0
  00db1	6a 00		 push	 0
  00db3	6a 00		 push	 0
  00db5	6a 00		 push	 0
  00db7	6a 00		 push	 0
  00db9	e8 00 00 00 00	 call	 __invoke_watson
$LN1285@Parse_int_:
  00dbe	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z$0:
  00000	8d 4d a4	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z$1:
  00008	8d 4d bc	 lea	 ecx, DWORD PTR __Groups$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 8a 70 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-144]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Zero_range@PAE@std@@YAPAEQAE0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PAE@std@@YAPAEQAE0@Z PROC		; std::_Zero_range<unsigned char *>, COMDAT

; 2069 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2070 :     char* const _First_ch = reinterpret_cast<char*>(_STD _To_address(_First));
; 2071 :     char* const _Last_ch  = reinterpret_cast<char*>(_STD _To_address(_Last));
; 2072 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	51		 push	 ecx
  0000c	6a 00		 push	 0
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 _memset

; 2073 :     return _Last;

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2074 : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Zero_range@PAE@std@@YAPAEQAE0@Z ENDP		; std::_Zero_range<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT
; _this$ = ecx

; 1838 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

  00000	56		 push	 esi

; 1839 :         _STD _Destroy_range(_First, _Last, _Al);

  00001	8b 31		 mov	 esi, DWORD PTR [ecx]
  00003	57		 push	 edi
  00004	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]

; 1102 :         for (; _First != _Last; ++_First) {

  00007	3b f7		 cmp	 esi, edi
  00009	74 13		 je	 SHORT $LN6@Uninitiali
  0000b	0f 1f 44 00 00	 npad	 5
$LL7@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1383 :         _Tidy_deallocate();

  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1102 :         for (; _First != _Last; ++_First) {

  00017	83 c6 18	 add	 esi, 24			; 00000018H
  0001a	3b f7		 cmp	 esi, edi
  0001c	75 f2		 jne	 SHORT $LL7@Uninitiali
$LN6@Uninitiali:
  0001e	5f		 pop	 edi

; 1840 :     }

  0001f	5e		 pop	 esi
  00020	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT

; 1977 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1978 :     // move [_First, _Last) to raw _Dest, using _Al
; 1979 :     // note: only called internally from elsewhere in the STL
; 1980 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1981 :     _STD _Adl_verify_range(_First, _Last);
; 1982 : #endif // ^^^ defined(_ENABLE_STL_INTERNAL_CHECK) ^^^
; 1983 :     using _Ptrval     = typename _Alloc::value_type*;
; 1984 :     auto _UFirst      = _STD _Get_unwrapped(_First);
; 1985 :     const auto _ULast = _STD _Get_unwrapped(_Last);
; 1986 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1987 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1988 : #if _HAS_CXX20
; 1989 :         if (!_STD is_constant_evaluated())
; 1990 : #endif // _HAS_CXX20
; 1991 :         {
; 1992 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));
; 1993 :             return _Dest + (_ULast - _UFirst);
; 1994 :         }
; 1995 :     }
; 1996 : 
; 1997 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1998 :     for (; _UFirst != _ULast; ++_UFirst) {

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]

; 1833 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 1977 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00009	56		 push	 esi

; 1978 :     // move [_First, _Last) to raw _Dest, using _Al
; 1979 :     // note: only called internally from elsewhere in the STL
; 1980 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1981 :     _STD _Adl_verify_range(_First, _Last);
; 1982 : #endif // ^^^ defined(_ENABLE_STL_INTERNAL_CHECK) ^^^
; 1983 :     using _Ptrval     = typename _Alloc::value_type*;
; 1984 :     auto _UFirst      = _STD _Get_unwrapped(_First);
; 1985 :     const auto _ULast = _STD _Get_unwrapped(_Last);
; 1986 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1987 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1988 : #if _HAS_CXX20
; 1989 :         if (!_STD is_constant_evaluated())
; 1990 : #endif // _HAS_CXX20
; 1991 :         {
; 1992 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));
; 1993 :             return _Dest + (_ULast - _UFirst);
; 1994 :         }
; 1995 :     }
; 1996 : 
; 1997 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1998 :     for (; _UFirst != _ULast; ++_UFirst) {

  0000a	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000d	3b ce		 cmp	 ecx, esi
  0000f	74 48		 je	 SHORT $LN3@Uninitiali

; 1833 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00011	8b d0		 mov	 edx, eax
  00013	2b d1		 sub	 edx, ecx
  00015	57		 push	 edi
$LL4@Uninitiali:
  00016	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1291 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  00019	33 ff		 xor	 edi, edi

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0001b	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

  0001e	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00025	c7 44 0a 14 00
	00 00 00	 mov	 DWORD PTR [edx+ecx+20], 0

; 1286 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0002d	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00030	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  00033	f3 0f 7e 41 10	 movq	 xmm0, QWORD PTR [ecx+16]
  00038	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1845 :         ++_Last;

  0003d	83 c0 18	 add	 eax, 24			; 00000018H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1288 :                 _Right_data._Mysize = 0;

  00040	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 1289 :                 _Right_data._Myres  = _Small_string_capacity;

  00047	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7

; 1291 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  0004e	66 89 39	 mov	 WORD PTR [ecx], di
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1845 :         ++_Last;

  00051	83 c1 18	 add	 ecx, 24			; 00000018H

; 1978 :     // move [_First, _Last) to raw _Dest, using _Al
; 1979 :     // note: only called internally from elsewhere in the STL
; 1980 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1981 :     _STD _Adl_verify_range(_First, _Last);
; 1982 : #endif // ^^^ defined(_ENABLE_STL_INTERNAL_CHECK) ^^^
; 1983 :     using _Ptrval     = typename _Alloc::value_type*;
; 1984 :     auto _UFirst      = _STD _Get_unwrapped(_First);
; 1985 :     const auto _ULast = _STD _Get_unwrapped(_Last);
; 1986 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1987 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1988 : #if _HAS_CXX20
; 1989 :         if (!_STD is_constant_evaluated())
; 1990 : #endif // _HAS_CXX20
; 1991 :         {
; 1992 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));
; 1993 :             return _Dest + (_ULast - _UFirst);
; 1994 :         }
; 1995 :     }
; 1996 : 
; 1997 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1998 :     for (; _UFirst != _ULast; ++_UFirst) {

  00054	3b ce		 cmp	 ecx, esi
  00056	75 be		 jne	 SHORT $LL4@Uninitiali
  00058	5f		 pop	 edi
$LN3@Uninitiali:
  00059	5e		 pop	 esi

; 1999 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 2000 :     }
; 2001 : 
; 2002 :     return _Backout._Release();
; 2003 : }

  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??1_Reallocation_guard@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Reallocation_guard@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Reallocation_guard::~_Reallocation_guard, COMDAT
; _this$ = ecx

; 620  :         _CONSTEXPR20 ~_Reallocation_guard() noexcept {

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx

; 621  :             if (_New_begin != nullptr) {

  00003	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  00007	74 4c		 je	 SHORT $LN27@Reallocati

; 622  :                 _STD _Destroy_range(_Constructed_first, _Constructed_last, _Al);

  00009	56		 push	 esi
  0000a	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
  0000d	57		 push	 edi
  0000e	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1102 :         for (; _First != _Last; ++_First) {

  00011	3b f7		 cmp	 esi, edi
  00013	74 0e		 je	 SHORT $LN7@Reallocati
$LL8@Reallocati:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1383 :         _Tidy_deallocate();

  00015	8b ce		 mov	 ecx, esi
  00017	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1102 :         for (; _First != _Last; ++_First) {

  0001c	83 c6 18	 add	 esi, 24			; 00000018H
  0001f	3b f7		 cmp	 esi, edi
  00021	75 f2		 jne	 SHORT $LL8@Reallocati
$LN7@Reallocati:

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00023	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  0002b	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0002e	c1 e1 03	 shl	 ecx, 3

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00031	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00037	72 12		 jb	 SHORT $LN32@Reallocati

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00039	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0003c	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0003f	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00041	83 c0 fc	 add	 eax, -4			; fffffffcH
  00044	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00047	77 0e		 ja	 SHORT $LN31@Reallocati

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00049	8b c2		 mov	 eax, edx
$LN32@Reallocati:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0004b	51		 push	 ecx
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00052	83 c4 08	 add	 esp, 8
$LN27@Reallocati:
  00055	5b		 pop	 ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 625  :         }

  00056	c3		 ret	 0
$LN31@Reallocati:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00057	6a 00		 push	 0
  00059	6a 00		 push	 0
  0005b	6a 00		 push	 0
  0005d	6a 00		 push	 0
  0005f	6a 00		 push	 0
  00061	e8 00 00 00 00	 call	 __invoke_watson
$LN44@Reallocati:
  00066	cc		 int	 3
??1_Reallocation_guard@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Reallocation_guard::~_Reallocation_guard
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$numpunct@_W@std@@MAEPAXI@Z PROC			; std::numpunct<wchar_t>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 142  :     __CLR_OR_THIS_CALL ~numpunct() noexcept override {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 202  :         _CSTD free(const_cast<char*>(_Grouping));

  00006	ff 76 08	 push	 DWORD PTR [esi+8]

; 142  :     __CLR_OR_THIS_CALL ~numpunct() noexcept override {

  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$numpunct@_W@std@@6B@

; 202  :         _CSTD free(const_cast<char*>(_Grouping));

  0000f	e8 00 00 00 00	 call	 _free

; 203  :         _CSTD free(const_cast<_Elem*>(_Falsename));

  00014	ff 76 10	 push	 DWORD PTR [esi+16]
  00017	e8 00 00 00 00	 call	 _free

; 204  :         _CSTD free(const_cast<_Elem*>(_Truename));

  0001c	ff 76 14	 push	 DWORD PTR [esi+20]
  0001f	e8 00 00 00 00	 call	 _free
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH

; 144  :     }

  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0002d	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00031	74 0b		 je	 SHORT $LN13@scalar
  00033	6a 18		 push	 24			; 00000018H
  00035	56		 push	 esi
  00036	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003b	83 c4 08	 add	 esp, 8
$LN13@scalar:
  0003e	8b c6		 mov	 eax, esi
  00040	5e		 pop	 esi
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
??_G?$numpunct@_W@std@@MAEPAXI@Z ENDP			; std::numpunct<wchar_t>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_truename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?do_truename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::numpunct<wchar_t>::do_truename, COMDAT
; _this$ = ecx

; 196  :     virtual string_type __CLR_OR_THIS_CALL do_truename() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 197  :         return string_type{_Truename};

  00004	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00007	0f 57 c0	 xorps	 xmm0, xmm0
  0000a	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0000b	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0000e	8b ca		 mov	 ecx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 196  :     virtual string_type __CLR_OR_THIS_CALL do_truename() const {

  00010	57		 push	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00011	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

  00014	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0001b	8d 79 02	 lea	 edi, DWORD PTR [ecx+2]
  0001e	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LL24@do_truenam:
  00025	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00028	83 c1 02	 add	 ecx, 2
  0002b	66 85 c0	 test	 ax, ax
  0002e	75 f5		 jne	 SHORT $LL24@do_truenam
  00030	2b cf		 sub	 ecx, edi
  00032	d1 f9		 sar	 ecx, 1

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00034	51		 push	 ecx
  00035	52		 push	 edx
  00036	8b ce		 mov	 ecx, esi
  00038	e8 00 00 00 00	 call	 ??$_Construct@$00PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 197  :         return string_type{_Truename};

  0003d	5f		 pop	 edi
  0003e	8b c6		 mov	 eax, esi
  00040	5e		 pop	 esi

; 198  :     }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?do_truename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::numpunct<wchar_t>::do_truename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_falsename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?do_falsename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::numpunct<wchar_t>::do_falsename, COMDAT
; _this$ = ecx

; 192  :     virtual string_type __CLR_OR_THIS_CALL do_falsename() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 193  :         return string_type{_Falsename};

  00004	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00007	0f 57 c0	 xorps	 xmm0, xmm0
  0000a	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0000b	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0000e	8b ca		 mov	 ecx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 192  :     virtual string_type __CLR_OR_THIS_CALL do_falsename() const {

  00010	57		 push	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00011	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

  00014	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0001b	8d 79 02	 lea	 edi, DWORD PTR [ecx+2]
  0001e	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LL24@do_falsena:
  00025	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00028	83 c1 02	 add	 ecx, 2
  0002b	66 85 c0	 test	 ax, ax
  0002e	75 f5		 jne	 SHORT $LL24@do_falsena
  00030	2b cf		 sub	 ecx, edi
  00032	d1 f9		 sar	 ecx, 1

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00034	51		 push	 ecx
  00035	52		 push	 edx
  00036	8b ce		 mov	 ecx, esi
  00038	e8 00 00 00 00	 call	 ??$_Construct@$00PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 193  :         return string_type{_Falsename};

  0003d	5f		 pop	 edi
  0003e	8b c6		 mov	 eax, esi
  00040	5e		 pop	 esi

; 194  :     }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?do_falsename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::numpunct<wchar_t>::do_falsename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_grouping@?$numpunct@_W@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?do_grouping@?$numpunct@_W@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<wchar_t>::do_grouping, COMDAT
; _this$ = ecx

; 188  :     virtual string __CLR_OR_THIS_CALL do_grouping() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 189  :         return string{_Grouping};

  00004	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00007	0f 57 c0	 xorps	 xmm0, xmm0
  0000a	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0000b	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  0000e	8b ca		 mov	 ecx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 188  :     virtual string __CLR_OR_THIS_CALL do_grouping() const {

  00010	57		 push	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00011	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

  00014	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  0001b	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0001e	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LL23@do_groupin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  00025	8a 01		 mov	 al, BYTE PTR [ecx]
  00027	41		 inc	 ecx
  00028	84 c0		 test	 al, al
  0002a	75 f9		 jne	 SHORT $LL23@do_groupin
  0002c	2b cf		 sub	 ecx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0002e	51		 push	 ecx
  0002f	52		 push	 edx
  00030	8b ce		 mov	 ecx, esi
  00032	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 189  :         return string{_Grouping};

  00037	5f		 pop	 edi
  00038	8b c6		 mov	 eax, esi
  0003a	5e		 pop	 esi

; 190  :     }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?do_grouping@?$numpunct@_W@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<wchar_t>::do_grouping
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_thousands_sep@?$numpunct@_W@std@@MBE_WXZ
_TEXT	SEGMENT
?do_thousands_sep@?$numpunct@_W@std@@MBE_WXZ PROC	; std::numpunct<wchar_t>::do_thousands_sep, COMDAT
; _this$ = ecx

; 185  :         return _Kseparator;

  00000	66 8b 41 0e	 mov	 ax, WORD PTR [ecx+14]

; 186  :     }

  00004	c3		 ret	 0
?do_thousands_sep@?$numpunct@_W@std@@MBE_WXZ ENDP	; std::numpunct<wchar_t>::do_thousands_sep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_decimal_point@?$numpunct@_W@std@@MBE_WXZ
_TEXT	SEGMENT
?do_decimal_point@?$numpunct@_W@std@@MBE_WXZ PROC	; std::numpunct<wchar_t>::do_decimal_point, COMDAT
; _this$ = ecx

; 181  :         return _Dp;

  00000	66 8b 41 0c	 mov	 ax, WORD PTR [ecx+12]

; 182  :     }

  00004	c3		 ret	 0
?do_decimal_point@?$numpunct@_W@std@@MBE_WXZ ENDP	; std::numpunct<wchar_t>::do_decimal_point
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??1?$numpunct@_W@std@@MAE@XZ
_TEXT	SEGMENT
??1?$numpunct@_W@std@@MAE@XZ PROC			; std::numpunct<wchar_t>::~numpunct<wchar_t>, COMDAT
; _this$ = ecx

; 142  :     __CLR_OR_THIS_CALL ~numpunct() noexcept override {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 202  :         _CSTD free(const_cast<char*>(_Grouping));

  00003	ff 76 08	 push	 DWORD PTR [esi+8]

; 142  :     __CLR_OR_THIS_CALL ~numpunct() noexcept override {

  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$numpunct@_W@std@@6B@

; 202  :         _CSTD free(const_cast<char*>(_Grouping));

  0000c	e8 00 00 00 00	 call	 _free

; 203  :         _CSTD free(const_cast<_Elem*>(_Falsename));

  00011	ff 76 10	 push	 DWORD PTR [esi+16]
  00014	e8 00 00 00 00	 call	 _free

; 204  :         _CSTD free(const_cast<_Elem*>(_Truename));

  00019	ff 76 14	 push	 DWORD PTR [esi+20]
  0001c	e8 00 00 00 00	 call	 _free
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH

; 143  :         _Tidy();
; 144  :     }

  00024	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0002a	5e		 pop	 esi
  0002b	c3		 ret	 0
??1?$numpunct@_W@std@@MAE@XZ ENDP			; std::numpunct<wchar_t>::~numpunct<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -176						; size = 44
$T3 = -132						; size = 52
__Mbst1$4 = -80						; size = 8
__Mbst1$5 = -80						; size = 8
$T6 = -76						; size = 4
$T7 = -72						; size = 4
__Guard$8 = -68						; size = 4
__Wc$9 = -68						; size = 2
__Wc$10 = -68						; size = 2
__Ploc$GSCopy$1$ = -68					; size = 4
__Byte$ = -64						; size = 1
__Byte$ = -64						; size = 1
__Cvt$11 = -60						; size = 44
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::numpunct<wchar_t>::_Getcat, COMDAT

; 133  :     static size_t _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b 7d 08	 mov	 edi, DWORD PTR __Ppf$[ebp]
  00030	8b 45 0c	 mov	 eax, DWORD PTR __Ploc$[ebp]
  00033	89 45 bc	 mov	 DWORD PTR __Ploc$GSCopy$1$[ebp], eax
  00036	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T7[ebp], 0

; 134  :         // return locale category mask and construct standard facet
; 135  :         if (_Ppf && !*_Ppf) {

  0003d	85 ff		 test	 edi, edi
  0003f	0f 84 73 01 00
	00		 je	 $LN9@Getcat
  00045	83 3f 00	 cmp	 DWORD PTR [edi], 0
  00048	0f 85 6a 01 00
	00		 jne	 $LN9@Getcat

; 136  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->_C_str()), 0, true);

  0004e	6a 18		 push	 24			; 00000018H
  00050	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00055	8b f0		 mov	 esi, eax
  00057	83 c4 04	 add	 esp, 4
  0005a	89 75 b4	 mov	 DWORD PTR $T6[ebp], esi
  0005d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00064	85 f6		 test	 esi, esi
  00066	0f 84 37 01 00
	00		 je	 $LN4@Getcat
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 373  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  0006c	8b 4d bc	 mov	 ecx, DWORD PTR __Ploc$GSCopy$1$[ebp]
  0006f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00072	85 c9		 test	 ecx, ecx
  00074	74 0c		 je	 SHORT $LN12@Getcat
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo

; 190  :         return _Myptr ? _Myptr : &_Nul;

  00076	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00079	85 c0		 test	 eax, eax
  0007b	75 0a		 jne	 SHORT $LN13@Getcat
  0007d	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 373  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  00080	eb 05		 jmp	 SHORT $LN13@Getcat
$LN12@Getcat:
  00082	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@@
$LN13@Getcat:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 136  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->_C_str()), 0, true);

  00087	50		 push	 eax
  00088	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0008e	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00093	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR $T7[ebp], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 143  :             : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs)) // non-atomic initialization

  0009a	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 129  :     numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false) : locale::facet(_Refs) {

  000a1	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  000a8	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$numpunct@_W@std@@6B@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo

; 285  :         return localeconv();

  000ae	e8 00 00 00 00	 call	 _localeconv

; 281  :         return ::_Getcvt();

  000b3	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 __Getcvt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 160  :         _Tidy_guard<numpunct> _Guard{this};

  000bf	89 75 bc	 mov	 DWORD PTR __Guard$8[ebp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo

; 281  :         return ::_Getcvt();

  000c2	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  000c5	0f 11 45 c4	 movups	 XMMWORD PTR __Cvt$11[ebp], xmm0
  000c9	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  000cd	0f 11 45 d4	 movups	 XMMWORD PTR __Cvt$11[ebp+16], xmm0
  000d1	f3 0f 7e 40 20	 movq	 xmm0, QWORD PTR [eax+32]
  000d6	66 0f d6 45 e4	 movq	 QWORD PTR __Cvt$11[ebp+32], xmm0
  000db	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  000de	89 45 ec	 mov	 DWORD PTR __Cvt$11[ebp+40], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 156  :         _Grouping  = nullptr;

  000e1	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 157  :         _Falsename = nullptr;

  000e8	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 158  :         _Truename  = nullptr;

  000ef	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 530  :     _Elem* _Ptrdest = static_cast<_Elem*>(_calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__));

  000f6	6a 01		 push	 1
  000f8	6a 01		 push	 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 160  :         _Tidy_guard<numpunct> _Guard{this};

  000fa	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 530  :     _Elem* _Ptrdest = static_cast<_Elem*>(_calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__));

  000fe	e8 00 00 00 00	 call	 _calloc
  00103	83 c4 0c	 add	 esp, 12			; 0000000cH

; 531  : 
; 532  :     if (!_Ptrdest) {

  00106	85 c0		 test	 eax, eax
  00108	0f 84 ca 00 00
	00		 je	 $LN69@Getcat

; 534  :     }
; 535  : 
; 536  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {
; 537  :         *_Ptrnext = static_cast<_Elem>(static_cast<unsigned char>(*_Ptr));

  0010e	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 161  :         _Grouping      = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char*>(nullptr), _Cvt);

  00111	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 162  :         _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);

  00114	8d 45 c4	 lea	 eax, DWORD PTR __Cvt$11[ebp]
  00117	50		 push	 eax
  00118	6a 00		 push	 0
  0011a	68 00 00 00 00	 push	 OFFSET ??_C@_05LAPONLG@false@
  0011f	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  00124	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 163  :         _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);

  00127	8d 45 c4	 lea	 eax, DWORD PTR __Cvt$11[ebp]
  0012a	50		 push	 eax
  0012b	6a 00		 push	 0
  0012d	68 00 00 00 00	 push	 OFFSET ??_C@_04LOAJBDKD@true@
  00132	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  00137	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0013a	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 510  :     _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);

  0013d	8d 45 c4	 lea	 eax, DWORD PTR __Cvt$11[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 167  :             _Dp         = _Maklocchr('.', static_cast<_Elem*>(nullptr), _Cvt);

  00140	c6 45 c0 2e	 mov	 BYTE PTR __Byte$[ebp], 46 ; 0000002eH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 510  :     _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);

  00144	50		 push	 eax
  00145	8d 45 b0	 lea	 eax, DWORD PTR __Mbst1$4[ebp]
  00148	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR __Wc$10[ebp], 0
  0014f	50		 push	 eax
  00150	6a 01		 push	 1
  00152	8d 45 c0	 lea	 eax, DWORD PTR __Byte$[ebp]
  00155	66 0f 13 45 b0	 movlpd	 QWORD PTR __Mbst1$4[ebp], xmm0
  0015a	50		 push	 eax
  0015b	8d 45 bc	 lea	 eax, DWORD PTR __Wc$10[ebp]
  0015e	50		 push	 eax
  0015f	e8 00 00 00 00	 call	 __Mbrtowc
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 167  :             _Dp         = _Maklocchr('.', static_cast<_Elem*>(nullptr), _Cvt);

  00164	0f b7 45 bc	 movzx	 eax, WORD PTR __Wc$10[ebp]
  00168	0f 57 c0	 xorps	 xmm0, xmm0
  0016b	66 89 46 0c	 mov	 WORD PTR [esi+12], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 510  :     _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);

  0016f	8d 45 c4	 lea	 eax, DWORD PTR __Cvt$11[ebp]
  00172	50		 push	 eax
  00173	8d 45 b0	 lea	 eax, DWORD PTR __Mbst1$5[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 168  :             _Kseparator = _Maklocchr(',', static_cast<_Elem*>(nullptr), _Cvt);

  00176	c6 45 c0 2c	 mov	 BYTE PTR __Byte$[ebp], 44 ; 0000002cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 510  :     _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);

  0017a	50		 push	 eax
  0017b	6a 01		 push	 1
  0017d	8d 45 c0	 lea	 eax, DWORD PTR __Byte$[ebp]
  00180	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR __Wc$9[ebp], 0
  00187	50		 push	 eax
  00188	8d 45 bc	 lea	 eax, DWORD PTR __Wc$9[ebp]
  0018b	66 0f 13 45 b0	 movlpd	 QWORD PTR __Mbst1$5[ebp], xmm0
  00190	50		 push	 eax
  00191	e8 00 00 00 00	 call	 __Mbrtowc
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 168  :             _Kseparator = _Maklocchr(',', static_cast<_Elem*>(nullptr), _Cvt);

  00196	0f b7 45 bc	 movzx	 eax, WORD PTR __Wc$9[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 510  :     _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);

  0019a	83 c4 40	 add	 esp, 64			; 00000040H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 168  :             _Kseparator = _Maklocchr(',', static_cast<_Elem*>(nullptr), _Cvt);

  0019d	66 89 46 0e	 mov	 WORD PTR [esi+14], ax

; 136  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->_C_str()), 0, true);

  001a1	eb 02		 jmp	 SHORT $LN5@Getcat
$LN4@Getcat:
  001a3	33 f6		 xor	 esi, esi
$LN5@Getcat:
  001a5	f6 45 b8 01	 test	 BYTE PTR $T7[ebp], 1
  001a9	89 37		 mov	 DWORD PTR [edi], esi
  001ab	74 0b		 je	 SHORT $LN9@Getcat
  001ad	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001b3	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN9@Getcat:

; 137  :         }
; 138  :         return _X_NUMERIC;

  001b8	b8 04 00 00 00	 mov	 eax, 4

; 139  :     }

  001bd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001c0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001c7	59		 pop	 ecx
  001c8	5f		 pop	 edi
  001c9	5e		 pop	 esi
  001ca	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001cd	33 cd		 xor	 ecx, ebp
  001cf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d4	8b e5		 mov	 esp, ebp
  001d6	5d		 pop	 ebp
  001d7	c3		 ret	 0
$LN69@Getcat:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 533  :         _Xbad_alloc();

  001d8	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN67@Getcat:
  001dd	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	6a 18		 push	 24			; 00000018H
  00002	8b 45 b4	 mov	 eax, DWORD PTR $T6[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__unwindfunclet$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1:
  0000f	8b 45 b8	 mov	 eax, DWORD PTR $T7[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	0f 84 0f 00 00
	00		 je	 $LN8@Getcat
  0001b	83 65 b8 fe	 and	 DWORD PTR $T7[ebp], -2	; fffffffeH
  0001f	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00025	e9 00 00 00 00	 jmp	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN8@Getcat:
  0002a	c3		 ret	 0
__unwindfunclet$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$2:
  0002b	8b 4d b4	 mov	 ecx, DWORD PTR $T6[ebp]
  0002e	e9 00 00 00 00	 jmp	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
__unwindfunclet$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$4:
  00033	8d 4d bc	 lea	 ecx, DWORD PTR __Guard$8[ebp]
  00036	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$numpunct@_W@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::numpunct<wchar_t> >::~_Tidy_guard<std::numpunct<wchar_t> >
  0003b	cc		 int	 3
  0003c	cc		 int	 3
  0003d	cc		 int	 3
  0003e	cc		 int	 3
  0003f	cc		 int	 3
__ehhandler$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  00040	90		 npad	 1
  00041	90		 npad	 1
  00042	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00046	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00049	8b 8a 50 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-176]
  0004f	33 c8		 xor	 ecx, eax
  00051	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00056	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00059	33 c8		 xor	 ecx, eax
  0005b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00060	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00065	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::numpunct<wchar_t>::_Getcat
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT
__Lock$2 = -24						; size = 4
__Psave$3 = -20						; size = 4
__Lock$4 = -16						; size = 4
$T5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
__Psave_guard$6 = 8					; size = 4
??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z PROC ; std::use_facet<std::numpunct<wchar_t> >, COMDAT

; 435  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 436  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

  00028	6a 00		 push	 0
  0002a	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 91   :             if (_Id == 0) { // still zero, allocate stamp

  00032	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id

; 437  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

  00038	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<wchar_t> >::_Psave
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	89 5d ec	 mov	 DWORD PTR __Psave$3[ebp], ebx

; 91   :             if (_Id == 0) { // still zero, allocate stamp

  00048	85 ff		 test	 edi, edi
  0004a	75 2f		 jne	 SHORT $LN11@use_facet

; 92   :                 _BEGIN_LOCK(_LOCK_LOCALE)

  0004c	57		 push	 edi
  0004d	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00050	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 93   :                 if (_Id == 0) {

  00055	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?id@?$numpunct@_W@std@@2V0locale@2@A, edi ; std::numpunct<wchar_t>::id
  0005b	75 10		 jne	 SHORT $LN12@use_facet

; 94   :                     _Id = static_cast<size_t>(++_Id_cnt);

  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00062	40		 inc	 eax
  00063	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00068	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$numpunct@_W@std@@2V0locale@2@A, eax ; std::numpunct<wchar_t>::id
$LN12@use_facet:

; 95   :                 }
; 96   :                 _END_LOCK()

  0006d	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00070	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00075	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
$LN11@use_facet:

; 377  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  0007b	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  0007e	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
  00085	89 4d f0	 mov	 DWORD PTR $T5[ebp], ecx
  00088	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008b	3b 7a 0c	 cmp	 edi, DWORD PTR [edx+12]
  0008e	73 12		 jae	 SHORT $LN19@use_facet
  00090	0f ae e8	 lfence
  00093	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00096	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00099	8b 34 01	 mov	 esi, DWORD PTR [ecx+eax]

; 378  :         if (_Facptr || !_Ptr->_Xparent) {

  0009c	85 f6		 test	 esi, esi
  0009e	75 63		 jne	 SHORT $LN39@use_facet
  000a0	eb 05		 jmp	 SHORT $LN42@use_facet
$LN19@use_facet:

; 97   :             }
; 98   :             return _Id;
; 99   :         }
; 100  : 
; 101  : #ifdef _CRTBLD // TRANSITION, ABI: preserved for binary compatibility
; 102  :         __CLR_OR_THIS_CALL operator size_t() {
; 103  :             return _Get_index();
; 104  :         }
; 105  : #endif // defined(_CRTBLD)
; 106  : 
; 107  :     private:
; 108  :         size_t _Id = 0; // the identifier stamp
; 109  : 
; 110  :         __PURE_APPDOMAIN_GLOBAL static int _Id_cnt;
; 111  :     };
; 112  : 
; 113  :     struct _Facet_guard;
; 114  : 
; 115  :     class _CRTIMP2_PURE_IMPORT facet : public _Facet_base, public _Crt_new_delete {
; 116  :         // base class for all locale facets, performs reference counting
; 117  :     private:
; 118  :         friend _Facet_guard;
; 119  : 
; 120  :     public:
; 121  :         static size_t __CLRCALL_OR_CDECL _Getcat(const facet** = nullptr, const locale* = nullptr) {
; 122  :             // get category value, or -1 if no corresponding C category
; 123  :             return static_cast<size_t>(-1);
; 124  :         }
; 125  : 
; 126  :         void __CLR_OR_THIS_CALL _Incref() noexcept override { // increment use count
; 127  :             _MT_INCR(_Myrefs);
; 128  :         }
; 129  : 
; 130  :         _Facet_base* __CLR_OR_THIS_CALL _Decref() noexcept override { // decrement use count
; 131  :             if (_MT_DECR(_Myrefs) == 0) {
; 132  :                 return this;
; 133  :             }
; 134  : 
; 135  :             return nullptr;
; 136  :         }
; 137  : 
; 138  :     private:
; 139  :         _Atomic_counter_t _Myrefs; // the reference count
; 140  : 
; 141  :     protected:
; 142  :         explicit __CLR_OR_THIS_CALL facet(size_t _Initrefs = 0) noexcept // strengthened
; 143  :             : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs)) // non-atomic initialization
; 144  :         {}
; 145  : 
; 146  :         __CLR_OR_THIS_CALL ~facet() noexcept override {}
; 147  : 
; 148  :     public:
; 149  :         __CLR_OR_THIS_CALL facet(const facet&)            = delete;
; 150  :         facet& __CLR_OR_THIS_CALL operator=(const facet&) = delete;
; 151  :     };
; 152  : 
; 153  :     struct _NODISCARD _Facet_guard {
; 154  :         facet* _Target;
; 155  :         ~_Facet_guard() {
; 156  :             if (_Target) {
; 157  :                 delete _Target->_Decref();
; 158  :             }
; 159  :         }
; 160  :     };
; 161  : 
; 162  :     class _CRTIMP2_PURE_IMPORT _Locimp : public facet { // reference-counted actual implementation of a locale
; 163  :     protected:
; 164  :         __CLR_OR_THIS_CALL ~_Locimp() noexcept {
; 165  :             _Locimp_dtor(this);
; 166  :         }
; 167  : 
; 168  :     private:
; 169  :         static _Locimp* __CLRCALL_PURE_OR_CDECL _New_Locimp(bool _Transparent = false);
; 170  :         static _Locimp* __CLRCALL_PURE_OR_CDECL _New_Locimp(const _Locimp& _Right);
; 171  : 
; 172  :         static void __CLRCALL_PURE_OR_CDECL _Locimp_dtor(_Locimp*);
; 173  :         static void __CLRCALL_PURE_OR_CDECL _Locimp_Addfac(_Locimp*, facet*, size_t); // add a facet
; 174  :         static void __CLRCALL_PURE_OR_CDECL _Locimp_ctor(_Locimp*, const _Locimp&);
; 175  : 
; 176  :         friend locale;
; 177  : 
; 178  :         __CLR_OR_THIS_CALL _Locimp(bool _Transparent)
; 179  :             : locale::facet(1), _Facetvec(nullptr), _Facetcount(0), _Catmask(none), _Xparent(_Transparent), _Name("*") {
; 180  :         }
; 181  : 
; 182  :         __CLR_OR_THIS_CALL _Locimp(const _Locimp& _Right)
; 183  :             : locale::facet(1), _Facetvec(nullptr), _Facetcount(_Right._Facetcount), _Catmask(_Right._Catmask),
; 184  :               _Xparent(_Right._Xparent), _Name(_Right._Name.c_str()) {
; 185  :             _Locimp_ctor(this, _Right);
; 186  :         }
; 187  : 
; 188  :         void __CLR_OR_THIS_CALL _Addfac(facet* _Pfacet, size_t _Id) { // add a facet
; 189  :             _Locimp_Addfac(this, _Pfacet, _Id);
; 190  :         }
; 191  : 
; 192  :         static _Locimp* __CLRCALL_OR_CDECL _Makeloc(
; 193  :             const _Locinfo&, category, _Locimp*, const locale*); // make essential facets
; 194  : 
; 195  :         static void __CLRCALL_OR_CDECL _Makewloc(
; 196  :             const _Locinfo&, category, _Locimp*, const locale*); // make wchar_t facets
; 197  : 
; 198  : #if defined(_NATIVE_WCHAR_T_DEFINED) && !_ENFORCE_FACET_SPECIALIZATIONS
; 199  :         static void __CLRCALL_OR_CDECL _Makeushloc(
; 200  :             const _Locinfo&, category, _Locimp*, const locale*); // make ushort facets
; 201  : #endif // defined(_NATIVE_WCHAR_T_DEFINED) && !_ENFORCE_FACET_SPECIALIZATIONS
; 202  : 
; 203  :         static void __CLRCALL_OR_CDECL _Makexloc(
; 204  :             const _Locinfo&, category, _Locimp*, const locale*); // make remaining facets
; 205  : 
; 206  :         facet** _Facetvec; // pointer to vector of facets
; 207  :         size_t _Facetcount; // size of vector of facets
; 208  :         category _Catmask; // mask describing implemented categories
; 209  :         bool _Xparent; // true if locale is transparent
; 210  :         _Yarn<char> _Name; // locale name, or "*" if not known
; 211  : 
; 212  :         __PURE_APPDOMAIN_GLOBAL static _Locimp* _Clocptr;
; 213  : 
; 214  :     public:
; 215  :         _Locimp& __CLR_OR_THIS_CALL operator=(const _Locimp&) = delete;
; 216  :     };
; 217  : 
; 218  :     template <class _Elem, class _Traits, class _Alloc>
; 219  :     bool operator()(
; 220  :         const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) const {
; 221  :         // compare _Left and _Right strings using collate facet in locale
; 222  :         const auto& _Coll_fac = _STD use_facet<_STD collate<_Elem>>(*this);
; 223  : 
; 224  :         const _Elem* const _Left_data  = _Left.data();
; 225  :         const _Elem* const _Right_data = _Right.data();
; 226  :         return _Coll_fac.compare(_Left_data, _Left_data + _Left.size(), _Right_data, _Right_data + _Right.size()) < 0;
; 227  :     }
; 228  : 
; 229  :     template <class _Facet>
; 230  :     locale combine(const locale& _Loc) const { // combine two locales
; 231  :         _Facet* _Facptr;
; 232  : 
; 233  :         _TRY_BEGIN
; 234  :         _Facptr = const_cast<_Facet*>(_STD addressof(_STD use_facet<_Facet>(_Loc)));
; 235  :         _CATCH_ALL
; 236  :         _Xruntime_error("locale::combine facet missing");
; 237  :         _CATCH_END
; 238  : 
; 239  :         _Locimp* _Newimp = _Locimp::_New_Locimp(*_Ptr);
; 240  :         _Newimp->_Addfac(_Facptr, _Facet::id._Get_index());
; 241  :         _Newimp->_Catmask = none;
; 242  :         _Newimp->_Name    = "*";
; 243  :         return locale{_Secret_locale_construct_tag{}, _Newimp};
; 244  :     }
; 245  : 
; 246  :     template <class _Facet>
; 247  :     locale(const locale& _Loc, const _Facet* _Facptr) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
; 248  :         if (_Facptr) { // replace facet
; 249  :             _Ptr->_Addfac(const_cast<_Facet*>(_Facptr), _Facet::id._Get_index());
; 250  :             _Ptr->_Catmask = none;
; 251  :             _Ptr->_Name    = "*";
; 252  :         }
; 253  :     }
; 254  : 
; 255  : #pragma warning(push)
; 256  : #pragma warning(disable : 26495) // Variable 'std::locale::_Ptr' is uninitialized.
; 257  :                                  // Always initialize a member variable (type.6).
; 258  : 
; 259  :     // We must not explicitly initialize _Ptr here; we rely on it maintaining the value
; 260  :     // previously created in its storage. To be precise:
; 261  :     // In locale0.cpp, locale::_Init() uses True Placement New at classic_locale's address,
; 262  :     // and classic_locale is constructed from the _Noinit enumerator of type _Uninitialized.
; 263  :     // The sequencing is highly unusual; the True Placement New happens before the _Uninitialized construction,
; 264  :     // so while _Ptr here formally has indeterminate value, we expect it to actually keep the previous value.
; 265  :     locale(_Uninitialized) {} // defer construction
; 266  : #pragma warning(pop)
; 267  : 
; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {
; 269  :         _Ptr->_Incref();
; 270  :     }
; 271  : 
; 272  :     locale() noexcept : _Ptr(_Init(true)) {}
; 273  : 
; 274  : #if !defined(MRTDLL) || !defined(_CRTBLD)
; 275  :     locale(const locale& _Loc, const locale& _Other, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
; 276  :         // construct a locale by copying named facets
; 277  :         if (_Cat != none) { // worth adding, do it
; 278  :             _STL_ASSERT((_Cat & all) == _Cat, "the bitmask value specifying category must be valid");
; 279  :             _Facet_guard _Guard{_Ptr};
; 280  :             _BEGIN_LOCINFO(_Lobj)
; 281  :             _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, &_Other);
; 282  :             _Lobj._Addcats(_Loc._Ptr->_Catmask, _Loc.name().c_str());
; 283  :             _Lobj._Addcats(_Other._Ptr->_Catmask, _Other.name().c_str());
; 284  :             _Ptr->_Catmask = _Loc._Ptr->_Catmask | _Other._Ptr->_Catmask;
; 285  :             _Ptr->_Name    = _Lobj._Getname();
; 286  :             _END_LOCINFO()
; 287  :             _Guard._Target = nullptr;
; 288  :         }
; 289  :     }
; 290  : 
; 291  : private:
; 292  :     void _Construct(const string& _Str, category _Cat) {
; 293  :         _STL_ASSERT((_Cat & all) == _Cat, "the bitmask value specifying category must be valid");
; 294  :         // construct a locale with named facets
; 295  :         bool _Bad = false;
; 296  :         _Init();
; 297  :         if (_Cat != none) { // worth adding, do it
; 298  :             _Facet_guard _Guard{_Ptr};
; 299  :             _BEGIN_LOCINFO(_Lobj(_Cat, _Str.c_str()))
; 300  :             if (_Badname(_Lobj)) {
; 301  :                 _Bad = true;
; 302  :             } else { // name okay, build the locale
; 303  :                 _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, nullptr);
; 304  :                 _Ptr->_Catmask = _Cat;
; 305  :                 _Ptr->_Name    = _Str.c_str();
; 306  :             }
; 307  :             _END_LOCINFO()
; 308  :             _Guard._Target = nullptr;
; 309  :         }
; 310  : 
; 311  :         if (_Bad) { // Don't throw within _BEGIN_LOCINFO if we can avoid it
; 312  :             delete _Ptr->_Decref();
; 313  :             _Xruntime_error("bad locale name");
; 314  :         }
; 315  :     }
; 316  : 
; 317  : public:
; 318  :     explicit locale(const char* _Locname, category _Cat = all) : _Ptr(_Locimp::_New_Locimp()) {
; 319  :         // construct a locale with named facets
; 320  :         // _Locname might have been returned from setlocale().
; 321  :         // Therefore, _Construct() takes const string&.
; 322  :         if (_Locname) {
; 323  :             _Construct(_Locname, _Cat);
; 324  :             return;
; 325  :         }
; 326  : 
; 327  :         _Xruntime_error("bad locale name");
; 328  :     }
; 329  : 
; 330  :     locale(const locale& _Loc, const char* _Locname, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
; 331  :         // construct a locale by copying, replacing named facets
; 332  :         // _Locname might have been returned from setlocale().
; 333  :         // Therefore, _Construct() takes const string&.
; 334  :         if (_Locname) {
; 335  :             _Construct(_Locname, _Cat);
; 336  :             return;
; 337  :         }
; 338  : 
; 339  :         _Xruntime_error("bad locale name");
; 340  :     }
; 341  : 
; 342  :     explicit locale(const string& _Str, category _Cat = all) : _Ptr(_Locimp::_New_Locimp()) {
; 343  :         // construct a locale with named facets
; 344  :         _Construct(_Str, _Cat);
; 345  :     }
; 346  : 
; 347  :     locale(const locale& _Loc, const string& _Str, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
; 348  :         // construct a locale by copying, replacing named facets
; 349  :         _Construct(_Str, _Cat);
; 350  :     }
; 351  : #endif // !MRTDLL || !_CRTBLD
; 352  : 
; 353  :     ~locale() noexcept {
; 354  :         if (_Ptr) {
; 355  :             delete _Ptr->_Decref();
; 356  :         }
; 357  :     }
; 358  : 
; 359  :     const locale& operator=(const locale& _Right) noexcept {
; 360  :         if (_Ptr != _Right._Ptr) { // different implementation, point at new one
; 361  :             delete _Ptr->_Decref();
; 362  :             _Ptr = _Right._Ptr;
; 363  :             _Ptr->_Incref();
; 364  :         }
; 365  :         return *this;
; 366  :     }
; 367  : 
; 368  :     string name() const {
; 369  :         return _Ptr ? _Ptr->_Name.c_str() : string{};
; 370  :     }
; 371  : 
; 372  :     _Ret_z_ const char* _C_str() const noexcept {
; 373  :         return _Ptr ? _Ptr->_Name.c_str() : "";
; 374  :     }
; 375  : 
; 376  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object
; 377  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  000a2	33 f6		 xor	 esi, esi
  000a4	89 4d f0	 mov	 DWORD PTR $T5[ebp], ecx
$LN42@use_facet:

; 378  :         if (_Facptr || !_Ptr->_Xparent) {

  000a7	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0
  000ab	74 16		 je	 SHORT $LN14@use_facet

; 379  :             return _Facptr; // found facet or not transparent
; 380  :         }
; 381  : 
; 382  :         // look in current locale
; 383  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

  000ad	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 384  :         if (_Id < _Ptr0->_Facetcount) {

  000b2	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  000b5	73 10		 jae	 SHORT $LN43@use_facet

; 385  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

  000b7	0f ae e8	 lfence
  000ba	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000bd	8b 75 f0	 mov	 esi, DWORD PTR $T5[ebp]
  000c0	8b 34 06	 mov	 esi, DWORD PTR [esi+eax]
$LN14@use_facet:

; 438  : 
; 439  :     const size_t _Id         = _Facet::id._Get_index();
; 440  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);
; 441  : 
; 442  :     if (!_Pf) {

  000c3	85 f6		 test	 esi, esi
  000c5	75 3c		 jne	 SHORT $LN39@use_facet
$LN43@use_facet:

; 443  :         if (_Psave) {

  000c7	85 db		 test	 ebx, ebx
  000c9	74 04		 je	 SHORT $LN3@use_facet

; 444  :             _Pf = _Psave; // lazy facet already allocated

  000cb	8b f3		 mov	 esi, ebx
  000cd	eb 34		 jmp	 SHORT $LN39@use_facet
$LN3@use_facet:

; 445  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

  000cf	ff 75 08	 push	 DWORD PTR __Loc$[ebp]
  000d2	8d 45 ec	 lea	 eax, DWORD PTR __Psave$3[ebp]
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 ?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::numpunct<wchar_t>::_Getcat
  000db	83 c4 08	 add	 esp, 8
  000de	83 f8 ff	 cmp	 eax, -1
  000e1	74 3c		 je	 SHORT $LN48@use_facet
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  000e3	8b 75 ec	 mov	 esi, DWORD PTR __Psave$3[ebp]
  000e6	89 75 08	 mov	 DWORD PTR __Psave_guard$6[ebp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 458  :             _Facet_Register(_Pfmod);

  000e9	56		 push	 esi
  000ea	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000ee	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register

; 459  : #endif // ^^^ !defined(_M_CEE) ^^^
; 460  : 
; 461  :             _Pfmod->_Incref();

  000f3	8b 16		 mov	 edx, DWORD PTR [esi]
  000f5	83 c4 04	 add	 esp, 4
  000f8	8b ce		 mov	 ecx, esi
  000fa	ff 52 04	 call	 DWORD PTR [edx+4]

; 462  :             _Facetptr<_Facet>::_Psave = _Psave;

  000fd	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::numpunct<wchar_t> >::_Psave
$LN39@use_facet:

; 463  :             _Pf                       = _Psave;
; 464  : 
; 465  :             (void) _Psave_guard.release();
; 466  :         }
; 467  :     }
; 468  : 
; 469  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

  00103	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00106	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0010b	8b c6		 mov	 eax, esi

; 470  :     _END_LOCK()
; 471  : } // end of use_facet body

  0010d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00110	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00117	59		 pop	 ecx
  00118	5f		 pop	 edi
  00119	5e		 pop	 esi
  0011a	5b		 pop	 ebx
  0011b	8b e5		 mov	 esp, ebp
  0011d	5d		 pop	 ebp
  0011e	c3		 ret	 0
$LN48@use_facet:

; 446  : #if _HAS_EXCEPTIONS
; 447  :             _Throw_bad_cast(); // lazy disallowed

  0011f	e8 00 00 00 00	 call	 ?_Throw_bad_cast@std@@YAXXZ ; std::_Throw_bad_cast
$LN45@use_facet:
  00124	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z$1:
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __Psave_guard$6[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::numpunct<wchar_t> >
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??$_Float_put_desired_precision@N@std@@YAH_JH@Z
_TEXT	SEGMENT
__Precision$ = 8					; size = 8
__Float_flags$ = 16					; size = 4
??$_Float_put_desired_precision@N@std@@YAH_JH@Z PROC	; std::_Float_put_desired_precision<double>, COMDAT

; 1178 : int _Float_put_desired_precision(const streamsize _Precision, const ios_base::fmtflags _Float_flags) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 10	 mov	 ecx, DWORD PTR __Float_flags$[ebp]

; 1179 :     // return the effective precision determined by N4950 [facet.num.put.virtuals]/2.1 and printf's rules
; 1180 :     const bool _Is_hex = _Float_flags == (ios_base::fixed | ios_base::scientific);

  00006	81 f9 00 30 00
	00		 cmp	 ecx, 12288		; 00003000H

; 1181 :     if (_Is_hex) {

  0000c	75 07		 jne	 SHORT $LN2@Float_put_

; 1182 :         // return the number of hexits needed (after the radix point) to represent the floating-point value exactly
; 1183 :         if constexpr (is_same_v<_Ty, double>) {
; 1184 :             return ((DBL_MANT_DIG - 1) + 3) / 4;

  0000e	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH

; 1204 :     }
; 1205 : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
$LN2@Float_put_:

; 1185 :         } else if constexpr (is_same_v<_Ty, long double>) {
; 1186 :             return ((LDBL_MANT_DIG - 1) + 3) / 4;
; 1187 :         } else {
; 1188 :             _STL_INTERNAL_STATIC_ASSERT(false); // unexpected type; shouldn't be float
; 1189 :         }
; 1190 :     }
; 1191 : 
; 1192 :     if (_Precision > 0) {

  00015	8b 55 0c	 mov	 edx, DWORD PTR __Precision$[ebp+4]
  00018	8b 45 08	 mov	 eax, DWORD PTR __Precision$[ebp]
  0001b	85 d2		 test	 edx, edx
  0001d	7c 06		 jl	 SHORT $LN3@Float_put_
  0001f	7f 14		 jg	 SHORT $LN6@Float_put_
  00021	85 c0		 test	 eax, eax
  00023	75 10		 jne	 SHORT $LN6@Float_put_
$LN3@Float_put_:

; 1193 :         return static_cast<int>(_Precision);
; 1194 :     } else if (_Precision == 0) {

  00025	0b c2		 or	 eax, edx
  00027	75 07		 jne	 SHORT $LN5@Float_put_

; 1195 :         const bool _Is_default_float = _Float_flags == 0;

  00029	85 c9		 test	 ecx, ecx
  0002b	0f 94 c0	 sete	 al

; 1204 :     }
; 1205 : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
$LN5@Float_put_:

; 1196 :         if (_Is_default_float) {
; 1197 :             return 1;
; 1198 :         } else {
; 1199 :             return 0;
; 1200 :         }
; 1201 :     } else {
; 1202 :         constexpr int _Default_precision = 6;
; 1203 :         return _Default_precision;

  00030	b8 06 00 00 00	 mov	 eax, 6
$LN6@Float_put_:

; 1204 :     }
; 1205 : }

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Float_put_desired_precision@N@std@@YAH_JH@Z ENDP	; std::_Float_put_desired_precision<double>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??$_Fput_v3@$0A@@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@1@V21@AAVios_base@1@_WPBDI_N@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$1$ = -116				; size = 4
__Su$1$ = -112						; size = 4
__Eoff$1$ = -108					; size = 4
__Old_capacity$1$ = -108				; size = 4
__Pg$1$ = -104						; size = 4
$T2 = -104						; size = 4
__New_ptr$1$ = -100					; size = 4
__Buf$GSCopy$1$ = -100					; size = 4
__Iosbase$GSCopy$1$ = -96				; size = 4
__Prefix$1$ = -92					; size = 4
__Dp$ = -88						; size = 2
$T3 = -84						; size = 8
$T4 = -84						; size = 8
$T5 = -84						; size = 8
$T6 = -84						; size = 8
$T7 = -84						; size = 8
$T8 = -84						; size = 8
$T9 = -84						; size = 8
$T10 = -84						; size = 8
tv1253 = -80						; size = 4
__Kseparator$1$ = -76					; size = 4
__Ctype_fac$1$ = -76					; size = 4
_this$1$ = -72						; size = 4
tv1259 = -68						; size = 4
__Punct_fac$1$ = -68					; size = 4
__Grouping$ = -64					; size = 24
__Groupstring$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Buf$ = 28						; size = 4
__Count$ = 32						; size = 4
__Is_finite_val$ = 36					; size = 1
??$_Fput_v3@$0A@@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@1@V21@AAVios_base@1@_WPBDI_N@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Fput_v3<0>, COMDAT
; _this$ = ecx

; 1470 :         bool _Is_finite_val) const { // put formatted floating-point to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Fput_v3@$0A@@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@1@V21@AAVios_base@1@_WPBDI_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 68	 sub	 esp, 104		; 00000068H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 4d b8	 mov	 DWORD PTR _this$1$[ebp], ecx
  0002e	8b 75 20	 mov	 esi, DWORD PTR __Count$[ebp]
  00031	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00034	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00037	8b 5d 1c	 mov	 ebx, DWORD PTR __Buf$[ebp]
  0003a	89 45 8c	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
  0003d	89 4d a0	 mov	 DWORD PTR __Iosbase$GSCopy$1$[ebp], ecx
  00040	89 5d 9c	 mov	 DWORD PTR __Buf$GSCopy$1$[ebp], ebx

; 1471 :         auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));

  00043	85 f6		 test	 esi, esi
  00045	74 11		 je	 SHORT $LN20@Fput_v3
  00047	8a 03		 mov	 al, BYTE PTR [ebx]
  00049	3c 2b		 cmp	 al, 43			; 0000002bH
  0004b	74 04		 je	 SHORT $LN19@Fput_v3
  0004d	3c 2d		 cmp	 al, 45			; 0000002dH
  0004f	75 07		 jne	 SHORT $LN20@Fput_v3
$LN19@Fput_v3:
  00051	bf 01 00 00 00	 mov	 edi, 1
  00056	eb 02		 jmp	 SHORT $LN285@Fput_v3
$LN20@Fput_v3:
  00058	33 ff		 xor	 edi, edi
$LN285@Fput_v3:

; 1472 :         const char* _Exps;
; 1473 :         if ((_Iosbase.flags() & ios_base::floatfield) != (ios_base::scientific | ios_base::fixed)) {

  0005a	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0005d	25 00 30 00 00	 and	 eax, 12288		; 00003000H
  00062	89 7d a4	 mov	 DWORD PTR __Prefix$1$[ebp], edi
  00065	3d 00 30 00 00	 cmp	 eax, 12288		; 00003000H
  0006a	74 07		 je	 SHORT $LN4@Fput_v3

; 1474 :             _Exps = "eE";

  0006c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02MDKMJEGG@eE@

; 1475 :         } else { // correct for hexadecimal floating-point

  00071	eb 25		 jmp	 SHORT $LN6@Fput_v3
$LN4@Fput_v3:

; 1476 :             _Exps = "pP";
; 1477 :             if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
; 1478 :                 && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X')) {

  00073	8d 47 02	 lea	 eax, DWORD PTR [edi+2]
  00076	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02OOPEBDOJ@pP@
  0007b	3b c6		 cmp	 eax, esi
  0007d	77 19		 ja	 SHORT $LN6@Fput_v3
  0007f	80 3c 3b 30	 cmp	 BYTE PTR [ebx+edi], 48	; 00000030H
  00083	75 13		 jne	 SHORT $LN6@Fput_v3
  00085	8a 4c 3b 01	 mov	 cl, BYTE PTR [ebx+edi+1]
  00089	80 f9 78	 cmp	 cl, 120			; 00000078H
  0008c	74 05		 je	 SHORT $LN7@Fput_v3
  0008e	80 f9 58	 cmp	 cl, 88			; 00000058H
  00091	75 05		 jne	 SHORT $LN6@Fput_v3
$LN7@Fput_v3:

; 1479 :                 _Prefix += 2;

  00093	8b f8		 mov	 edi, eax
  00095	89 7d a4	 mov	 DWORD PTR __Prefix$1$[ebp], edi
$LN6@Fput_v3:

; 1480 :             }
; 1481 :         }
; 1482 :         const size_t _Eoff = _CSTD strcspn(&_Buf[0], _Exps); // find exponent

  00098	52		 push	 edx
  00099	53		 push	 ebx
  0009a	e8 00 00 00 00	 call	 _strcspn
  0009f	89 45 94	 mov	 DWORD PTR __Eoff$1$[ebp], eax

; 1483 :         char _Dp[2]        = {"."};

  000a2	b8 2e 00 00 00	 mov	 eax, 46			; 0000002eH
  000a7	66 89 45 a8	 mov	 WORD PTR __Dp$[ebp], ax

; 1484 :         _Dp[0]             = (_CSTD localeconv())->decimal_point[0];

  000ab	e8 00 00 00 00	 call	 _localeconv
  000b0	8b 00		 mov	 eax, DWORD PTR [eax]
  000b2	8a 00		 mov	 al, BYTE PTR [eax]
  000b4	88 45 a8	 mov	 BYTE PTR __Dp$[ebp], al

; 1485 :         const size_t _Poff = _CSTD strcspn(&_Buf[0], &_Dp[0]); // find decimal point

  000b7	8d 45 a8	 lea	 eax, DWORD PTR __Dp$[ebp]
  000ba	50		 push	 eax
  000bb	53		 push	 ebx
  000bc	e8 00 00 00 00	 call	 _strcspn
  000c1	8b d8		 mov	 ebx, eax
  000c3	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 289  :         return *_Ploc;

  000c6	8b 45 a0	 mov	 eax, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  000c9	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  000cc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000cf	89 4d 98	 mov	 DWORD PTR $T2[ebp], ecx
  000d2	89 4d b0	 mov	 DWORD PTR $T3[ebp+4], ecx

; 269  :         _Ptr->_Incref();

  000d5	8b 01		 mov	 eax, DWORD PTR [ecx]
  000d7	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1487 :         const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());

  000da	8d 45 ac	 lea	 eax, DWORD PTR $T3[ebp]
  000dd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
  000ea	8b 4d 98	 mov	 ecx, DWORD PTR $T2[ebp]
  000ed	83 c4 04	 add	 esp, 4
  000f0	89 45 b4	 mov	 DWORD PTR __Ctype_fac$1$[ebp], eax
  000f3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000fa	85 c9		 test	 ecx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  000fc	74 11		 je	 SHORT $LN124@Fput_v3

; 355  :             delete _Ptr->_Decref();

  000fe	8b 01		 mov	 eax, DWORD PTR [ecx]
  00100	ff 50 08	 call	 DWORD PTR [eax+8]
  00103	8b c8		 mov	 ecx, eax
  00105	85 c9		 test	 ecx, ecx
  00107	74 06		 je	 SHORT $LN124@Fput_v3
  00109	8b 01		 mov	 eax, DWORD PTR [ecx]
  0010b	6a 01		 push	 1
  0010d	ff 10		 call	 DWORD PTR [eax]
$LN124@Fput_v3:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1488 :         basic_string<_Elem> _Groupstring(_Count, _Elem(0)); // reserve space

  0010f	6a 00		 push	 0
  00111	56		 push	 esi
  00112	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00115	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  0011a	83 7d ec 07	 cmp	 DWORD PTR __Groupstring$[ebp+20], 7

; 435  :         value_type* _Result = _Bx._Buf;

  0011e	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 2936 :         return do_widen(_First, _Last, _Dest);

  00121	8b 45 b4	 mov	 eax, DWORD PTR __Ctype_fac$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 436  :         if (_Large_mode_engaged()) {

  00124	0f 47 4d d8	 cmova	 ecx, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 2936 :         return do_widen(_First, _Last, _Dest);

  00128	51		 push	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1489 :         _Ctype_fac.widen(_Buf, _Buf + _Count, &_Groupstring[0]);

  00129	8b 4d 9c	 mov	 ecx, DWORD PTR __Buf$GSCopy$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 2936 :         return do_widen(_First, _Last, _Dest);

  0012c	8b 00		 mov	 eax, DWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1488 :         basic_string<_Elem> _Groupstring(_Count, _Elem(0)); // reserve space

  0012e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 2936 :         return do_widen(_First, _Last, _Dest);

  00135	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1489 :         _Ctype_fac.widen(_Buf, _Buf + _Count, &_Groupstring[0]);

  00138	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 2936 :         return do_widen(_First, _Last, _Dest);

  0013b	50		 push	 eax
  0013c	51		 push	 ecx
  0013d	8b 4d b4	 mov	 ecx, DWORD PTR __Ctype_fac$1$[ebp]
  00140	ff d2		 call	 edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 289  :         return *_Ploc;

  00142	8b 4d a0	 mov	 ecx, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00145	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  00148	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0014b	89 4d b0	 mov	 DWORD PTR $T4[ebp+4], ecx

; 269  :         _Ptr->_Incref();

  0014e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00150	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1491 :         const auto& _Punct_fac  = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

  00153	8d 45 ac	 lea	 eax, DWORD PTR $T4[ebp]
  00156	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0015a	50		 push	 eax
  0015b	e8 00 00 00 00	 call	 ??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<wchar_t> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  00160	8b 55 b0	 mov	 edx, DWORD PTR $T4[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1491 :         const auto& _Punct_fac  = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

  00163	83 c4 04	 add	 esp, 4
  00166	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0016a	8b c8		 mov	 ecx, eax
  0016c	89 4d bc	 mov	 DWORD PTR __Punct_fac$1$[ebp], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  0016f	85 d2		 test	 edx, edx
  00171	74 16		 je	 SHORT $LN150@Fput_v3

; 355  :             delete _Ptr->_Decref();

  00173	8b 02		 mov	 eax, DWORD PTR [edx]
  00175	8b ca		 mov	 ecx, edx
  00177	ff 50 08	 call	 DWORD PTR [eax+8]
  0017a	8b c8		 mov	 ecx, eax
  0017c	85 c9		 test	 ecx, ecx
  0017e	74 06		 je	 SHORT $LN282@Fput_v3
  00180	8b 01		 mov	 eax, DWORD PTR [ecx]
  00182	6a 01		 push	 1
  00184	ff 10		 call	 DWORD PTR [eax]
$LN282@Fput_v3:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 108  :         return do_grouping();

  00186	8b 4d bc	 mov	 ecx, DWORD PTR __Punct_fac$1$[ebp]
$LN150@Fput_v3:
  00189	8b 01		 mov	 eax, DWORD PTR [ecx]
  0018b	8d 55 c0	 lea	 edx, DWORD PTR __Grouping$[ebp]
  0018e	52		 push	 edx
  0018f	ff 50 14	 call	 DWORD PTR [eax+20]

; 104  :         return do_thousands_sep();

  00192	8b 4d bc	 mov	 ecx, DWORD PTR __Punct_fac$1$[ebp]

; 1492 :         const string _Grouping  = _Punct_fac.grouping();

  00195	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 104  :         return do_thousands_sep();

  00199	8b 01		 mov	 eax, DWORD PTR [ecx]
  0019b	ff 50 10	 call	 DWORD PTR [eax+16]

; 1493 :         const _Elem _Kseparator = _Punct_fac.thousands_sep();

  0019e	0f b7 c0	 movzx	 eax, ax
  001a1	89 45 b4	 mov	 DWORD PTR __Kseparator$1$[ebp], eax

; 1494 : 
; 1495 :         if (_Poff != _Count) {

  001a4	3b de		 cmp	 ebx, esi
  001a6	74 1a		 je	 SHORT $LN8@Fput_v3

; 100  :         return do_decimal_point();

  001a8	8b 4d bc	 mov	 ecx, DWORD PTR __Punct_fac$1$[ebp]
  001ab	8b 01		 mov	 eax, DWORD PTR [ecx]
  001ad	ff 50 0c	 call	 DWORD PTR [eax+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  001b0	83 7d ec 07	 cmp	 DWORD PTR __Groupstring$[ebp+20], 7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 100  :         return do_decimal_point();

  001b4	0f b7 c8	 movzx	 ecx, ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 435  :         value_type* _Result = _Bx._Buf;

  001b7	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]

; 436  :         if (_Large_mode_engaged()) {

  001ba	0f 47 45 d8	 cmova	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1496 :             _Groupstring[_Poff] = _Punct_fac.decimal_point();

  001be	66 89 0c 58	 mov	 WORD PTR [eax+ebx*2], cx
$LN8@Fput_v3:

; 1497 :         }
; 1498 : 
; 1499 :         if (_Is_finite_val) {

  001c2	80 7d 24 00	 cmp	 BYTE PTR __Is_finite_val$[ebp], 0
  001c6	0f 84 a5 01 00
	00		 je	 $LN281@Fput_v3

; 1500 :             size_t _Off     = _Poff == _Count ? _Eoff : _Poff;

  001cc	3b de		 cmp	 ebx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

  001ce	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1500 :             size_t _Off     = _Poff == _Count ? _Eoff : _Poff;

  001d1	0f 44 5d 94	 cmove	 ebx, DWORD PTR __Eoff$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  001d5	83 7d d4 0f	 cmp	 DWORD PTR __Grouping$[ebp+20], 15 ; 0000000fH

; 445  :         if (_Large_mode_engaged()) {

  001d9	0f 47 4d c0	 cmova	 ecx, DWORD PTR __Grouping$[ebp]
  001dd	89 4d 98	 mov	 DWORD PTR __Pg$1$[ebp], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1502 :             while (*_Pg != CHAR_MAX && '\0' < *_Pg && static_cast<size_t>(*_Pg) < _Off - _Prefix) {

  001e0	8a 01		 mov	 al, BYTE PTR [ecx]
  001e2	3c 7f		 cmp	 al, 127			; 0000007fH
  001e4	0f 84 87 01 00
	00		 je	 $LN281@Fput_v3
  001ea	66 0f 1f 44 00
	00		 npad	 6
$LL2@Fput_v3:
  001f0	84 c0		 test	 al, al
  001f2	0f 8e 79 01 00
	00		 jle	 $LN281@Fput_v3
  001f8	0f be 09	 movsx	 ecx, BYTE PTR [ecx]
  001fb	8b c3		 mov	 eax, ebx
  001fd	2b c7		 sub	 eax, edi
  001ff	3b c8		 cmp	 ecx, eax
  00201	0f 83 6a 01 00
	00		 jae	 $LN281@Fput_v3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 469  :         if (_Mysize < _Off) {

  00207	8b 7d e8	 mov	 edi, DWORD PTR __Groupstring$[ebp+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1504 :                 _Groupstring.insert(_Off -= *_Pg, 1, _Kseparator);

  0020a	2b d9		 sub	 ebx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 469  :         if (_Mysize < _Off) {

  0020c	3b fb		 cmp	 edi, ebx
  0020e	0f 82 0b 03 00
	00		 jb	 $LN264@Fput_v3

; 1787 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00214	8b 4d ec	 mov	 ecx, DWORD PTR __Groupstring$[ebp+20]
  00217	8b c1		 mov	 eax, ecx
  00219	2b c7		 sub	 eax, edi
  0021b	89 4d 94	 mov	 DWORD PTR __Old_capacity$1$[ebp], ecx

; 1788 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  0021e	83 f8 01	 cmp	 eax, 1
  00221	72 36		 jb	 SHORT $LN27@Fput_v3

; 1789 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1790 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00223	0f ae e8	 lfence
  00226	ff 45 e8	 inc	 DWORD PTR __Groupstring$[ebp+16]

; 435  :         value_type* _Result = _Bx._Buf;

  00229	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]

; 453  :         return _Myres > _Small_string_capacity;

  0022c	83 7d ec 07	 cmp	 DWORD PTR __Groupstring$[ebp+20], 7

; 436  :         if (_Large_mode_engaged()) {

  00230	0f 47 45 d8	 cmova	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00234	2b fb		 sub	 edi, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1792 :             _Elem* const _Insert_at = _Old_ptr + _Off;

  00236	8d 34 58	 lea	 esi, DWORD PTR [eax+ebx*2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00239	8d 04 7d 02 00
	00 00		 lea	 eax, DWORD PTR [edi*2+2]
  00240	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1793 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

  00241	8d 46 02	 lea	 eax, DWORD PTR [esi+2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00244	56		 push	 esi
  00245	50		 push	 eax
  00246	e8 00 00 00 00	 call	 _memmove
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h

; 519  :             *_Su = _C;

  0024b	8b 45 b4	 mov	 eax, DWORD PTR __Kseparator$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0024e	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h

; 519  :             *_Su = _C;

  00251	66 89 06	 mov	 WORD PTR [esi], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1795 :             return *this;

  00254	e9 fb 00 00 00	 jmp	 $LN54@Fput_v3
$LN27@Fput_v3:

; 3028 :         const size_type _Old_size = _My_data._Mysize;

  00259	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH
  0025e	2b c7		 sub	 eax, edi

; 3029 :         if (max_size() - _Old_size < _Size_increase) {

  00260	83 f8 01	 cmp	 eax, 1
  00263	0f 82 b1 02 00
	00		 jb	 $LN265@Fput_v3

; 3031 :         }
; 3032 : 
; 3033 :         const size_type _New_size     = _Old_size + _Size_increase;

  00269	8d 77 01	 lea	 esi, DWORD PTR [edi+1]

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

  0026c	83 ce 07	 or	 esi, 7
  0026f	81 fe fe ff ff
	7f		 cmp	 esi, 2147483646		; 7ffffffeH

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00275	76 0a		 jbe	 SHORT $LN60@Fput_v3

; 2980 :             return _Max;

  00277	be fe ff ff 7f	 mov	 esi, 2147483646		; 7ffffffeH
  0027c	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0027f	eb 2f		 jmp	 SHORT $LN279@Fput_v3
$LN60@Fput_v3:

; 2981 :         }
; 2982 : 
; 2983 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00281	8b d1		 mov	 edx, ecx
  00283	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH
  00288	d1 ea		 shr	 edx, 1
  0028a	2b c2		 sub	 eax, edx
  0028c	3b c8		 cmp	 ecx, eax
  0028e	76 0a		 jbe	 SHORT $LN61@Fput_v3

; 2984 :             return _Max;

  00290	be fe ff ff 7f	 mov	 esi, 2147483646		; 7ffffffeH
  00295	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00298	eb 16		 jmp	 SHORT $LN279@Fput_v3
$LN61@Fput_v3:

; 2985 :         }
; 2986 : 
; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0029a	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  0029d	3b f0		 cmp	 esi, eax
  0029f	0f 42 f0	 cmovb	 esi, eax

; 825  :         ++_Capacity; // Take null terminator into consideration

  002a2	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  002a5	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  002aa	0f 87 65 02 00
	00		 ja	 $LN266@Fput_v3
$LN279@Fput_v3:

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  002b0	03 c0		 add	 eax, eax

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  002b2	50		 push	 eax

; 122  :     return _Count * _Ty_size;

  002b3	0f ae e8	 lfence

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  002b6	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3041 :         _My_data._Mysize      = _New_size;

  002bb	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]

; 3042 :         _My_data._Myres       = _New_capacity;

  002be	89 75 ec	 mov	 DWORD PTR __Groupstring$[ebp+20], esi

; 3043 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  002c1	2b fb		 sub	 edi, ebx
  002c3	89 4d e8	 mov	 DWORD PTR __Groupstring$[ebp+16], ecx
  002c6	8d 0c 1b	 lea	 ecx, DWORD PTR [ebx+ebx]
  002c9	89 45 9c	 mov	 DWORD PTR __New_ptr$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  002cc	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3043 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  002cf	8d 34 01	 lea	 esi, DWORD PTR [ecx+eax]
  002d2	89 75 90	 mov	 DWORD PTR __Su$1$[ebp], esi
  002d5	8d 14 7d 02 00
	00 00		 lea	 edx, DWORD PTR [edi*2+2]

; 3044 :         if (_Old_capacity > _Small_string_capacity) {

  002dc	8b 7d 94	 mov	 edi, DWORD PTR __Old_capacity$1$[ebp]
  002df	89 55 bc	 mov	 DWORD PTR tv1259[ebp], edx
  002e2	8d 56 02	 lea	 edx, DWORD PTR [esi+2]
  002e5	89 55 b0	 mov	 DWORD PTR tv1253[ebp], edx
  002e8	0f ae e8	 lfence
  002eb	51		 push	 ecx
  002ec	83 ff 07	 cmp	 edi, 7
  002ef	76 35		 jbe	 SHORT $LN53@Fput_v3

; 3045 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  002f1	8b 75 d8	 mov	 esi, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  002f4	56		 push	 esi
  002f5	50		 push	 eax
  002f6	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h

; 519  :             *_Su = _C;

  002fb	8b 45 90	 mov	 eax, DWORD PTR __Su$1$[ebp]
  002fe	8b 4d b4	 mov	 ecx, DWORD PTR __Kseparator$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00301	ff 75 bc	 push	 DWORD PTR tv1259[ebp]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h

; 519  :             *_Su = _C;

  00304	66 89 08	 mov	 WORD PTR [eax], cx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1804 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  00307	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  0030a	03 c6		 add	 eax, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0030c	50		 push	 eax
  0030d	8b 45 b0	 mov	 eax, DWORD PTR tv1253[ebp]
  00310	50		 push	 eax
  00311	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3047 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

  00316	57		 push	 edi
  00317	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  0031a	56		 push	 esi
  0031b	50		 push	 eax
  0031c	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAAV?$allocator@_W@2@QA_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Deallocate_for_capacity
  00321	83 c4 24	 add	 esp, 36			; 00000024H

; 3048 :             _My_data._Bx._Ptr = _New_ptr;
; 3049 :         } else {

  00324	eb 28		 jmp	 SHORT $LN286@Fput_v3
$LN53@Fput_v3:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00326	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00329	51		 push	 ecx
  0032a	50		 push	 eax
  0032b	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h

; 519  :             *_Su = _C;

  00330	8b 45 b4	 mov	 eax, DWORD PTR __Kseparator$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1804 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  00333	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00336	ff 75 bc	 push	 DWORD PTR tv1259[ebp]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h

; 519  :             *_Su = _C;

  00339	66 89 06	 mov	 WORD PTR [esi], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1804 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  0033c	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  0033f	03 c1		 add	 eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00341	50		 push	 eax
  00342	8d 46 02	 lea	 eax, DWORD PTR [esi+2]
  00345	50		 push	 eax
  00346	e8 00 00 00 00	 call	 _memcpy
  0034b	83 c4 18	 add	 esp, 24			; 00000018H
$LN286@Fput_v3:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1505 :                 if ('\0' < _Pg[1]) {

  0034e	8b 45 9c	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
  00351	89 45 d8	 mov	 DWORD PTR __Groupstring$[ebp], eax
$LN54@Fput_v3:
  00354	8b 4d 98	 mov	 ecx, DWORD PTR __Pg$1$[ebp]
  00357	80 79 01 00	 cmp	 BYTE PTR [ecx+1], 0
  0035b	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0035e	8b 7d a4	 mov	 edi, DWORD PTR __Prefix$1$[ebp]
  00361	0f 4f c8	 cmovg	 ecx, eax
  00364	89 4d 98	 mov	 DWORD PTR __Pg$1$[ebp], ecx
  00367	8a 01		 mov	 al, BYTE PTR [ecx]
  00369	3c 7f		 cmp	 al, 127			; 0000007fH
  0036b	0f 85 7f fe ff
	ff		 jne	 $LL2@Fput_v3
$LN281@Fput_v3:

; 1506 :                     ++_Pg; // not last group, advance
; 1507 :                 }
; 1508 :             }
; 1509 :         }
; 1510 : 
; 1511 :         _Count = _Groupstring.size();
; 1512 : 
; 1513 :         size_t _Fillcount;
; 1514 :         if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Count) {

  00371	8b 45 a0	 mov	 eax, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00374	8b 5d e8	 mov	 ebx, DWORD PTR __Groupstring$[ebp+16]
  00377	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  0037b	8b 70 20	 mov	 esi, DWORD PTR [eax+32]
  0037e	7c 0e		 jl	 SHORT $LN13@Fput_v3
  00380	7f 04		 jg	 SHORT $LN280@Fput_v3
  00382	85 f6		 test	 esi, esi
  00384	74 08		 je	 SHORT $LN13@Fput_v3
$LN280@Fput_v3:
  00386	3b f3		 cmp	 esi, ebx
  00388	76 04		 jbe	 SHORT $LN13@Fput_v3

; 1516 :         } else {
; 1517 :             _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Count;

  0038a	2b f3		 sub	 esi, ebx
  0038c	eb 02		 jmp	 SHORT $LN12@Fput_v3
$LN13@Fput_v3:

; 1515 :             _Fillcount = 0;

  0038e	33 f6		 xor	 esi, esi
$LN12@Fput_v3:

; 1518 :         }
; 1519 : 
; 1520 :         ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;

  00390	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00393	25 c0 01 00 00	 and	 eax, 448		; 000001c0H

; 1521 :         if (_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal) { // put leading fill

  00398	83 f8 40	 cmp	 eax, 64			; 00000040H
  0039b	0f 84 8d 00 00
	00		 je	 $LN16@Fput_v3
  003a1	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  003a6	74 43		 je	 SHORT $LN278@Fput_v3

; 1522 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

  003a8	56		 push	 esi
  003a9	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  003ac	8d 45 ac	 lea	 eax, DWORD PTR $T5[ebp]
  003af	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  003b2	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  003b5	50		 push	 eax
  003b6	ff 75 b8	 push	 DWORD PTR _this$1$[ebp]
  003b9	e8 00 00 00 00	 call	 ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep

; 1523 :             _Fillcount = 0;

  003be	33 f6		 xor	 esi, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  003c0	83 7d ec 07	 cmp	 DWORD PTR __Groupstring$[ebp+20], 7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1524 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

  003c4	57		 push	 edi
  003c5	8b 10		 mov	 edx, DWORD PTR [eax]
  003c7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 435  :         value_type* _Result = _Bx._Buf;

  003ca	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]

; 436  :         if (_Large_mode_engaged()) {

  003cd	0f 47 45 d8	 cmova	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1524 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

  003d1	50		 push	 eax
  003d2	51		 push	 ecx
  003d3	52		 push	 edx
  003d4	8d 45 ac	 lea	 eax, DWORD PTR $T6[ebp]
  003d7	89 55 0c	 mov	 DWORD PTR __Dest$[ebp], edx
  003da	50		 push	 eax
  003db	ff 75 b8	 push	 DWORD PTR _this$1$[ebp]
  003de	89 4d 10	 mov	 DWORD PTR __Dest$[ebp+4], ecx
  003e1	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put
  003e6	83 c4 30	 add	 esp, 48			; 00000030H
  003e9	eb 65		 jmp	 SHORT $LN17@Fput_v3
$LN278@Fput_v3:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  003eb	83 7d ec 07	 cmp	 DWORD PTR __Groupstring$[ebp+20], 7

; 435  :         value_type* _Result = _Bx._Buf;

  003ef	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1526 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

  003f2	57		 push	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 436  :         if (_Large_mode_engaged()) {

  003f3	0f 47 45 d8	 cmova	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1526 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

  003f7	50		 push	 eax
  003f8	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  003fb	8d 45 ac	 lea	 eax, DWORD PTR $T7[ebp]
  003fe	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00401	50		 push	 eax
  00402	ff 75 b8	 push	 DWORD PTR _this$1$[ebp]
  00405	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put

; 1527 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

  0040a	56		 push	 esi
  0040b	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  0040e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00410	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00413	50		 push	 eax
  00414	89 45 10	 mov	 DWORD PTR __Dest$[ebp+4], eax
  00417	8d 45 ac	 lea	 eax, DWORD PTR $T8[ebp]
  0041a	51		 push	 ecx
  0041b	50		 push	 eax
  0041c	ff 75 b8	 push	 DWORD PTR _this$1$[ebp]
  0041f	89 4d 0c	 mov	 DWORD PTR __Dest$[ebp], ecx
  00422	e8 00 00 00 00	 call	 ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep
  00427	83 c4 30	 add	 esp, 48			; 00000030H

; 1528 :             _Fillcount = 0;

  0042a	33 f6		 xor	 esi, esi

; 1529 :         } else {

  0042c	eb 22		 jmp	 SHORT $LN17@Fput_v3
$LN16@Fput_v3:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  0042e	83 7d ec 07	 cmp	 DWORD PTR __Groupstring$[ebp+20], 7

; 435  :         value_type* _Result = _Bx._Buf;

  00432	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1530 :             _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  00435	57		 push	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 436  :         if (_Large_mode_engaged()) {

  00436	0f 47 45 d8	 cmova	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1530 :             _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  0043a	50		 push	 eax
  0043b	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0043e	8d 45 ac	 lea	 eax, DWORD PTR $T9[ebp]
  00441	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00444	50		 push	 eax
  00445	ff 75 b8	 push	 DWORD PTR _this$1$[ebp]
  00448	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put
  0044d	83 c4 18	 add	 esp, 24			; 00000018H
$LN17@Fput_v3:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2272 :         return _Mypair._Myval2._Myptr()[_Off];

  00450	8b 10		 mov	 edx, DWORD PTR [eax]
  00452	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 435  :         value_type* _Result = _Bx._Buf;

  00455	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]

; 453  :         return _Myres > _Small_string_capacity;

  00458	83 7d ec 07	 cmp	 DWORD PTR __Groupstring$[ebp+20], 7

; 2272 :         return _Mypair._Myval2._Myptr()[_Off];

  0045c	89 55 0c	 mov	 DWORD PTR __Dest$[ebp], edx

; 436  :         if (_Large_mode_engaged()) {

  0045f	0f 47 45 d8	 cmova	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1533 :         _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

  00463	2b df		 sub	 ebx, edi
  00465	53		 push	 ebx
  00466	8b 5d b8	 mov	 ebx, DWORD PTR _this$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2272 :         return _Mypair._Myval2._Myptr()[_Off];

  00469	89 4d 10	 mov	 DWORD PTR __Dest$[ebp+4], ecx
  0046c	8d 04 78	 lea	 eax, DWORD PTR [eax+edi*2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1533 :         _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

  0046f	50		 push	 eax
  00470	51		 push	 ecx
  00471	52		 push	 edx
  00472	8d 45 ac	 lea	 eax, DWORD PTR $T10[ebp]
  00475	50		 push	 eax
  00476	53		 push	 ebx
  00477	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 284  :         _Wide                      = _Newwidth;

  0047c	8b 55 a0	 mov	 edx, DWORD PTR __Iosbase$GSCopy$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1535 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

  0047f	56		 push	 esi
  00480	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00483	8b 08		 mov	 ecx, DWORD PTR [eax]
  00485	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00488	8b 75 8c	 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  0048b	50		 push	 eax
  0048c	51		 push	 ecx
  0048d	56		 push	 esi
  0048e	53		 push	 ebx
  0048f	89 4d 0c	 mov	 DWORD PTR __Dest$[ebp], ecx
  00492	89 45 10	 mov	 DWORD PTR __Dest$[ebp+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 284  :         _Wide                      = _Newwidth;

  00495	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0
  0049c	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1535 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

  004a3	e8 00 00 00 00	 call	 ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  004a8	8b 4d d4	 mov	 ecx, DWORD PTR __Grouping$[ebp+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1535 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

  004ab	83 c4 30	 add	 esp, 48			; 00000030H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  004ae	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3083 :         if (_My_data._Large_mode_engaged()) {

  004b1	76 28		 jbe	 SHORT $LN179@Fput_v3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  004b3	8b 55 c0	 mov	 edx, DWORD PTR __Grouping$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  004b6	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  004b7	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  004b9	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  004bf	72 10		 jb	 SHORT $LN184@Fput_v3

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  004c1	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  004c4	83 c1 23	 add	 ecx, 35			; 00000023H
  004c7	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  004c9	83 c0 fc	 add	 eax, -4			; fffffffcH
  004cc	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  004cf	77 53		 ja	 SHORT $LN288@Fput_v3
$LN184@Fput_v3:

; 289  :         ::operator delete(_Ptr, _Bytes);

  004d1	51		 push	 ecx
  004d2	52		 push	 edx
  004d3	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  004d8	83 c4 08	 add	 esp, 8
$LN179@Fput_v3:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1383 :         _Tidy_deallocate();

  004db	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]

; 3090 :         _My_data._Mysize = 0;

  004de	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR __Grouping$[ebp+16], 0

; 3091 :         _My_data._Myres  = _Small_string_capacity;

  004e5	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR __Grouping$[ebp+20], 15 ; 0000000fH

; 3092 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  004ec	c6 45 c0 00	 mov	 BYTE PTR __Grouping$[ebp], 0

; 1383 :         _Tidy_deallocate();

  004f0	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1535 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

  004f5	8b c6		 mov	 eax, esi

; 1536 :     }

  004f7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  004fa	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00501	59		 pop	 ecx
  00502	5f		 pop	 edi
  00503	5e		 pop	 esi
  00504	5b		 pop	 ebx
  00505	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00508	33 cd		 xor	 ecx, ebp
  0050a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0050f	8b e5		 mov	 esp, ebp
  00511	5d		 pop	 ebp
  00512	c2 20 00	 ret	 32			; 00000020H
$LN266@Fput_v3:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00515	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN265@Fput_v3:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3030 :             _Xlen_string(); // result too long

  0051a	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN264@Fput_v3:

; 470  :             _Xran();

  0051f	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
$LN288@Fput_v3:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00524	6a 00		 push	 0
  00526	6a 00		 push	 0
  00528	6a 00		 push	 0
  0052a	6a 00		 push	 0
  0052c	6a 00		 push	 0
  0052e	e8 00 00 00 00	 call	 __invoke_watson
$LN284@Fput_v3:
  00533	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Fput_v3@$0A@@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@1@V21@AAVios_base@1@_WPBDI_N@Z$0:
  00000	8d 4d ac	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$??$_Fput_v3@$0A@@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@1@V21@AAVios_base@1@_WPBDI_N@Z$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$??$_Fput_v3@$0A@@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@1@V21@AAVios_base@1@_WPBDI_N@Z$2:
  00010	8d 4d ac	 lea	 ecx, DWORD PTR $T4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$??$_Fput_v3@$0A@@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@1@V21@AAVios_base@1@_WPBDI_N@Z$3:
  00018	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00020	cc		 int	 3
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
  00024	cc		 int	 3
__ehhandler$??$_Fput_v3@$0A@@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@1@V21@AAVios_base@1@_WPBDI_N@Z:
  00025	90		 npad	 1
  00026	90		 npad	 1
  00027	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002e	8b 4a 88	 mov	 ecx, DWORD PTR [edx-120]
  00031	33 c8		 xor	 ecx, eax
  00033	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00038	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0003b	33 c8		 xor	 ecx, eax
  0003d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00042	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Fput_v3@$0A@@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@1@V21@AAVios_base@1@_WPBDI_N@Z
  00047	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Fput_v3@$0A@@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@1@V21@AAVios_base@1@_WPBDI_N@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Fput_v3<0>
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??$_Float_put_desired_precision@O@std@@YAH_JH@Z
_TEXT	SEGMENT
__Precision$ = 8					; size = 8
__Float_flags$ = 16					; size = 4
??$_Float_put_desired_precision@O@std@@YAH_JH@Z PROC	; std::_Float_put_desired_precision<long double>, COMDAT

; 1178 : int _Float_put_desired_precision(const streamsize _Precision, const ios_base::fmtflags _Float_flags) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 10	 mov	 ecx, DWORD PTR __Float_flags$[ebp]

; 1179 :     // return the effective precision determined by N4950 [facet.num.put.virtuals]/2.1 and printf's rules
; 1180 :     const bool _Is_hex = _Float_flags == (ios_base::fixed | ios_base::scientific);

  00006	81 f9 00 30 00
	00		 cmp	 ecx, 12288		; 00003000H

; 1181 :     if (_Is_hex) {

  0000c	75 07		 jne	 SHORT $LN2@Float_put_

; 1182 :         // return the number of hexits needed (after the radix point) to represent the floating-point value exactly
; 1183 :         if constexpr (is_same_v<_Ty, double>) {
; 1184 :             return ((DBL_MANT_DIG - 1) + 3) / 4;
; 1185 :         } else if constexpr (is_same_v<_Ty, long double>) {
; 1186 :             return ((LDBL_MANT_DIG - 1) + 3) / 4;

  0000e	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH

; 1204 :     }
; 1205 : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
$LN2@Float_put_:

; 1187 :         } else {
; 1188 :             _STL_INTERNAL_STATIC_ASSERT(false); // unexpected type; shouldn't be float
; 1189 :         }
; 1190 :     }
; 1191 : 
; 1192 :     if (_Precision > 0) {

  00015	8b 55 0c	 mov	 edx, DWORD PTR __Precision$[ebp+4]
  00018	8b 45 08	 mov	 eax, DWORD PTR __Precision$[ebp]
  0001b	85 d2		 test	 edx, edx
  0001d	7c 06		 jl	 SHORT $LN3@Float_put_
  0001f	7f 14		 jg	 SHORT $LN6@Float_put_
  00021	85 c0		 test	 eax, eax
  00023	75 10		 jne	 SHORT $LN6@Float_put_
$LN3@Float_put_:

; 1193 :         return static_cast<int>(_Precision);
; 1194 :     } else if (_Precision == 0) {

  00025	0b c2		 or	 eax, edx
  00027	75 07		 jne	 SHORT $LN5@Float_put_

; 1195 :         const bool _Is_default_float = _Float_flags == 0;

  00029	85 c9		 test	 ecx, ecx
  0002b	0f 94 c0	 sete	 al

; 1204 :     }
; 1205 : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
$LN5@Float_put_:

; 1196 :         if (_Is_default_float) {
; 1197 :             return 1;
; 1198 :         } else {
; 1199 :             return 0;
; 1200 :         }
; 1201 :     } else {
; 1202 :         constexpr int _Default_precision = 6;
; 1203 :         return _Default_precision;

  00030	b8 06 00 00 00	 mov	 eax, 6
$LN6@Float_put_:

; 1204 :     }
; 1205 : }

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Float_put_desired_precision@O@std@@YAH_JH@Z ENDP	; std::_Float_put_desired_precision<long double>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  00010	74 0b		 je	 SHORT $LN5@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_G?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
_TEXT	SEGMENT
__Ep$2 = -64						; size = 4
$T3 = -60						; size = 8
__Errno$4 = -56						; size = 4
__Parse_result$ = -52					; size = 2
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 623  :         void*& _Val) const { // get void pointer from [_First, _Last) into _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 34	 sub	 esp, 52			; 00000034H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 289  :         return *_Ploc;

  0002b	8b 45 1c	 mov	 eax, DWORD PTR __Iosbase$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 623  :         void*& _Val) const { // get void pointer from [_First, _Last) into _Val

  0002e	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00031	8b 75 20	 mov	 esi, DWORD PTR __State$[ebp]
  00034	8b 5d 24	 mov	 ebx, DWORD PTR __Val$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 289  :         return *_Ploc;

  00037	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  0003a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003d	89 4d c8	 mov	 DWORD PTR $T3[ebp+4], ecx

; 269  :         _Ptr->_Incref();

  00040	8b 01		 mov	 eax, DWORD PTR [ecx]
  00042	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 627  :             _Parse_int_with_locale(_Ac, _First, _Last, ios_base::hex, _Iosbase.getloc()); // gather field

  00045	8d 45 c4	 lea	 eax, DWORD PTR $T3[ebp]
  00048	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004f	50		 push	 eax
  00050	68 00 08 00 00	 push	 2048			; 00000800H
  00055	8d 45 14	 lea	 eax, DWORD PTR __Last$[ebp]
  00058	50		 push	 eax
  00059	8d 45 0c	 lea	 eax, DWORD PTR __First$[ebp]
  0005c	50		 push	 eax
  0005d	8d 45 d0	 lea	 eax, DWORD PTR __Ac$[ebp]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  00066	8b 4d c8	 mov	 ecx, DWORD PTR $T3[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 627  :             _Parse_int_with_locale(_Ac, _First, _Last, ios_base::hex, _Iosbase.getloc()); // gather field

  00069	83 c4 14	 add	 esp, 20			; 00000014H
  0006c	66 89 45 cc	 mov	 WORD PTR __Parse_result$[ebp], ax
  00070	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  00077	85 c9		 test	 ecx, ecx
  00079	74 15		 je	 SHORT $LN21@do_get

; 355  :             delete _Ptr->_Decref();

  0007b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0007d	ff 50 08	 call	 DWORD PTR [eax+8]
  00080	85 c0		 test	 eax, eax
  00082	74 08		 je	 SHORT $LN24@do_get
  00084	8b 10		 mov	 edx, DWORD PTR [eax]
  00086	8b c8		 mov	 ecx, eax
  00088	6a 01		 push	 1
  0008a	ff 12		 call	 DWORD PTR [edx]
$LN24@do_get:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 628  :         if (_Parse_result._Base < 0) { // ditto "fails to convert the entire field"

  0008c	66 8b 45 cc	 mov	 ax, WORD PTR __Parse_result$[ebp]
$LN21@do_get:
  00090	84 c0		 test	 al, al
  00092	79 0e		 jns	 SHORT $LN2@do_get

; 629  :             _State = ios_base::failbit;

  00094	c7 06 02 00 00
	00		 mov	 DWORD PTR [esi], 2

; 630  :             _Val   = nullptr;

  0009a	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0

; 631  :         } else {

  000a0	eb 40		 jmp	 SHORT $LN6@do_get
$LN2@do_get:

; 632  :             int _Errno;
; 633  :             char* _Ep;
; 634  : #ifdef _WIN64
; 635  :             _Val = reinterpret_cast<void*>(_CSTD _Stoullx(_Ac, &_Ep, _Parse_result._Base, &_Errno));
; 636  : #else // ^^^ defined(_WIN64) / !defined(_WIN64) vvv
; 637  :             _Val = reinterpret_cast<void*>(_CSTD _Stoulx(_Ac, &_Ep, _Parse_result._Base, &_Errno));

  000a2	8d 4d c8	 lea	 ecx, DWORD PTR __Errno$4[ebp]
  000a5	0f be c0	 movsx	 eax, al
  000a8	51		 push	 ecx
  000a9	50		 push	 eax
  000aa	8d 45 c0	 lea	 eax, DWORD PTR __Ep$2[ebp]
  000ad	50		 push	 eax
  000ae	8d 45 d0	 lea	 eax, DWORD PTR __Ac$[ebp]
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 __Stoulx
  000b7	89 03		 mov	 DWORD PTR [ebx], eax
  000b9	83 c4 10	 add	 esp, 16			; 00000010H

; 638  : #endif // ^^^ !defined(_WIN64) ^^^
; 639  :             if (_Ep == _Ac || _Errno != 0) { // N4950 [facet.num.get.virtuals]/3

  000bc	8d 45 d0	 lea	 eax, DWORD PTR __Ac$[ebp]
  000bf	39 45 c0	 cmp	 DWORD PTR __Ep$2[ebp], eax
  000c2	74 06		 je	 SHORT $LN5@do_get
  000c4	83 7d c8 00	 cmp	 DWORD PTR __Errno$4[ebp], 0
  000c8	74 0c		 je	 SHORT $LN4@do_get
$LN5@do_get:

; 640  :                 _State = ios_base::failbit;

  000ca	c7 06 02 00 00
	00		 mov	 DWORD PTR [esi], 2

; 641  :                 _Val   = nullptr;

  000d0	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
$LN4@do_get:

; 642  :             }
; 643  : 
; 644  :             if (_Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4

  000d6	80 7d cd 00	 cmp	 BYTE PTR __Parse_result$[ebp+1], 0
  000da	74 06		 je	 SHORT $LN6@do_get

; 645  :                 _State = ios_base::failbit;

  000dc	c7 06 02 00 00
	00		 mov	 DWORD PTR [esi], 2
$LN6@do_get:

; 646  :             }
; 647  :         }
; 648  : 
; 649  :         if (_First == _Last) {

  000e2	8d 45 14	 lea	 eax, DWORD PTR __Last$[ebp]
  000e5	50		 push	 eax
  000e6	8d 45 0c	 lea	 eax, DWORD PTR __First$[ebp]
  000e9	50		 push	 eax
  000ea	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
  000ef	83 c4 08	 add	 esp, 8
  000f2	84 c0		 test	 al, al
  000f4	74 03		 je	 SHORT $LN7@do_get

; 650  :             _State |= ios_base::eofbit;

  000f6	83 0e 01	 or	 DWORD PTR [esi], 1
$LN7@do_get:

; 651  :         }
; 652  : 
; 653  :         return _First;

  000f9	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  000fc	8b c7		 mov	 eax, edi
  000fe	8b 55 10	 mov	 edx, DWORD PTR __First$[ebp+4]
  00101	89 0f		 mov	 DWORD PTR [edi], ecx
  00103	89 57 04	 mov	 DWORD PTR [edi+4], edx

; 654  :     }

  00106	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00109	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00110	59		 pop	 ecx
  00111	5f		 pop	 edi
  00112	5e		 pop	 esi
  00113	5b		 pop	 ebx
  00114	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00117	33 cd		 xor	 ecx, ebp
  00119	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c2 20 00	 ret	 32			; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z$0:
  00000	8d 4d c4	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z
_TEXT	SEGMENT
__Last$ = -852						; size = 8
__Val$2 = -844						; size = 8
__Result$1$ = -844					; size = 8
$T3 = -836						; size = 8
__Ep$4 = -832						; size = 4
__First$ = -828						; size = 8
__Val$GSCopy$1$ = -820					; size = 4
___$ReturnUdt$GSCopy$1$ = -816				; size = 4
__Parse_result$5 = -812					; size = 2
__Ac$6 = -808						; size = 792
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 612  :         long double& _Val) const { // get long double from [_First, _Last) into _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 48 03 00
	00		 sub	 esp, 840		; 00000348H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 617  :         _First = num_get::do_get(_First, _Last, _Iosbase, _State, _Result); // avoid virtual call for perf

  0002e	8b 45 14	 mov	 eax, DWORD PTR __Last$[ebp]
  00031	8b 4d 18	 mov	 ecx, DWORD PTR __Last$[ebp+4]
  00034	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00037	8b 7d 24	 mov	 edi, DWORD PTR __Val$[ebp]
  0003a	8b 5d 20	 mov	 ebx, DWORD PTR __State$[ebp]
  0003d	89 85 ac fc ff
	ff		 mov	 DWORD PTR __Last$[ebp], eax
  00043	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00046	89 85 c4 fc ff
	ff		 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 289  :         return *_Ploc;

  0004c	8b 45 1c	 mov	 eax, DWORD PTR __Iosbase$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 617  :         _First = num_get::do_get(_First, _Last, _Iosbase, _State, _Result); // avoid virtual call for perf

  0004f	89 8d b0 fc ff
	ff		 mov	 DWORD PTR __Last$[ebp+4], ecx
  00055	8b 4d 10	 mov	 ecx, DWORD PTR __First$[ebp+4]
  00058	89 8d c8 fc ff
	ff		 mov	 DWORD PTR __First$[ebp+4], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 289  :         return *_Ploc;

  0005e	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 612  :         long double& _Val) const { // get long double from [_First, _Last) into _Val

  00061	89 b5 d0 fc ff
	ff		 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], esi
  00067	89 bd cc fc ff
	ff		 mov	 DWORD PTR __Val$GSCopy$1$[ebp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  0006d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00070	89 8d c0 fc ff
	ff		 mov	 DWORD PTR $T3[ebp+4], ecx

; 269  :         _Ptr->_Incref();

  00076	8b 01		 mov	 eax, DWORD PTR [ecx]
  00078	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 588  :             _Parse_fp_with_locale(_Ac, _MAX_SIG_DIG_V2, _First, _Last, _Iosbase.getloc()); // gather field

  0007b	8d 85 bc fc ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00081	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00088	50		 push	 eax
  00089	8d 85 ac fc ff
	ff		 lea	 eax, DWORD PTR __Last$[ebp]
  0008f	50		 push	 eax
  00090	8d 85 c4 fc ff
	ff		 lea	 eax, DWORD PTR __First$[ebp]
  00096	50		 push	 eax
  00097	8d 85 d8 fc ff
	ff		 lea	 eax, DWORD PTR __Ac$6[ebp]
  0009d	68 00 03 00 00	 push	 768			; 00000300H
  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_fp_with_locale<0>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  000a8	8b 8d c0 fc ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 588  :             _Parse_fp_with_locale(_Ac, _MAX_SIG_DIG_V2, _First, _Last, _Iosbase.getloc()); // gather field

  000ae	83 c4 14	 add	 esp, 20			; 00000014H
  000b1	66 89 85 d4 fc
	ff ff		 mov	 WORD PTR __Parse_result$5[ebp], ax
  000b8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  000bf	85 c9		 test	 ecx, ecx
  000c1	74 18		 je	 SHORT $LN22@do_get

; 355  :             delete _Ptr->_Decref();

  000c3	8b 01		 mov	 eax, DWORD PTR [ecx]
  000c5	ff 50 08	 call	 DWORD PTR [eax+8]
  000c8	85 c0		 test	 eax, eax
  000ca	74 08		 je	 SHORT $LN28@do_get
  000cc	8b 10		 mov	 edx, DWORD PTR [eax]
  000ce	8b c8		 mov	 ecx, eax
  000d0	6a 01		 push	 1
  000d2	ff 12		 call	 DWORD PTR [edx]
$LN28@do_get:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 589  :         if (_Parse_result._Base == 0) { // ditto "fails to convert the entire field"

  000d4	66 8b 85 d4 fc
	ff ff		 mov	 ax, WORD PTR __Parse_result$5[ebp]
$LN22@do_get:
  000db	84 c0		 test	 al, al
  000dd	75 13		 jne	 SHORT $LN4@do_get
  000df	0f 57 c0	 xorps	 xmm0, xmm0

; 590  :             _State = ios_base::failbit;

  000e2	c7 03 02 00 00
	00		 mov	 DWORD PTR [ebx], 2

; 591  :             _Val   = 0.0;

  000e8	f2 0f 11 85 b4
	fc ff ff	 movsd	 QWORD PTR __Result$1$[ebp], xmm0

; 592  :         } else {

  000f0	eb 6b		 jmp	 SHORT $LN6@do_get
$LN4@do_get:

; 43   :     int& _Errno_ref = errno; // Nonzero cost, pay it once

  000f2	e8 00 00 00 00	 call	 __errno
  000f7	8b f8		 mov	 edi, eax

; 44   :     const int _Orig = _Errno_ref;
; 45   : 
; 46   :     _Errno_ref  = 0;
; 47   :     double _Val = _CSTD strtod(_Str, _Endptr);

  000f9	8d 85 c0 fc ff
	ff		 lea	 eax, DWORD PTR __Ep$4[ebp]
  000ff	50		 push	 eax
  00100	8d 85 d8 fc ff
	ff		 lea	 eax, DWORD PTR __Ac$6[ebp]
  00106	50		 push	 eax
  00107	8b 37		 mov	 esi, DWORD PTR [edi]
  00109	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  0010f	e8 00 00 00 00	 call	 _strtod

; 48   :     *_Perr      = _Errno_ref;

  00114	8b 07		 mov	 eax, DWORD PTR [edi]

; 597  :                 || _Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4

  00116	8d 8d d8 fc ff
	ff		 lea	 ecx, DWORD PTR __Ac$6[ebp]

; 47   :     double _Val = _CSTD strtod(_Str, _Endptr);

  0011c	dd 9d b4 fc ff
	ff		 fstp	 QWORD PTR __Val$2[ebp]

; 595  :             _Val = _STD _Stodx_v3(_Ac, &_Ep, &_Errno); // convert

  00122	f2 0f 10 85 b4
	fc ff ff	 movsd	 xmm0, QWORD PTR __Val$2[ebp]

; 47   :     double _Val = _CSTD strtod(_Str, _Endptr);

  0012a	83 c4 08	 add	 esp, 8

; 49   :     _Errno_ref  = _Orig;

  0012d	89 37		 mov	 DWORD PTR [edi], esi

; 595  :             _Val = _STD _Stodx_v3(_Ac, &_Ep, &_Errno); // convert

  0012f	f2 0f 11 85 b4
	fc ff ff	 movsd	 QWORD PTR __Result$1$[ebp], xmm0

; 596  :             if (_Ep == _Ac || _Errno != 0 // N4950 [facet.num.get.virtuals]/3
; 597  :                 || _Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4

  00137	39 8d c0 fc ff
	ff		 cmp	 DWORD PTR __Ep$4[ebp], ecx
  0013d	74 0c		 je	 SHORT $LN7@do_get
  0013f	85 c0		 test	 eax, eax
  00141	75 08		 jne	 SHORT $LN7@do_get
  00143	38 85 d5 fc ff
	ff		 cmp	 BYTE PTR __Parse_result$5[ebp+1], al
  00149	74 06		 je	 SHORT $LN29@do_get
$LN7@do_get:

; 598  :                 _State = ios_base::failbit;

  0014b	c7 03 02 00 00
	00		 mov	 DWORD PTR [ebx], 2
$LN29@do_get:

; 599  :             }
; 600  :         }
; 601  : 
; 602  :         if (_First == _Last) {

  00151	8b bd cc fc ff
	ff		 mov	 edi, DWORD PTR __Val$GSCopy$1$[ebp]
  00157	8b b5 d0 fc ff
	ff		 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
$LN6@do_get:
  0015d	8d 85 ac fc ff
	ff		 lea	 eax, DWORD PTR __Last$[ebp]
  00163	50		 push	 eax
  00164	8d 85 c4 fc ff
	ff		 lea	 eax, DWORD PTR __First$[ebp]
  0016a	50		 push	 eax
  0016b	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
  00170	83 c4 08	 add	 esp, 8
  00173	84 c0		 test	 al, al
  00175	74 03		 je	 SHORT $LN8@do_get

; 603  :             _State |= ios_base::eofbit;

  00177	83 0b 01	 or	 DWORD PTR [ebx], 1
$LN8@do_get:

; 618  :         _Val   = _Result;

  0017a	f2 0f 10 85 b4
	fc ff ff	 movsd	 xmm0, QWORD PTR __Result$1$[ebp]

; 619  :         return _First;

  00182	8b c6		 mov	 eax, esi
  00184	8b 8d c4 fc ff
	ff		 mov	 ecx, DWORD PTR __First$[ebp]
  0018a	8b 95 c8 fc ff
	ff		 mov	 edx, DWORD PTR __First$[ebp+4]
  00190	f2 0f 11 07	 movsd	 QWORD PTR [edi], xmm0
  00194	89 0e		 mov	 DWORD PTR [esi], ecx
  00196	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 620  :     }

  00199	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0019c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001a3	59		 pop	 ecx
  001a4	5f		 pop	 edi
  001a5	5e		 pop	 esi
  001a6	5b		 pop	 ebx
  001a7	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001aa	33 cd		 xor	 ecx, ebp
  001ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b1	8b e5		 mov	 esp, ebp
  001b3	5d		 pop	 ebp
  001b4	c2 20 00	 ret	 32			; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z$0:
  00000	8d 8d bc fc ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a a8 fc ff
	ff		 mov	 ecx, DWORD PTR [edx-856]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z
_TEXT	SEGMENT
__Val$2 = -836						; size = 8
__Val$GSCopy$1$ = -828					; size = 4
$T3 = -824						; size = 8
__Ep$4 = -820						; size = 4
___$ReturnUdt$GSCopy$1$ = -816				; size = 4
__Parse_result$ = -812					; size = 2
__Ac$ = -808						; size = 792
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 584  :         double& _Val) const { // get double from [_First, _Last) into _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 38 03 00
	00		 sub	 esp, 824		; 00000338H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 289  :         return *_Ploc;

  0002e	8b 45 1c	 mov	 eax, DWORD PTR __Iosbase$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 584  :         double& _Val) const { // get double from [_First, _Last) into _Val

  00031	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00034	8b 7d 24	 mov	 edi, DWORD PTR __Val$[ebp]
  00037	8b 5d 20	 mov	 ebx, DWORD PTR __State$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 289  :         return *_Ploc;

  0003a	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 584  :         double& _Val) const { // get double from [_First, _Last) into _Val

  0003d	89 b5 d0 fc ff
	ff		 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], esi
  00043	89 bd c4 fc ff
	ff		 mov	 DWORD PTR __Val$GSCopy$1$[ebp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  00049	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004c	89 8d cc fc ff
	ff		 mov	 DWORD PTR $T3[ebp+4], ecx

; 269  :         _Ptr->_Incref();

  00052	8b 01		 mov	 eax, DWORD PTR [ecx]
  00054	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 588  :             _Parse_fp_with_locale(_Ac, _MAX_SIG_DIG_V2, _First, _Last, _Iosbase.getloc()); // gather field

  00057	8d 85 c8 fc ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0005d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00064	50		 push	 eax
  00065	8d 45 14	 lea	 eax, DWORD PTR __Last$[ebp]
  00068	50		 push	 eax
  00069	8d 45 0c	 lea	 eax, DWORD PTR __First$[ebp]
  0006c	50		 push	 eax
  0006d	8d 85 d8 fc ff
	ff		 lea	 eax, DWORD PTR __Ac$[ebp]
  00073	68 00 03 00 00	 push	 768			; 00000300H
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_fp_with_locale<0>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  0007e	8b 8d cc fc ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 588  :             _Parse_fp_with_locale(_Ac, _MAX_SIG_DIG_V2, _First, _Last, _Iosbase.getloc()); // gather field

  00084	83 c4 14	 add	 esp, 20			; 00000014H
  00087	66 89 85 d4 fc
	ff ff		 mov	 WORD PTR __Parse_result$[ebp], ax
  0008e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  00095	85 c9		 test	 ecx, ecx
  00097	74 18		 je	 SHORT $LN20@do_get

; 355  :             delete _Ptr->_Decref();

  00099	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009b	ff 50 08	 call	 DWORD PTR [eax+8]
  0009e	85 c0		 test	 eax, eax
  000a0	74 08		 je	 SHORT $LN26@do_get
  000a2	8b 10		 mov	 edx, DWORD PTR [eax]
  000a4	8b c8		 mov	 ecx, eax
  000a6	6a 01		 push	 1
  000a8	ff 12		 call	 DWORD PTR [edx]
$LN26@do_get:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 589  :         if (_Parse_result._Base == 0) { // ditto "fails to convert the entire field"

  000aa	66 8b 85 d4 fc
	ff ff		 mov	 ax, WORD PTR __Parse_result$[ebp]
$LN20@do_get:
  000b1	84 c0		 test	 al, al
  000b3	75 0f		 jne	 SHORT $LN2@do_get

; 590  :             _State = ios_base::failbit;

  000b5	0f 57 c0	 xorps	 xmm0, xmm0
  000b8	c7 03 02 00 00
	00		 mov	 DWORD PTR [ebx], 2

; 591  :             _Val   = 0.0;

  000be	f2 0f 11 07	 movsd	 QWORD PTR [edi], xmm0

; 592  :         } else {

  000c2	eb 67		 jmp	 SHORT $LN4@do_get
$LN2@do_get:

; 43   :     int& _Errno_ref = errno; // Nonzero cost, pay it once

  000c4	e8 00 00 00 00	 call	 __errno
  000c9	8b f8		 mov	 edi, eax

; 44   :     const int _Orig = _Errno_ref;
; 45   : 
; 46   :     _Errno_ref  = 0;
; 47   :     double _Val = _CSTD strtod(_Str, _Endptr);

  000cb	8d 85 cc fc ff
	ff		 lea	 eax, DWORD PTR __Ep$4[ebp]
  000d1	50		 push	 eax
  000d2	8d 85 d8 fc ff
	ff		 lea	 eax, DWORD PTR __Ac$[ebp]
  000d8	50		 push	 eax
  000d9	8b 37		 mov	 esi, DWORD PTR [edi]
  000db	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  000e1	e8 00 00 00 00	 call	 _strtod

; 593  :             int _Errno;
; 594  :             char* _Ep;
; 595  :             _Val = _STD _Stodx_v3(_Ac, &_Ep, &_Errno); // convert

  000e6	8b 85 c4 fc ff
	ff		 mov	 eax, DWORD PTR __Val$GSCopy$1$[ebp]

; 47   :     double _Val = _CSTD strtod(_Str, _Endptr);

  000ec	83 c4 08	 add	 esp, 8

; 48   :     *_Perr      = _Errno_ref;

  000ef	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000f1	dd 9d bc fc ff
	ff		 fstp	 QWORD PTR __Val$2[ebp]

; 593  :             int _Errno;
; 594  :             char* _Ep;
; 595  :             _Val = _STD _Stodx_v3(_Ac, &_Ep, &_Errno); // convert

  000f7	f2 0f 10 85 bc
	fc ff ff	 movsd	 xmm0, QWORD PTR __Val$2[ebp]

; 49   :     _Errno_ref  = _Orig;

  000ff	89 37		 mov	 DWORD PTR [edi], esi

; 593  :             int _Errno;
; 594  :             char* _Ep;
; 595  :             _Val = _STD _Stodx_v3(_Ac, &_Ep, &_Errno); // convert

  00101	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0

; 596  :             if (_Ep == _Ac || _Errno != 0 // N4950 [facet.num.get.virtuals]/3
; 597  :                 || _Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4

  00105	8d 85 d8 fc ff
	ff		 lea	 eax, DWORD PTR __Ac$[ebp]
  0010b	39 85 cc fc ff
	ff		 cmp	 DWORD PTR __Ep$4[ebp], eax
  00111	74 0c		 je	 SHORT $LN5@do_get
  00113	85 c9		 test	 ecx, ecx
  00115	75 08		 jne	 SHORT $LN5@do_get
  00117	38 8d d5 fc ff
	ff		 cmp	 BYTE PTR __Parse_result$[ebp+1], cl
  0011d	74 06		 je	 SHORT $LN27@do_get
$LN5@do_get:

; 598  :                 _State = ios_base::failbit;

  0011f	c7 03 02 00 00
	00		 mov	 DWORD PTR [ebx], 2
$LN27@do_get:

; 599  :             }
; 600  :         }
; 601  : 
; 602  :         if (_First == _Last) {

  00125	8b b5 d0 fc ff
	ff		 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
$LN4@do_get:
  0012b	8d 45 14	 lea	 eax, DWORD PTR __Last$[ebp]
  0012e	50		 push	 eax
  0012f	8d 45 0c	 lea	 eax, DWORD PTR __First$[ebp]
  00132	50		 push	 eax
  00133	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
  00138	83 c4 08	 add	 esp, 8
  0013b	84 c0		 test	 al, al
  0013d	74 03		 je	 SHORT $LN6@do_get

; 603  :             _State |= ios_base::eofbit;

  0013f	83 0b 01	 or	 DWORD PTR [ebx], 1
$LN6@do_get:

; 604  :         }
; 605  : 
; 606  :         return _First;

  00142	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00145	8b c6		 mov	 eax, esi
  00147	8b 55 10	 mov	 edx, DWORD PTR __First$[ebp+4]
  0014a	89 0e		 mov	 DWORD PTR [esi], ecx
  0014c	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 607  :     }

  0014f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00152	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00159	59		 pop	 ecx
  0015a	5f		 pop	 edi
  0015b	5e		 pop	 esi
  0015c	5b		 pop	 ebx
  0015d	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00160	33 cd		 xor	 ecx, ebp
  00162	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c2 20 00	 ret	 32			; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z$0:
  00000	8d 8d c8 fc ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a b8 fc ff
	ff		 mov	 ecx, DWORD PTR [edx-840]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z
_TEXT	SEGMENT
__Val$GSCopy$1$ = -832					; size = 4
__Val$2 = -828						; size = 4
$T3 = -824						; size = 8
__Ep$4 = -820						; size = 4
___$ReturnUdt$GSCopy$1$ = -816				; size = 4
__Parse_result$ = -812					; size = 2
__Ac$ = -808						; size = 792
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 558  :         float& _Val) const { // get float from [_First, _Last) into _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 34 03 00
	00		 sub	 esp, 820		; 00000334H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 289  :         return *_Ploc;

  0002e	8b 45 1c	 mov	 eax, DWORD PTR __Iosbase$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 558  :         float& _Val) const { // get float from [_First, _Last) into _Val

  00031	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00034	8b 7d 24	 mov	 edi, DWORD PTR __Val$[ebp]
  00037	8b 5d 20	 mov	 ebx, DWORD PTR __State$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 289  :         return *_Ploc;

  0003a	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 558  :         float& _Val) const { // get float from [_First, _Last) into _Val

  0003d	89 b5 d0 fc ff
	ff		 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], esi
  00043	89 bd c0 fc ff
	ff		 mov	 DWORD PTR __Val$GSCopy$1$[ebp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  00049	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004c	89 8d cc fc ff
	ff		 mov	 DWORD PTR $T3[ebp+4], ecx

; 269  :         _Ptr->_Incref();

  00052	8b 01		 mov	 eax, DWORD PTR [ecx]
  00054	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 562  :             _Parse_fp_with_locale(_Ac, _MAX_SIG_DIG_V2, _First, _Last, _Iosbase.getloc()); // gather field

  00057	8d 85 c8 fc ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0005d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00064	50		 push	 eax
  00065	8d 45 14	 lea	 eax, DWORD PTR __Last$[ebp]
  00068	50		 push	 eax
  00069	8d 45 0c	 lea	 eax, DWORD PTR __First$[ebp]
  0006c	50		 push	 eax
  0006d	8d 85 d8 fc ff
	ff		 lea	 eax, DWORD PTR __Ac$[ebp]
  00073	68 00 03 00 00	 push	 768			; 00000300H
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ??$_Parse_fp_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1ABVlocale@1@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_fp_with_locale<0>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  0007e	8b 8d cc fc ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 562  :             _Parse_fp_with_locale(_Ac, _MAX_SIG_DIG_V2, _First, _Last, _Iosbase.getloc()); // gather field

  00084	83 c4 14	 add	 esp, 20			; 00000014H
  00087	66 89 85 d4 fc
	ff ff		 mov	 WORD PTR __Parse_result$[ebp], ax
  0008e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  00095	85 c9		 test	 ecx, ecx
  00097	74 18		 je	 SHORT $LN20@do_get

; 355  :             delete _Ptr->_Decref();

  00099	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009b	ff 50 08	 call	 DWORD PTR [eax+8]
  0009e	85 c0		 test	 eax, eax
  000a0	74 08		 je	 SHORT $LN26@do_get
  000a2	8b 10		 mov	 edx, DWORD PTR [eax]
  000a4	8b c8		 mov	 ecx, eax
  000a6	6a 01		 push	 1
  000a8	ff 12		 call	 DWORD PTR [edx]
$LN26@do_get:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 563  :         if (_Parse_result._Base == 0) { // ditto "fails to convert the entire field"

  000aa	66 8b 85 d4 fc
	ff ff		 mov	 ax, WORD PTR __Parse_result$[ebp]
$LN20@do_get:
  000b1	84 c0		 test	 al, al
  000b3	75 0e		 jne	 SHORT $LN2@do_get

; 564  :             _State = ios_base::failbit;

  000b5	c7 03 02 00 00
	00		 mov	 DWORD PTR [ebx], 2

; 565  :             _Val   = 0.0f;

  000bb	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 566  :         } else {

  000c1	eb 67		 jmp	 SHORT $LN4@do_get
$LN2@do_get:

; 55   :     int& _Errno_ref = errno; // Nonzero cost, pay it once

  000c3	e8 00 00 00 00	 call	 __errno
  000c8	8b f8		 mov	 edi, eax

; 56   :     const int _Orig = _Errno_ref;
; 57   : 
; 58   :     _Errno_ref = 0;
; 59   :     float _Val = _CSTD strtof(_Str, _Endptr);

  000ca	8d 85 cc fc ff
	ff		 lea	 eax, DWORD PTR __Ep$4[ebp]
  000d0	50		 push	 eax
  000d1	8d 85 d8 fc ff
	ff		 lea	 eax, DWORD PTR __Ac$[ebp]
  000d7	50		 push	 eax
  000d8	8b 37		 mov	 esi, DWORD PTR [edi]
  000da	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  000e0	e8 00 00 00 00	 call	 _strtof

; 567  :             int _Errno;
; 568  :             char* _Ep;
; 569  :             _Val = _STD _Stofx_v3(_Ac, &_Ep, &_Errno); // convert

  000e5	8b 85 c0 fc ff
	ff		 mov	 eax, DWORD PTR __Val$GSCopy$1$[ebp]

; 59   :     float _Val = _CSTD strtof(_Str, _Endptr);

  000eb	83 c4 08	 add	 esp, 8

; 60   :     *_Perr     = _Errno_ref;

  000ee	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000f0	d9 9d c4 fc ff
	ff		 fstp	 DWORD PTR __Val$2[ebp]

; 567  :             int _Errno;
; 568  :             char* _Ep;
; 569  :             _Val = _STD _Stofx_v3(_Ac, &_Ep, &_Errno); // convert

  000f6	f3 0f 10 85 c4
	fc ff ff	 movss	 xmm0, DWORD PTR __Val$2[ebp]

; 61   :     _Errno_ref = _Orig;

  000fe	89 37		 mov	 DWORD PTR [edi], esi

; 567  :             int _Errno;
; 568  :             char* _Ep;
; 569  :             _Val = _STD _Stofx_v3(_Ac, &_Ep, &_Errno); // convert

  00100	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 570  :             if (_Ep == _Ac || _Errno != 0 // N4950 [facet.num.get.virtuals]/3
; 571  :                 || _Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4

  00104	8d 85 d8 fc ff
	ff		 lea	 eax, DWORD PTR __Ac$[ebp]
  0010a	39 85 cc fc ff
	ff		 cmp	 DWORD PTR __Ep$4[ebp], eax
  00110	74 0c		 je	 SHORT $LN5@do_get
  00112	85 c9		 test	 ecx, ecx
  00114	75 08		 jne	 SHORT $LN5@do_get
  00116	38 8d d5 fc ff
	ff		 cmp	 BYTE PTR __Parse_result$[ebp+1], cl
  0011c	74 06		 je	 SHORT $LN27@do_get
$LN5@do_get:

; 572  :                 _State = ios_base::failbit;

  0011e	c7 03 02 00 00
	00		 mov	 DWORD PTR [ebx], 2
$LN27@do_get:

; 573  :             }
; 574  :         }
; 575  : 
; 576  :         if (_First == _Last) {

  00124	8b b5 d0 fc ff
	ff		 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
$LN4@do_get:
  0012a	8d 45 14	 lea	 eax, DWORD PTR __Last$[ebp]
  0012d	50		 push	 eax
  0012e	8d 45 0c	 lea	 eax, DWORD PTR __First$[ebp]
  00131	50		 push	 eax
  00132	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
  00137	83 c4 08	 add	 esp, 8
  0013a	84 c0		 test	 al, al
  0013c	74 03		 je	 SHORT $LN6@do_get

; 577  :             _State |= ios_base::eofbit;

  0013e	83 0b 01	 or	 DWORD PTR [ebx], 1
$LN6@do_get:

; 578  :         }
; 579  : 
; 580  :         return _First;

  00141	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00144	8b c6		 mov	 eax, esi
  00146	8b 55 10	 mov	 edx, DWORD PTR __First$[ebp+4]
  00149	89 0e		 mov	 DWORD PTR [esi], ecx
  0014b	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 581  :     }

  0014e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00151	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00158	59		 pop	 ecx
  00159	5f		 pop	 edi
  0015a	5e		 pop	 esi
  0015b	5b		 pop	 ebx
  0015c	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015f	33 cd		 xor	 ecx, ebp
  00161	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00166	8b e5		 mov	 esp, ebp
  00168	5d		 pop	 ebp
  00169	c2 20 00	 ret	 32			; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z$0:
  00000	8d 8d c8 fc ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a bc fc ff
	ff		 mov	 ecx, DWORD PTR [edx-836]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$1$ = -68				; size = 4
__Ep$2 = -64						; size = 4
$T3 = -60						; size = 8
__Errno$4 = -56						; size = 4
__Parse_result$ = -52					; size = 2
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 527  :         unsigned long long& _Val) const { // get unsigned long long from [_First, _Last) into _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 75 1c	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0002e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00031	8b 7d 20	 mov	 edi, DWORD PTR __State$[ebp]
  00034	8b 5d 24	 mov	 ebx, DWORD PTR __Val$[ebp]
  00037	89 45 bc	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 289  :         return *_Ploc;

  0003a	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  0003d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00040	89 4d c8	 mov	 DWORD PTR $T3[ebp+4], ecx

; 269  :         _Ptr->_Incref();

  00043	8b 01		 mov	 eax, DWORD PTR [ecx]
  00045	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 531  :             _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field

  00048	8d 45 c4	 lea	 eax, DWORD PTR $T3[ebp]
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00052	50		 push	 eax
  00053	ff 76 14	 push	 DWORD PTR [esi+20]
  00056	8d 45 14	 lea	 eax, DWORD PTR __Last$[ebp]
  00059	50		 push	 eax
  0005a	8d 45 0c	 lea	 eax, DWORD PTR __First$[ebp]
  0005d	50		 push	 eax
  0005e	8d 45 d0	 lea	 eax, DWORD PTR __Ac$[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  00067	8b 4d c8	 mov	 ecx, DWORD PTR $T3[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 531  :             _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field

  0006a	83 c4 14	 add	 esp, 20			; 00000014H
  0006d	66 89 45 cc	 mov	 WORD PTR __Parse_result$[ebp], ax
  00071	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  00078	85 c9		 test	 ecx, ecx
  0007a	74 15		 je	 SHORT $LN20@do_get

; 355  :             delete _Ptr->_Decref();

  0007c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0007e	ff 50 08	 call	 DWORD PTR [eax+8]
  00081	85 c0		 test	 eax, eax
  00083	74 08		 je	 SHORT $LN23@do_get
  00085	8b 10		 mov	 edx, DWORD PTR [eax]
  00087	8b c8		 mov	 ecx, eax
  00089	6a 01		 push	 1
  0008b	ff 12		 call	 DWORD PTR [edx]
$LN23@do_get:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 532  :         if (_Parse_result._Base < 0) { // ditto "fails to convert the entire field"

  0008d	66 8b 45 cc	 mov	 ax, WORD PTR __Parse_result$[ebp]
$LN20@do_get:
  00091	84 c0		 test	 al, al
  00093	79 15		 jns	 SHORT $LN2@do_get

; 533  :             _State = ios_base::failbit;

  00095	c7 07 02 00 00
	00		 mov	 DWORD PTR [edi], 2

; 534  :             _Val   = 0;

  0009b	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  000a1	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 535  :         } else {

  000a8	eb 37		 jmp	 SHORT $LN4@do_get
$LN2@do_get:

; 536  :             int _Errno;
; 537  :             char* _Ep;
; 538  :             _Val = _CSTD _Stoullx(_Ac, &_Ep, _Parse_result._Base, &_Errno); // convert

  000aa	8d 4d c8	 lea	 ecx, DWORD PTR __Errno$4[ebp]
  000ad	0f be c0	 movsx	 eax, al
  000b0	51		 push	 ecx
  000b1	50		 push	 eax
  000b2	8d 45 c0	 lea	 eax, DWORD PTR __Ep$2[ebp]
  000b5	50		 push	 eax
  000b6	8d 45 d0	 lea	 eax, DWORD PTR __Ac$[ebp]
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 __Stoullx
  000bf	89 03		 mov	 DWORD PTR [ebx], eax
  000c1	83 c4 10	 add	 esp, 16			; 00000010H

; 539  :             if (_Ep == _Ac || _Errno != 0 // N4950 [facet.num.get.virtuals]/3
; 540  :                 || _Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4

  000c4	8d 45 d0	 lea	 eax, DWORD PTR __Ac$[ebp]
  000c7	89 53 04	 mov	 DWORD PTR [ebx+4], edx
  000ca	39 45 c0	 cmp	 DWORD PTR __Ep$2[ebp], eax
  000cd	74 0c		 je	 SHORT $LN5@do_get
  000cf	83 7d c8 00	 cmp	 DWORD PTR __Errno$4[ebp], 0
  000d3	75 06		 jne	 SHORT $LN5@do_get
  000d5	80 7d cd 00	 cmp	 BYTE PTR __Parse_result$[ebp+1], 0
  000d9	74 06		 je	 SHORT $LN4@do_get
$LN5@do_get:

; 541  :                 _State = ios_base::failbit;

  000db	c7 07 02 00 00
	00		 mov	 DWORD PTR [edi], 2
$LN4@do_get:

; 542  :             }
; 543  :         }
; 544  : 
; 545  :         if (_First == _Last) {

  000e1	8d 45 14	 lea	 eax, DWORD PTR __Last$[ebp]
  000e4	50		 push	 eax
  000e5	8d 45 0c	 lea	 eax, DWORD PTR __First$[ebp]
  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
  000ee	83 c4 08	 add	 esp, 8
  000f1	84 c0		 test	 al, al
  000f3	74 03		 je	 SHORT $LN6@do_get

; 546  :             _State |= ios_base::eofbit;

  000f5	83 0f 01	 or	 DWORD PTR [edi], 1
$LN6@do_get:

; 547  :         }
; 548  : 
; 549  :         return _First;

  000f8	8b 45 bc	 mov	 eax, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  000fb	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  000fe	8b 55 10	 mov	 edx, DWORD PTR __First$[ebp+4]
  00101	89 08		 mov	 DWORD PTR [eax], ecx
  00103	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 550  :     }

  00106	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00109	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00110	59		 pop	 ecx
  00111	5f		 pop	 edi
  00112	5e		 pop	 esi
  00113	5b		 pop	 ebx
  00114	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00117	33 cd		 xor	 ecx, ebp
  00119	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c2 20 00	 ret	 32			; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z$0:
  00000	8d 4d c4	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$1$ = -68				; size = 4
__Ep$2 = -64						; size = 4
$T3 = -60						; size = 8
__Errno$4 = -56						; size = 4
__Parse_result$ = -52					; size = 2
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 501  :         long long& _Val) const { // get long long from [_First, _Last) into _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 75 1c	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0002e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00031	8b 7d 20	 mov	 edi, DWORD PTR __State$[ebp]
  00034	8b 5d 24	 mov	 ebx, DWORD PTR __Val$[ebp]
  00037	89 45 bc	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 289  :         return *_Ploc;

  0003a	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  0003d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00040	89 4d c8	 mov	 DWORD PTR $T3[ebp+4], ecx

; 269  :         _Ptr->_Incref();

  00043	8b 01		 mov	 eax, DWORD PTR [ecx]
  00045	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 505  :             _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field

  00048	8d 45 c4	 lea	 eax, DWORD PTR $T3[ebp]
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00052	50		 push	 eax
  00053	ff 76 14	 push	 DWORD PTR [esi+20]
  00056	8d 45 14	 lea	 eax, DWORD PTR __Last$[ebp]
  00059	50		 push	 eax
  0005a	8d 45 0c	 lea	 eax, DWORD PTR __First$[ebp]
  0005d	50		 push	 eax
  0005e	8d 45 d0	 lea	 eax, DWORD PTR __Ac$[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  00067	8b 4d c8	 mov	 ecx, DWORD PTR $T3[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 505  :             _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field

  0006a	83 c4 14	 add	 esp, 20			; 00000014H
  0006d	66 89 45 cc	 mov	 WORD PTR __Parse_result$[ebp], ax
  00071	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  00078	85 c9		 test	 ecx, ecx
  0007a	74 15		 je	 SHORT $LN20@do_get

; 355  :             delete _Ptr->_Decref();

  0007c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0007e	ff 50 08	 call	 DWORD PTR [eax+8]
  00081	85 c0		 test	 eax, eax
  00083	74 08		 je	 SHORT $LN23@do_get
  00085	8b 10		 mov	 edx, DWORD PTR [eax]
  00087	8b c8		 mov	 ecx, eax
  00089	6a 01		 push	 1
  0008b	ff 12		 call	 DWORD PTR [edx]
$LN23@do_get:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 506  :         if (_Parse_result._Base < 0) { // ditto "fails to convert the entire field"

  0008d	66 8b 45 cc	 mov	 ax, WORD PTR __Parse_result$[ebp]
$LN20@do_get:
  00091	84 c0		 test	 al, al
  00093	79 15		 jns	 SHORT $LN2@do_get

; 507  :             _State = ios_base::failbit;

  00095	c7 07 02 00 00
	00		 mov	 DWORD PTR [edi], 2

; 508  :             _Val   = 0;

  0009b	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  000a1	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 509  :         } else {

  000a8	eb 37		 jmp	 SHORT $LN4@do_get
$LN2@do_get:

; 510  :             char* _Ep;
; 511  :             int _Errno;
; 512  :             _Val = _CSTD _Stollx(_Ac, &_Ep, _Parse_result._Base, &_Errno); // convert

  000aa	8d 4d c8	 lea	 ecx, DWORD PTR __Errno$4[ebp]
  000ad	0f be c0	 movsx	 eax, al
  000b0	51		 push	 ecx
  000b1	50		 push	 eax
  000b2	8d 45 c0	 lea	 eax, DWORD PTR __Ep$2[ebp]
  000b5	50		 push	 eax
  000b6	8d 45 d0	 lea	 eax, DWORD PTR __Ac$[ebp]
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 __Stollx
  000bf	89 03		 mov	 DWORD PTR [ebx], eax
  000c1	83 c4 10	 add	 esp, 16			; 00000010H

; 513  :             if (_Ep == _Ac || _Errno != 0 // N4950 [facet.num.get.virtuals]/3
; 514  :                 || _Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4

  000c4	8d 45 d0	 lea	 eax, DWORD PTR __Ac$[ebp]
  000c7	89 53 04	 mov	 DWORD PTR [ebx+4], edx
  000ca	39 45 c0	 cmp	 DWORD PTR __Ep$2[ebp], eax
  000cd	74 0c		 je	 SHORT $LN5@do_get
  000cf	83 7d c8 00	 cmp	 DWORD PTR __Errno$4[ebp], 0
  000d3	75 06		 jne	 SHORT $LN5@do_get
  000d5	80 7d cd 00	 cmp	 BYTE PTR __Parse_result$[ebp+1], 0
  000d9	74 06		 je	 SHORT $LN4@do_get
$LN5@do_get:

; 515  :                 _State = ios_base::failbit;

  000db	c7 07 02 00 00
	00		 mov	 DWORD PTR [edi], 2
$LN4@do_get:

; 516  :             }
; 517  :         }
; 518  : 
; 519  :         if (_First == _Last) {

  000e1	8d 45 14	 lea	 eax, DWORD PTR __Last$[ebp]
  000e4	50		 push	 eax
  000e5	8d 45 0c	 lea	 eax, DWORD PTR __First$[ebp]
  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
  000ee	83 c4 08	 add	 esp, 8
  000f1	84 c0		 test	 al, al
  000f3	74 03		 je	 SHORT $LN6@do_get

; 520  :             _State |= ios_base::eofbit;

  000f5	83 0f 01	 or	 DWORD PTR [edi], 1
$LN6@do_get:

; 521  :         }
; 522  : 
; 523  :         return _First;

  000f8	8b 45 bc	 mov	 eax, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  000fb	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  000fe	8b 55 10	 mov	 edx, DWORD PTR __First$[ebp+4]
  00101	89 08		 mov	 DWORD PTR [eax], ecx
  00103	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 524  :     }

  00106	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00109	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00110	59		 pop	 ecx
  00111	5f		 pop	 edi
  00112	5e		 pop	 esi
  00113	5b		 pop	 ebx
  00114	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00117	33 cd		 xor	 ecx, ebp
  00119	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c2 20 00	 ret	 32			; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z$0:
  00000	8d 4d c4	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
_TEXT	SEGMENT
__Ep$2 = -68						; size = 4
$T3 = -64						; size = 8
__Errno$4 = -60						; size = 4
__Val$GSCopy$1$ = -56					; size = 4
__Parse_result$ = -52					; size = 2
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 475  :         unsigned long& _Val) const { // get unsigned long from [_First, _Last) into _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 75 1c	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0002e	8b 45 24	 mov	 eax, DWORD PTR __Val$[ebp]
  00031	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  00034	8b 7d 20	 mov	 edi, DWORD PTR __State$[ebp]
  00037	89 45 c8	 mov	 DWORD PTR __Val$GSCopy$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 289  :         return *_Ploc;

  0003a	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  0003d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00040	89 4d c4	 mov	 DWORD PTR $T3[ebp+4], ecx

; 269  :         _Ptr->_Incref();

  00043	8b 01		 mov	 eax, DWORD PTR [ecx]
  00045	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 479  :             _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field

  00048	8d 45 c0	 lea	 eax, DWORD PTR $T3[ebp]
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00052	50		 push	 eax
  00053	ff 76 14	 push	 DWORD PTR [esi+20]
  00056	8d 45 14	 lea	 eax, DWORD PTR __Last$[ebp]
  00059	50		 push	 eax
  0005a	8d 45 0c	 lea	 eax, DWORD PTR __First$[ebp]
  0005d	50		 push	 eax
  0005e	8d 45 d0	 lea	 eax, DWORD PTR __Ac$[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  00067	8b 4d c4	 mov	 ecx, DWORD PTR $T3[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 479  :             _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field

  0006a	83 c4 14	 add	 esp, 20			; 00000014H
  0006d	66 89 45 cc	 mov	 WORD PTR __Parse_result$[ebp], ax
  00071	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  00078	85 c9		 test	 ecx, ecx
  0007a	74 15		 je	 SHORT $LN20@do_get

; 355  :             delete _Ptr->_Decref();

  0007c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0007e	ff 50 08	 call	 DWORD PTR [eax+8]
  00081	85 c0		 test	 eax, eax
  00083	74 08		 je	 SHORT $LN23@do_get
  00085	8b 10		 mov	 edx, DWORD PTR [eax]
  00087	8b c8		 mov	 ecx, eax
  00089	6a 01		 push	 1
  0008b	ff 12		 call	 DWORD PTR [edx]
$LN23@do_get:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 480  :         if (_Parse_result._Base < 0) { // ditto "fails to convert the entire field"

  0008d	66 8b 45 cc	 mov	 ax, WORD PTR __Parse_result$[ebp]
$LN20@do_get:
  00091	84 c0		 test	 al, al
  00093	79 11		 jns	 SHORT $LN2@do_get

; 481  :             _State = ios_base::failbit;
; 482  :             _Val   = 0;

  00095	8b 4d c8	 mov	 ecx, DWORD PTR __Val$GSCopy$1$[ebp]
  00098	c7 07 02 00 00
	00		 mov	 DWORD PTR [edi], 2
  0009e	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  :         } else {

  000a4	eb 37		 jmp	 SHORT $LN4@do_get
$LN2@do_get:

; 484  :             char* _Ep;
; 485  :             int _Errno;
; 486  :             _Val = _CSTD _Stoulx(_Ac, &_Ep, _Parse_result._Base, &_Errno); // convert

  000a6	8d 4d c4	 lea	 ecx, DWORD PTR __Errno$4[ebp]
  000a9	0f be c0	 movsx	 eax, al
  000ac	51		 push	 ecx
  000ad	50		 push	 eax
  000ae	8d 45 bc	 lea	 eax, DWORD PTR __Ep$2[ebp]
  000b1	50		 push	 eax
  000b2	8d 45 d0	 lea	 eax, DWORD PTR __Ac$[ebp]
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 __Stoulx
  000bb	8b 4d c8	 mov	 ecx, DWORD PTR __Val$GSCopy$1$[ebp]
  000be	83 c4 10	 add	 esp, 16			; 00000010H
  000c1	89 01		 mov	 DWORD PTR [ecx], eax

; 487  :             if (_Ep == _Ac || _Errno != 0 // N4950 [facet.num.get.virtuals]/3
; 488  :                 || _Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4

  000c3	8d 45 d0	 lea	 eax, DWORD PTR __Ac$[ebp]
  000c6	39 45 bc	 cmp	 DWORD PTR __Ep$2[ebp], eax
  000c9	74 0c		 je	 SHORT $LN5@do_get
  000cb	83 7d c4 00	 cmp	 DWORD PTR __Errno$4[ebp], 0
  000cf	75 06		 jne	 SHORT $LN5@do_get
  000d1	80 7d cd 00	 cmp	 BYTE PTR __Parse_result$[ebp+1], 0
  000d5	74 06		 je	 SHORT $LN4@do_get
$LN5@do_get:

; 489  :                 _State = ios_base::failbit;

  000d7	c7 07 02 00 00
	00		 mov	 DWORD PTR [edi], 2
$LN4@do_get:

; 490  :             }
; 491  :         }
; 492  : 
; 493  :         if (_First == _Last) {

  000dd	8d 45 14	 lea	 eax, DWORD PTR __Last$[ebp]
  000e0	50		 push	 eax
  000e1	8d 45 0c	 lea	 eax, DWORD PTR __First$[ebp]
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
  000ea	83 c4 08	 add	 esp, 8
  000ed	84 c0		 test	 al, al
  000ef	74 03		 je	 SHORT $LN6@do_get

; 494  :             _State |= ios_base::eofbit;

  000f1	83 0f 01	 or	 DWORD PTR [edi], 1
$LN6@do_get:

; 495  :         }
; 496  : 
; 497  :         return _First;

  000f4	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  000f7	8b c3		 mov	 eax, ebx
  000f9	8b 55 10	 mov	 edx, DWORD PTR __First$[ebp+4]
  000fc	89 0b		 mov	 DWORD PTR [ebx], ecx
  000fe	89 53 04	 mov	 DWORD PTR [ebx+4], edx

; 498  :     }

  00101	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00104	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0010b	59		 pop	 ecx
  0010c	5f		 pop	 edi
  0010d	5e		 pop	 esi
  0010e	5b		 pop	 ebx
  0010f	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00112	33 cd		 xor	 ecx, ebp
  00114	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00119	8b e5		 mov	 esp, ebp
  0011b	5d		 pop	 ebp
  0011c	c2 20 00	 ret	 32			; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
_TEXT	SEGMENT
__Ep$2 = -68						; size = 4
$T3 = -64						; size = 8
__Errno$4 = -60						; size = 4
__Val$GSCopy$1$ = -56					; size = 4
__Parse_result$ = -52					; size = 2
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 449  :         long& _Val) const { // get long from [_First, _Last) into _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 75 1c	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0002e	8b 45 24	 mov	 eax, DWORD PTR __Val$[ebp]
  00031	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  00034	8b 7d 20	 mov	 edi, DWORD PTR __State$[ebp]
  00037	89 45 c8	 mov	 DWORD PTR __Val$GSCopy$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 289  :         return *_Ploc;

  0003a	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  0003d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00040	89 4d c4	 mov	 DWORD PTR $T3[ebp+4], ecx

; 269  :         _Ptr->_Incref();

  00043	8b 01		 mov	 eax, DWORD PTR [ecx]
  00045	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 453  :             _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field

  00048	8d 45 c0	 lea	 eax, DWORD PTR $T3[ebp]
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00052	50		 push	 eax
  00053	ff 76 14	 push	 DWORD PTR [esi+20]
  00056	8d 45 14	 lea	 eax, DWORD PTR __Last$[ebp]
  00059	50		 push	 eax
  0005a	8d 45 0c	 lea	 eax, DWORD PTR __First$[ebp]
  0005d	50		 push	 eax
  0005e	8d 45 d0	 lea	 eax, DWORD PTR __Ac$[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  00067	8b 4d c4	 mov	 ecx, DWORD PTR $T3[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 453  :             _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field

  0006a	83 c4 14	 add	 esp, 20			; 00000014H
  0006d	66 89 45 cc	 mov	 WORD PTR __Parse_result$[ebp], ax
  00071	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  00078	85 c9		 test	 ecx, ecx
  0007a	74 15		 je	 SHORT $LN20@do_get

; 355  :             delete _Ptr->_Decref();

  0007c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0007e	ff 50 08	 call	 DWORD PTR [eax+8]
  00081	85 c0		 test	 eax, eax
  00083	74 08		 je	 SHORT $LN23@do_get
  00085	8b 10		 mov	 edx, DWORD PTR [eax]
  00087	8b c8		 mov	 ecx, eax
  00089	6a 01		 push	 1
  0008b	ff 12		 call	 DWORD PTR [edx]
$LN23@do_get:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 454  :         if (_Parse_result._Base < 0) { // ditto "fails to convert the entire field"

  0008d	66 8b 45 cc	 mov	 ax, WORD PTR __Parse_result$[ebp]
$LN20@do_get:
  00091	84 c0		 test	 al, al
  00093	79 11		 jns	 SHORT $LN2@do_get

; 455  :             _State = ios_base::failbit;
; 456  :             _Val   = 0;

  00095	8b 4d c8	 mov	 ecx, DWORD PTR __Val$GSCopy$1$[ebp]
  00098	c7 07 02 00 00
	00		 mov	 DWORD PTR [edi], 2
  0009e	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 457  :         } else {

  000a4	eb 37		 jmp	 SHORT $LN4@do_get
$LN2@do_get:

; 458  :             char* _Ep;
; 459  :             int _Errno;
; 460  :             _Val = _CSTD _Stolx(_Ac, &_Ep, _Parse_result._Base, &_Errno); // convert

  000a6	8d 4d c4	 lea	 ecx, DWORD PTR __Errno$4[ebp]
  000a9	0f be c0	 movsx	 eax, al
  000ac	51		 push	 ecx
  000ad	50		 push	 eax
  000ae	8d 45 bc	 lea	 eax, DWORD PTR __Ep$2[ebp]
  000b1	50		 push	 eax
  000b2	8d 45 d0	 lea	 eax, DWORD PTR __Ac$[ebp]
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 __Stolx
  000bb	8b 4d c8	 mov	 ecx, DWORD PTR __Val$GSCopy$1$[ebp]
  000be	83 c4 10	 add	 esp, 16			; 00000010H
  000c1	89 01		 mov	 DWORD PTR [ecx], eax

; 461  :             if (_Ep == _Ac || _Errno != 0 // N4950 [facet.num.get.virtuals]/3
; 462  :                 || _Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4

  000c3	8d 45 d0	 lea	 eax, DWORD PTR __Ac$[ebp]
  000c6	39 45 bc	 cmp	 DWORD PTR __Ep$2[ebp], eax
  000c9	74 0c		 je	 SHORT $LN5@do_get
  000cb	83 7d c4 00	 cmp	 DWORD PTR __Errno$4[ebp], 0
  000cf	75 06		 jne	 SHORT $LN5@do_get
  000d1	80 7d cd 00	 cmp	 BYTE PTR __Parse_result$[ebp+1], 0
  000d5	74 06		 je	 SHORT $LN4@do_get
$LN5@do_get:

; 463  :                 _State = ios_base::failbit;

  000d7	c7 07 02 00 00
	00		 mov	 DWORD PTR [edi], 2
$LN4@do_get:

; 464  :             }
; 465  :         }
; 466  : 
; 467  :         if (_First == _Last) {

  000dd	8d 45 14	 lea	 eax, DWORD PTR __Last$[ebp]
  000e0	50		 push	 eax
  000e1	8d 45 0c	 lea	 eax, DWORD PTR __First$[ebp]
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
  000ea	83 c4 08	 add	 esp, 8
  000ed	84 c0		 test	 al, al
  000ef	74 03		 je	 SHORT $LN6@do_get

; 468  :             _State |= ios_base::eofbit;

  000f1	83 0f 01	 or	 DWORD PTR [edi], 1
$LN6@do_get:

; 469  :         }
; 470  : 
; 471  :         return _First;

  000f4	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  000f7	8b c3		 mov	 eax, ebx
  000f9	8b 55 10	 mov	 edx, DWORD PTR __First$[ebp+4]
  000fc	89 0b		 mov	 DWORD PTR [ebx], ecx
  000fe	89 53 04	 mov	 DWORD PTR [ebx+4], edx

; 472  :     }

  00101	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00104	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0010b	59		 pop	 ecx
  0010c	5f		 pop	 edi
  0010d	5e		 pop	 esi
  0010e	5b		 pop	 ebx
  0010f	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00112	33 cd		 xor	 ecx, ebp
  00114	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00119	8b e5		 mov	 esp, ebp
  0011b	5d		 pop	 ebp
  0011c	c2 20 00	 ret	 32			; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z
_TEXT	SEGMENT
__Last$ = -84						; size = 8
__Val$GSCopy$1$ = -76					; size = 4
__Ep$2 = -72						; size = 4
$T3 = -68						; size = 8
__Errno$4 = -64						; size = 4
__First$ = -60						; size = 8
__Parse_result$5 = -52					; size = 2
__Ac$6 = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 439  :         unsigned int& _Val) const { // get unsigned int from [_First, _Last) into _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 45 24	 mov	 eax, DWORD PTR __Val$[ebp]
  0002e	8b 75 1c	 mov	 esi, DWORD PTR __Iosbase$[ebp]

; 443  :         _First = num_get::do_get(_First, _Last, _Iosbase, _State, _Tmp); // avoid virtual call for perf

  00031	8b 4d 18	 mov	 ecx, DWORD PTR __Last$[ebp+4]
  00034	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  00037	8b 7d 20	 mov	 edi, DWORD PTR __State$[ebp]
  0003a	89 45 b4	 mov	 DWORD PTR __Val$GSCopy$1$[ebp], eax
  0003d	8b 45 14	 mov	 eax, DWORD PTR __Last$[ebp]
  00040	89 45 ac	 mov	 DWORD PTR __Last$[ebp], eax
  00043	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00046	89 45 c4	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 289  :         return *_Ploc;

  00049	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 443  :         _First = num_get::do_get(_First, _Last, _Iosbase, _State, _Tmp); // avoid virtual call for perf

  0004c	89 4d b0	 mov	 DWORD PTR __Last$[ebp+4], ecx
  0004f	8b 4d 10	 mov	 ecx, DWORD PTR __First$[ebp+4]
  00052	89 4d c8	 mov	 DWORD PTR __First$[ebp+4], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  00055	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00058	89 4d c0	 mov	 DWORD PTR $T3[ebp+4], ecx

; 269  :         _Ptr->_Incref();

  0005b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005d	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 479  :             _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field

  00060	8d 45 bc	 lea	 eax, DWORD PTR $T3[ebp]
  00063	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006a	50		 push	 eax
  0006b	ff 76 14	 push	 DWORD PTR [esi+20]
  0006e	8d 45 ac	 lea	 eax, DWORD PTR __Last$[ebp]
  00071	50		 push	 eax
  00072	8d 45 c4	 lea	 eax, DWORD PTR __First$[ebp]
  00075	50		 push	 eax
  00076	8d 45 d0	 lea	 eax, DWORD PTR __Ac$6[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  0007f	8b 4d c0	 mov	 ecx, DWORD PTR $T3[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 479  :             _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field

  00082	83 c4 14	 add	 esp, 20			; 00000014H
  00085	66 89 45 cc	 mov	 WORD PTR __Parse_result$5[ebp], ax
  00089	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  00090	85 c9		 test	 ecx, ecx
  00092	74 15		 je	 SHORT $LN22@do_get

; 355  :             delete _Ptr->_Decref();

  00094	8b 01		 mov	 eax, DWORD PTR [ecx]
  00096	ff 50 08	 call	 DWORD PTR [eax+8]
  00099	85 c0		 test	 eax, eax
  0009b	74 08		 je	 SHORT $LN25@do_get
  0009d	8b 10		 mov	 edx, DWORD PTR [eax]
  0009f	8b c8		 mov	 ecx, eax
  000a1	6a 01		 push	 1
  000a3	ff 12		 call	 DWORD PTR [edx]
$LN25@do_get:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 480  :         if (_Parse_result._Base < 0) { // ditto "fails to convert the entire field"

  000a5	66 8b 45 cc	 mov	 ax, WORD PTR __Parse_result$5[ebp]
$LN22@do_get:
  000a9	84 c0		 test	 al, al
  000ab	79 04		 jns	 SHORT $LN4@do_get

; 481  :             _State = ios_base::failbit;
; 482  :             _Val   = 0;

  000ad	33 f6		 xor	 esi, esi

; 483  :         } else {

  000af	eb 2e		 jmp	 SHORT $LN7@do_get
$LN4@do_get:

; 484  :             char* _Ep;
; 485  :             int _Errno;
; 486  :             _Val = _CSTD _Stoulx(_Ac, &_Ep, _Parse_result._Base, &_Errno); // convert

  000b1	8d 4d c0	 lea	 ecx, DWORD PTR __Errno$4[ebp]
  000b4	0f be c0	 movsx	 eax, al
  000b7	51		 push	 ecx
  000b8	50		 push	 eax
  000b9	8d 45 b8	 lea	 eax, DWORD PTR __Ep$2[ebp]
  000bc	50		 push	 eax
  000bd	8d 45 d0	 lea	 eax, DWORD PTR __Ac$6[ebp]
  000c0	50		 push	 eax
  000c1	e8 00 00 00 00	 call	 __Stoulx
  000c6	8b f0		 mov	 esi, eax
  000c8	83 c4 10	 add	 esp, 16			; 00000010H

; 487  :             if (_Ep == _Ac || _Errno != 0 // N4950 [facet.num.get.virtuals]/3
; 488  :                 || _Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4

  000cb	8d 45 d0	 lea	 eax, DWORD PTR __Ac$6[ebp]
  000ce	39 45 b8	 cmp	 DWORD PTR __Ep$2[ebp], eax
  000d1	74 0c		 je	 SHORT $LN7@do_get
  000d3	83 7d c0 00	 cmp	 DWORD PTR __Errno$4[ebp], 0
  000d7	75 06		 jne	 SHORT $LN7@do_get
  000d9	80 7d cd 00	 cmp	 BYTE PTR __Parse_result$5[ebp+1], 0
  000dd	74 06		 je	 SHORT $LN6@do_get
$LN7@do_get:

; 489  :                 _State = ios_base::failbit;
; 490  :             }
; 491  :         }
; 492  : 
; 493  :         if (_First == _Last) {

  000df	c7 07 02 00 00
	00		 mov	 DWORD PTR [edi], 2
$LN6@do_get:
  000e5	8d 45 ac	 lea	 eax, DWORD PTR __Last$[ebp]
  000e8	50		 push	 eax
  000e9	8d 45 c4	 lea	 eax, DWORD PTR __First$[ebp]
  000ec	50		 push	 eax
  000ed	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
  000f2	83 c4 08	 add	 esp, 8
  000f5	84 c0		 test	 al, al
  000f7	74 03		 je	 SHORT $LN8@do_get

; 494  :             _State |= ios_base::eofbit;

  000f9	83 0f 01	 or	 DWORD PTR [edi], 1
$LN8@do_get:

; 444  :         _Val   = _Tmp;

  000fc	8b 45 b4	 mov	 eax, DWORD PTR __Val$GSCopy$1$[ebp]

; 445  :         return _First;

  000ff	8b 4d c4	 mov	 ecx, DWORD PTR __First$[ebp]
  00102	8b 55 c8	 mov	 edx, DWORD PTR __First$[ebp+4]
  00105	89 30		 mov	 DWORD PTR [eax], esi
  00107	8b c3		 mov	 eax, ebx
  00109	89 0b		 mov	 DWORD PTR [ebx], ecx
  0010b	89 53 04	 mov	 DWORD PTR [ebx+4], edx

; 446  :     }

  0010e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00111	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00118	59		 pop	 ecx
  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi
  0011b	5b		 pop	 ebx
  0011c	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011f	33 cd		 xor	 ecx, ebp
  00121	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c2 20 00	 ret	 32			; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z$0:
  00000	8d 4d bc	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$1$ = -72				; size = 4
__Ep$2 = -68						; size = 4
$T3 = -64						; size = 8
__Errno$4 = -60						; size = 4
__Parse_result$ = -56					; size = 2
__Minus$1$ = -49					; size = 1
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 397  :         unsigned short& _Val) const { // get unsigned short from [_First, _Last) into _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 75 1c	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0002e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00031	8b 7d 20	 mov	 edi, DWORD PTR __State$[ebp]
  00034	8b 5d 24	 mov	 ebx, DWORD PTR __Val$[ebp]
  00037	89 45 b8	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 289  :         return *_Ploc;

  0003a	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  0003d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00040	89 4d c4	 mov	 DWORD PTR $T3[ebp+4], ecx

; 269  :         _Ptr->_Incref();

  00043	8b 01		 mov	 eax, DWORD PTR [ecx]
  00045	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 401  :             _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field

  00048	8d 45 c0	 lea	 eax, DWORD PTR $T3[ebp]
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00052	50		 push	 eax
  00053	ff 76 14	 push	 DWORD PTR [esi+20]
  00056	8d 45 14	 lea	 eax, DWORD PTR __Last$[ebp]
  00059	50		 push	 eax
  0005a	8d 45 0c	 lea	 eax, DWORD PTR __First$[ebp]
  0005d	50		 push	 eax
  0005e	8d 45 d0	 lea	 eax, DWORD PTR __Ac$[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  00067	8b 4d c4	 mov	 ecx, DWORD PTR $T3[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 401  :             _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field

  0006a	83 c4 14	 add	 esp, 20			; 00000014H
  0006d	66 89 45 c8	 mov	 WORD PTR __Parse_result$[ebp], ax
  00071	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  00078	85 c9		 test	 ecx, ecx
  0007a	74 15		 je	 SHORT $LN24@do_get

; 355  :             delete _Ptr->_Decref();

  0007c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0007e	ff 50 08	 call	 DWORD PTR [eax+8]
  00081	85 c0		 test	 eax, eax
  00083	74 08		 je	 SHORT $LN27@do_get
  00085	8b 10		 mov	 edx, DWORD PTR [eax]
  00087	8b c8		 mov	 ecx, eax
  00089	6a 01		 push	 1
  0008b	ff 12		 call	 DWORD PTR [edx]
$LN27@do_get:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 402  :         if (_Parse_result._Base < 0) { // ditto "fails to convert the entire field"

  0008d	66 8b 45 c8	 mov	 ax, WORD PTR __Parse_result$[ebp]
$LN24@do_get:
  00091	84 c0		 test	 al, al
  00093	79 0d		 jns	 SHORT $LN2@do_get

; 403  :             _State = ios_base::failbit;
; 404  :             _Val   = 0;

  00095	33 c0		 xor	 eax, eax
  00097	c7 07 02 00 00
	00		 mov	 DWORD PTR [edi], 2
  0009d	66 89 03	 mov	 WORD PTR [ebx], ax

; 405  :         } else {

  000a0	eb 65		 jmp	 SHORT $LN9@do_get
$LN2@do_get:

; 406  :             const bool _Minus   = _Ac[0] == '-';

  000a2	80 7d d0 2d	 cmp	 BYTE PTR __Ac$[ebp], 45	; 0000002dH

; 407  :             const char* _Digits = _Ac;
; 408  :             // C11 7.22.1.4/5: the sequence of characters starting with the first digit
; 409  :             // is interpreted as an integer constant according to the rules of 6.4.4.1
; 410  :             if (_Minus) { // skip over minus to start with the first digit
; 411  :                 ++_Digits;
; 412  :             }
; 413  : 
; 414  :             char* _Ep;
; 415  :             int _Errno;
; 416  :             const unsigned long _Tmp = _CSTD _Stoulx(_Digits, &_Ep, _Parse_result._Base, &_Errno); // convert

  000a6	8d 4d c4	 lea	 ecx, DWORD PTR __Errno$4[ebp]
  000a9	51		 push	 ecx
  000aa	0f be c0	 movsx	 eax, al
  000ad	8d 55 d0	 lea	 edx, DWORD PTR __Ac$[ebp]
  000b0	50		 push	 eax
  000b1	8d 45 bc	 lea	 eax, DWORD PTR __Ep$2[ebp]
  000b4	0f 94 45 cf	 sete	 BYTE PTR __Minus$1$[ebp]
  000b8	8d 75 d1	 lea	 esi, DWORD PTR __Ac$[ebp+1]
  000bb	0f 45 f2	 cmovne	 esi, edx
  000be	50		 push	 eax
  000bf	56		 push	 esi
  000c0	e8 00 00 00 00	 call	 __Stoulx
  000c5	83 c4 10	 add	 esp, 16			; 00000010H

; 417  :             _Val                     = static_cast<unsigned short>(_Tmp);

  000c8	0f b7 c8	 movzx	 ecx, ax
  000cb	66 89 0b	 mov	 WORD PTR [ebx], cx

; 418  :             if (_Ep == _Digits || _Errno != 0 || _Tmp > USHRT_MAX) { // N4950 [facet.num.get.virtuals]/3

  000ce	39 75 bc	 cmp	 DWORD PTR __Ep$2[ebp], esi
  000d1	74 1a		 je	 SHORT $LN7@do_get
  000d3	83 7d c4 00	 cmp	 DWORD PTR __Errno$4[ebp], 0
  000d7	75 14		 jne	 SHORT $LN7@do_get
  000d9	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  000de	77 0d		 ja	 SHORT $LN7@do_get

; 421  :             } else if (_Minus) { // C11 7.22.1.4/5:  If the subject sequence begins with a minus sign,

  000e0	80 7d cf 00	 cmp	 BYTE PTR __Minus$1$[ebp], 0
  000e4	74 15		 je	 SHORT $LN8@do_get

; 422  :                                  // the value resulting from the conversion is negated (in the return type).
; 423  :                 _Val = static_cast<unsigned short>(0 - _Val);

  000e6	f7 d9		 neg	 ecx
  000e8	66 89 0b	 mov	 WORD PTR [ebx], cx
  000eb	eb 0e		 jmp	 SHORT $LN8@do_get
$LN7@do_get:

; 419  :                 _State = ios_base::failbit;
; 420  :                 _Val   = USHRT_MAX;

  000ed	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  000f2	c7 07 02 00 00
	00		 mov	 DWORD PTR [edi], 2
  000f8	66 89 03	 mov	 WORD PTR [ebx], ax
$LN8@do_get:

; 424  :             }
; 425  : 
; 426  :             if (_Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4

  000fb	80 7d c9 00	 cmp	 BYTE PTR __Parse_result$[ebp+1], 0
  000ff	74 06		 je	 SHORT $LN9@do_get

; 427  :                 _State = ios_base::failbit;

  00101	c7 07 02 00 00
	00		 mov	 DWORD PTR [edi], 2
$LN9@do_get:

; 428  :             }
; 429  :         }
; 430  : 
; 431  :         if (_First == _Last) {

  00107	8d 45 14	 lea	 eax, DWORD PTR __Last$[ebp]
  0010a	50		 push	 eax
  0010b	8d 45 0c	 lea	 eax, DWORD PTR __First$[ebp]
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
  00114	83 c4 08	 add	 esp, 8
  00117	84 c0		 test	 al, al
  00119	74 03		 je	 SHORT $LN10@do_get

; 432  :             _State |= ios_base::eofbit;

  0011b	83 0f 01	 or	 DWORD PTR [edi], 1
$LN10@do_get:

; 433  :         }
; 434  : 
; 435  :         return _First;

  0011e	8b 45 b8	 mov	 eax, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  00121	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00124	8b 55 10	 mov	 edx, DWORD PTR __First$[ebp+4]
  00127	89 08		 mov	 DWORD PTR [eax], ecx
  00129	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 436  :     }

  0012c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0012f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00136	59		 pop	 ecx
  00137	5f		 pop	 edi
  00138	5e		 pop	 esi
  00139	5b		 pop	 ebx
  0013a	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013d	33 cd		 xor	 ecx, ebp
  0013f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00144	8b e5		 mov	 esp, ebp
  00146	5d		 pop	 ebp
  00147	c2 20 00	 ret	 32			; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$1$ = -132				; size = 4
__Old_capacity$1$ = -128				; size = 4
$T2 = -124						; size = 8
__Ep$3 = -120						; size = 4
tv1357 = -120						; size = 4
__Iosbase$GSCopy$1$ = -120				; size = 4
$T4 = -116						; size = 8
__Errno$5 = -112					; size = 4
__Val$GSCopy$1$ = -112					; size = 4
__Fancy_ptr$1$ = -108					; size = 4
__State$GSCopy$1$ = -104				; size = 4
__Parse_result$6 = -100					; size = 2
__Punct_fac$1$ = -100					; size = 4
$T7 = -96						; size = 24
$T8 = -96						; size = 24
__Str$9 = -72						; size = 24
__Ac$10 = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 343  :         bool& _Val) const { // get bool from [_First, _Last) into _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 78	 sub	 esp, 120		; 00000078H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002d	8b 7d 20	 mov	 edi, DWORD PTR __State$[ebp]
  00030	8b 75 24	 mov	 esi, DWORD PTR __Val$[ebp]
  00033	89 85 7c ff ff
	ff		 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
  00039	8b 45 1c	 mov	 eax, DWORD PTR __Iosbase$[ebp]
  0003c	89 45 88	 mov	 DWORD PTR __Iosbase$GSCopy$1$[ebp], eax
  0003f	89 7d 98	 mov	 DWORD PTR __State$GSCopy$1$[ebp], edi
  00042	89 75 90	 mov	 DWORD PTR __Val$GSCopy$1$[ebp], esi

; 344  :         _Adl_verify_range(_First, _Last);
; 345  :         if (_Iosbase.flags() & ios_base::boolalpha) { // get false name or true name

  00045	f7 40 14 00 40
	00 00		 test	 DWORD PTR [eax+20], 16384 ; 00004000H
  0004c	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0004f	0f 84 9a 02 00
	00		 je	 $LN4@do_get
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  00055	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]

; 269  :         _Ptr->_Incref();

  00058	8b cf		 mov	 ecx, edi
  0005a	89 7d 88	 mov	 DWORD PTR $T2[ebp+4], edi
  0005d	8b 07		 mov	 eax, DWORD PTR [edi]
  0005f	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 346  :             const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

  00062	8d 45 84	 lea	 eax, DWORD PTR $T2[ebp]
  00065	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
  00072	83 c4 04	 add	 esp, 4
  00075	8b c8		 mov	 ecx, eax
  00077	89 4d 9c	 mov	 DWORD PTR __Punct_fac$1$[ebp], ecx
  0007a	85 ff		 test	 edi, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  0007c	74 18		 je	 SHORT $LN33@do_get

; 355  :             delete _Ptr->_Decref();

  0007e	8b 07		 mov	 eax, DWORD PTR [edi]
  00080	8b cf		 mov	 ecx, edi
  00082	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00085	ff d0		 call	 eax
  00087	8b c8		 mov	 ecx, eax
  00089	85 c9		 test	 ecx, ecx
  0008b	74 06		 je	 SHORT $LN286@do_get
  0008d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0008f	6a 01		 push	 1
  00091	ff 10		 call	 DWORD PTR [eax]
$LN286@do_get:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00093	8b 4d 9c	 mov	 ecx, DWORD PTR __Punct_fac$1$[ebp]
$LN33@do_get:
  00096	0f 57 c0	 xorps	 xmm0, xmm0

; 890  :             _My_data._Mysize = _Count;

  00099	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR __Str$9[ebp+16], 1

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  000a0	0f 11 45 b8	 movups	 XMMWORD PTR __Str$9[ebp], xmm0

; 891  :             _My_data._Myres  = _Small_string_capacity;

  000a4	c7 45 cc 0f 00
	00 00		 mov	 DWORD PTR __Str$9[ebp+20], 15 ; 0000000fH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 493  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  000ab	66 c7 45 b8 00
	00		 mov	 WORD PTR __Str$9[ebp], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 112  :         return do_falsename();

  000b1	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b3	8d 55 a0	 lea	 edx, DWORD PTR $T7[ebp]
  000b6	52		 push	 edx

; 347  :             basic_string<_Elem> _Str(static_cast<size_t>(1), _Elem{});

  000b7	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 112  :         return do_falsename();

  000be	ff 50 18	 call	 DWORD PTR [eax+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  000c1	83 7d b4 0f	 cmp	 DWORD PTR $T7[ebp+20], 15 ; 0000000fH

; 444  :         const value_type* _Result = _Bx._Buf;

  000c5	8d 45 a0	 lea	 eax, DWORD PTR $T7[ebp]

; 1483 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  000c8	ff 75 b0	 push	 DWORD PTR $T7[ebp+16]

; 445  :         if (_Large_mode_engaged()) {

  000cb	0f 47 45 a0	 cmova	 eax, DWORD PTR $T7[ebp]

; 1483 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  000cf	8d 4d b8	 lea	 ecx, DWORD PTR __Str$9[ebp]
  000d2	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 348  :             _Str += _Punct_fac.falsename();

  000d3	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1483 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  000d7	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 453  :         return _Myres > _Small_string_capacity;

  000dc	8b 4d b4	 mov	 ecx, DWORD PTR $T7[ebp+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 348  :             _Str += _Punct_fac.falsename();

  000df	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  000e3	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3083 :         if (_My_data._Large_mode_engaged()) {

  000e6	76 2c		 jbe	 SHORT $LN112@do_get
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e8	8b 55 a0	 mov	 edx, DWORD PTR $T7[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  000eb	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000ec	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000ee	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000f4	72 14		 jb	 SHORT $LN117@do_get

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f6	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000f9	83 c1 23	 add	 ecx, 35			; 00000023H
  000fc	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000fe	83 c0 fc	 add	 eax, -4			; fffffffcH
  00101	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00104	0f 87 d5 02 00
	00		 ja	 $LN292@do_get
$LN117@do_get:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0010a	51		 push	 ecx
  0010b	52		 push	 edx
  0010c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00111	83 c4 08	 add	 esp, 8
$LN112@do_get:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00114	8b 4d cc	 mov	 ecx, DWORD PTR __Str$9[ebp+20]
  00117	8b 7d c8	 mov	 edi, DWORD PTR __Str$9[ebp+16]

; 3090 :         _My_data._Mysize = 0;

  0011a	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T7[ebp+16], 0

; 3091 :         _My_data._Myres  = _Small_string_capacity;

  00121	c7 45 b4 0f 00
	00 00		 mov	 DWORD PTR $T7[ebp+20], 15 ; 0000000fH

; 3092 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00128	c6 45 a0 00	 mov	 BYTE PTR $T7[ebp], 0

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  0012c	89 4d 80	 mov	 DWORD PTR __Old_capacity$1$[ebp], ecx
  0012f	3b f9		 cmp	 edi, ecx

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

  00131	73 1b		 jae	 SHORT $LN124@do_get

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  00133	8d 47 01	 lea	 eax, DWORD PTR [edi+1]

; 453  :         return _Myres > _Small_string_capacity;

  00136	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  00139	89 45 c8	 mov	 DWORD PTR __Str$9[ebp+16], eax

; 435  :         value_type* _Result = _Bx._Buf;

  0013c	8d 45 b8	 lea	 eax, DWORD PTR __Str$9[ebp]

; 436  :         if (_Large_mode_engaged()) {

  0013f	0f 47 45 b8	 cmova	 eax, DWORD PTR __Str$9[ebp]

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

  00143	66 c7 04 38 00
	00		 mov	 WORD PTR [eax+edi], 0

; 2298 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());
; 2299 :             return;

  00149	e9 be 00 00 00	 jmp	 $LN136@do_get
$LN124@do_get:

; 3028 :         const size_type _Old_size = _My_data._Mysize;

  0014e	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH
  00153	8b c2		 mov	 eax, edx
  00155	2b c7		 sub	 eax, edi

; 3029 :         if (max_size() - _Old_size < _Size_increase) {

  00157	83 f8 01	 cmp	 eax, 1
  0015a	0f 82 8e 02 00
	00		 jb	 $LN293@do_get

; 3031 :         }
; 3032 : 
; 3033 :         const size_type _New_size     = _Old_size + _Size_increase;

  00160	8d 77 01	 lea	 esi, DWORD PTR [edi+1]

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

  00163	83 ce 0f	 or	 esi, 15			; 0000000fH
  00166	3b f2		 cmp	 esi, edx

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00168	76 04		 jbe	 SHORT $LN142@do_get

; 2980 :             return _Max;

  0016a	8b f2		 mov	 esi, edx
  0016c	eb 18		 jmp	 SHORT $LN141@do_get
$LN142@do_get:

; 2981 :         }
; 2982 : 
; 2983 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0016e	8b c1		 mov	 eax, ecx
  00170	d1 e8		 shr	 eax, 1
  00172	2b d0		 sub	 edx, eax
  00174	3b ca		 cmp	 ecx, edx
  00176	76 07		 jbe	 SHORT $LN143@do_get

; 2984 :             return _Max;

  00178	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  0017d	eb 07		 jmp	 SHORT $LN141@do_get
$LN143@do_get:

; 2985 :         }
; 2986 : 
; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0017f	03 c1		 add	 eax, ecx
  00181	3b f0		 cmp	 esi, eax
  00183	0f 42 f0	 cmovb	 esi, eax
$LN141@do_get:

; 825  :         ++_Capacity; // Take null terminator into consideration

  00186	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00189	50		 push	 eax
  0018a	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
  0018f	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3042 :         _My_data._Myres       = _New_capacity;

  00192	89 75 cc	 mov	 DWORD PTR __Str$9[ebp+20], esi

; 3044 :         if (_Old_capacity > _Small_string_capacity) {

  00195	83 7d 80 0f	 cmp	 DWORD PTR __Old_capacity$1$[ebp], 15 ; 0000000fH
  00199	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]

; 829  :             _Fancy_ptr = _Allocate_at_least_helper(_Al, _Capacity);

  0019c	89 45 94	 mov	 DWORD PTR __Fancy_ptr$1$[ebp], eax

; 3043 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  0019f	8d 34 07	 lea	 esi, DWORD PTR [edi+eax]
  001a2	89 4d c8	 mov	 DWORD PTR __Str$9[ebp+16], ecx
  001a5	89 75 88	 mov	 DWORD PTR tv1357[ebp], esi

; 3044 :         if (_Old_capacity > _Small_string_capacity) {

  001a8	57		 push	 edi
  001a9	76 46		 jbe	 SHORT $LN135@do_get

; 3045 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  001ab	8b 75 b8	 mov	 esi, DWORD PTR __Str$9[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  001ae	56		 push	 esi
  001af	50		 push	 eax
  001b0	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2307 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

  001b5	8b 45 88	 mov	 eax, DWORD PTR tv1357[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  001b8	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  001bb	8b 4d 80	 mov	 ecx, DWORD PTR __Old_capacity$1$[ebp]
  001be	41		 inc	 ecx

; 2307 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

  001bf	66 c7 00 00 00	 mov	 WORD PTR [eax], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  001c4	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  001ca	72 16		 jb	 SHORT $LN173@do_get

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001cc	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  001cf	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  001d2	2b f2		 sub	 esi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001d4	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  001d7	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001da	0f 87 22 02 00
	00		 ja	 $LN264@do_get

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  001e0	8b f2		 mov	 esi, edx
$LN173@do_get:

; 289  :         ::operator delete(_Ptr, _Bytes);

  001e2	51		 push	 ecx
  001e3	56		 push	 esi
  001e4	0f ae e8	 lfence
  001e7	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001ec	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3049 :         } else {

  001ef	eb 12		 jmp	 SHORT $LN289@do_get
$LN135@do_get:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  001f1	8d 4d b8	 lea	 ecx, DWORD PTR __Str$9[ebp]
  001f4	51		 push	 ecx
  001f5	50		 push	 eax
  001f6	e8 00 00 00 00	 call	 _memcpy
  001fb	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2307 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

  001fe	66 c7 06 00 00	 mov	 WORD PTR [esi], 0
$LN289@do_get:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 116  :         return do_truename();

  00203	8b 45 94	 mov	 eax, DWORD PTR __Fancy_ptr$1$[ebp]
  00206	8b 75 90	 mov	 esi, DWORD PTR __Val$GSCopy$1$[ebp]
  00209	89 45 b8	 mov	 DWORD PTR __Str$9[ebp], eax
$LN136@do_get:
  0020c	8b 4d 9c	 mov	 ecx, DWORD PTR __Punct_fac$1$[ebp]
  0020f	8d 55 a0	 lea	 edx, DWORD PTR $T8[ebp]
  00212	52		 push	 edx
  00213	8b 01		 mov	 eax, DWORD PTR [ecx]
  00215	ff 50 1c	 call	 DWORD PTR [eax+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00218	83 7d b4 0f	 cmp	 DWORD PTR $T8[ebp+20], 15 ; 0000000fH

; 444  :         const value_type* _Result = _Bx._Buf;

  0021c	8d 45 a0	 lea	 eax, DWORD PTR $T8[ebp]

; 1483 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0021f	ff 75 b0	 push	 DWORD PTR $T8[ebp+16]

; 445  :         if (_Large_mode_engaged()) {

  00222	0f 47 45 a0	 cmova	 eax, DWORD PTR $T8[ebp]

; 1483 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00226	8d 4d b8	 lea	 ecx, DWORD PTR __Str$9[ebp]
  00229	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 350  :             _Str += _Punct_fac.truename(); // construct "\0false\0true"

  0022a	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1483 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0022e	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 453  :         return _Myres > _Small_string_capacity;

  00233	8b 4d b4	 mov	 ecx, DWORD PTR $T8[ebp+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 350  :             _Str += _Punct_fac.truename(); // construct "\0false\0true"

  00236	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  0023a	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3083 :         if (_My_data._Large_mode_engaged()) {

  0023d	76 2c		 jbe	 SHORT $LN219@do_get
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0023f	8b 55 a0	 mov	 edx, DWORD PTR $T8[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00242	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00243	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00245	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0024b	72 14		 jb	 SHORT $LN224@do_get

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0024d	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00250	83 c1 23	 add	 ecx, 35			; 00000023H
  00253	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00255	83 c0 fc	 add	 eax, -4			; fffffffcH
  00258	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0025b	0f 87 92 01 00
	00		 ja	 $LN294@do_get
$LN224@do_get:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00261	51		 push	 ecx
  00262	52		 push	 edx
  00263	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00268	83 c4 08	 add	 esp, 8
$LN219@do_get:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  0026b	83 7d cc 0f	 cmp	 DWORD PTR __Str$9[ebp+20], 15 ; 0000000fH

; 444  :         const value_type* _Result = _Bx._Buf;

  0026f	8d 45 b8	 lea	 eax, DWORD PTR __Str$9[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 351  :             switch (_Getloctxt(_First, _Last, 2, _Str.c_str(), _Case_sensitive::_Yes)) {

  00272	6a 01		 push	 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

  00274	0f 47 45 b8	 cmova	 eax, DWORD PTR __Str$9[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 351  :             switch (_Getloctxt(_First, _Last, 2, _Str.c_str(), _Case_sensitive::_Yes)) {

  00278	50		 push	 eax
  00279	6a 02		 push	 2
  0027b	8d 45 14	 lea	 eax, DWORD PTR __Last$[ebp]
  0027e	50		 push	 eax
  0027f	8d 45 0c	 lea	 eax, DWORD PTR __First$[ebp]
  00282	50		 push	 eax
  00283	e8 00 00 00 00	 call	 ??$_Getloctxt@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@D@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBDW4_Case_sensitive@0@@Z ; std::_Getloctxt<std::istreambuf_iterator<char,std::char_traits<char> >,char>
  00288	8b 7d 98	 mov	 edi, DWORD PTR __State$GSCopy$1$[ebp]
  0028b	83 c4 14	 add	 esp, 20			; 00000014H
  0028e	83 e8 00	 sub	 eax, 0
  00291	74 15		 je	 SHORT $LN6@do_get
  00293	83 e8 01	 sub	 eax, 1
  00296	74 0b		 je	 SHORT $LN7@do_get

; 358  :             default:
; 359  :                 _Val   = false;

  00298	c6 06 00	 mov	 BYTE PTR [esi], 0

; 360  :                 _State = ios_base::failbit;

  0029b	c7 07 02 00 00
	00		 mov	 DWORD PTR [edi], 2
  002a1	eb 08		 jmp	 SHORT $LN2@do_get
$LN7@do_get:

; 354  :                 break;
; 355  :             case 1:
; 356  :                 _Val = true;

  002a3	c6 06 01	 mov	 BYTE PTR [esi], 1

; 357  :                 break;

  002a6	eb 03		 jmp	 SHORT $LN2@do_get
$LN6@do_get:

; 352  :             case 0:
; 353  :                 _Val = false;

  002a8	c6 06 00	 mov	 BYTE PTR [esi], 0
$LN2@do_get:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  002ab	8b 4d cc	 mov	 ecx, DWORD PTR __Str$9[ebp+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 363  :         } else { // get long value

  002ae	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  002b5	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3083 :         if (_My_data._Large_mode_engaged()) {

  002b8	0f 86 dc 00 00
	00		 jbe	 $LN14@do_get
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002be	8b 55 b8	 mov	 edx, DWORD PTR __Str$9[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  002c1	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002c2	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  002c4	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  002ca	72 14		 jb	 SHORT $LN265@do_get

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  002cc	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  002cf	83 c1 23	 add	 ecx, 35			; 00000023H
  002d2	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  002d4	83 c0 fc	 add	 eax, -4			; fffffffcH
  002d7	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  002da	0f 87 22 01 00
	00		 ja	 $LN264@do_get
$LN265@do_get:

; 289  :         ::operator delete(_Ptr, _Bytes);

  002e0	51		 push	 ecx
  002e1	52		 push	 edx
  002e2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  002e7	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 363  :         } else { // get long value

  002ea	e9 ab 00 00 00	 jmp	 $LN14@do_get
$LN4@do_get:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  002ef	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  002f2	89 4d 90	 mov	 DWORD PTR $T4[ebp+4], ecx

; 269  :         _Ptr->_Incref();

  002f5	8b 01		 mov	 eax, DWORD PTR [ecx]
  002f7	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 366  :                 _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field

  002fa	8d 45 8c	 lea	 eax, DWORD PTR $T4[ebp]
  002fd	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
  00304	50		 push	 eax
  00305	8b 45 88	 mov	 eax, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00308	ff 70 14	 push	 DWORD PTR [eax+20]
  0030b	8d 45 14	 lea	 eax, DWORD PTR __Last$[ebp]
  0030e	50		 push	 eax
  0030f	8d 45 0c	 lea	 eax, DWORD PTR __First$[ebp]
  00312	50		 push	 eax
  00313	8d 45 d0	 lea	 eax, DWORD PTR __Ac$10[ebp]
  00316	50		 push	 eax
  00317	e8 00 00 00 00	 call	 ??$_Parse_int_with_locale@$0A@@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CA?AU_Num_get_parse_result@1@QADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@1HABVlocale@1@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Parse_int_with_locale<0>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  0031c	8b 4d 90	 mov	 ecx, DWORD PTR $T4[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 366  :                 _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field

  0031f	83 c4 14	 add	 esp, 20			; 00000014H
  00322	66 89 45 9c	 mov	 WORD PTR __Parse_result$6[ebp], ax
  00326	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  0032d	85 c9		 test	 ecx, ecx
  0032f	74 17		 je	 SHORT $LN282@do_get

; 355  :             delete _Ptr->_Decref();

  00331	8b 01		 mov	 eax, DWORD PTR [ecx]
  00333	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00336	ff d0		 call	 eax
  00338	8b c8		 mov	 ecx, eax
  0033a	85 c9		 test	 ecx, ecx
  0033c	74 06		 je	 SHORT $LN285@do_get
  0033e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00340	6a 01		 push	 1
  00342	ff 10		 call	 DWORD PTR [eax]
$LN285@do_get:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 367  :             if (_Parse_result._Base < 0) {

  00344	66 8b 45 9c	 mov	 ax, WORD PTR __Parse_result$6[ebp]
$LN282@do_get:
  00348	84 c0		 test	 al, al
  0034a	79 05		 jns	 SHORT $LN9@do_get

; 368  :                 // N4950 [facet.num.get.virtuals]/3.9:
; 369  :                 //  "zero, if the conversion function does not convert the entire field."
; 370  :                 _Val   = false;

  0034c	c6 06 00	 mov	 BYTE PTR [esi], 0

; 371  :                 _State = ios_base::failbit;
; 372  :             } else {

  0034f	eb 43		 jmp	 SHORT $LN290@do_get
$LN9@do_get:

; 373  :                 char* _Ep;
; 374  :                 int _Errno;
; 375  :                 const long _Ans = _CSTD _Stolx(_Ac, &_Ep, _Parse_result._Base, &_Errno); // convert

  00351	8d 4d 90	 lea	 ecx, DWORD PTR __Errno$5[ebp]
  00354	0f be c0	 movsx	 eax, al
  00357	51		 push	 ecx
  00358	50		 push	 eax
  00359	8d 45 88	 lea	 eax, DWORD PTR __Ep$3[ebp]
  0035c	50		 push	 eax
  0035d	8d 45 d0	 lea	 eax, DWORD PTR __Ac$10[ebp]
  00360	50		 push	 eax
  00361	e8 00 00 00 00	 call	 __Stolx
  00366	8b c8		 mov	 ecx, eax
  00368	83 c4 10	 add	 esp, 16			; 00000010H

; 376  :                 if (_Ep == _Ac || _Errno != 0 // N4950 [facet.num.get.virtuals]/3
; 377  :                     || _Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4

  0036b	8d 45 d0	 lea	 eax, DWORD PTR __Ac$10[ebp]
  0036e	39 45 88	 cmp	 DWORD PTR __Ep$3[ebp], eax
  00371	74 1e		 je	 SHORT $LN13@do_get
  00373	83 7d 90 00	 cmp	 DWORD PTR __Errno$5[ebp], 0
  00377	75 18		 jne	 SHORT $LN13@do_get
  00379	80 7d 9d 00	 cmp	 BYTE PTR __Parse_result$6[ebp+1], 0
  0037d	75 12		 jne	 SHORT $LN13@do_get

; 379  :                     _State = ios_base::failbit;
; 380  :                 } else {
; 381  :                     _Val = _Ans != 0;

  0037f	85 c9		 test	 ecx, ecx
  00381	0f 95 c0	 setne	 al
  00384	88 06		 mov	 BYTE PTR [esi], al

; 382  :                     if (_Ans != 0 && _Ans != 1) {

  00386	85 c9		 test	 ecx, ecx
  00388	74 10		 je	 SHORT $LN14@do_get
  0038a	83 f9 01	 cmp	 ecx, 1
  0038d	74 0b		 je	 SHORT $LN14@do_get

; 383  :                         _State = ios_base::failbit;

  0038f	eb 03		 jmp	 SHORT $LN290@do_get
$LN13@do_get:

; 378  :                     _Val   = true;

  00391	c6 06 01	 mov	 BYTE PTR [esi], 1
$LN290@do_get:

; 384  :                     }
; 385  :                 }
; 386  :             }
; 387  :         }
; 388  : 
; 389  :         if (_First == _Last) {

  00394	c7 07 02 00 00
	00		 mov	 DWORD PTR [edi], 2
$LN14@do_get:
  0039a	8d 45 14	 lea	 eax, DWORD PTR __Last$[ebp]
  0039d	50		 push	 eax
  0039e	8d 45 0c	 lea	 eax, DWORD PTR __First$[ebp]
  003a1	50		 push	 eax
  003a2	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
  003a7	83 c4 08	 add	 esp, 8
  003aa	84 c0		 test	 al, al
  003ac	74 03		 je	 SHORT $LN15@do_get

; 390  :             _State |= ios_base::eofbit;

  003ae	83 0f 01	 or	 DWORD PTR [edi], 1
$LN15@do_get:

; 391  :         }
; 392  : 
; 393  :         return _First;

  003b1	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  003b7	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  003ba	8b 55 10	 mov	 edx, DWORD PTR __First$[ebp+4]
  003bd	89 08		 mov	 DWORD PTR [eax], ecx
  003bf	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 394  :     }

  003c2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003c5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003cc	59		 pop	 ecx
  003cd	5f		 pop	 edi
  003ce	5e		 pop	 esi
  003cf	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003d2	33 cd		 xor	 ecx, ebp
  003d4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003d9	8b e5		 mov	 esp, ebp
  003db	5d		 pop	 ebp
  003dc	c2 20 00	 ret	 32			; 00000020H
$LN292@do_get:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003df	6a 00		 push	 0
  003e1	6a 00		 push	 0
  003e3	6a 00		 push	 0
  003e5	6a 00		 push	 0
  003e7	6a 00		 push	 0
  003e9	e8 00 00 00 00	 call	 __invoke_watson
$LN293@do_get:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3030 :             _Xlen_string(); // result too long

  003ee	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN294@do_get:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003f3	6a 00		 push	 0
  003f5	6a 00		 push	 0
  003f7	6a 00		 push	 0
  003f9	6a 00		 push	 0
  003fb	6a 00		 push	 0
  003fd	e8 00 00 00 00	 call	 __invoke_watson
$LN264@do_get:
  00402	6a 00		 push	 0
  00404	6a 00		 push	 0
  00406	6a 00		 push	 0
  00408	6a 00		 push	 0
  0040a	6a 00		 push	 0
  0040c	e8 00 00 00 00	 call	 __invoke_watson
$LN288@do_get:
  00411	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$0:
  00000	8d 4d 84	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$1:
  00008	8d 4d b8	 lea	 ecx, DWORD PTR __Str$9[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$2:
  00010	8d 4d a0	 lea	 ecx, DWORD PTR $T7[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$3:
  00018	8d 4d a0	 lea	 ecx, DWORD PTR $T8[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$4:
  00020	8d 4d 8c	 lea	 ecx, DWORD PTR $T4[ebp]
  00023	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00028	cc		 int	 3
  00029	cc		 int	 3
  0002a	cc		 int	 3
  0002b	cc		 int	 3
  0002c	cc		 int	 3
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z:
  0002d	90		 npad	 1
  0002e	90		 npad	 1
  0002f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00033	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00036	8b 8a 7c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-132]
  0003c	33 c8		 xor	 ecx, eax
  0003e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00043	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00046	33 c8		 xor	 ecx, eax
  00048	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
  00052	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT
??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::~num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 268  :     __CLR_OR_THIS_CALL ~num_get() noexcept override {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
  00006	c3		 ret	 0
??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::~num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -76						; size = 52
__Lock$3 = -24						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
__Psave$1$ = -20					; size = 4
__Lock$6 = -16						; size = 4
$T7 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
__Psave_guard$8 = 8					; size = 4
??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >, COMDAT

; 435  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	33 db		 xor	 ebx, ebx

; 436  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

  0002a	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0002d	53		 push	 ebx
  0002e	89 5d e8	 mov	 DWORD PTR $T4[ebp], ebx
  00031	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 91   :             if (_Id == 0) { // still zero, allocate stamp

  00036	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id

; 437  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

  0003c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >::_Psave
  00041	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00044	89 45 ec	 mov	 DWORD PTR __Psave$1$[ebp], eax

; 91   :             if (_Id == 0) { // still zero, allocate stamp

  00047	85 ff		 test	 edi, edi
  00049	75 2f		 jne	 SHORT $LN11@use_facet

; 92   :                 _BEGIN_LOCK(_LOCK_LOCALE)

  0004b	57		 push	 edi
  0004c	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$6[ebp]
  0004f	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 93   :                 if (_Id == 0) {

  00054	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, edi ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
  0005a	75 10		 jne	 SHORT $LN12@use_facet

; 94   :                     _Id = static_cast<size_t>(++_Id_cnt);

  0005c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00061	40		 inc	 eax
  00062	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00067	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, eax ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
$LN12@use_facet:

; 95   :                 }
; 96   :                 _END_LOCK()

  0006c	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$6[ebp]
  0006f	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00074	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
$LN11@use_facet:

; 377  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  0007a	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  0007d	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
  00084	89 4d f0	 mov	 DWORD PTR $T7[ebp], ecx
  00087	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008a	3b 7a 0c	 cmp	 edi, DWORD PTR [edx+12]
  0008d	73 16		 jae	 SHORT $LN19@use_facet
  0008f	0f ae e8	 lfence
  00092	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00095	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00098	8b 34 01	 mov	 esi, DWORD PTR [ecx+eax]

; 378  :         if (_Facptr || !_Ptr->_Xparent) {

  0009b	85 f6		 test	 esi, esi
  0009d	0f 85 b1 00 00
	00		 jne	 $LN68@use_facet
  000a3	eb 05		 jmp	 SHORT $LN72@use_facet
$LN19@use_facet:

; 374  :     }
; 375  : 
; 376  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object
; 377  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  000a5	33 f6		 xor	 esi, esi
  000a7	89 4d f0	 mov	 DWORD PTR $T7[ebp], ecx
$LN72@use_facet:

; 378  :         if (_Facptr || !_Ptr->_Xparent) {

  000aa	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0
  000ae	74 16		 je	 SHORT $LN14@use_facet

; 379  :             return _Facptr; // found facet or not transparent
; 380  :         }
; 381  : 
; 382  :         // look in current locale
; 383  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

  000b0	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 384  :         if (_Id < _Ptr0->_Facetcount) {

  000b5	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  000b8	73 14		 jae	 SHORT $LN73@use_facet

; 385  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

  000ba	0f ae e8	 lfence
  000bd	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c0	8b 75 f0	 mov	 esi, DWORD PTR $T7[ebp]
  000c3	8b 34 06	 mov	 esi, DWORD PTR [esi+eax]
$LN14@use_facet:

; 438  : 
; 439  :     const size_t _Id         = _Facet::id._Get_index();
; 440  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);
; 441  : 
; 442  :     if (!_Pf) {

  000c6	85 f6		 test	 esi, esi
  000c8	0f 85 86 00 00
	00		 jne	 $LN68@use_facet
$LN73@use_facet:

; 443  :         if (_Psave) {

  000ce	8b 45 ec	 mov	 eax, DWORD PTR __Psave$1$[ebp]
  000d1	85 c0		 test	 eax, eax
  000d3	74 04		 je	 SHORT $LN3@use_facet

; 444  :             _Pf = _Psave; // lazy facet already allocated

  000d5	8b f0		 mov	 esi, eax

; 445  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

  000d7	eb 7b		 jmp	 SHORT $LN68@use_facet
$LN3@use_facet:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 259  :             *_Ppf = new num_get<_Elem, _InIt>(_Locinfo(_Ploc->_C_str()));

  000d9	6a 08		 push	 8
  000db	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000e0	8b f0		 mov	 esi, eax
  000e2	83 c4 04	 add	 esp, 4
  000e5	89 75 ec	 mov	 DWORD PTR $T5[ebp], esi
  000e8	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000ec	85 f6		 test	 esi, esi
  000ee	74 38		 je	 SHORT $LN24@use_facet
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 373  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  000f0	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  000f3	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000f6	85 c9		 test	 ecx, ecx
  000f8	74 0c		 je	 SHORT $LN32@use_facet
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo

; 190  :         return _Myptr ? _Myptr : &_Nul;

  000fa	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  000fd	85 c0		 test	 eax, eax
  000ff	75 0a		 jne	 SHORT $LN33@use_facet
  00101	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 373  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  00104	eb 05		 jmp	 SHORT $LN33@use_facet
$LN32@use_facet:
  00106	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@@
$LN33@use_facet:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 259  :             *_Ppf = new num_get<_Elem, _InIt>(_Locinfo(_Ploc->_C_str()));

  0010b	50		 push	 eax
  0010c	8d 4d b4	 lea	 ecx, DWORD PTR $T2[ebp]
  0010f	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00114	bb 01 00 00 00	 mov	 ebx, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 143  :             : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs)) // non-atomic initialization

  00119	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 279  :     __CLR_OR_THIS_CALL num_get(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs) {

  00120	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@

; 259  :             *_Ppf = new num_get<_Elem, _InIt>(_Locinfo(_Ploc->_C_str()));

  00126	eb 02		 jmp	 SHORT $LN25@use_facet
$LN24@use_facet:
  00128	33 f6		 xor	 esi, esi
$LN25@use_facet:
  0012a	f6 c3 01	 test	 bl, 1
  0012d	74 08		 je	 SHORT $LN29@use_facet
  0012f	8d 4d b4	 lea	 ecx, DWORD PTR $T2[ebp]
  00132	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN29@use_facet:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00137	89 75 08	 mov	 DWORD PTR __Psave_guard$8[ebp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 458  :             _Facet_Register(_Pfmod);

  0013a	56		 push	 esi
  0013b	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0013f	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register

; 459  : #endif // ^^^ !defined(_M_CEE) ^^^
; 460  : 
; 461  :             _Pfmod->_Incref();

  00144	8b 16		 mov	 edx, DWORD PTR [esi]
  00146	83 c4 04	 add	 esp, 4
  00149	8b ce		 mov	 ecx, esi
  0014b	ff 52 04	 call	 DWORD PTR [edx+4]

; 462  :             _Facetptr<_Facet>::_Psave = _Psave;

  0014e	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >::_Psave
$LN68@use_facet:

; 463  :             _Pf                       = _Psave;
; 464  : 
; 465  :             (void) _Psave_guard.release();
; 466  :         }
; 467  :     }
; 468  : 
; 469  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

  00154	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00157	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0015c	8b c6		 mov	 eax, esi

; 470  :     _END_LOCK()
; 471  : } // end of use_facet body

  0015e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00161	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00168	59		 pop	 ecx
  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	5b		 pop	 ebx
  0016c	8b e5		 mov	 esp, ebp
  0016e	5d		 pop	 ebp
  0016f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$2:
  00008	6a 08		 push	 8
  0000a	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00013	83 c4 08	 add	 esp, 8
  00016	c3		 ret	 0
__unwindfunclet$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$1:
  00017	8d 4d 08	 lea	 ecx, DWORD PTR __Psave_guard$8[ebp]
  0001a	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
  0001f	cc		 int	 3
  00020	cc		 int	 3
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
__ehhandler$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z:
  00024	90		 npad	 1
  00025	90		 npad	 1
  00026	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002d	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  00030	33 c8		 xor	 ecx, eax
  00032	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00037	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
  0003c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Search_vectorized@$$CB_W$$CB_W@std@@YAPB_WQB_W00I@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count2$ = 20						; size = 4
??$_Search_vectorized@$$CB_W$$CB_W@std@@YAPB_WQB_W00I@Z PROC ; std::_Search_vectorized<wchar_t const ,wchar_t const >, COMDAT

; 247  : _Ty1* _Search_vectorized(_Ty1* const _First1, _Ty1* const _Last1, _Ty2* const _First2, const size_t _Count2) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 248  :     _STL_INTERNAL_STATIC_ASSERT(sizeof(_Ty1) == sizeof(_Ty2));
; 249  :     if constexpr (sizeof(_Ty1) == 1) {
; 250  :         return const_cast<_Ty1*>(static_cast<const _Ty1*>(::__std_search_1(_First1, _Last1, _First2, _Count2)));
; 251  :     } else if constexpr (sizeof(_Ty1) == 2) {
; 252  :         return const_cast<_Ty1*>(static_cast<const _Ty1*>(::__std_search_2(_First1, _Last1, _First2, _Count2)));

  00003	ff 75 14	 push	 DWORD PTR __Count2$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __First2$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Last1$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __First1$[ebp]
  0000f	e8 00 00 00 00	 call	 ___std_search_2@16

; 253  :     } else {
; 254  :         _STL_INTERNAL_STATIC_ASSERT(false); // unexpected size
; 255  :     }
; 256  : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??$_Search_vectorized@$$CB_W$$CB_W@std@@YAPB_WQB_W00I@Z ENDP ; std::_Search_vectorized<wchar_t const ,wchar_t const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tidy_guard@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_Tidy_guard<std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::~_Tidy_guard<std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >, COMDAT
; _this$ = ecx

; 87   :         if (_Target) {

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	85 c9		 test	 ecx, ecx
  00004	0f 85 00 00 00
	00		 jne	 ?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Tidy

; 88   :             _Target->_Tidy();
; 89   :         }
; 90   :     }

  0000a	c3		 ret	 0
??1?$_Tidy_guard@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_guard<std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::~_Tidy_guard<std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z
_TEXT	SEGMENT
__Guard$ = -52						; size = 20
tv563 = -32						; size = 4
tv559 = -28						; size = 4
__Oldsize$1$ = -24					; size = 4
__Newvec$1$ = -20					; size = 4
__Whereoff$1$ = -16					; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &>, COMDAT
; _this$ = ecx

; 875  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx

; 876  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 877  :         _Alty& _Al        = _Getal();
; 878  :         auto& _My_data    = _Mypair._Myval2;
; 879  :         pointer& _Myfirst = _My_data._Myfirst;
; 880  :         pointer& _Mylast  = _My_data._Mylast;
; 881  : 
; 882  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 883  : 
; 884  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  0002a	8b 37		 mov	 esi, DWORD PTR [edi]
  0002c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00031	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]

; 885  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00034	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00037	2b d6		 sub	 edx, esi
  00039	f7 ea		 imul	 edx
  0003b	2b ce		 sub	 ecx, esi
  0003d	c1 fa 02	 sar	 edx, 2
  00040	8b c2		 mov	 eax, edx
  00042	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00045	03 c2		 add	 eax, edx
  00047	89 45 f0	 mov	 DWORD PTR __Whereoff$1$[ebp], eax
  0004a	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0004f	f7 e9		 imul	 ecx
  00051	c1 fa 02	 sar	 edx, 2
  00054	8b c2		 mov	 eax, edx
  00056	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00059	03 c2		 add	 eax, edx
  0005b	89 45 e8	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 886  : 
; 887  :         if (_Oldsize == max_size()) {

  0005e	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  00063	0f 84 60 01 00
	00		 je	 $LN107@Emplace_re

; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00069	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]

; 889  :         }
; 890  : 
; 891  :         const size_type _Newsize = _Oldsize + 1;

  0006c	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]

; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0006f	2b ce		 sub	 ecx, esi
  00071	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00076	f7 e9		 imul	 ecx

; 2011 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00078	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0007d	c1 fa 02	 sar	 edx, 2
  00080	8b ca		 mov	 ecx, edx
  00082	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00085	03 ca		 add	 ecx, edx

; 2011 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00087	8b d1		 mov	 edx, ecx
  00089	d1 ea		 shr	 edx, 1
  0008b	2b c2		 sub	 eax, edx
  0008d	3b c8		 cmp	 ecx, eax
  0008f	76 60		 jbe	 SHORT $LN8@Emplace_re

; 2012 :             return _Max; // geometric growth would overflow

  00091	be aa aa aa 0a	 mov	 esi, 178956970		; 0aaaaaaaH
$LN19@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 122  :     return _Count * _Ty_size;

  00096	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  00099	c1 e0 03	 shl	 eax, 3

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0009c	50		 push	 eax

; 122  :     return _Count * _Ty_size;

  0009d	0f ae e8	 lfence
  000a0	89 45 e4	 mov	 DWORD PTR tv559[ebp], eax

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000a3	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 894  :         const pointer _Newvec           = _STD _Allocate_at_least_helper(_Al, _Newcapacity);

  000a8	8b d8		 mov	 ebx, eax

; 897  :         _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};

  000aa	89 7d cc	 mov	 DWORD PTR __Guard$[ebp], edi
  000ad	8b 45 f0	 mov	 eax, DWORD PTR __Whereoff$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000b0	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 894  :         const pointer _Newvec           = _STD _Allocate_at_least_helper(_Al, _Newcapacity);

  000b3	89 5d ec	 mov	 DWORD PTR __Newvec$1$[ebp], ebx

; 897  :         _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};

  000b6	89 5d d0	 mov	 DWORD PTR __Guard$[ebp+4], ebx
  000b9	89 75 d4	 mov	 DWORD PTR __Guard$[ebp+8], esi
  000bc	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  000bf	8d 0c c3	 lea	 ecx, DWORD PTR [ebx+eax*8]
  000c2	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  000c5	89 4d e0	 mov	 DWORD PTR tv563[ebp], ecx
  000c8	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  000cb	89 45 d8	 mov	 DWORD PTR __Guard$[ebp+12], eax
  000ce	89 45 dc	 mov	 DWORD PTR __Guard$[ebp+16], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  000d1	ff 75 0c	 push	 DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 897  :         _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};

  000d4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  000db	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 903  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000e0	8b 75 08	 mov	 esi, DWORD PTR __Whereptr$[ebp]
  000e3	3b 77 04	 cmp	 esi, DWORD PTR [edi+4]
  000e6	0f ae e8	 lfence
  000e9	75 1e		 jne	 SHORT $LN3@Emplace_re

; 904  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 905  :                 _STD _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

  000eb	8b 37		 mov	 esi, DWORD PTR [edi]
  000ed	8b c3		 mov	 eax, ebx

; 906  :             } else {
; 907  :                 _STD _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 908  :             }
; 909  :         } else { // provide basic guarantee

  000ef	eb 28		 jmp	 SHORT $LN4@Emplace_re
$LN8@Emplace_re:

; 2015 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  000f1	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  000f4	8b f3		 mov	 esi, ebx
  000f6	3b c3		 cmp	 eax, ebx
  000f8	0f 43 f0	 cmovae	 esi, eax
  000fb	81 fe aa aa aa
	0a		 cmp	 esi, 178956970		; 0aaaaaaaH
  00101	0f 87 c7 00 00
	00		 ja	 $LN108@Emplace_re
  00107	eb 8d		 jmp	 SHORT $LN19@Emplace_re
$LN3@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 910  :             _STD _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

  00109	57		 push	 edi
  0010a	53		 push	 ebx
  0010b	56		 push	 esi
  0010c	ff 37		 push	 DWORD PTR [edi]
  0010e	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
  00113	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00116	83 c4 10	 add	 esp, 16			; 00000010H
$LN4@Emplace_re:

; 911  :             _Constructed_first = _Newvec;
; 912  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);
; 913  :         }
; 914  : 
; 915  :         _Guard._New_begin = nullptr;

  00119	57		 push	 edi
  0011a	50		 push	 eax
  0011b	ff 77 04	 push	 DWORD PTR [edi+4]
  0011e	56		 push	 esi
  0011f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >

; 2069 :         if (_Myfirst) { // destroy and deallocate old array

  00124	8b 37		 mov	 esi, DWORD PTR [edi]

; 911  :             _Constructed_first = _Newvec;
; 912  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);
; 913  :         }
; 914  : 
; 915  :         _Guard._New_begin = nullptr;

  00126	83 c4 10	 add	 esp, 16			; 00000010H

; 2069 :         if (_Myfirst) { // destroy and deallocate old array

  00129	85 f6		 test	 esi, esi
  0012b	74 5a		 je	 SHORT $LN52@Emplace_re

; 2070 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

  0012d	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1102 :         for (; _First != _Last; ++_First) {

  00130	3b f3		 cmp	 esi, ebx
  00132	74 0e		 je	 SHORT $LN32@Emplace_re
$LL33@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1383 :         _Tidy_deallocate();

  00134	8b ce		 mov	 ecx, esi
  00136	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1102 :         for (; _First != _Last; ++_First) {

  0013b	83 c6 18	 add	 esi, 24			; 00000018H
  0013e	3b f3		 cmp	 esi, ebx
  00140	75 f2		 jne	 SHORT $LL33@Emplace_re
$LN32@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2072 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00142	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00145	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0014a	8b 37		 mov	 esi, DWORD PTR [edi]
  0014c	2b ce		 sub	 ecx, esi
  0014e	f7 e9		 imul	 ecx
  00150	c1 fa 02	 sar	 edx, 2
  00153	8b c2		 mov	 eax, edx
  00155	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00158	03 c2		 add	 eax, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0015a	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  0015d	c1 e1 03	 shl	 ecx, 3

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00160	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00166	72 12		 jb	 SHORT $LN57@Emplace_re

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00168	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  0016b	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0016e	2b f2		 sub	 esi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00170	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  00173	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00176	77 42		 ja	 SHORT $LN56@Emplace_re

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00178	8b f2		 mov	 esi, edx
$LN57@Emplace_re:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0017a	51		 push	 ecx
  0017b	56		 push	 esi
  0017c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00181	8b 5d ec	 mov	 ebx, DWORD PTR __Newvec$1$[ebp]
  00184	83 c4 08	 add	 esp, 8
$LN52@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2076 :         _Mylast  = _Newvec + _Newsize;

  00187	8b 4d e8	 mov	 ecx, DWORD PTR __Oldsize$1$[ebp]

; 916  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 917  :         return _Newvec + _Whereoff;

  0018a	8b 45 e0	 mov	 eax, DWORD PTR tv563[ebp]

; 2075 :         _Myfirst = _Newvec;

  0018d	89 1f		 mov	 DWORD PTR [edi], ebx

; 2076 :         _Mylast  = _Newvec + _Newsize;

  0018f	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  00192	8d 49 03	 lea	 ecx, DWORD PTR [ecx+3]
  00195	8d 0c cb	 lea	 ecx, DWORD PTR [ebx+ecx*8]
  00198	89 4f 04	 mov	 DWORD PTR [edi+4], ecx

; 2077 :         _Myend   = _Newvec + _Newcapacity;

  0019b	8b 4d e4	 mov	 ecx, DWORD PTR tv559[ebp]
  0019e	03 cb		 add	 ecx, ebx
  001a0	89 4f 08	 mov	 DWORD PTR [edi+8], ecx

; 916  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 917  :         return _Newvec + _Whereoff;

  001a3	0f ae e8	 lfence

; 918  :     }

  001a6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001a9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001b0	59		 pop	 ecx
  001b1	5f		 pop	 edi
  001b2	5e		 pop	 esi
  001b3	5b		 pop	 ebx
  001b4	8b e5		 mov	 esp, ebp
  001b6	5d		 pop	 ebp
  001b7	c2 08 00	 ret	 8
$LN56@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001ba	6a 00		 push	 0
  001bc	6a 00		 push	 0
  001be	6a 00		 push	 0
  001c0	6a 00		 push	 0
  001c2	6a 00		 push	 0
  001c4	e8 00 00 00 00	 call	 __invoke_watson
$LN107@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 888  :             _Xlength();

  001c9	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Xlength
$LN108@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  001ce	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN105@Emplace_re:
  001d3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z$0:
  00000	8d 4d cc	 lea	 ecx, DWORD PTR __Guard$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Reallocation_guard@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Reallocation_guard::~_Reallocation_guard
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &>
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@AAEPAKQAKABK@Z
_TEXT	SEGMENT
tv747 = -12						; size = 4
__Newsize$1$ = -8					; size = 4
tv752 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@AAEPAKQAKABK@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_reallocate<unsigned long const &>, COMDAT
; _this$ = ecx

; 875  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 876  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 877  :         _Alty& _Al        = _Getal();
; 878  :         auto& _My_data    = _Mypair._Myval2;
; 879  :         pointer& _Myfirst = _My_data._Myfirst;
; 880  :         pointer& _Mylast  = _My_data._Mylast;
; 881  : 
; 882  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 883  : 
; 884  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00010	2b d9		 sub	 ebx, ecx

; 885  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00012	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00015	2b c1		 sub	 eax, ecx
  00017	c1 fb 02	 sar	 ebx, 2
  0001a	c1 f8 02	 sar	 eax, 2

; 886  : 
; 887  :         if (_Oldsize == max_size()) {

  0001d	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00022	0f 84 01 01 00
	00		 je	 $LN114@Emplace_re

; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 889  :         }
; 890  : 
; 891  :         const size_type _Newsize = _Oldsize + 1;

  0002b	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002e	2b d1		 sub	 edx, ecx

; 889  :         }
; 890  : 
; 891  :         const size_type _Newsize = _Oldsize + 1;

  00030	89 7d f8	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00033	c1 fa 02	 sar	 edx, 2

; 2011 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00036	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003b	8b ca		 mov	 ecx, edx
  0003d	d1 e9		 shr	 ecx, 1
  0003f	2b c1		 sub	 eax, ecx
  00041	3b d0		 cmp	 edx, eax
  00043	76 48		 jbe	 SHORT $LN8@Emplace_re

; 2012 :             return _Max; // geometric growth would overflow

  00045	b9 ff ff ff 3f	 mov	 ecx, 1073741823		; 3fffffffH
$LN19@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 122  :     return _Count * _Ty_size;

  0004a	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00051	50		 push	 eax

; 122  :     return _Count * _Ty_size;

  00052	0f ae e8	 lfence
  00055	89 45 f4	 mov	 DWORD PTR tv747[ebp], eax

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00058	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 900  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0005d	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Val_0>$[ebp]
  00060	8b f8		 mov	 edi, eax
  00062	8d 04 9f	 lea	 eax, DWORD PTR [edi+ebx*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00065	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 903  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00068	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  0006b	89 45 fc	 mov	 DWORD PTR tv752[ebp], eax
  0006e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00070	89 08		 mov	 DWORD PTR [eax], ecx
  00072	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00075	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00077	3b d8		 cmp	 ebx, eax
  00079	75 2a		 jne	 SHORT $LN3@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 4769 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);

  0007b	2b c1		 sub	 eax, ecx

; 4751 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  0007d	50		 push	 eax
  0007e	51		 push	 ecx
  0007f	57		 push	 edi
  00080	e8 00 00 00 00	 call	 _memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 909  :         } else { // provide basic guarantee

  00085	8b 5d fc	 mov	 ebx, DWORD PTR tv752[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 4751 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00088	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 909  :         } else { // provide basic guarantee

  0008b	eb 3a		 jmp	 SHORT $LN54@Emplace_re
$LN8@Emplace_re:

; 2015 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0008d	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  00090	8b cf		 mov	 ecx, edi
  00092	3b c7		 cmp	 eax, edi
  00094	0f 43 c8	 cmovae	 ecx, eax
  00097	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  0009d	0f 87 8b 00 00
	00		 ja	 $LN115@Emplace_re
  000a3	eb a5		 jmp	 SHORT $LN19@Emplace_re
$LN3@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 4769 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);

  000a5	8b c3		 mov	 eax, ebx
  000a7	2b c1		 sub	 eax, ecx

; 4751 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  000a9	50		 push	 eax
  000aa	51		 push	 ecx
  000ab	57		 push	 edi
  000ac	e8 00 00 00 00	 call	 _memmove

; 4769 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);

  000b1	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000b4	2b c3		 sub	 eax, ebx

; 4751 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  000b6	50		 push	 eax
  000b7	53		 push	 ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 912  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000b8	8b 5d fc	 mov	 ebx, DWORD PTR tv752[ebp]
  000bb	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 4751 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 _memmove
  000c4	83 c4 18	 add	 esp, 24			; 00000018H
$LN54@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2069 :         if (_Myfirst) { // destroy and deallocate old array

  000c7	8b 06		 mov	 eax, DWORD PTR [esi]
  000c9	85 c0		 test	 eax, eax
  000cb	74 2c		 je	 SHORT $LN78@Emplace_re

; 2070 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2071 :             _ASAN_VECTOR_REMOVE;
; 2072 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000cd	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000d0	2b c8		 sub	 ecx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000d2	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000d5	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000db	72 12		 jb	 SHORT $LN83@Emplace_re

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000dd	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000e0	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000e3	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000e5	83 c0 fc	 add	 eax, -4			; fffffffcH
  000e8	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000eb	77 2d		 ja	 SHORT $LN82@Emplace_re

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000ed	8b c2		 mov	 eax, edx
$LN83@Emplace_re:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000ef	51		 push	 ecx
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000f6	83 c4 08	 add	 esp, 8
$LN78@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2076 :         _Mylast  = _Newvec + _Newsize;

  000f9	8b 45 f8	 mov	 eax, DWORD PTR __Newsize$1$[ebp]
  000fc	89 3e		 mov	 DWORD PTR [esi], edi
  000fe	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]

; 913  :         }
; 914  : 
; 915  :         _Guard._New_begin = nullptr;
; 916  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 917  :         return _Newvec + _Whereoff;

  00101	8b c3		 mov	 eax, ebx

; 2076 :         _Mylast  = _Newvec + _Newsize;

  00103	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 2077 :         _Myend   = _Newvec + _Newcapacity;

  00106	8b 4d f4	 mov	 ecx, DWORD PTR tv747[ebp]
  00109	03 cf		 add	 ecx, edi

; 918  :     }

  0010b	5f		 pop	 edi

; 2077 :         _Myend   = _Newvec + _Newcapacity;

  0010c	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 918  :     }

  0010f	5e		 pop	 esi
  00110	0f ae e8	 lfence
  00113	5b		 pop	 ebx
  00114	8b e5		 mov	 esp, ebp
  00116	5d		 pop	 ebp
  00117	c2 08 00	 ret	 8
$LN82@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0011a	6a 00		 push	 0
  0011c	6a 00		 push	 0
  0011e	6a 00		 push	 0
  00120	6a 00		 push	 0
  00122	6a 00		 push	 0
  00124	e8 00 00 00 00	 call	 __invoke_watson
$LN114@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 888  :             _Xlength();

  00129	e8 00 00 00 00	 call	 ?_Xlength@?$vector@KV?$allocator@K@std@@@std@@CAXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlength
$LN115@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  0012e	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN112@Emplace_re:
  00133	cc		 int	 3
??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@AAEPAKQAKABK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_reallocate<unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
;	COMDAT ??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z PROC ; std::operator!=<char,std::char_traits<char> >, COMDAT

; 494  :     const istreambuf_iterator<_Elem, _Traits>& _Left, const istreambuf_iterator<_Elem, _Traits>& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 495  :     return !(_Left == _Right);

  00003	ff 75 0c	 push	 DWORD PTR __Right$[ebp]
  00006	ff 75 08	 push	 DWORD PTR __Left$[ebp]
  00009	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
  0000e	83 c4 08	 add	 esp, 8
  00011	34 01		 xor	 al, 1

; 496  : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ENDP ; std::operator!=<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC ; std::_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 97   :         if (_Target) {

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	85 c9		 test	 ecx, ecx
  00004	0f 85 00 00 00
	00		 jne	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 98   :             _Target->_Tidy_deallocate();
; 99   :         }
; 100  :     }

  0000a	c3		 ret	 0
??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
;	COMDAT ??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z
_TEXT	SEGMENT
$T2 = -84						; size = 20
$T3 = -64						; size = 8
$T4 = -64						; size = 8
$T5 = -56						; size = 8
__Ok$ = -48						; size = 8
$T6 = -40						; size = 8
$T7 = -32						; size = 8
__Err$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Common_extract_with_num_get<long>, COMDAT
; _this$ = ecx

; 207  :     basic_istream& _Common_extract_with_num_get(_Ty& _Val) { // formatted extract with num_get

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 208  :         ios_base::iostate _Err = ios_base::goodbit;

  00030	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Err$[ebp], 0

; 87   :             const auto _Rdbuf = _Myistr.rdbuf();

  00037	8b 06		 mov	 eax, DWORD PTR [esi]
  00039	89 75 d0	 mov	 DWORD PTR __Ok$[ebp], esi
  0003c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003f	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]

; 88   :             if (_Rdbuf) {

  00043	85 c9		 test	 ecx, ecx
  00045	74 05		 je	 SHORT $LN15@Common_ext

; 89   :                 _Rdbuf->_Lock();

  00047	8b 01		 mov	 eax, DWORD PTR [ecx]
  00049	ff 50 04	 call	 DWORD PTR [eax+4]
$LN15@Common_ext:

; 108  :             : _Sentry_base(_Istr), _Ok(_Sentry_base::_Myistr._Ipfx(_Noskip)) {}

  0004c	6a 00		 push	 0
  0004e	8b ce		 mov	 ecx, esi
  00050	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00057	e8 00 00 00 00	 call	 ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
  0005c	88 45 d4	 mov	 BYTE PTR __Ok$[ebp+4], al

; 209  :         const sentry _Ok(*this);

  0005f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  00066	84 c0		 test	 al, al

; 210  : 
; 211  :         if (_Ok) { // state okay, use facet to extract

  00068	0f 84 9e 00 00
	00		 je	 $LN9@Common_ext

; 213  :             _STD use_facet<_Nget>(this->getloc()).get(*this, {}, *this, _Err, _Val);

  0006e	8b 06		 mov	 eax, DWORD PTR [esi]
  00070	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 289  :         return *_Ploc;

  00073	8b 44 30 30	 mov	 eax, DWORD PTR [eax+esi+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  00077	8b 78 04	 mov	 edi, DWORD PTR [eax+4]

; 269  :         _Ptr->_Incref();

  0007a	8b cf		 mov	 ecx, edi
  0007c	89 7d cc	 mov	 DWORD PTR $T5[ebp+4], edi
  0007f	8b 07		 mov	 eax, DWORD PTR [edi]
  00081	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 213  :             _STD use_facet<_Nget>(this->getloc()).get(*this, {}, *this, _Err, _Val);

  00084	8d 45 c8	 lea	 eax, DWORD PTR $T5[ebp]
  00087	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 ??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >
  00091	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 303  :         return do_get(_First, _Last, _Iosbase, _State, _Val);

  00093	8d 55 e8	 lea	 edx, DWORD PTR __Err$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 213  :             _STD use_facet<_Nget>(this->getloc()).get(*this, {}, *this, _Err, _Val);

  00096	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 376  :     constexpr istreambuf_iterator() noexcept : _Strbuf(nullptr), _Got(true), _Val() {}

  00099	66 c7 45 e4 01
	00		 mov	 WORD PTR $T7[ebp+4], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 213  :             _STD use_facet<_Nget>(this->getloc()).get(*this, {}, *this, _Err, _Val);

  0009f	8b d8		 mov	 ebx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 381  :     istreambuf_iterator(istream_type& _Istr) noexcept : _Strbuf(_Istr.rdbuf()), _Got(!_Strbuf), _Val() {}

  000a1	c6 45 dd 00	 mov	 BYTE PTR $T6[ebp+5], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 213  :             _STD use_facet<_Nget>(this->getloc()).get(*this, {}, *this, _Err, _Val);

  000a5	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 303  :         return do_get(_First, _Last, _Iosbase, _State, _Val);

  000a8	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  000ab	8b 03		 mov	 eax, DWORD PTR [ebx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 213  :             _STD use_facet<_Nget>(this->getloc()).get(*this, {}, *this, _Err, _Val);

  000ad	03 ce		 add	 ecx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 303  :         return do_get(_First, _Last, _Iosbase, _State, _Val);

  000af	52		 push	 edx
  000b0	51		 push	 ecx
  000b1	ff 75 e4	 push	 DWORD PTR $T7[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 381  :     istreambuf_iterator(istream_type& _Istr) noexcept : _Strbuf(_Istr.rdbuf()), _Got(!_Strbuf), _Val() {}

  000b4	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 303  :         return do_get(_First, _Last, _Iosbase, _State, _Val);

  000b8	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  000bb	8d 4d c0	 lea	 ecx, DWORD PTR $T3[ebp]
  000be	6a 00		 push	 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 381  :     istreambuf_iterator(istream_type& _Istr) noexcept : _Strbuf(_Istr.rdbuf()), _Got(!_Strbuf), _Val() {}

  000c0	0f 94 45 dc	 sete	 BYTE PTR $T6[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 303  :         return do_get(_First, _Last, _Iosbase, _State, _Val);

  000c4	ff 75 dc	 push	 DWORD PTR $T6[ebp+4]
  000c7	52		 push	 edx
  000c8	51		 push	 ecx
  000c9	8b cb		 mov	 ecx, ebx
  000cb	ff 50 28	 call	 DWORD PTR [eax+40]
  000ce	85 ff		 test	 edi, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  000d0	74 33		 je	 SHORT $LN10@Common_ext

; 355  :             delete _Ptr->_Decref();

  000d2	8b 07		 mov	 eax, DWORD PTR [edi]
  000d4	8b cf		 mov	 ecx, edi
  000d6	ff 50 08	 call	 DWORD PTR [eax+8]
  000d9	85 c0		 test	 eax, eax
  000db	74 28		 je	 SHORT $LN10@Common_ext
  000dd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000df	6a 01		 push	 1
  000e1	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e3	8b c8		 mov	 ecx, eax
  000e5	ff d2		 call	 edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 213  :             _STD use_facet<_Nget>(this->getloc()).get(*this, {}, *this, _Err, _Val);

  000e7	eb 1c		 jmp	 SHORT $LN10@Common_ext
__catch$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z$0:

; 214  :             _CATCH_IO_END

  000e9	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000ec	6a 01		 push	 1
  000ee	6a 04		 push	 4
  000f0	8b 02		 mov	 eax, DWORD PTR [edx]
  000f2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f5	03 ca		 add	 ecx, edx
  000f7	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
  000fc	b8 00 00 00 00	 mov	 eax, $LN65@Common_ext
  00101	c3		 ret	 0
$LN65@Common_ext:
  00102	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN10@Common_ext:
  00105	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
$LN9@Common_ext:

; 217  :         _Myios::setstate(_Err);

  0010c	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  0010e	33 ff		 xor	 edi, edi
  00110	b9 04 00 00 00	 mov	 ecx, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 217  :         _Myios::setstate(_Err);

  00115	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 51   :         clear(rdstate() | _State, _Reraise);

  00118	8b 44 32 0c	 mov	 eax, DWORD PTR [edx+esi+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 217  :         _Myios::setstate(_Err);

  0011c	03 d6		 add	 edx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 51   :         clear(rdstate() | _State, _Reraise);

  0011e	0b 45 e8	 or	 eax, DWORD PTR __Err$[ebp]

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  00121	39 7a 38	 cmp	 DWORD PTR [edx+56], edi
  00124	0f 45 cf	 cmovne	 ecx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 155  :         _State &= _Statmask;

  00127	0b c8		 or	 ecx, eax

; 156  :         _Mystate             = _State;
; 157  :         const auto _Filtered = _State & _Except;

  00129	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0012c	83 e1 17	 and	 ecx, 23			; 00000017H
  0012f	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00132	23 c1		 and	 eax, ecx

; 158  :         if (_Filtered) {

  00134	75 2f		 jne	 SHORT $LN69@Common_ext
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 94   :             const auto _Rdbuf = _Myistr.rdbuf();

  00136	8b 06		 mov	 eax, DWORD PTR [esi]
  00138	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 5
  0013f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00142	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]

; 95   :             if (_Rdbuf) {

  00146	85 c9		 test	 ecx, ecx
  00148	74 05		 je	 SHORT $LN60@Common_ext

; 96   :                 _Rdbuf->_Unlock();

  0014a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0014c	ff 50 08	 call	 DWORD PTR [eax+8]
$LN60@Common_ext:

; 218  :         return *this;

  0014f	8b c6		 mov	 eax, esi

; 219  :     }

  00151	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00154	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0015b	59		 pop	 ecx
  0015c	5f		 pop	 edi
  0015d	5e		 pop	 esi
  0015e	5b		 pop	 ebx
  0015f	8b e5		 mov	 esp, ebp
  00161	5d		 pop	 ebp
  00162	c2 04 00	 ret	 4
$LN69@Common_ext:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 164  :             if (_Filtered & ios_base::badbit) {

  00165	a8 04		 test	 al, 4
  00167	74 07		 je	 SHORT $LN46@Common_ext

; 165  :                 _Msg = "ios_base::badbit set";

  00169	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  0016e	eb 0f		 jmp	 SHORT $LN48@Common_ext
$LN46@Common_ext:

; 166  :             } else if (_Filtered & ios_base::failbit) {

  00170	a8 02		 test	 al, 2
  00172	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
  00177	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
  0017c	0f 44 f0	 cmove	 esi, eax
$LN48@Common_ext:

; 167  :                 _Msg = "ios_base::failbit set";
; 168  :             } else {
; 169  :                 _Msg = "ios_base::eofbit set";
; 170  :             }
; 171  : 
; 172  :             _THROW(failure(_Msg));

  0017f	8d 45 c0	 lea	 eax, DWORD PTR $T4[ebp]
  00182	6a 01		 push	 1
  00184	50		 push	 eax
  00185	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  0018a	83 c4 08	 add	 esp, 8
  0018d	8d 4d ac	 lea	 ecx, DWORD PTR $T2[ebp]
  00190	50		 push	 eax
  00191	56		 push	 esi
  00192	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  00197	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  0019c	8d 45 ac	 lea	 eax, DWORD PTR $T2[ebp]
  0019f	50		 push	 eax
  001a0	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN67@Common_ext:
  001a5	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z$4:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z$2:
  00008	8d 4d d0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__unwindfunclet$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z$3:
  00010	8d 4d c8	 lea	 ecx, DWORD PTR $T5[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
__ehhandler$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z:
  0001d	90		 npad	 1
  0001e	90		 npad	 1
  0001f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00023	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00026	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Common_extract_with_num_get<long>
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 94   :             const auto _Rdbuf = _Myistr.rdbuf();

  00022	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00024	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00030	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]

; 95   :             if (_Rdbuf) {

  00034	85 c9		 test	 ecx, ecx
  00036	74 05		 je	 SHORT $LN5@sentry

; 96   :                 _Rdbuf->_Unlock();

  00038	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003a	ff 50 08	 call	 DWORD PTR [eax+8]
$LN5@sentry:
  0003d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00040	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00047	59		 pop	 ecx
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
  0004c	cc		 int	 3
  0004d	cc		 int	 3
  0004e	cc		 int	 3
  0004f	cc		 int	 3
  00050	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 93   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 94   :             const auto _Rdbuf = _Myistr.rdbuf();

  00022	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00024	8b 01		 mov	 eax, DWORD PTR [ecx]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00029	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]

; 95   :             if (_Rdbuf) {

  0002d	85 c9		 test	 ecx, ecx
  0002f	74 05		 je	 SHORT $LN2@Sentry_bas

; 96   :                 _Rdbuf->_Unlock();

  00031	8b 01		 mov	 eax, DWORD PTR [ecx]
  00033	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 97   :             }
; 98   :         }

  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
  00045	cc		 int	 3
  00046	cc		 int	 3
  00047	cc		 int	 3
  00048	cc		 int	 3
  00049	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
;	COMDAT ??_G?$codecvt@DDU_Mbstatet@@@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$codecvt@DDU_Mbstatet@@@std@@MAEPAXI@Z PROC	; std::codecvt<char,char,_Mbstatet>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  00010	74 0b		 je	 SHORT $LN5@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_G?$codecvt@DDU_Mbstatet@@@std@@MAEPAXI@Z ENDP	; std::codecvt<char,char,_Mbstatet>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_length@?$codecvt@DDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PBD1I@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__Count$ = 20						; size = 4
?do_length@?$codecvt@DDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PBD1I@Z PROC ; std::codecvt<char,char,_Mbstatet>::do_length, COMDAT
; _this$ = ecx

; 797  :         _Statype&, const _Byte* _First1, const _Byte* _Last1, size_t _Count) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 798  :         // return p - _First1, for the largest value p in [_First1, _Last1] such that [_First1, p) successfully
; 799  :         // converts to at most _Count _Elems
; 800  :         // assumes 1:1 conversion
; 801  :         const auto _Dist = static_cast<size_t>((_STD min)(_Last1 - _First1, ptrdiff_t{INT_MAX}));

  00003	8b 4d 10	 mov	 ecx, DWORD PTR __Last1$[ebp]
  00006	2b 4d 0c	 sub	 ecx, DWORD PTR __First1$[ebp]
  00009	8b 45 14	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	3b c8		 cmp	 ecx, eax
  0000e	0f 42 c1	 cmovb	 eax, ecx

; 802  :         return static_cast<int>((_STD min)(_Count, _Dist));
; 803  :     }

  00011	5d		 pop	 ebp
  00012	c2 10 00	 ret	 16			; 00000010H
?do_length@?$codecvt@DDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PBD1I@Z ENDP ; std::codecvt<char,char,_Mbstatet>::do_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_unshift@?$codecvt@DDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PAD1AAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__First2$ = 12						; size = 4
___formal$ = 16						; size = 4
__Mid2$ = 20						; size = 4
?do_unshift@?$codecvt@DDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PAD1AAPAD@Z PROC ; std::codecvt<char,char,_Mbstatet>::do_unshift, COMDAT
; _this$ = ecx

; 790  :     virtual result __CLR_OR_THIS_CALL do_unshift(_Statype&, _Byte* _First2, _Byte*, _Byte*& _Mid2) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 791  :         // generate bytes to return to default shift state
; 792  :         _Mid2 = _First2;

  00003	8b 4d 14	 mov	 ecx, DWORD PTR __Mid2$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __First2$[ebp]
  00009	89 01		 mov	 DWORD PTR [ecx], eax

; 793  :         return noconv; // no termination required

  0000b	b8 03 00 00 00	 mov	 eax, 3

; 794  :     }

  00010	5d		 pop	 ebp
  00011	c2 10 00	 ret	 16			; 00000010H
?do_unshift@?$codecvt@DDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PAD1AAPAD@Z ENDP ; std::codecvt<char,char,_Mbstatet>::do_unshift
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_out@?$codecvt@DDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__Mid1$ = 20						; size = 4
__First2$ = 24						; size = 4
__Last2$ = 28						; size = 4
__Mid2$ = 32						; size = 4
?do_out@?$codecvt@DDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z PROC ; std::codecvt<char,char,_Mbstatet>::do_out, COMDAT
; _this$ = ecx

; 772  :         _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const { // convert [_First1, _Last1) to bytes [_First2, _Last2)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 773  :         _Mid1 = _First1;

  00003	8b 4d 14	 mov	 ecx, DWORD PTR __Mid1$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __First1$[ebp]
  00009	89 01		 mov	 DWORD PTR [ecx], eax

; 774  :         _Mid2 = _First2;

  0000b	8b 4d 20	 mov	 ecx, DWORD PTR __Mid2$[ebp]
  0000e	8b 45 18	 mov	 eax, DWORD PTR __First2$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 775  :         if constexpr (_Is_codecvt_do_always_noconv_v<_Elem, _Byte>) {
; 776  :             return noconv; // convert nothing

  00013	b8 03 00 00 00	 mov	 eax, 3

; 777  :         } else {
; 778  :             // types differ, copy one for one
; 779  :             for (; _Mid1 != _Last1; ++_Mid1, ++_Mid2) {
; 780  :                 if (_Mid2 == _Last2) {
; 781  :                     return partial;
; 782  :                 }
; 783  :                 *_Mid2 = static_cast<_Byte>(*_Mid1);
; 784  :             }
; 785  : 
; 786  :             return ok;
; 787  :         }
; 788  :     }

  00018	5d		 pop	 ebp
  00019	c2 1c 00	 ret	 28			; 0000001cH
?do_out@?$codecvt@DDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z ENDP ; std::codecvt<char,char,_Mbstatet>::do_out
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_in@?$codecvt@DDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__Mid1$ = 20						; size = 4
__First2$ = 24						; size = 4
__Last2$ = 28						; size = 4
__Mid2$ = 32						; size = 4
?do_in@?$codecvt@DDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z PROC ; std::codecvt<char,char,_Mbstatet>::do_in, COMDAT
; _this$ = ecx

; 753  :         _Elem* _First2, _Elem* _Last2, _Elem*& _Mid2) const { // convert bytes [_First1, _Last1) to [_First2, _Last2)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 754  :         _Mid1 = _First1;

  00003	8b 4d 14	 mov	 ecx, DWORD PTR __Mid1$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __First1$[ebp]
  00009	89 01		 mov	 DWORD PTR [ecx], eax

; 755  :         _Mid2 = _First2;

  0000b	8b 4d 20	 mov	 ecx, DWORD PTR __Mid2$[ebp]
  0000e	8b 45 18	 mov	 eax, DWORD PTR __First2$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 756  :         if constexpr (_Is_codecvt_do_always_noconv_v<_Elem, _Byte>) {
; 757  :             return noconv; // convert nothing

  00013	b8 03 00 00 00	 mov	 eax, 3

; 758  :         } else {
; 759  :             // types differ, copy one for one
; 760  :             for (; _Mid1 != _Last1; ++_Mid1, ++_Mid2) {
; 761  :                 if (_Mid2 == _Last2) {
; 762  :                     return partial;
; 763  :                 }
; 764  :                 *_Mid2 = static_cast<_Elem>(*_Mid1);
; 765  :             }
; 766  : 
; 767  :             return ok;
; 768  :         }
; 769  :     }

  00018	5d		 pop	 ebp
  00019	c2 1c 00	 ret	 28			; 0000001cH
?do_in@?$codecvt@DDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z ENDP ; std::codecvt<char,char,_Mbstatet>::do_in
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_always_noconv@?$codecvt@DDU_Mbstatet@@@std@@MBE_NXZ
_TEXT	SEGMENT
?do_always_noconv@?$codecvt@DDU_Mbstatet@@@std@@MBE_NXZ PROC ; std::codecvt<char,char,_Mbstatet>::do_always_noconv, COMDAT
; _this$ = ecx

; 748  :         // return true if conversions never change input (from codecvt)
; 749  :         return _Is_codecvt_do_always_noconv_v<_Elem, _Byte>;

  00000	b0 01		 mov	 al, 1

; 750  :     }

  00002	c3		 ret	 0
?do_always_noconv@?$codecvt@DDU_Mbstatet@@@std@@MBE_NXZ ENDP ; std::codecvt<char,char,_Mbstatet>::do_always_noconv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??1?$codecvt@DDU_Mbstatet@@@std@@MAE@XZ
_TEXT	SEGMENT
??1?$codecvt@DDU_Mbstatet@@@std@@MAE@XZ PROC		; std::codecvt<char,char,_Mbstatet>::~codecvt<char,char,_Mbstatet>, COMDAT
; _this$ = ecx

; 743  :     __CLR_OR_THIS_CALL ~codecvt() noexcept override {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
  00006	c3		 ret	 0
??1?$codecvt@DDU_Mbstatet@@@std@@MAE@XZ ENDP		; std::codecvt<char,char,_Mbstatet>::~codecvt<char,char,_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -76						; size = 52
__Lock$3 = -24						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
__Psave$1$ = -20					; size = 4
__Lock$6 = -16						; size = 4
$T7 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
__Psave_guard$8 = 8					; size = 4
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::codecvt<char,char,_Mbstatet> >, COMDAT

; 435  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	33 db		 xor	 ebx, ebx

; 436  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

  0002a	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0002d	53		 push	 ebx
  0002e	89 5d e8	 mov	 DWORD PTR $T4[ebp], ebx
  00031	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 91   :             if (_Id == 0) { // still zero, allocate stamp

  00036	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A ; std::codecvt<char,char,_Mbstatet>::id

; 437  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

  0003c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
  00041	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00044	89 45 ec	 mov	 DWORD PTR __Psave$1$[ebp], eax

; 91   :             if (_Id == 0) { // still zero, allocate stamp

  00047	85 ff		 test	 edi, edi
  00049	75 2f		 jne	 SHORT $LN11@use_facet

; 92   :                 _BEGIN_LOCK(_LOCK_LOCALE)

  0004b	57		 push	 edi
  0004c	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$6[ebp]
  0004f	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 93   :                 if (_Id == 0) {

  00054	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A, edi ; std::codecvt<char,char,_Mbstatet>::id
  0005a	75 10		 jne	 SHORT $LN12@use_facet

; 94   :                     _Id = static_cast<size_t>(++_Id_cnt);

  0005c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00061	40		 inc	 eax
  00062	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00067	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A, eax ; std::codecvt<char,char,_Mbstatet>::id
$LN12@use_facet:

; 95   :                 }
; 96   :                 _END_LOCK()

  0006c	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$6[ebp]
  0006f	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00074	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A ; std::codecvt<char,char,_Mbstatet>::id
$LN11@use_facet:

; 377  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  0007a	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  0007d	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
  00084	89 4d f0	 mov	 DWORD PTR $T7[ebp], ecx
  00087	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008a	3b 7a 0c	 cmp	 edi, DWORD PTR [edx+12]
  0008d	73 16		 jae	 SHORT $LN19@use_facet
  0008f	0f ae e8	 lfence
  00092	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00095	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00098	8b 34 01	 mov	 esi, DWORD PTR [ecx+eax]

; 378  :         if (_Facptr || !_Ptr->_Xparent) {

  0009b	85 f6		 test	 esi, esi
  0009d	0f 85 b1 00 00
	00		 jne	 $LN73@use_facet
  000a3	eb 05		 jmp	 SHORT $LN77@use_facet
$LN19@use_facet:

; 374  :     }
; 375  : 
; 376  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object
; 377  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  000a5	33 f6		 xor	 esi, esi
  000a7	89 4d f0	 mov	 DWORD PTR $T7[ebp], ecx
$LN77@use_facet:

; 378  :         if (_Facptr || !_Ptr->_Xparent) {

  000aa	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0
  000ae	74 16		 je	 SHORT $LN14@use_facet

; 379  :             return _Facptr; // found facet or not transparent
; 380  :         }
; 381  : 
; 382  :         // look in current locale
; 383  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

  000b0	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 384  :         if (_Id < _Ptr0->_Facetcount) {

  000b5	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  000b8	73 14		 jae	 SHORT $LN78@use_facet

; 385  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

  000ba	0f ae e8	 lfence
  000bd	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c0	8b 75 f0	 mov	 esi, DWORD PTR $T7[ebp]
  000c3	8b 34 06	 mov	 esi, DWORD PTR [esi+eax]
$LN14@use_facet:

; 438  : 
; 439  :     const size_t _Id         = _Facet::id._Get_index();
; 440  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);
; 441  : 
; 442  :     if (!_Pf) {

  000c6	85 f6		 test	 esi, esi
  000c8	0f 85 86 00 00
	00		 jne	 $LN73@use_facet
$LN78@use_facet:

; 443  :         if (_Psave) {

  000ce	8b 45 ec	 mov	 eax, DWORD PTR __Psave$1$[ebp]
  000d1	85 c0		 test	 eax, eax
  000d3	74 04		 je	 SHORT $LN3@use_facet

; 444  :             _Pf = _Psave; // lazy facet already allocated

  000d5	8b f0		 mov	 esi, eax

; 445  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

  000d7	eb 7b		 jmp	 SHORT $LN73@use_facet
$LN3@use_facet:

; 736  :             *_Ppf = new codecvt(_Locinfo(_Ploc->_C_str()));

  000d9	6a 08		 push	 8
  000db	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000e0	8b f0		 mov	 esi, eax
  000e2	83 c4 04	 add	 esp, 4
  000e5	89 75 ec	 mov	 DWORD PTR $T5[ebp], esi
  000e8	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000ec	85 f6		 test	 esi, esi
  000ee	74 38		 je	 SHORT $LN24@use_facet

; 373  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  000f0	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  000f3	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000f6	85 c9		 test	 ecx, ecx
  000f8	74 0c		 je	 SHORT $LN32@use_facet
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo

; 190  :         return _Myptr ? _Myptr : &_Nul;

  000fa	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  000fd	85 c0		 test	 eax, eax
  000ff	75 0a		 jne	 SHORT $LN33@use_facet
  00101	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 373  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  00104	eb 05		 jmp	 SHORT $LN33@use_facet
$LN32@use_facet:
  00106	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@@
$LN33@use_facet:

; 736  :             *_Ppf = new codecvt(_Locinfo(_Ploc->_C_str()));

  0010b	50		 push	 eax
  0010c	8d 4d b4	 lea	 ecx, DWORD PTR $T2[ebp]
  0010f	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00114	bb 01 00 00 00	 mov	 ebx, 1

; 143  :             : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs)) // non-atomic initialization

  00119	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 729  :     explicit __CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0) : codecvt_base(_Refs) {

  00120	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$codecvt@DDU_Mbstatet@@@std@@6B@

; 736  :             *_Ppf = new codecvt(_Locinfo(_Ploc->_C_str()));

  00126	eb 02		 jmp	 SHORT $LN25@use_facet
$LN24@use_facet:
  00128	33 f6		 xor	 esi, esi
$LN25@use_facet:
  0012a	f6 c3 01	 test	 bl, 1
  0012d	74 08		 je	 SHORT $LN29@use_facet
  0012f	8d 4d b4	 lea	 ecx, DWORD PTR $T2[ebp]
  00132	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN29@use_facet:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00137	89 75 08	 mov	 DWORD PTR __Psave_guard$8[ebp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 458  :             _Facet_Register(_Pfmod);

  0013a	56		 push	 esi
  0013b	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0013f	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register

; 459  : #endif // ^^^ !defined(_M_CEE) ^^^
; 460  : 
; 461  :             _Pfmod->_Incref();

  00144	8b 16		 mov	 edx, DWORD PTR [esi]
  00146	83 c4 04	 add	 esp, 4
  00149	8b ce		 mov	 ecx, esi
  0014b	ff 52 04	 call	 DWORD PTR [edx+4]

; 462  :             _Facetptr<_Facet>::_Psave = _Psave;

  0014e	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
$LN73@use_facet:

; 463  :             _Pf                       = _Psave;
; 464  : 
; 465  :             (void) _Psave_guard.release();
; 466  :         }
; 467  :     }
; 468  : 
; 469  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

  00154	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00157	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0015c	8b c6		 mov	 eax, esi

; 470  :     _END_LOCK()
; 471  : } // end of use_facet body

  0015e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00161	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00168	59		 pop	 ecx
  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	5b		 pop	 ebx
  0016c	8b e5		 mov	 esp, ebp
  0016e	5d		 pop	 ebp
  0016f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z$2:
  00008	6a 08		 push	 8
  0000a	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00013	83 c4 08	 add	 esp, 8
  00016	c3		 ret	 0
__unwindfunclet$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z$1:
  00017	8d 4d 08	 lea	 ecx, DWORD PTR __Psave_guard$8[ebp]
  0001a	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
  0001f	cc		 int	 3
  00020	cc		 int	 3
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
__ehhandler$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z:
  00024	90		 npad	 1
  00025	90		 npad	 1
  00026	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002d	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  00030	33 c8		 xor	 ecx, eax
  00032	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00037	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z
  0003c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
; Function compile flags: /Ogtp
;	COMDAT ??_G?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAEPAXI@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  00010	74 0b		 je	 SHORT $LN5@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_G?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAEPAXI@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ch$ = 24						; size = 2
__Count$ = 28						; size = 4
?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep, COMDAT

; 1631 :     _OutIt __CLRCALL_OR_CDECL _Rep(_OutIt _Dest, _Elem _Ch, size_t _Count) const { // put _Count * _Ch to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1632 :         for (; 0 < _Count; --_Count, (void) ++_Dest) {

  00003	8b 45 14	 mov	 eax, DWORD PTR __Dest$[ebp+4]
  00006	56		 push	 esi
  00007	8b 75 1c	 mov	 esi, DWORD PTR __Count$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	74 54		 je	 SHORT $LN3@Rep
  0000e	53		 push	 ebx
  0000f	57		 push	 edi
  00010	8b 7d 18	 mov	 edi, DWORD PTR __Ch$[ebp]
  00013	bb ff ff 00 00	 mov	 ebx, 65535		; 0000ffffH
$LL4@Rep:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 526  :         if (!_Strbuf || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

  00018	85 c0		 test	 eax, eax
  0001a	74 3b		 je	 SHORT $LN8@Rep
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 261  :         return *_IPnext ? *_IPcount : 0;

  0001c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0001f	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00022	74 1e		 je	 SHORT $LN12@Rep
  00024	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  00027	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  00029	85 c9		 test	 ecx, ecx
  0002b	7e 15		 jle	 SHORT $LN12@Rep

; 256  :         --*_IPcount;

  0002d	49		 dec	 ecx
  0002e	89 0a		 mov	 DWORD PTR [edx], ecx

; 257  :         return (*_IPnext)++;

  00030	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  00038	89 01		 mov	 DWORD PTR [ecx], eax

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  0003a	66 89 3a	 mov	 WORD PTR [edx], di
  0003d	0f b7 c7	 movzx	 eax, di
  00040	eb 0d		 jmp	 SHORT $LN13@Rep
$LN12@Rep:
  00042	8b 08		 mov	 ecx, DWORD PTR [eax]
  00044	57		 push	 edi
  00045	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00048	8b c8		 mov	 ecx, eax
  0004a	ff d2		 call	 edx
  0004c	0f b7 c0	 movzx	 eax, ax
$LN13@Rep:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 367  :         return _Left == _Right;

  0004f	66 3b d8	 cmp	 bx, ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 526  :         if (!_Strbuf || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

  00052	8b 45 14	 mov	 eax, DWORD PTR __Dest$[ebp+4]
  00055	75 04		 jne	 SHORT $LN2@Rep
$LN8@Rep:

; 527  :             _Failed = true;

  00057	c6 45 10 01	 mov	 BYTE PTR __Dest$[ebp], 1
$LN2@Rep:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1632 :         for (; 0 < _Count; --_Count, (void) ++_Dest) {

  0005b	83 ee 01	 sub	 esi, 1
  0005e	75 b8		 jne	 SHORT $LL4@Rep
  00060	5f		 pop	 edi
  00061	5b		 pop	 ebx
$LN3@Rep:

; 1633 :             *_Dest = _Ch;
; 1634 :         }
; 1635 : 
; 1636 :         return _Dest;

  00062	8b 55 0c	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00065	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00068	5e		 pop	 esi
  00069	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0006c	8b c2		 mov	 eax, edx
  0006e	89 0a		 mov	 DWORD PTR [edx], ecx

; 1637 :     }

  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ptr$ = 24						; size = 4
__Count$ = 28						; size = 4
?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put, COMDAT

; 1623 :         _OutIt _Dest, const _Elem* _Ptr, size_t _Count) const { // put [_Ptr, _Ptr + _Count) to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1624 :         for (; 0 < _Count; --_Count, (void) ++_Dest, ++_Ptr) {

  00003	8b 45 14	 mov	 eax, DWORD PTR __Dest$[ebp+4]
  00006	56		 push	 esi
  00007	8b 75 1c	 mov	 esi, DWORD PTR __Count$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	74 59		 je	 SHORT $LN3@Put
  0000e	53		 push	 ebx
  0000f	57		 push	 edi
  00010	8b 7d 18	 mov	 edi, DWORD PTR __Ptr$[ebp]
$LL4@Put:

; 1625 :             *_Dest = *_Ptr;

  00013	0f b7 1f	 movzx	 ebx, WORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 526  :         if (!_Strbuf || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

  00016	85 c0		 test	 eax, eax
  00018	74 3f		 je	 SHORT $LN8@Put
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 261  :         return *_IPnext ? *_IPcount : 0;

  0001a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0001d	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00020	74 1d		 je	 SHORT $LN12@Put
  00022	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  00025	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  00027	85 c9		 test	 ecx, ecx
  00029	7e 14		 jle	 SHORT $LN12@Put

; 256  :         --*_IPcount;

  0002b	49		 dec	 ecx
  0002c	89 0a		 mov	 DWORD PTR [edx], ecx

; 257  :         return (*_IPnext)++;

  0002e	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00031	8b 11		 mov	 edx, DWORD PTR [ecx]
  00033	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  00036	89 01		 mov	 DWORD PTR [ecx], eax

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  00038	8b c3		 mov	 eax, ebx
  0003a	66 89 1a	 mov	 WORD PTR [edx], bx
  0003d	eb 0d		 jmp	 SHORT $LN13@Put
$LN12@Put:
  0003f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00041	53		 push	 ebx
  00042	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00045	8b c8		 mov	 ecx, eax
  00047	ff d2		 call	 edx
  00049	0f b7 c0	 movzx	 eax, ax
$LN13@Put:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 367  :         return _Left == _Right;

  0004c	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00051	66 3b c8	 cmp	 cx, ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 526  :         if (!_Strbuf || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

  00054	8b 45 14	 mov	 eax, DWORD PTR __Dest$[ebp+4]
  00057	75 04		 jne	 SHORT $LN2@Put
$LN8@Put:

; 527  :             _Failed = true;

  00059	c6 45 10 01	 mov	 BYTE PTR __Dest$[ebp], 1
$LN2@Put:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1624 :         for (; 0 < _Count; --_Count, (void) ++_Dest, ++_Ptr) {

  0005d	83 c7 02	 add	 edi, 2
  00060	83 ee 01	 sub	 esi, 1
  00063	75 ae		 jne	 SHORT $LL4@Put
  00065	5f		 pop	 edi
  00066	5b		 pop	 ebx
$LN3@Put:

; 1626 :         }
; 1627 : 
; 1628 :         return _Dest;

  00067	8b 55 0c	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0006a	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0006d	5e		 pop	 esi
  0006e	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00071	8b c2		 mov	 eax, edx
  00073	89 0a		 mov	 DWORD PTR [edx], ecx

; 1629 :     }

  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$1$ = -108				; size = 4
__Su$1$ = -104						; size = 4
__Old_capacity$1$ = -100				; size = 4
tv1226 = -96						; size = 4
__Iosbase$GSCopy$1$ = -92				; size = 4
__Pg$1$ = -88						; size = 4
__Ctype_fac$1$ = -88					; size = 4
__Prefix$1$ = -84					; size = 4
$T2 = -80						; size = 8
$T3 = -80						; size = 8
$T4 = -80						; size = 8
$T5 = -80						; size = 8
$T6 = -80						; size = 8
$T7 = -80						; size = 8
$T8 = -80						; size = 8
$T9 = -80						; size = 8
tv1237 = -76						; size = 4
__New_ptr$1$ = -72					; size = 4
__Punct_fac$1$ = -72					; size = 4
__Buf$GSCopy$1$ = -72					; size = 4
__Kseparator$1$ = -68					; size = 4
__Count$GSCopy$2$ = -68					; size = 4
__Grouping$ = -64					; size = 24
__Groupstring$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 2
__Buf$ = 32						; size = 4
__Count$ = 36						; size = 4
?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Iput, COMDAT

; 1569 :         size_t _Count) const { // put formatted integer to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 60	 sub	 esp, 96			; 00000060H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 5d 24	 mov	 ebx, DWORD PTR __Count$[ebp]
  0002e	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00031	8b 55 18	 mov	 edx, DWORD PTR __Iosbase$[ebp]
  00034	8b 4d 20	 mov	 ecx, DWORD PTR __Buf$[ebp]
  00037	89 45 94	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
  0003a	89 55 a4	 mov	 DWORD PTR __Iosbase$GSCopy$1$[ebp], edx
  0003d	89 4d b8	 mov	 DWORD PTR __Buf$GSCopy$1$[ebp], ecx

; 1570 :         auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));

  00040	85 db		 test	 ebx, ebx
  00042	74 11		 je	 SHORT $LN17@Iput
  00044	8a 01		 mov	 al, BYTE PTR [ecx]
  00046	3c 2b		 cmp	 al, 43			; 0000002bH
  00048	74 04		 je	 SHORT $LN16@Iput
  0004a	3c 2d		 cmp	 al, 45			; 0000002dH
  0004c	75 07		 jne	 SHORT $LN17@Iput
$LN16@Iput:
  0004e	bf 01 00 00 00	 mov	 edi, 1
  00053	eb 02		 jmp	 SHORT $LN269@Iput
$LN17@Iput:
  00055	33 ff		 xor	 edi, edi
$LN269@Iput:

; 1571 :         if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex && _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
; 1572 :             && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X')) {

  00057	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0005a	25 00 0e 00 00	 and	 eax, 3584		; 00000e00H
  0005f	89 7d ac	 mov	 DWORD PTR __Prefix$1$[ebp], edi
  00062	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  00067	75 20		 jne	 SHORT $LN4@Iput
  00069	8d 47 02	 lea	 eax, DWORD PTR [edi+2]
  0006c	3b c3		 cmp	 eax, ebx
  0006e	77 19		 ja	 SHORT $LN4@Iput
  00070	80 3c 39 30	 cmp	 BYTE PTR [ecx+edi], 48	; 00000030H
  00074	75 13		 jne	 SHORT $LN4@Iput
  00076	8a 4c 39 01	 mov	 cl, BYTE PTR [ecx+edi+1]
  0007a	80 f9 78	 cmp	 cl, 120			; 00000078H
  0007d	74 05		 je	 SHORT $LN5@Iput
  0007f	80 f9 58	 cmp	 cl, 88			; 00000058H
  00082	75 05		 jne	 SHORT $LN4@Iput
$LN5@Iput:

; 1573 :             _Prefix += 2;

  00084	8b f8		 mov	 edi, eax
  00086	89 7d ac	 mov	 DWORD PTR __Prefix$1$[ebp], edi
$LN4@Iput:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 289  :         return *_Ploc;

  00089	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  0008c	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 269  :         _Ptr->_Incref();

  0008f	8b ce		 mov	 ecx, esi
  00091	89 75 b4	 mov	 DWORD PTR $T3[ebp+4], esi
  00094	8b 06		 mov	 eax, DWORD PTR [esi]
  00096	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1576 :         const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());

  00099	8d 45 b0	 lea	 eax, DWORD PTR $T3[ebp]
  0009c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
  000a9	83 c4 04	 add	 esp, 4
  000ac	89 45 a8	 mov	 DWORD PTR __Ctype_fac$1$[ebp], eax
  000af	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000b6	85 f6		 test	 esi, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  000b8	74 13		 je	 SHORT $LN121@Iput

; 355  :             delete _Ptr->_Decref();

  000ba	8b 06		 mov	 eax, DWORD PTR [esi]
  000bc	8b ce		 mov	 ecx, esi
  000be	ff 50 08	 call	 DWORD PTR [eax+8]
  000c1	8b c8		 mov	 ecx, eax
  000c3	85 c9		 test	 ecx, ecx
  000c5	74 06		 je	 SHORT $LN121@Iput
  000c7	8b 01		 mov	 eax, DWORD PTR [ecx]
  000c9	6a 01		 push	 1
  000cb	ff 10		 call	 DWORD PTR [eax]
$LN121@Iput:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1577 :         basic_string<_Elem> _Groupstring(_Count, _Elem(0)); // reserve space

  000cd	6a 00		 push	 0
  000cf	53		 push	 ebx
  000d0	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  000d3	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  000d8	83 7d ec 07	 cmp	 DWORD PTR __Groupstring$[ebp+20], 7

; 435  :         value_type* _Result = _Bx._Buf;

  000dc	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 2936 :         return do_widen(_First, _Last, _Dest);

  000df	8b 75 a8	 mov	 esi, DWORD PTR __Ctype_fac$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 436  :         if (_Large_mode_engaged()) {

  000e2	0f 47 4d d8	 cmova	 ecx, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 2936 :         return do_widen(_First, _Last, _Dest);

  000e6	51		 push	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1578 :         _Ctype_fac.widen(_Buf, _Buf + _Count, &_Groupstring[0]);

  000e7	8b 4d b8	 mov	 ecx, DWORD PTR __Buf$GSCopy$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 2936 :         return do_widen(_First, _Last, _Dest);

  000ea	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1577 :         basic_string<_Elem> _Groupstring(_Count, _Elem(0)); // reserve space

  000ec	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 2936 :         return do_widen(_First, _Last, _Dest);

  000f3	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1578 :         _Ctype_fac.widen(_Buf, _Buf + _Count, &_Groupstring[0]);

  000f6	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 2936 :         return do_widen(_First, _Last, _Dest);

  000f9	50		 push	 eax
  000fa	51		 push	 ecx
  000fb	8b ce		 mov	 ecx, esi
  000fd	ff d2		 call	 edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 289  :         return *_Ploc;

  000ff	8b 55 a4	 mov	 edx, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00102	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  00105	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00108	89 4d b4	 mov	 DWORD PTR $T4[ebp+4], ecx

; 269  :         _Ptr->_Incref();

  0010b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0010d	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1580 :         const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

  00110	8d 45 b0	 lea	 eax, DWORD PTR $T4[ebp]
  00113	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 ??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<wchar_t> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  0011d	8b 4d b4	 mov	 ecx, DWORD PTR $T4[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1580 :         const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

  00120	83 c4 04	 add	 esp, 4
  00123	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00127	8b f0		 mov	 esi, eax
  00129	89 75 b8	 mov	 DWORD PTR __Punct_fac$1$[ebp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  0012c	85 c9		 test	 ecx, ecx
  0012e	74 11		 je	 SHORT $LN147@Iput

; 355  :             delete _Ptr->_Decref();

  00130	8b 01		 mov	 eax, DWORD PTR [ecx]
  00132	ff 50 08	 call	 DWORD PTR [eax+8]
  00135	8b c8		 mov	 ecx, eax
  00137	85 c9		 test	 ecx, ecx
  00139	74 06		 je	 SHORT $LN147@Iput
  0013b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0013d	6a 01		 push	 1
  0013f	ff 10		 call	 DWORD PTR [eax]
$LN147@Iput:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 108  :         return do_grouping();

  00141	8b 06		 mov	 eax, DWORD PTR [esi]
  00143	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  00146	51		 push	 ecx
  00147	8b ce		 mov	 ecx, esi
  00149	ff 50 14	 call	 DWORD PTR [eax+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  0014c	83 7d d4 0f	 cmp	 DWORD PTR __Grouping$[ebp+20], 15 ; 0000000fH

; 444  :         const value_type* _Result = _Bx._Buf;

  00150	8d 75 c0	 lea	 esi, DWORD PTR __Grouping$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1581 :         const string _Grouping = _Punct_fac.grouping();

  00153	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

  00157	0f 47 75 c0	 cmova	 esi, DWORD PTR __Grouping$[ebp]
  0015b	89 75 a8	 mov	 DWORD PTR __Pg$1$[ebp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1583 :         if (*_Pg != CHAR_MAX && '\0' < *_Pg) { // grouping specified, add thousands separators

  0015e	8a 06		 mov	 al, BYTE PTR [esi]
  00160	3c 7f		 cmp	 al, 127			; 0000007fH
  00162	0f 84 a1 01 00
	00		 je	 $LN266@Iput
  00168	84 c0		 test	 al, al
  0016a	0f 8e 99 01 00
	00		 jle	 $LN266@Iput

; 104  :         return do_thousands_sep();

  00170	8b 4d b8	 mov	 ecx, DWORD PTR __Punct_fac$1$[ebp]
  00173	8b 01		 mov	 eax, DWORD PTR [ecx]
  00175	ff 50 10	 call	 DWORD PTR [eax+16]

; 1584 :             const _Elem _Kseparator = _Punct_fac.thousands_sep();

  00178	0f b7 c0	 movzx	 eax, ax
  0017b	89 45 bc	 mov	 DWORD PTR __Kseparator$1$[ebp], eax

; 1585 :             while (*_Pg != CHAR_MAX && '\0' < *_Pg && static_cast<size_t>(*_Pg) < _Count - _Prefix) {

  0017e	8a 06		 mov	 al, BYTE PTR [esi]
  00180	3c 7f		 cmp	 al, 127			; 0000007fH
  00182	0f 84 81 01 00
	00		 je	 $LN266@Iput
$LL2@Iput:
  00188	84 c0		 test	 al, al
  0018a	0f 8e 79 01 00
	00		 jle	 $LN266@Iput
  00190	0f be 0e	 movsx	 ecx, BYTE PTR [esi]
  00193	8b c3		 mov	 eax, ebx
  00195	2b c7		 sub	 eax, edi
  00197	3b c8		 cmp	 ecx, eax
  00199	0f 83 6a 01 00
	00		 jae	 $LN266@Iput
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 469  :         if (_Mysize < _Off) {

  0019f	8b 7d e8	 mov	 edi, DWORD PTR __Groupstring$[ebp+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1587 :                 _Count -= *_Pg;

  001a2	2b d9		 sub	 ebx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 469  :         if (_Mysize < _Off) {

  001a4	3b fb		 cmp	 edi, ebx
  001a6	0f 82 05 03 00
	00		 jb	 $LN249@Iput

; 1787 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  001ac	8b 4d ec	 mov	 ecx, DWORD PTR __Groupstring$[ebp+20]
  001af	8b c1		 mov	 eax, ecx
  001b1	2b c7		 sub	 eax, edi
  001b3	89 4d 9c	 mov	 DWORD PTR __Old_capacity$1$[ebp], ecx

; 1788 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  001b6	83 f8 01	 cmp	 eax, 1
  001b9	72 36		 jb	 SHORT $LN24@Iput

; 1789 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1790 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  001bb	0f ae e8	 lfence
  001be	ff 45 e8	 inc	 DWORD PTR __Groupstring$[ebp+16]

; 435  :         value_type* _Result = _Bx._Buf;

  001c1	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]

; 453  :         return _Myres > _Small_string_capacity;

  001c4	83 7d ec 07	 cmp	 DWORD PTR __Groupstring$[ebp+20], 7

; 436  :         if (_Large_mode_engaged()) {

  001c8	0f 47 45 d8	 cmova	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  001cc	2b fb		 sub	 edi, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1792 :             _Elem* const _Insert_at = _Old_ptr + _Off;

  001ce	8d 34 58	 lea	 esi, DWORD PTR [eax+ebx*2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  001d1	8d 04 7d 02 00
	00 00		 lea	 eax, DWORD PTR [edi*2+2]
  001d8	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1793 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

  001d9	8d 46 02	 lea	 eax, DWORD PTR [esi+2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  001dc	56		 push	 esi
  001dd	50		 push	 eax
  001de	e8 00 00 00 00	 call	 _memmove
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h

; 519  :             *_Su = _C;

  001e3	8b 45 bc	 mov	 eax, DWORD PTR __Kseparator$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  001e6	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h

; 519  :             *_Su = _C;

  001e9	66 89 06	 mov	 WORD PTR [esi], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1795 :             return *this;

  001ec	e9 fb 00 00 00	 jmp	 $LN51@Iput
$LN24@Iput:

; 3028 :         const size_type _Old_size = _My_data._Mysize;

  001f1	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH
  001f6	2b c7		 sub	 eax, edi

; 3029 :         if (max_size() - _Old_size < _Size_increase) {

  001f8	83 f8 01	 cmp	 eax, 1
  001fb	0f 82 ab 02 00
	00		 jb	 $LN250@Iput

; 3031 :         }
; 3032 : 
; 3033 :         const size_type _New_size     = _Old_size + _Size_increase;

  00201	8d 77 01	 lea	 esi, DWORD PTR [edi+1]

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

  00204	83 ce 07	 or	 esi, 7
  00207	81 fe fe ff ff
	7f		 cmp	 esi, 2147483646		; 7ffffffeH

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0020d	76 0a		 jbe	 SHORT $LN57@Iput

; 2980 :             return _Max;

  0020f	be fe ff ff 7f	 mov	 esi, 2147483646		; 7ffffffeH
  00214	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00217	eb 2f		 jmp	 SHORT $LN264@Iput
$LN57@Iput:

; 2981 :         }
; 2982 : 
; 2983 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00219	8b d1		 mov	 edx, ecx
  0021b	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH
  00220	d1 ea		 shr	 edx, 1
  00222	2b c2		 sub	 eax, edx
  00224	3b c8		 cmp	 ecx, eax
  00226	76 0a		 jbe	 SHORT $LN58@Iput

; 2984 :             return _Max;

  00228	be fe ff ff 7f	 mov	 esi, 2147483646		; 7ffffffeH
  0022d	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00230	eb 16		 jmp	 SHORT $LN264@Iput
$LN58@Iput:

; 2985 :         }
; 2986 : 
; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00232	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  00235	3b f0		 cmp	 esi, eax
  00237	0f 42 f0	 cmovb	 esi, eax

; 825  :         ++_Capacity; // Take null terminator into consideration

  0023a	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  0023d	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00242	0f 87 5f 02 00
	00		 ja	 $LN251@Iput
$LN264@Iput:

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  00248	03 c0		 add	 eax, eax

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0024a	50		 push	 eax

; 122  :     return _Count * _Ty_size;

  0024b	0f ae e8	 lfence

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0024e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3041 :         _My_data._Mysize      = _New_size;

  00253	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]

; 3042 :         _My_data._Myres       = _New_capacity;

  00256	89 75 ec	 mov	 DWORD PTR __Groupstring$[ebp+20], esi

; 3043 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  00259	2b fb		 sub	 edi, ebx
  0025b	89 4d e8	 mov	 DWORD PTR __Groupstring$[ebp+16], ecx
  0025e	8d 0c 1b	 lea	 ecx, DWORD PTR [ebx+ebx]
  00261	89 45 b8	 mov	 DWORD PTR __New_ptr$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00264	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3043 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  00267	8d 34 01	 lea	 esi, DWORD PTR [ecx+eax]
  0026a	89 75 98	 mov	 DWORD PTR __Su$1$[ebp], esi
  0026d	8d 14 7d 02 00
	00 00		 lea	 edx, DWORD PTR [edi*2+2]

; 3044 :         if (_Old_capacity > _Small_string_capacity) {

  00274	8b 7d 9c	 mov	 edi, DWORD PTR __Old_capacity$1$[ebp]
  00277	89 55 a0	 mov	 DWORD PTR tv1226[ebp], edx
  0027a	8d 56 02	 lea	 edx, DWORD PTR [esi+2]
  0027d	89 55 b4	 mov	 DWORD PTR tv1237[ebp], edx
  00280	0f ae e8	 lfence
  00283	51		 push	 ecx
  00284	83 ff 07	 cmp	 edi, 7
  00287	76 35		 jbe	 SHORT $LN50@Iput

; 3045 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  00289	8b 75 d8	 mov	 esi, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0028c	56		 push	 esi
  0028d	50		 push	 eax
  0028e	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h

; 519  :             *_Su = _C;

  00293	8b 45 98	 mov	 eax, DWORD PTR __Su$1$[ebp]
  00296	8b 4d bc	 mov	 ecx, DWORD PTR __Kseparator$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00299	ff 75 a0	 push	 DWORD PTR tv1226[ebp]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h

; 519  :             *_Su = _C;

  0029c	66 89 08	 mov	 WORD PTR [eax], cx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1804 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  0029f	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  002a2	03 c6		 add	 eax, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  002a4	50		 push	 eax
  002a5	8b 45 b4	 mov	 eax, DWORD PTR tv1237[ebp]
  002a8	50		 push	 eax
  002a9	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3047 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

  002ae	57		 push	 edi
  002af	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  002b2	56		 push	 esi
  002b3	50		 push	 eax
  002b4	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAAV?$allocator@_W@2@QA_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Deallocate_for_capacity
  002b9	83 c4 24	 add	 esp, 36			; 00000024H

; 3048 :             _My_data._Bx._Ptr = _New_ptr;
; 3049 :         } else {

  002bc	eb 28		 jmp	 SHORT $LN270@Iput
$LN50@Iput:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  002be	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  002c1	51		 push	 ecx
  002c2	50		 push	 eax
  002c3	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h

; 519  :             *_Su = _C;

  002c8	8b 45 bc	 mov	 eax, DWORD PTR __Kseparator$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1804 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  002cb	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  002ce	ff 75 a0	 push	 DWORD PTR tv1226[ebp]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h

; 519  :             *_Su = _C;

  002d1	66 89 06	 mov	 WORD PTR [esi], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1804 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  002d4	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  002d7	03 c1		 add	 eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  002d9	50		 push	 eax
  002da	8d 46 02	 lea	 eax, DWORD PTR [esi+2]
  002dd	50		 push	 eax
  002de	e8 00 00 00 00	 call	 _memcpy
  002e3	83 c4 18	 add	 esp, 24			; 00000018H
$LN270@Iput:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1589 :                 if ('\0' < _Pg[1]) {

  002e6	8b 45 b8	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
  002e9	89 45 d8	 mov	 DWORD PTR __Groupstring$[ebp], eax
$LN51@Iput:
  002ec	8b 75 a8	 mov	 esi, DWORD PTR __Pg$1$[ebp]
  002ef	80 7e 01 00	 cmp	 BYTE PTR [esi+1], 0
  002f3	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  002f6	8b 7d ac	 mov	 edi, DWORD PTR __Prefix$1$[ebp]
  002f9	0f 4f f0	 cmovg	 esi, eax
  002fc	89 75 a8	 mov	 DWORD PTR __Pg$1$[ebp], esi
  002ff	8a 06		 mov	 al, BYTE PTR [esi]
  00301	3c 7f		 cmp	 al, 127			; 0000007fH
  00303	0f 85 7f fe ff
	ff		 jne	 $LL2@Iput
$LN266@Iput:

; 1590 :                     ++_Pg; // not last group, advance
; 1591 :                 }
; 1592 :             }
; 1593 :         }
; 1594 : 
; 1595 :         _Count = _Groupstring.size();
; 1596 : 
; 1597 :         size_t _Fillcount;
; 1598 :         if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Count) {

  00309	8b 4d a4	 mov	 ecx, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  0030c	8b 45 e8	 mov	 eax, DWORD PTR __Groupstring$[ebp+16]
  0030f	89 45 bc	 mov	 DWORD PTR __Count$GSCopy$2$[ebp], eax
  00312	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00316	8b 71 20	 mov	 esi, DWORD PTR [ecx+32]
  00319	7c 0e		 jl	 SHORT $LN10@Iput
  0031b	7f 04		 jg	 SHORT $LN265@Iput
  0031d	85 f6		 test	 esi, esi
  0031f	74 08		 je	 SHORT $LN10@Iput
$LN265@Iput:
  00321	3b f0		 cmp	 esi, eax
  00323	76 04		 jbe	 SHORT $LN10@Iput

; 1600 :         } else {
; 1601 :             _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Count;

  00325	2b f0		 sub	 esi, eax
  00327	eb 02		 jmp	 SHORT $LN9@Iput
$LN10@Iput:

; 1599 :             _Fillcount = 0;

  00329	33 f6		 xor	 esi, esi
$LN9@Iput:

; 1602 :         }
; 1603 : 
; 1604 :         ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;

  0032b	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 1605 :         if (_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal) { // put leading fill

  0032e	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  00331	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00336	83 f8 40	 cmp	 eax, 64			; 00000040H
  00339	0f 84 85 00 00
	00		 je	 $LN13@Iput
  0033f	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00344	74 3f		 je	 SHORT $LN263@Iput

; 1606 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

  00346	56		 push	 esi
  00347	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  0034a	8d 45 b0	 lea	 eax, DWORD PTR $T5[ebp]
  0034d	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  00350	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00353	50		 push	 eax
  00354	53		 push	 ebx
  00355	e8 00 00 00 00	 call	 ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep

; 1607 :             _Fillcount = 0;

  0035a	33 f6		 xor	 esi, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  0035c	83 7d ec 07	 cmp	 DWORD PTR __Groupstring$[ebp+20], 7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1608 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

  00360	57		 push	 edi
  00361	8b 10		 mov	 edx, DWORD PTR [eax]
  00363	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 435  :         value_type* _Result = _Bx._Buf;

  00366	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]

; 436  :         if (_Large_mode_engaged()) {

  00369	0f 47 45 d8	 cmova	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1608 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

  0036d	50		 push	 eax
  0036e	51		 push	 ecx
  0036f	52		 push	 edx
  00370	8d 45 b0	 lea	 eax, DWORD PTR $T6[ebp]
  00373	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx
  00376	50		 push	 eax
  00377	53		 push	 ebx
  00378	89 4d 14	 mov	 DWORD PTR __Dest$[ebp+4], ecx
  0037b	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put
  00380	83 c4 30	 add	 esp, 48			; 00000030H
  00383	eb 5f		 jmp	 SHORT $LN14@Iput
$LN263@Iput:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00385	83 7d ec 07	 cmp	 DWORD PTR __Groupstring$[ebp+20], 7

; 435  :         value_type* _Result = _Bx._Buf;

  00389	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1610 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

  0038c	57		 push	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 436  :         if (_Large_mode_engaged()) {

  0038d	0f 47 45 d8	 cmova	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1610 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

  00391	50		 push	 eax
  00392	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  00395	8d 45 b0	 lea	 eax, DWORD PTR $T7[ebp]
  00398	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0039b	50		 push	 eax
  0039c	53		 push	 ebx
  0039d	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put

; 1611 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

  003a2	56		 push	 esi
  003a3	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  003a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  003a8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  003ab	50		 push	 eax
  003ac	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  003af	8d 45 b0	 lea	 eax, DWORD PTR $T8[ebp]
  003b2	51		 push	 ecx
  003b3	50		 push	 eax
  003b4	53		 push	 ebx
  003b5	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  003b8	e8 00 00 00 00	 call	 ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep
  003bd	83 c4 30	 add	 esp, 48			; 00000030H

; 1612 :             _Fillcount = 0;

  003c0	33 f6		 xor	 esi, esi

; 1613 :         } else {

  003c2	eb 20		 jmp	 SHORT $LN14@Iput
$LN13@Iput:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  003c4	83 7d ec 07	 cmp	 DWORD PTR __Groupstring$[ebp+20], 7

; 435  :         value_type* _Result = _Bx._Buf;

  003c8	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1614 :             _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  003cb	57		 push	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 436  :         if (_Large_mode_engaged()) {

  003cc	0f 47 45 d8	 cmova	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1614 :             _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  003d0	50		 push	 eax
  003d1	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  003d4	8d 45 b0	 lea	 eax, DWORD PTR $T9[ebp]
  003d7	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  003da	50		 push	 eax
  003db	53		 push	 ebx
  003dc	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put
  003e1	83 c4 18	 add	 esp, 24			; 00000018H
$LN14@Iput:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2272 :         return _Mypair._Myval2._Myptr()[_Off];

  003e4	8b 10		 mov	 edx, DWORD PTR [eax]
  003e6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 435  :         value_type* _Result = _Bx._Buf;

  003e9	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]

; 453  :         return _Myres > _Small_string_capacity;

  003ec	83 7d ec 07	 cmp	 DWORD PTR __Groupstring$[ebp+20], 7

; 2272 :         return _Mypair._Myval2._Myptr()[_Off];

  003f0	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx

; 436  :         if (_Large_mode_engaged()) {

  003f3	0f 47 45 d8	 cmova	 eax, DWORD PTR __Groupstring$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1617 :         _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

  003f7	29 7d bc	 sub	 DWORD PTR __Count$GSCopy$2$[ebp], edi
  003fa	ff 75 bc	 push	 DWORD PTR __Count$GSCopy$2$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2272 :         return _Mypair._Myval2._Myptr()[_Off];

  003fd	89 4d 14	 mov	 DWORD PTR __Dest$[ebp+4], ecx
  00400	8d 04 78	 lea	 eax, DWORD PTR [eax+edi*2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1617 :         _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

  00403	50		 push	 eax
  00404	51		 push	 ecx
  00405	52		 push	 edx
  00406	8d 45 b0	 lea	 eax, DWORD PTR $T2[ebp]
  00409	50		 push	 eax
  0040a	53		 push	 ebx
  0040b	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 284  :         _Wide                      = _Newwidth;

  00410	8b 55 a4	 mov	 edx, DWORD PTR __Iosbase$GSCopy$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1619 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

  00413	56		 push	 esi
  00414	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  00417	8b 08		 mov	 ecx, DWORD PTR [eax]
  00419	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0041c	8b 75 94	 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  0041f	50		 push	 eax
  00420	51		 push	 ecx
  00421	56		 push	 esi
  00422	53		 push	 ebx
  00423	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  00426	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 284  :         _Wide                      = _Newwidth;

  00429	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0
  00430	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1619 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

  00437	e8 00 00 00 00	 call	 ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  0043c	8b 4d d4	 mov	 ecx, DWORD PTR __Grouping$[ebp+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1619 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

  0043f	83 c4 30	 add	 esp, 48			; 00000030H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00442	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3083 :         if (_My_data._Large_mode_engaged()) {

  00445	76 28		 jbe	 SHORT $LN184@Iput
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00447	8b 55 c0	 mov	 edx, DWORD PTR __Grouping$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0044a	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0044b	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0044d	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00453	72 10		 jb	 SHORT $LN189@Iput

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00455	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00458	83 c1 23	 add	 ecx, 35			; 00000023H
  0045b	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0045d	83 c0 fc	 add	 eax, -4			; fffffffcH
  00460	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00463	77 51		 ja	 SHORT $LN272@Iput
$LN189@Iput:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00465	51		 push	 ecx
  00466	52		 push	 edx
  00467	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0046c	83 c4 08	 add	 esp, 8
$LN184@Iput:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1383 :         _Tidy_deallocate();

  0046f	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]

; 3090 :         _My_data._Mysize = 0;

  00472	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR __Grouping$[ebp+16], 0

; 3091 :         _My_data._Myres  = _Small_string_capacity;

  00479	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR __Grouping$[ebp+20], 15 ; 0000000fH

; 3092 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00480	c6 45 c0 00	 mov	 BYTE PTR __Grouping$[ebp], 0

; 1383 :         _Tidy_deallocate();

  00484	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1619 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

  00489	8b c6		 mov	 eax, esi

; 1620 :     }

  0048b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0048e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00495	59		 pop	 ecx
  00496	5f		 pop	 edi
  00497	5e		 pop	 esi
  00498	5b		 pop	 ebx
  00499	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0049c	33 cd		 xor	 ecx, ebp
  0049e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004a3	8b e5		 mov	 esp, ebp
  004a5	5d		 pop	 ebp
  004a6	c3		 ret	 0
$LN251@Iput:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  004a7	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN250@Iput:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3030 :             _Xlen_string(); // result too long

  004ac	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN249@Iput:

; 470  :             _Xran();

  004b1	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
$LN272@Iput:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  004b6	6a 00		 push	 0
  004b8	6a 00		 push	 0
  004ba	6a 00		 push	 0
  004bc	6a 00		 push	 0
  004be	6a 00		 push	 0
  004c0	e8 00 00 00 00	 call	 __invoke_watson
$LN268@Iput:
  004c5	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$0:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$2:
  00010	8d 4d b0	 lea	 ecx, DWORD PTR $T4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$3:
  00018	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00020	cc		 int	 3
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
  00024	cc		 int	 3
__ehhandler$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z:
  00025	90		 npad	 1
  00026	90		 npad	 1
  00027	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002e	8b 4a 90	 mov	 ecx, DWORD PTR [edx-112]
  00031	33 c8		 xor	 ecx, eax
  00033	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00038	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0003b	33 c8		 xor	 ecx, eax
  0003d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00042	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z
  00047	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Iput
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?_Ffmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADDH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 1
__Flags$ = 20						; size = 4
?_Ffmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADDH@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ffmt, COMDAT

; 1416 :         char* _Fmt, char _Spec, ios_base::fmtflags _Flags) const { // generate sprintf format for floating-point

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1417 :         char* _Ptr = _Fmt;
; 1418 :         *_Ptr++    = '%';
; 1419 : 
; 1420 :         if (_Flags & ios_base::showpos) {

  00003	8b 55 14	 mov	 edx, DWORD PTR __Flags$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR __Fmt$[ebp]
  0000a	c6 06 25	 mov	 BYTE PTR [esi], 37	; 00000025H
  0000d	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00010	f6 c2 20	 test	 dl, 32			; 00000020H
  00013	74 04		 je	 SHORT $LN2@Ffmt

; 1421 :             *_Ptr++ = '+';

  00015	c6 00 2b	 mov	 BYTE PTR [eax], 43	; 0000002bH
  00018	40		 inc	 eax
$LN2@Ffmt:

; 1422 :         }
; 1423 : 
; 1424 :         if (_Flags & ios_base::showpoint) {

  00019	f6 c2 10	 test	 dl, 16			; 00000010H
  0001c	74 04		 je	 SHORT $LN3@Ffmt

; 1425 :             *_Ptr++ = '#';

  0001e	c6 00 23	 mov	 BYTE PTR [eax], 35	; 00000023H
  00021	40		 inc	 eax
$LN3@Ffmt:

; 1426 :         }
; 1427 : 
; 1428 :         *_Ptr++ = '.';
; 1429 :         *_Ptr++ = '*'; // for precision argument
; 1430 :         if (_Spec != '\0') {

  00022	8a 4d 10	 mov	 cl, BYTE PTR __Spec$[ebp]
  00025	66 c7 00 2e 2a	 mov	 WORD PTR [eax], 10798	; 00002a2eH
  0002a	83 c0 02	 add	 eax, 2
  0002d	84 c9		 test	 cl, cl
  0002f	74 03		 je	 SHORT $LN4@Ffmt

; 1431 :             *_Ptr++ = _Spec; // 'L' qualifier for long double only

  00031	88 08		 mov	 BYTE PTR [eax], cl
  00033	40		 inc	 eax
$LN4@Ffmt:

; 1432 :         }
; 1433 : 
; 1434 :         char _Ch; // specifier
; 1435 :         ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;

  00034	8b ca		 mov	 ecx, edx
  00036	81 e1 00 30 00
	00		 and	 ecx, 12288		; 00003000H

; 1436 :         if (_Flags & ios_base::uppercase) {

  0003c	f6 c2 04	 test	 dl, 4
  0003f	74 45		 je	 SHORT $LN5@Ffmt

; 1437 :             if (_Ffl == ios_base::fixed) {

  00041	81 f9 00 20 00
	00		 cmp	 ecx, 8192		; 00002000H
  00047	75 0d		 jne	 SHORT $LN7@Ffmt

; 1438 :                 _Ch = 'F';

  00049	b1 46		 mov	 cl, 70			; 00000046H

; 1452 :                 _Ch = 'e';
; 1453 :             } else {
; 1454 :                 _Ch = 'g';
; 1455 :             }
; 1456 :         }
; 1457 :         *_Ptr++ = _Ch;

  0004b	88 08		 mov	 BYTE PTR [eax], cl

; 1458 : 
; 1459 :         *_Ptr = '\0';

  0004d	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1460 :         return _Fmt;

  00051	8b c6		 mov	 eax, esi
  00053	5e		 pop	 esi

; 1461 :     }

  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
$LN7@Ffmt:

; 1439 :             } else if (_Ffl == (ios_base::scientific | ios_base::fixed)) {

  00056	81 f9 00 30 00
	00		 cmp	 ecx, 12288		; 00003000H
  0005c	75 0d		 jne	 SHORT $LN9@Ffmt

; 1440 :                 _Ch = 'A';

  0005e	b1 41		 mov	 cl, 65			; 00000041H

; 1452 :                 _Ch = 'e';
; 1453 :             } else {
; 1454 :                 _Ch = 'g';
; 1455 :             }
; 1456 :         }
; 1457 :         *_Ptr++ = _Ch;

  00060	88 08		 mov	 BYTE PTR [eax], cl

; 1458 : 
; 1459 :         *_Ptr = '\0';

  00062	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1460 :         return _Fmt;

  00066	8b c6		 mov	 eax, esi
  00068	5e		 pop	 esi

; 1461 :     }

  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
$LN9@Ffmt:

; 1441 :             } else if (_Ffl == ios_base::scientific) {

  0006b	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00071	0f 95 c1	 setne	 cl
  00074	8d 0c 4d 45 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+69]

; 1452 :                 _Ch = 'e';
; 1453 :             } else {
; 1454 :                 _Ch = 'g';
; 1455 :             }
; 1456 :         }
; 1457 :         *_Ptr++ = _Ch;

  0007b	88 08		 mov	 BYTE PTR [eax], cl

; 1458 : 
; 1459 :         *_Ptr = '\0';

  0007d	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1460 :         return _Fmt;

  00081	8b c6		 mov	 eax, esi
  00083	5e		 pop	 esi

; 1461 :     }

  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
$LN5@Ffmt:

; 1442 :                 _Ch = 'E';
; 1443 :             } else {
; 1444 :                 _Ch = 'G';
; 1445 :             }
; 1446 :         } else {
; 1447 :             if (_Ffl == ios_base::fixed) {

  00086	81 f9 00 20 00
	00		 cmp	 ecx, 8192		; 00002000H
  0008c	75 0d		 jne	 SHORT $LN13@Ffmt

; 1448 :                 _Ch = 'f';

  0008e	b1 66		 mov	 cl, 102			; 00000066H

; 1452 :                 _Ch = 'e';
; 1453 :             } else {
; 1454 :                 _Ch = 'g';
; 1455 :             }
; 1456 :         }
; 1457 :         *_Ptr++ = _Ch;

  00090	88 08		 mov	 BYTE PTR [eax], cl

; 1458 : 
; 1459 :         *_Ptr = '\0';

  00092	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1460 :         return _Fmt;

  00096	8b c6		 mov	 eax, esi
  00098	5e		 pop	 esi

; 1461 :     }

  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
$LN13@Ffmt:

; 1449 :             } else if (_Ffl == (ios_base::scientific | ios_base::fixed)) {

  0009b	81 f9 00 30 00
	00		 cmp	 ecx, 12288		; 00003000H
  000a1	75 0d		 jne	 SHORT $LN15@Ffmt

; 1450 :                 _Ch = 'a';

  000a3	b1 61		 mov	 cl, 97			; 00000061H

; 1452 :                 _Ch = 'e';
; 1453 :             } else {
; 1454 :                 _Ch = 'g';
; 1455 :             }
; 1456 :         }
; 1457 :         *_Ptr++ = _Ch;

  000a5	88 08		 mov	 BYTE PTR [eax], cl

; 1458 : 
; 1459 :         *_Ptr = '\0';

  000a7	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1460 :         return _Fmt;

  000ab	8b c6		 mov	 eax, esi
  000ad	5e		 pop	 esi

; 1461 :     }

  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
$LN15@Ffmt:

; 1451 :             } else if (_Ffl == ios_base::scientific) {

  000b0	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000b6	0f 95 c1	 setne	 cl
  000b9	8d 0c 4d 65 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+101]

; 1452 :                 _Ch = 'e';
; 1453 :             } else {
; 1454 :                 _Ch = 'g';
; 1455 :             }
; 1456 :         }
; 1457 :         *_Ptr++ = _Ch;

  000c0	88 08		 mov	 BYTE PTR [eax], cl

; 1458 : 
; 1459 :         *_Ptr = '\0';

  000c2	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1460 :         return _Fmt;

  000c6	8b c6		 mov	 eax, esi
  000c8	5e		 pop	 esi

; 1461 :     }

  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
?_Ffmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADDH@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ffmt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBX@Z
_TEXT	SEGMENT
__Buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 4
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBX@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put, COMDAT
; _this$ = ecx

; 1407 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const void* _Val) const { // put formatted void pointer to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 1c	 mov	 eax, DWORD PTR __Val$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	56		 push	 esi
  00018	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0001b	57		 push	 edi

; 1408 :         char _Buf[2 * _Max_int_dig];
; 1409 : 
; 1410 :         return _Iput(

  0001c	50		 push	 eax
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  00022	8d 45 bc	 lea	 eax, DWORD PTR __Buf$[ebp]
  00025	8b f9		 mov	 edi, ecx
  00027	6a 40		 push	 64			; 00000040H
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _sprintf_s
  0002f	50		 push	 eax
  00030	8d 45 bc	 lea	 eax, DWORD PTR __Buf$[ebp]
  00033	50		 push	 eax
  00034	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00037	56		 push	 esi
  00038	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0003b	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  0003e	53		 push	 ebx
  0003f	57		 push	 edi
  00040	e8 00 00 00 00	 call	 ?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Iput

; 1411 :             _Dest, _Iosbase, _Fill, _Buf, static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), "%p", _Val)));
; 1412 :     }

  00045	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00048	83 c4 30	 add	 esp, 48			; 00000030H
  0004b	8b c3		 mov	 eax, ebx
  0004d	33 cd		 xor	 ecx, ebp
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 18 00	 ret	 24			; 00000018H
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBX@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$1$ = -68				; size = 4
__Iosbase$GSCopy$1$ = -64				; size = 4
__Precision$ = -60					; size = 8
__Ptwo$2 = -56						; size = 4
__Is_finite$ = -56					; size = 1
_this$GSCopy$1$ = -52					; size = 4
__Buf$ = -48						; size = 24
__Fmt$ = -24						; size = 8
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 8
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put, COMDAT
; _this$ = ecx

; 1379 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long double _Val) const { // put formatted long double to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d cc	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00030	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 860  :         _My_data._Mysize = 0;

  00033	33 d2		 xor	 edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1379 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long double _Val) const { // put formatted long double to _Dest

  00035	89 45 bc	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
  00038	8b 45 14	 mov	 eax, DWORD PTR __Iosbase$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0003b	0f 11 45 d0	 movups	 XMMWORD PTR __Buf$[ebp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1379 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long double _Val) const { // put formatted long double to _Dest

  0003f	89 45 c0	 mov	 DWORD PTR __Iosbase$GSCopy$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 860  :         _My_data._Mysize = 0;

  00042	89 55 e0	 mov	 DWORD PTR __Buf$[ebp+16], edx

; 861  :         _My_data._Myres  = _Small_string_capacity;

  00045	c7 45 e4 0f 00
	00 00		 mov	 DWORD PTR __Buf$[ebp+20], 15 ; 0000000fH

; 862  :         _My_data._Activate_SSO_buffer();
; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0004c	88 55 d0	 mov	 BYTE PTR __Buf$[ebp], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1382 :         const auto _Float_flags     = _Iosbase.flags() & ios_base::floatfield;

  0004f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00052	81 e1 00 30 00
	00		 and	 ecx, 12288		; 00003000H
  00058	89 55 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edx

; 1383 :         const bool _Is_fixed        = _Float_flags == ios_base::fixed;
; 1384 :         const bool _Is_hex          = _Float_flags == (ios_base::fixed | ios_base::scientific);

  0005b	81 f9 00 30 00
	00		 cmp	 ecx, 12288		; 00003000H

; 1385 :         const streamsize _Precision = _Is_hex ? -1 : _Iosbase.precision(); // precision setting

  00061	75 0e		 jne	 SHORT $LN4@do_put
  00063	83 cf ff	 or	 edi, -1

; 1386 :         const int _Desired_precision =
; 1387 :             _Float_put_desired_precision<long double>(_Precision, _Float_flags); // desired precision
; 1388 :         size_t _Bufsize = static_cast<size_t>(_Desired_precision);

  00066	8d 72 0d	 lea	 esi, DWORD PTR [edx+13]
  00069	89 7d c8	 mov	 DWORD PTR __Precision$[ebp+4], edi

; 1186 :             return ((LDBL_MANT_DIG - 1) + 3) / 4;

  0006c	e9 8a 00 00 00	 jmp	 $LN2@do_put
$LN4@do_put:

; 1385 :         const streamsize _Precision = _Is_hex ? -1 : _Iosbase.precision(); // precision setting

  00071	8b 70 1c	 mov	 esi, DWORD PTR [eax+28]
  00074	8b 78 18	 mov	 edi, DWORD PTR [eax+24]

; 1192 :     if (_Precision > 0) {

  00077	85 f6		 test	 esi, esi
  00079	7c 0a		 jl	 SHORT $LN31@do_put
  0007b	7f 04		 jg	 SHORT $LN115@do_put
  0007d	85 ff		 test	 edi, edi
  0007f	74 04		 je	 SHORT $LN31@do_put
$LN115@do_put:

; 1193 :         return static_cast<int>(_Precision);

  00081	8b f7		 mov	 esi, edi
  00083	eb 18		 jmp	 SHORT $LN34@do_put
$LN31@do_put:

; 1194 :     } else if (_Precision == 0) {

  00085	8b c7		 mov	 eax, edi
  00087	0b c6		 or	 eax, esi
  00089	75 0d		 jne	 SHORT $LN33@do_put

; 1195 :         const bool _Is_default_float = _Float_flags == 0;

  0008b	85 c9		 test	 ecx, ecx

; 1196 :         if (_Is_default_float) {

  0008d	75 05		 jne	 SHORT $LN35@do_put

; 1386 :         const int _Desired_precision =
; 1387 :             _Float_put_desired_precision<long double>(_Precision, _Float_flags); // desired precision
; 1388 :         size_t _Bufsize = static_cast<size_t>(_Desired_precision);

  0008f	8d 70 01	 lea	 esi, DWORD PTR [eax+1]

; 1197 :             return 1;

  00092	eb 67		 jmp	 SHORT $LN2@do_put
$LN35@do_put:

; 1198 :         } else {
; 1199 :             return 0;

  00094	33 f6		 xor	 esi, esi
  00096	eb 05		 jmp	 SHORT $LN34@do_put
$LN33@do_put:

; 1200 :         }
; 1201 :     } else {
; 1202 :         constexpr int _Default_precision = 6;
; 1203 :         return _Default_precision;

  00098	be 06 00 00 00	 mov	 esi, 6
$LN34@do_put:

; 1389 :         if (_Is_fixed && 1e10 < _CSTD fabsl(_Val)) { // f or F format

  0009d	81 f9 00 20 00
	00		 cmp	 ecx, 8192		; 00002000H
  000a3	75 56		 jne	 SHORT $LN2@do_put
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 882  :         return fabs((double)_X);

  000a5	f2 0f 10 4d 1c	 movsd	 xmm1, QWORD PTR __Val$[ebp]
  000aa	0f 28 c1	 movaps	 xmm0, xmm1
  000ad	0f 54 05 00 00
	00 00		 andps	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1389 :         if (_Is_fixed && 1e10 < _CSTD fabsl(_Val)) { // f or F format

  000b4	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@4202a05f20000000
  000bc	76 3d		 jbe	 SHORT $LN2@do_put
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 903  :         return frexp((double)_X, _Y);

  000be	8d 45 c8	 lea	 eax, DWORD PTR __Ptwo$2[ebp]
  000c1	50		 push	 eax
  000c2	83 ec 08	 sub	 esp, 8
  000c5	0f ae e8	 lfence
  000c8	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  000cd	e8 00 00 00 00	 call	 _frexp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1392 :             _Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

  000d2	8b 45 c8	 mov	 eax, DWORD PTR __Ptwo$2[ebp]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 903  :         return frexp((double)_X, _Y);

  000d5	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1392 :             _Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

  000d8	99		 cdq
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 903  :         return frexp((double)_X, _Y);

  000d9	dd d8		 fstp	 ST(0)
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1392 :             _Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

  000db	33 c2		 xor	 eax, edx
  000dd	2b c2		 sub	 eax, edx
  000df	69 c8 97 75 00
	00		 imul	 ecx, eax, 30103
  000e5	b8 89 b5 f8 14	 mov	 eax, 351843721		; 14f8b589H
  000ea	f7 e9		 imul	 ecx
  000ec	c1 fa 0d	 sar	 edx, 13			; 0000000dH
  000ef	8b c2		 mov	 eax, edx
  000f1	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000f4	03 c2		 add	 eax, edx
  000f6	8b 55 e0	 mov	 edx, DWORD PTR __Buf$[ebp+16]
  000f9	03 f0		 add	 esi, eax
$LN2@do_put:

; 1393 :         }
; 1394 : 
; 1395 :         _Buf.resize(_Bufsize + 50); // add fudge factor

  000fb	83 c6 32	 add	 esi, 50			; 00000032H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2389 :         if (_New_size <= _Old_size) {

  000fe	3b f2		 cmp	 esi, edx
  00100	77 14		 ja	 SHORT $LN39@do_put

; 453  :         return _Myres > _Small_string_capacity;

  00102	83 7d e4 0f	 cmp	 DWORD PTR __Buf$[ebp+20], 15 ; 0000000fH

; 435  :         value_type* _Result = _Bx._Buf;

  00106	8d 45 d0	 lea	 eax, DWORD PTR __Buf$[ebp]

; 3076 :         _Mypair._Myval2._Mysize = _New_size;

  00109	89 75 e0	 mov	 DWORD PTR __Buf$[ebp+16], esi

; 436  :         if (_Large_mode_engaged()) {

  0010c	0f 47 45 d0	 cmova	 eax, DWORD PTR __Buf$[ebp]

; 3077 :         _Traits::assign(_Mypair._Myval2._Myptr()[_New_size], _Elem());

  00110	c6 04 30 00	 mov	 BYTE PTR [eax+esi], 0

; 2391 :         } else {

  00114	eb 10		 jmp	 SHORT $LN40@do_put
$LN39@do_put:

; 2392 :             append(_New_size - _Old_size, _Ch);

  00116	6a 00		 push	 0
  00118	2b f2		 sub	 esi, edx
  0011a	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  0011d	56		 push	 esi
  0011e	0f ae e8	 lfence
  00121	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN40@do_put:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 335  :         return _ldtest(&_X);

  00126	dd 45 1c	 fld	 QWORD PTR __Val$[ebp]
  00129	83 ec 08	 sub	 esp, 8
  0012c	dd 1c 24	 fstp	 QWORD PTR [esp]
  0012f	e8 00 00 00 00	 call	 __ldclass
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1396 :         const bool _Is_finite      = (_STD isfinite)(_Val);

  00134	8b 75 c0	 mov	 esi, DWORD PTR __Iosbase$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 437  :         return fpclassify(_X) <= 0;

  00137	66 85 c0	 test	 ax, ax
  0013a	0f 9e c2	 setle	 dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1396 :         const bool _Is_finite      = (_STD isfinite)(_Val);

  0013d	88 55 c8	 mov	 BYTE PTR __Is_finite$[ebp], dl
  00140	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 1399 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

  00143	8b c1		 mov	 eax, ecx
  00145	83 e0 ef	 and	 eax, -17		; ffffffefH
  00148	84 d2		 test	 dl, dl
  0014a	0f 44 c8	 cmove	 ecx, eax
  0014d	8d 45 e8	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00150	51		 push	 ecx
  00151	6a 4c		 push	 76			; 0000004cH
  00153	50		 push	 eax
  00154	ff 75 cc	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  00157	e8 00 00 00 00	 call	 ?_Ffmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ffmt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  0015c	83 7d e4 0f	 cmp	 DWORD PTR __Buf$[ebp+20], 15 ; 0000000fH

; 435  :         value_type* _Result = _Bx._Buf;

  00160	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1399 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

  00163	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR __Val$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 436  :         if (_Large_mode_engaged()) {

  00168	0f 47 4d d0	 cmova	 ecx, DWORD PTR __Buf$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1399 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

  0016c	83 c4 10	 add	 esp, 16			; 00000010H
  0016f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00174	57		 push	 edi
  00175	50		 push	 eax
  00176	ff 75 e0	 push	 DWORD PTR __Buf$[ebp+16]
  00179	51		 push	 ecx
  0017a	e8 00 00 00 00	 call	 _sprintf_s
  0017f	83 c4 18	 add	 esp, 24			; 00000018H

; 1402 :         return _Fput_v3(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen, _Is_finite);

  00182	8b 4d cc	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00185	83 7d e4 0f	 cmp	 DWORD PTR __Buf$[ebp+20], 15 ; 0000000fH

; 444  :         const value_type* _Result = _Bx._Buf;

  00189	8d 55 d0	 lea	 edx, DWORD PTR __Buf$[ebp]

; 445  :         if (_Large_mode_engaged()) {

  0018c	0f 47 55 d0	 cmova	 edx, DWORD PTR __Buf$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1402 :         return _Fput_v3(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen, _Is_finite);

  00190	ff 75 c8	 push	 DWORD PTR __Is_finite$[ebp]
  00193	50		 push	 eax
  00194	52		 push	 edx
  00195	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00198	56		 push	 esi
  00199	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0019c	8b 75 bc	 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  0019f	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  001a2	56		 push	 esi
  001a3	e8 00 00 00 00	 call	 ??$_Fput_v3@$0A@@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@1@V21@AAVios_base@1@_WPBDI_N@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Fput_v3<0>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  001a8	8b 4d e4	 mov	 ecx, DWORD PTR __Buf$[ebp+20]
  001ab	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3083 :         if (_My_data._Large_mode_engaged()) {

  001ae	76 28		 jbe	 SHORT $LN98@do_put
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001b0	8b 55 d0	 mov	 edx, DWORD PTR __Buf$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  001b3	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001b4	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  001b6	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  001bc	72 10		 jb	 SHORT $LN103@do_put

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001be	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  001c1	83 c1 23	 add	 ecx, 35			; 00000023H
  001c4	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001c6	83 c0 fc	 add	 eax, -4			; fffffffcH
  001c9	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001cc	77 29		 ja	 SHORT $LN119@do_put
$LN103@do_put:

; 289  :         ::operator delete(_Ptr, _Bytes);

  001ce	51		 push	 ecx
  001cf	52		 push	 edx
  001d0	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001d5	83 c4 08	 add	 esp, 8
$LN98@do_put:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1402 :         return _Fput_v3(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen, _Is_finite);

  001d8	8b c6		 mov	 eax, esi

; 1403 :     }

  001da	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001dd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e4	59		 pop	 ecx
  001e5	5f		 pop	 edi
  001e6	5e		 pop	 esi
  001e7	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ea	33 cd		 xor	 ecx, ebp
  001ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f1	8b e5		 mov	 esp, ebp
  001f3	5d		 pop	 ebp
  001f4	c2 1c 00	 ret	 28			; 0000001cH
$LN119@do_put:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001f7	6a 00		 push	 0
  001f9	6a 00		 push	 0
  001fb	6a 00		 push	 0
  001fd	6a 00		 push	 0
  001ff	6a 00		 push	 0
  00201	e8 00 00 00 00	 call	 __invoke_watson
$LN117@do_put:
  00206	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$1$ = -68				; size = 4
__Iosbase$GSCopy$1$ = -64				; size = 4
__Precision$ = -60					; size = 8
__Ptwo$2 = -56						; size = 4
__Is_finite$ = -56					; size = 1
_this$GSCopy$1$ = -52					; size = 4
__Buf$ = -48						; size = 24
__Fmt$ = -24						; size = 8
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 8
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put, COMDAT
; _this$ = ecx

; 1352 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, double _Val) const { // put formatted double to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d cc	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00030	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 860  :         _My_data._Mysize = 0;

  00033	33 d2		 xor	 edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1352 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, double _Val) const { // put formatted double to _Dest

  00035	89 45 bc	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
  00038	8b 45 14	 mov	 eax, DWORD PTR __Iosbase$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0003b	0f 11 45 d0	 movups	 XMMWORD PTR __Buf$[ebp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1352 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, double _Val) const { // put formatted double to _Dest

  0003f	89 45 c0	 mov	 DWORD PTR __Iosbase$GSCopy$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 860  :         _My_data._Mysize = 0;

  00042	89 55 e0	 mov	 DWORD PTR __Buf$[ebp+16], edx

; 861  :         _My_data._Myres  = _Small_string_capacity;

  00045	c7 45 e4 0f 00
	00 00		 mov	 DWORD PTR __Buf$[ebp+20], 15 ; 0000000fH

; 862  :         _My_data._Activate_SSO_buffer();
; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0004c	88 55 d0	 mov	 BYTE PTR __Buf$[ebp], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1355 :         const auto _Float_flags     = _Iosbase.flags() & ios_base::floatfield;

  0004f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00052	81 e1 00 30 00
	00		 and	 ecx, 12288		; 00003000H
  00058	89 55 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edx

; 1356 :         const bool _Is_fixed        = _Float_flags == ios_base::fixed;
; 1357 :         const bool _Is_hex          = _Float_flags == (ios_base::fixed | ios_base::scientific);

  0005b	81 f9 00 30 00
	00		 cmp	 ecx, 12288		; 00003000H

; 1358 :         const streamsize _Precision = _Is_hex ? -1 : _Iosbase.precision(); // precision setting

  00061	75 0e		 jne	 SHORT $LN4@do_put
  00063	83 cf ff	 or	 edi, -1

; 1359 :         const int _Desired_precision =
; 1360 :             _Float_put_desired_precision<double>(_Precision, _Float_flags); // desired precision
; 1361 :         size_t _Bufsize = static_cast<size_t>(_Desired_precision);

  00066	8d 72 0d	 lea	 esi, DWORD PTR [edx+13]
  00069	89 7d c8	 mov	 DWORD PTR __Precision$[ebp+4], edi

; 1184 :             return ((DBL_MANT_DIG - 1) + 3) / 4;

  0006c	e9 8a 00 00 00	 jmp	 $LN2@do_put
$LN4@do_put:

; 1358 :         const streamsize _Precision = _Is_hex ? -1 : _Iosbase.precision(); // precision setting

  00071	8b 70 1c	 mov	 esi, DWORD PTR [eax+28]
  00074	8b 78 18	 mov	 edi, DWORD PTR [eax+24]

; 1192 :     if (_Precision > 0) {

  00077	85 f6		 test	 esi, esi
  00079	7c 0a		 jl	 SHORT $LN31@do_put
  0007b	7f 04		 jg	 SHORT $LN111@do_put
  0007d	85 ff		 test	 edi, edi
  0007f	74 04		 je	 SHORT $LN31@do_put
$LN111@do_put:

; 1193 :         return static_cast<int>(_Precision);

  00081	8b f7		 mov	 esi, edi
  00083	eb 18		 jmp	 SHORT $LN34@do_put
$LN31@do_put:

; 1194 :     } else if (_Precision == 0) {

  00085	8b c7		 mov	 eax, edi
  00087	0b c6		 or	 eax, esi
  00089	75 0d		 jne	 SHORT $LN33@do_put

; 1195 :         const bool _Is_default_float = _Float_flags == 0;

  0008b	85 c9		 test	 ecx, ecx

; 1196 :         if (_Is_default_float) {

  0008d	75 05		 jne	 SHORT $LN35@do_put

; 1359 :         const int _Desired_precision =
; 1360 :             _Float_put_desired_precision<double>(_Precision, _Float_flags); // desired precision
; 1361 :         size_t _Bufsize = static_cast<size_t>(_Desired_precision);

  0008f	8d 70 01	 lea	 esi, DWORD PTR [eax+1]

; 1197 :             return 1;

  00092	eb 67		 jmp	 SHORT $LN2@do_put
$LN35@do_put:

; 1198 :         } else {
; 1199 :             return 0;

  00094	33 f6		 xor	 esi, esi
  00096	eb 05		 jmp	 SHORT $LN34@do_put
$LN33@do_put:

; 1200 :         }
; 1201 :     } else {
; 1202 :         constexpr int _Default_precision = 6;
; 1203 :         return _Default_precision;

  00098	be 06 00 00 00	 mov	 esi, 6
$LN34@do_put:

; 1362 :         if (_Is_fixed && 1e10 < _CSTD fabs(_Val)) { // f or F format

  0009d	81 f9 00 20 00
	00		 cmp	 ecx, 8192		; 00002000H
  000a3	75 56		 jne	 SHORT $LN2@do_put
  000a5	f2 0f 10 4d 1c	 movsd	 xmm1, QWORD PTR __Val$[ebp]
  000aa	0f 28 c1	 movaps	 xmm0, xmm1
  000ad	0f 54 05 00 00
	00 00		 andps	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  000b4	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@4202a05f20000000
  000bc	76 3d		 jbe	 SHORT $LN2@do_put

; 1363 :             int _Ptwo;
; 1364 :             (void) _CSTD frexp(_Val, &_Ptwo);

  000be	8d 45 c8	 lea	 eax, DWORD PTR __Ptwo$2[ebp]
  000c1	50		 push	 eax
  000c2	83 ec 08	 sub	 esp, 8
  000c5	0f ae e8	 lfence
  000c8	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  000cd	e8 00 00 00 00	 call	 _frexp

; 1365 :             _Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

  000d2	8b 45 c8	 mov	 eax, DWORD PTR __Ptwo$2[ebp]
  000d5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d8	99		 cdq
  000d9	dd d8		 fstp	 ST(0)
  000db	33 c2		 xor	 eax, edx
  000dd	2b c2		 sub	 eax, edx
  000df	69 c8 97 75 00
	00		 imul	 ecx, eax, 30103
  000e5	b8 89 b5 f8 14	 mov	 eax, 351843721		; 14f8b589H
  000ea	f7 e9		 imul	 ecx
  000ec	c1 fa 0d	 sar	 edx, 13			; 0000000dH
  000ef	8b c2		 mov	 eax, edx
  000f1	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000f4	03 c2		 add	 eax, edx
  000f6	8b 55 e0	 mov	 edx, DWORD PTR __Buf$[ebp+16]
  000f9	03 f0		 add	 esi, eax
$LN2@do_put:

; 1366 :         }
; 1367 : 
; 1368 :         _Buf.resize(_Bufsize + 50); // add fudge factor

  000fb	83 c6 32	 add	 esi, 50			; 00000032H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2389 :         if (_New_size <= _Old_size) {

  000fe	3b f2		 cmp	 esi, edx
  00100	77 14		 ja	 SHORT $LN39@do_put

; 453  :         return _Myres > _Small_string_capacity;

  00102	83 7d e4 0f	 cmp	 DWORD PTR __Buf$[ebp+20], 15 ; 0000000fH

; 435  :         value_type* _Result = _Bx._Buf;

  00106	8d 45 d0	 lea	 eax, DWORD PTR __Buf$[ebp]

; 3076 :         _Mypair._Myval2._Mysize = _New_size;

  00109	89 75 e0	 mov	 DWORD PTR __Buf$[ebp+16], esi

; 436  :         if (_Large_mode_engaged()) {

  0010c	0f 47 45 d0	 cmova	 eax, DWORD PTR __Buf$[ebp]

; 3077 :         _Traits::assign(_Mypair._Myval2._Myptr()[_New_size], _Elem());

  00110	c6 04 30 00	 mov	 BYTE PTR [eax+esi], 0

; 2391 :         } else {

  00114	eb 10		 jmp	 SHORT $LN40@do_put
$LN39@do_put:

; 2392 :             append(_New_size - _Old_size, _Ch);

  00116	6a 00		 push	 0
  00118	2b f2		 sub	 esi, edx
  0011a	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  0011d	56		 push	 esi
  0011e	0f ae e8	 lfence
  00121	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN40@do_put:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 326  :         return _dtest(&_X);

  00126	dd 45 1c	 fld	 QWORD PTR __Val$[ebp]
  00129	83 ec 08	 sub	 esp, 8
  0012c	dd 1c 24	 fstp	 QWORD PTR [esp]
  0012f	e8 00 00 00 00	 call	 __dclass
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1369 :         const bool _Is_finite      = (_STD isfinite)(_Val);

  00134	8b 75 c0	 mov	 esi, DWORD PTR __Iosbase$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 437  :         return fpclassify(_X) <= 0;

  00137	66 85 c0	 test	 ax, ax
  0013a	0f 9e c2	 setle	 dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1369 :         const bool _Is_finite      = (_STD isfinite)(_Val);

  0013d	88 55 c8	 mov	 BYTE PTR __Is_finite$[ebp], dl
  00140	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 1372 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

  00143	8b c1		 mov	 eax, ecx
  00145	83 e0 ef	 and	 eax, -17		; ffffffefH
  00148	84 d2		 test	 dl, dl
  0014a	0f 44 c8	 cmove	 ecx, eax
  0014d	8d 45 e8	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00150	51		 push	 ecx
  00151	6a 00		 push	 0
  00153	50		 push	 eax
  00154	ff 75 cc	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  00157	e8 00 00 00 00	 call	 ?_Ffmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ffmt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  0015c	83 7d e4 0f	 cmp	 DWORD PTR __Buf$[ebp+20], 15 ; 0000000fH

; 435  :         value_type* _Result = _Bx._Buf;

  00160	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1372 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

  00163	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR __Val$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 436  :         if (_Large_mode_engaged()) {

  00168	0f 47 4d d0	 cmova	 ecx, DWORD PTR __Buf$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1372 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

  0016c	83 c4 10	 add	 esp, 16			; 00000010H
  0016f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00174	57		 push	 edi
  00175	50		 push	 eax
  00176	ff 75 e0	 push	 DWORD PTR __Buf$[ebp+16]
  00179	51		 push	 ecx
  0017a	e8 00 00 00 00	 call	 _sprintf_s
  0017f	83 c4 18	 add	 esp, 24			; 00000018H

; 1375 :         return _Fput_v3(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen, _Is_finite);

  00182	8b 4d cc	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00185	83 7d e4 0f	 cmp	 DWORD PTR __Buf$[ebp+20], 15 ; 0000000fH

; 444  :         const value_type* _Result = _Bx._Buf;

  00189	8d 55 d0	 lea	 edx, DWORD PTR __Buf$[ebp]

; 445  :         if (_Large_mode_engaged()) {

  0018c	0f 47 55 d0	 cmova	 edx, DWORD PTR __Buf$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1375 :         return _Fput_v3(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen, _Is_finite);

  00190	ff 75 c8	 push	 DWORD PTR __Is_finite$[ebp]
  00193	50		 push	 eax
  00194	52		 push	 edx
  00195	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00198	56		 push	 esi
  00199	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0019c	8b 75 bc	 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  0019f	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  001a2	56		 push	 esi
  001a3	e8 00 00 00 00	 call	 ??$_Fput_v3@$0A@@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@1@V21@AAVios_base@1@_WPBDI_N@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Fput_v3<0>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  001a8	8b 4d e4	 mov	 ecx, DWORD PTR __Buf$[ebp+20]
  001ab	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3083 :         if (_My_data._Large_mode_engaged()) {

  001ae	76 28		 jbe	 SHORT $LN98@do_put
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001b0	8b 55 d0	 mov	 edx, DWORD PTR __Buf$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  001b3	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001b4	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  001b6	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  001bc	72 10		 jb	 SHORT $LN103@do_put

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001be	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  001c1	83 c1 23	 add	 ecx, 35			; 00000023H
  001c4	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001c6	83 c0 fc	 add	 eax, -4			; fffffffcH
  001c9	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001cc	77 29		 ja	 SHORT $LN115@do_put
$LN103@do_put:

; 289  :         ::operator delete(_Ptr, _Bytes);

  001ce	51		 push	 ecx
  001cf	52		 push	 edx
  001d0	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001d5	83 c4 08	 add	 esp, 8
$LN98@do_put:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1375 :         return _Fput_v3(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen, _Is_finite);

  001d8	8b c6		 mov	 eax, esi

; 1376 :     }

  001da	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001dd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e4	59		 pop	 ecx
  001e5	5f		 pop	 edi
  001e6	5e		 pop	 esi
  001e7	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ea	33 cd		 xor	 ecx, ebp
  001ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f1	8b e5		 mov	 esp, ebp
  001f3	5d		 pop	 ebp
  001f4	c2 1c 00	 ret	 28			; 0000001cH
$LN115@do_put:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001f7	6a 00		 push	 0
  001f9	6a 00		 push	 0
  001fb	6a 00		 push	 0
  001fd	6a 00		 push	 0
  001ff	6a 00		 push	 0
  00201	e8 00 00 00 00	 call	 __invoke_watson
$LN113@do_put:
  00206	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_K@Z
_TEXT	SEGMENT
_this$1$ = -80						; size = 4
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 8
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_K@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put, COMDAT
; _this$ = ecx

; 1343 :         unsigned long long _Val) const { // put formatted unsigned long long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b 7d 14	 mov	 edi, DWORD PTR __Iosbase$[ebp]
  00019	89 4d b0	 mov	 DWORD PTR _this$1$[ebp], ecx

; 1541 :         *_Ptr++    = '%';

  0001c	c6 45 f4 25	 mov	 BYTE PTR __Fmt$[ebp], 37 ; 00000025H

; 1344 :         char _Buf[2 * _Max_int_dig];
; 1345 :         char _Fmt[8];
; 1346 : 
; 1347 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  00020	8b 57 14	 mov	 edx, DWORD PTR [edi+20]

; 1543 :         if (_Flags & ios_base::showpos) {

  00023	8b f2		 mov	 esi, edx
  00025	83 e6 20	 and	 esi, 32			; 00000020H
  00028	74 04		 je	 SHORT $LN4@do_put

; 1544 :             *_Ptr++ = '+';

  0002a	c6 45 f5 2b	 mov	 BYTE PTR __Fmt$[ebp+1], 43 ; 0000002bH
$LN4@do_put:

; 1545 :         }
; 1546 : 
; 1547 :         if (_Flags & ios_base::showbase) {

  0002e	85 f6		 test	 esi, esi
  00030	8d 45 f5	 lea	 eax, DWORD PTR __Fmt$[ebp+1]
  00033	8d 4d f6	 lea	 ecx, DWORD PTR __Fmt$[ebp+2]
  00036	0f 45 c1	 cmovne	 eax, ecx
  00039	f6 c2 08	 test	 dl, 8
  0003c	74 04		 je	 SHORT $LN5@do_put

; 1548 :             *_Ptr++ = '#';

  0003e	c6 00 23	 mov	 BYTE PTR [eax], 35	; 00000023H
  00041	40		 inc	 eax
$LN5@do_put:

; 1549 :         }
; 1550 : 
; 1551 :         if (_Spec[0] != 'L') {
; 1552 :             *_Ptr++ = _Spec[0]; // qualifier
; 1553 :         } else { // change L to I64
; 1554 :             *_Ptr++ = 'I';
; 1555 :             *_Ptr++ = '6';
; 1556 :             *_Ptr++ = '4';
; 1557 :         }
; 1558 : 
; 1559 :         ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;

  00042	8b ca		 mov	 ecx, edx
  00044	66 c7 00 49 36	 mov	 WORD PTR [eax], 13897	; 00003649H
  00049	81 e1 00 0e 00
	00		 and	 ecx, 3584		; 00000e00H
  0004f	c6 40 02 34	 mov	 BYTE PTR [eax+2], 52	; 00000034H

; 1560 :         *_Ptr++                       = _Basefield == ios_base::oct  ? 'o'

  00053	81 f9 00 04 00
	00		 cmp	 ecx, 1024		; 00000400H
  00059	75 04		 jne	 SHORT $LN11@do_put
  0005b	b2 6f		 mov	 dl, 111			; 0000006fH
  0005d	eb 17		 jmp	 SHORT $LN10@do_put
$LN11@do_put:
  0005f	81 f9 00 08 00
	00		 cmp	 ecx, 2048		; 00000800H
  00065	74 04		 je	 SHORT $LN9@do_put
  00067	b2 75		 mov	 dl, 117			; 00000075H
  00069	eb 0b		 jmp	 SHORT $LN10@do_put
$LN9@do_put:
  0006b	c0 e2 03	 shl	 dl, 3
  0006e	f6 d2		 not	 dl
  00070	80 e2 20	 and	 dl, 32			; 00000020H
  00073	80 ca 58	 or	 dl, 88			; 00000058H
$LN10@do_put:

; 1344 :         char _Buf[2 * _Max_int_dig];
; 1345 :         char _Fmt[8];
; 1346 : 
; 1347 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  00076	ff 75 20	 push	 DWORD PTR __Val$[ebp+4]

; 1560 :         *_Ptr++                       = _Basefield == ios_base::oct  ? 'o'

  00079	88 50 03	 mov	 BYTE PTR [eax+3], dl

; 1344 :         char _Buf[2 * _Max_int_dig];
; 1345 :         char _Fmt[8];
; 1346 : 
; 1347 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  0007c	ff 75 1c	 push	 DWORD PTR __Val$[ebp]

; 1564 :         *_Ptr                         = '\0';

  0007f	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 1344 :         char _Buf[2 * _Max_int_dig];
; 1345 :         char _Fmt[8];
; 1346 : 
; 1347 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  00083	8d 45 f4	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00086	50		 push	 eax
  00087	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  0008a	6a 40		 push	 64			; 00000040H
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 _sprintf_s
  00092	50		 push	 eax
  00093	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00096	50		 push	 eax
  00097	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  0009a	57		 push	 edi
  0009b	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0009e	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  000a1	53		 push	 ebx
  000a2	ff 75 b0	 push	 DWORD PTR _this$1$[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Iput

; 1348 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Lu", _Iosbase.flags()), _Val)));
; 1349 :     }

  000aa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ad	83 c4 34	 add	 esp, 52			; 00000034H
  000b0	8b c3		 mov	 eax, ebx
  000b2	33 cd		 xor	 ecx, ebp
  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx
  000b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c2 1c 00	 ret	 28			; 0000001cH
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_K@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_J@Z
_TEXT	SEGMENT
_this$1$ = -80						; size = 4
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 8
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_J@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put, COMDAT
; _this$ = ecx

; 1334 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long long _Val) const { // put formatted long long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b 7d 14	 mov	 edi, DWORD PTR __Iosbase$[ebp]
  00019	89 4d b0	 mov	 DWORD PTR _this$1$[ebp], ecx

; 1541 :         *_Ptr++    = '%';

  0001c	c6 45 f4 25	 mov	 BYTE PTR __Fmt$[ebp], 37 ; 00000025H

; 1335 :         char _Buf[2 * _Max_int_dig];
; 1336 :         char _Fmt[8];
; 1337 : 
; 1338 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  00020	8b 57 14	 mov	 edx, DWORD PTR [edi+20]

; 1543 :         if (_Flags & ios_base::showpos) {

  00023	8b f2		 mov	 esi, edx
  00025	83 e6 20	 and	 esi, 32			; 00000020H
  00028	74 04		 je	 SHORT $LN4@do_put

; 1544 :             *_Ptr++ = '+';

  0002a	c6 45 f5 2b	 mov	 BYTE PTR __Fmt$[ebp+1], 43 ; 0000002bH
$LN4@do_put:

; 1545 :         }
; 1546 : 
; 1547 :         if (_Flags & ios_base::showbase) {

  0002e	85 f6		 test	 esi, esi
  00030	8d 45 f5	 lea	 eax, DWORD PTR __Fmt$[ebp+1]
  00033	8d 4d f6	 lea	 ecx, DWORD PTR __Fmt$[ebp+2]
  00036	0f 45 c1	 cmovne	 eax, ecx
  00039	f6 c2 08	 test	 dl, 8
  0003c	74 04		 je	 SHORT $LN5@do_put

; 1548 :             *_Ptr++ = '#';

  0003e	c6 00 23	 mov	 BYTE PTR [eax], 35	; 00000023H
  00041	40		 inc	 eax
$LN5@do_put:

; 1549 :         }
; 1550 : 
; 1551 :         if (_Spec[0] != 'L') {
; 1552 :             *_Ptr++ = _Spec[0]; // qualifier
; 1553 :         } else { // change L to I64
; 1554 :             *_Ptr++ = 'I';
; 1555 :             *_Ptr++ = '6';
; 1556 :             *_Ptr++ = '4';
; 1557 :         }
; 1558 : 
; 1559 :         ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;

  00042	8b ca		 mov	 ecx, edx
  00044	66 c7 00 49 36	 mov	 WORD PTR [eax], 13897	; 00003649H
  00049	81 e1 00 0e 00
	00		 and	 ecx, 3584		; 00000e00H
  0004f	c6 40 02 34	 mov	 BYTE PTR [eax+2], 52	; 00000034H

; 1560 :         *_Ptr++                       = _Basefield == ios_base::oct  ? 'o'

  00053	81 f9 00 04 00
	00		 cmp	 ecx, 1024		; 00000400H
  00059	75 04		 jne	 SHORT $LN11@do_put
  0005b	b2 6f		 mov	 dl, 111			; 0000006fH
  0005d	eb 17		 jmp	 SHORT $LN10@do_put
$LN11@do_put:
  0005f	81 f9 00 08 00
	00		 cmp	 ecx, 2048		; 00000800H
  00065	74 04		 je	 SHORT $LN9@do_put
  00067	b2 64		 mov	 dl, 100			; 00000064H
  00069	eb 0b		 jmp	 SHORT $LN10@do_put
$LN9@do_put:
  0006b	c0 e2 03	 shl	 dl, 3
  0006e	f6 d2		 not	 dl
  00070	80 e2 20	 and	 dl, 32			; 00000020H
  00073	80 ca 58	 or	 dl, 88			; 00000058H
$LN10@do_put:

; 1335 :         char _Buf[2 * _Max_int_dig];
; 1336 :         char _Fmt[8];
; 1337 : 
; 1338 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  00076	ff 75 20	 push	 DWORD PTR __Val$[ebp+4]

; 1560 :         *_Ptr++                       = _Basefield == ios_base::oct  ? 'o'

  00079	88 50 03	 mov	 BYTE PTR [eax+3], dl

; 1335 :         char _Buf[2 * _Max_int_dig];
; 1336 :         char _Fmt[8];
; 1337 : 
; 1338 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  0007c	ff 75 1c	 push	 DWORD PTR __Val$[ebp]

; 1564 :         *_Ptr                         = '\0';

  0007f	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 1335 :         char _Buf[2 * _Max_int_dig];
; 1336 :         char _Fmt[8];
; 1337 : 
; 1338 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  00083	8d 45 f4	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00086	50		 push	 eax
  00087	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  0008a	6a 40		 push	 64			; 00000040H
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 _sprintf_s
  00092	50		 push	 eax
  00093	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00096	50		 push	 eax
  00097	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  0009a	57		 push	 edi
  0009b	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0009e	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  000a1	53		 push	 ebx
  000a2	ff 75 b0	 push	 DWORD PTR _this$1$[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Iput

; 1339 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Ld", _Iosbase.flags()), _Val)));
; 1340 :     }

  000aa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ad	83 c4 34	 add	 esp, 52			; 00000034H
  000b0	8b c3		 mov	 eax, ebx
  000b2	33 cd		 xor	 ecx, ebp
  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx
  000b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c2 1c 00	 ret	 28			; 0000001cH
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_J@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WK@Z
_TEXT	SEGMENT
_this$1$ = -80						; size = 4
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 4
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WK@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put, COMDAT
; _this$ = ecx

; 1325 :         unsigned long _Val) const { // put formatted unsigned long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  00015	57		 push	 edi
  00016	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00019	89 4d b0	 mov	 DWORD PTR _this$1$[ebp], ecx

; 1326 :         char _Buf[2 * _Max_int_dig];
; 1327 :         char _Fmt[6];
; 1328 : 
; 1329 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  0001c	8b 46 14	 mov	 eax, DWORD PTR [esi+20]

; 1543 :         if (_Flags & ios_base::showpos) {

  0001f	8b d0		 mov	 edx, eax
  00021	c6 45 f4 25	 mov	 BYTE PTR __Fmt$[ebp], 37 ; 00000025H
  00025	83 e2 20	 and	 edx, 32			; 00000020H
  00028	74 04		 je	 SHORT $LN4@do_put

; 1544 :             *_Ptr++ = '+';

  0002a	c6 45 f5 2b	 mov	 BYTE PTR __Fmt$[ebp+1], 43 ; 0000002bH
$LN4@do_put:

; 1545 :         }
; 1546 : 
; 1547 :         if (_Flags & ios_base::showbase) {

  0002e	8b 5d b0	 mov	 ebx, DWORD PTR _this$1$[ebp]
  00031	8d 4d f5	 lea	 ecx, DWORD PTR __Fmt$[ebp+1]
  00034	85 d2		 test	 edx, edx
  00036	8d 55 f6	 lea	 edx, DWORD PTR __Fmt$[ebp+2]
  00039	0f 45 ca	 cmovne	 ecx, edx
  0003c	a8 08		 test	 al, 8
  0003e	74 04		 je	 SHORT $LN5@do_put

; 1548 :             *_Ptr++ = '#';

  00040	c6 01 23	 mov	 BYTE PTR [ecx], 35	; 00000023H
  00043	41		 inc	 ecx
$LN5@do_put:

; 1549 :         }
; 1550 : 
; 1551 :         if (_Spec[0] != 'L') {
; 1552 :             *_Ptr++ = _Spec[0]; // qualifier
; 1553 :         } else { // change L to I64
; 1554 :             *_Ptr++ = 'I';
; 1555 :             *_Ptr++ = '6';
; 1556 :             *_Ptr++ = '4';
; 1557 :         }
; 1558 : 
; 1559 :         ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;

  00044	8b d0		 mov	 edx, eax
  00046	c6 01 6c	 mov	 BYTE PTR [ecx], 108	; 0000006cH
  00049	81 e2 00 0e 00
	00		 and	 edx, 3584		; 00000e00H

; 1560 :         *_Ptr++                       = _Basefield == ios_base::oct  ? 'o'

  0004f	81 fa 00 04 00
	00		 cmp	 edx, 1024		; 00000400H
  00055	75 04		 jne	 SHORT $LN11@do_put
  00057	b0 6f		 mov	 al, 111			; 0000006fH
  00059	eb 15		 jmp	 SHORT $LN10@do_put
$LN11@do_put:
  0005b	81 fa 00 08 00
	00		 cmp	 edx, 2048		; 00000800H
  00061	74 04		 je	 SHORT $LN9@do_put
  00063	b0 75		 mov	 al, 117			; 00000075H
  00065	eb 09		 jmp	 SHORT $LN10@do_put
$LN9@do_put:
  00067	c0 e0 03	 shl	 al, 3
  0006a	f6 d0		 not	 al
  0006c	24 20		 and	 al, 32			; 00000020H
  0006e	0c 58		 or	 al, 88			; 00000058H
$LN10@do_put:

; 1326 :         char _Buf[2 * _Max_int_dig];
; 1327 :         char _Fmt[6];
; 1328 : 
; 1329 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  00070	ff 75 1c	 push	 DWORD PTR __Val$[ebp]

; 1560 :         *_Ptr++                       = _Basefield == ios_base::oct  ? 'o'

  00073	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 1326 :         char _Buf[2 * _Max_int_dig];
; 1327 :         char _Fmt[6];
; 1328 : 
; 1329 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  00076	8d 45 f4	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00079	50		 push	 eax
  0007a	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]

; 1564 :         *_Ptr                         = '\0';

  0007d	c6 41 02 00	 mov	 BYTE PTR [ecx+2], 0

; 1326 :         char _Buf[2 * _Max_int_dig];
; 1327 :         char _Fmt[6];
; 1328 : 
; 1329 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  00081	6a 40		 push	 64			; 00000040H
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 _sprintf_s
  00089	50		 push	 eax
  0008a	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  0008d	50		 push	 eax
  0008e	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00091	56		 push	 esi
  00092	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00095	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00098	57		 push	 edi
  00099	53		 push	 ebx
  0009a	e8 00 00 00 00	 call	 ?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Iput

; 1330 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "lu", _Iosbase.flags()), _Val)));
; 1331 :     }

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	83 c4 30	 add	 esp, 48			; 00000030H
  000a5	8b c7		 mov	 eax, edi
  000a7	33 cd		 xor	 ecx, ebp
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 18 00	 ret	 24			; 00000018H
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WK@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WJ@Z
_TEXT	SEGMENT
_this$1$ = -80						; size = 4
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 4
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WJ@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put, COMDAT
; _this$ = ecx

; 1316 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long _Val) const { // put formatted long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  00015	57		 push	 edi
  00016	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00019	89 4d b0	 mov	 DWORD PTR _this$1$[ebp], ecx

; 1317 :         char _Buf[2 * _Max_int_dig];
; 1318 :         char _Fmt[6];
; 1319 : 
; 1320 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  0001c	8b 46 14	 mov	 eax, DWORD PTR [esi+20]

; 1543 :         if (_Flags & ios_base::showpos) {

  0001f	8b d0		 mov	 edx, eax
  00021	c6 45 f4 25	 mov	 BYTE PTR __Fmt$[ebp], 37 ; 00000025H
  00025	83 e2 20	 and	 edx, 32			; 00000020H
  00028	74 04		 je	 SHORT $LN4@do_put

; 1544 :             *_Ptr++ = '+';

  0002a	c6 45 f5 2b	 mov	 BYTE PTR __Fmt$[ebp+1], 43 ; 0000002bH
$LN4@do_put:

; 1545 :         }
; 1546 : 
; 1547 :         if (_Flags & ios_base::showbase) {

  0002e	8b 5d b0	 mov	 ebx, DWORD PTR _this$1$[ebp]
  00031	8d 4d f5	 lea	 ecx, DWORD PTR __Fmt$[ebp+1]
  00034	85 d2		 test	 edx, edx
  00036	8d 55 f6	 lea	 edx, DWORD PTR __Fmt$[ebp+2]
  00039	0f 45 ca	 cmovne	 ecx, edx
  0003c	a8 08		 test	 al, 8
  0003e	74 04		 je	 SHORT $LN5@do_put

; 1548 :             *_Ptr++ = '#';

  00040	c6 01 23	 mov	 BYTE PTR [ecx], 35	; 00000023H
  00043	41		 inc	 ecx
$LN5@do_put:

; 1549 :         }
; 1550 : 
; 1551 :         if (_Spec[0] != 'L') {
; 1552 :             *_Ptr++ = _Spec[0]; // qualifier
; 1553 :         } else { // change L to I64
; 1554 :             *_Ptr++ = 'I';
; 1555 :             *_Ptr++ = '6';
; 1556 :             *_Ptr++ = '4';
; 1557 :         }
; 1558 : 
; 1559 :         ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;

  00044	8b d0		 mov	 edx, eax
  00046	c6 01 6c	 mov	 BYTE PTR [ecx], 108	; 0000006cH
  00049	81 e2 00 0e 00
	00		 and	 edx, 3584		; 00000e00H

; 1560 :         *_Ptr++                       = _Basefield == ios_base::oct  ? 'o'

  0004f	81 fa 00 04 00
	00		 cmp	 edx, 1024		; 00000400H
  00055	75 04		 jne	 SHORT $LN11@do_put
  00057	b0 6f		 mov	 al, 111			; 0000006fH
  00059	eb 15		 jmp	 SHORT $LN10@do_put
$LN11@do_put:
  0005b	81 fa 00 08 00
	00		 cmp	 edx, 2048		; 00000800H
  00061	74 04		 je	 SHORT $LN9@do_put
  00063	b0 64		 mov	 al, 100			; 00000064H
  00065	eb 09		 jmp	 SHORT $LN10@do_put
$LN9@do_put:
  00067	c0 e0 03	 shl	 al, 3
  0006a	f6 d0		 not	 al
  0006c	24 20		 and	 al, 32			; 00000020H
  0006e	0c 58		 or	 al, 88			; 00000058H
$LN10@do_put:

; 1317 :         char _Buf[2 * _Max_int_dig];
; 1318 :         char _Fmt[6];
; 1319 : 
; 1320 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  00070	ff 75 1c	 push	 DWORD PTR __Val$[ebp]

; 1560 :         *_Ptr++                       = _Basefield == ios_base::oct  ? 'o'

  00073	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 1317 :         char _Buf[2 * _Max_int_dig];
; 1318 :         char _Fmt[6];
; 1319 : 
; 1320 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  00076	8d 45 f4	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00079	50		 push	 eax
  0007a	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]

; 1564 :         *_Ptr                         = '\0';

  0007d	c6 41 02 00	 mov	 BYTE PTR [ecx+2], 0

; 1317 :         char _Buf[2 * _Max_int_dig];
; 1318 :         char _Fmt[6];
; 1319 : 
; 1320 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  00081	6a 40		 push	 64			; 00000040H
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 _sprintf_s
  00089	50		 push	 eax
  0008a	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  0008d	50		 push	 eax
  0008e	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00091	56		 push	 esi
  00092	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00095	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00098	57		 push	 edi
  00099	53		 push	 ebx
  0009a	e8 00 00 00 00	 call	 ?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Iput

; 1321 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "ld", _Iosbase.flags()), _Val)));
; 1322 :     }

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	83 c4 30	 add	 esp, 48			; 00000030H
  000a5	8b c7		 mov	 eax, edi
  000a7	33 cd		 xor	 ecx, ebp
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 18 00	 ret	 24			; 00000018H
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WJ@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$1$ = -84				; size = 4
$T2 = -80						; size = 8
$T3 = -80						; size = 8
$T4 = -80						; size = 8
_this$GSCopy$1$ = -72					; size = 4
__Fill$GSCopy$1$ = -68					; size = 4
$T5 = -64						; size = 24
$T6 = -64						; size = 24
__Str$7 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 1
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put, COMDAT
; _this$ = ecx

; 1284 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, bool _Val) const { // put formatted bool to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d b8	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0002d	8b 7d 14	 mov	 edi, DWORD PTR __Iosbase$[ebp]
  00030	0f b7 45 18	 movzx	 eax, WORD PTR __Fill$[ebp]
  00034	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00037	89 75 ac	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], esi

; 1285 :         if (!(_Iosbase.flags() & ios_base::boolalpha)) {

  0003a	f7 47 14 00 40
	00 00		 test	 DWORD PTR [edi+20], 16384 ; 00004000H
  00041	89 45 bc	 mov	 DWORD PTR __Fill$GSCopy$1$[ebp], eax
  00044	75 1a		 jne	 SHORT $LN2@do_put

; 1286 :             return do_put(_Dest, _Iosbase, _Fill, static_cast<long>(_Val));

  00046	0f b6 45 1c	 movzx	 eax, BYTE PTR __Val$[ebp]
  0004a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004c	50		 push	 eax
  0004d	ff 75 bc	 push	 DWORD PTR __Fill$GSCopy$1$[ebp]
  00050	57		 push	 edi
  00051	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00054	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00057	56		 push	 esi
  00058	ff 52 24	 call	 DWORD PTR [edx+36]
  0005b	e9 79 01 00 00	 jmp	 $LN82@do_put
$LN2@do_put:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 289  :         return *_Ploc;

  00060	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  00063	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00066	89 4d b4	 mov	 DWORD PTR $T2[ebp+4], ecx

; 269  :         _Ptr->_Incref();

  00069	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006b	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1288 :             const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

  0006e	8d 45 b0	 lea	 eax, DWORD PTR $T2[ebp]
  00071	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<wchar_t> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  0007e	8b 4d b4	 mov	 ecx, DWORD PTR $T2[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1288 :             const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

  00081	83 c4 04	 add	 esp, 4
  00084	8b f0		 mov	 esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  00086	85 c9		 test	 ecx, ecx
  00088	74 15		 je	 SHORT $LN26@do_put

; 355  :             delete _Ptr->_Decref();

  0008a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008c	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  0008f	ff d2		 call	 edx
  00091	85 c0		 test	 eax, eax
  00093	74 0a		 je	 SHORT $LN26@do_put
  00095	8b 08		 mov	 ecx, DWORD PTR [eax]
  00097	6a 01		 push	 1
  00099	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009b	8b c8		 mov	 ecx, eax
  0009d	ff d2		 call	 edx
$LN26@do_put:
  0009f	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 860  :         _My_data._Mysize = 0;

  000a2	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Str$7[ebp+16], 0

; 861  :         _My_data._Myres  = _Small_string_capacity;
; 862  :         _My_data._Activate_SSO_buffer();
; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  000a9	33 c0		 xor	 eax, eax
  000ab	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR __Str$7[ebp+20], 7

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  000b2	0f 11 45 d8	 movups	 XMMWORD PTR __Str$7[ebp], xmm0

; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  000b6	66 89 45 d8	 mov	 WORD PTR __Str$7[ebp], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1290 :             if (_Val) {

  000ba	80 7d 1c 00	 cmp	 BYTE PTR __Val$[ebp], 0
  000be	8d 4d c0	 lea	 ecx, DWORD PTR $T5[ebp]
  000c1	8b 06		 mov	 eax, DWORD PTR [esi]
  000c3	51		 push	 ecx
  000c4	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000cb	8b ce		 mov	 ecx, esi
  000cd	74 05		 je	 SHORT $LN4@do_put

; 116  :         return do_truename();

  000cf	ff 50 1c	 call	 DWORD PTR [eax+28]

; 1291 :                 _Str.assign(_Punct_fac.truename());
; 1292 :             } else {

  000d2	eb 03		 jmp	 SHORT $LN206@do_put
$LN4@do_put:

; 112  :         return do_falsename();

  000d4	ff 50 18	 call	 DWORD PTR [eax+24]
$LN206@do_put:

; 1293 :                 _Str.assign(_Punct_fac.falsename());
; 1294 :             }
; 1295 : 
; 1296 :             size_t _Fillcount;
; 1297 :             if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Str.size()) {

  000d7	0f 10 45 c0	 movups	 xmm0, XMMWORD PTR $T6[ebp]
  000db	33 c0		 xor	 eax, eax
  000dd	8d 4d c0	 lea	 ecx, DWORD PTR $T6[ebp]
  000e0	66 89 45 c0	 mov	 WORD PTR $T6[ebp], ax
  000e4	0f 11 45 d8	 movups	 XMMWORD PTR __Str$7[ebp], xmm0
  000e8	f3 0f 7e 45 d0	 movq	 xmm0, QWORD PTR $T6[ebp+16]
  000ed	66 0f d6 45 e8	 movq	 QWORD PTR __Str$7[ebp+16], xmm0
  000f2	89 45 d0	 mov	 DWORD PTR $T6[ebp+16], eax
  000f5	c7 45 d4 07 00
	00 00		 mov	 DWORD PTR $T6[ebp+20], 7
  000fc	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
  00101	83 7f 24 00	 cmp	 DWORD PTR [edi+36], 0
  00105	8b 77 20	 mov	 esi, DWORD PTR [edi+32]
  00108	8b 45 e8	 mov	 eax, DWORD PTR __Str$7[ebp+16]
  0010b	7c 0e		 jl	 SHORT $LN8@do_put
  0010d	7f 04		 jg	 SHORT $LN202@do_put
  0010f	85 f6		 test	 esi, esi
  00111	74 08		 je	 SHORT $LN8@do_put
$LN202@do_put:
  00113	3b f0		 cmp	 esi, eax
  00115	76 04		 jbe	 SHORT $LN8@do_put

; 1299 :             } else {
; 1300 :                 _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Str.size();

  00117	2b f0		 sub	 esi, eax
  00119	eb 02		 jmp	 SHORT $LN7@do_put
$LN8@do_put:

; 1298 :                 _Fillcount = 0;

  0011b	33 f6		 xor	 esi, esi
$LN7@do_put:

; 1301 :             }
; 1302 : 
; 1303 :             if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left) { // put leading fill

  0011d	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00120	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00125	83 f8 40	 cmp	 eax, 64			; 00000040H
  00128	74 28		 je	 SHORT $LN203@do_put

; 1304 :                 _Dest      = _Rep(_Dest, _Fill, _Fillcount);

  0012a	56		 push	 esi
  0012b	ff 75 bc	 push	 DWORD PTR __Fill$GSCopy$1$[ebp]
  0012e	8d 45 b0	 lea	 eax, DWORD PTR $T3[ebp]
  00131	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00134	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00137	50		 push	 eax
  00138	ff 75 b8	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  0013b	e8 00 00 00 00	 call	 ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep
  00140	83 c4 18	 add	 esp, 24			; 00000018H

; 1305 :                 _Fillcount = 0;

  00143	33 f6		 xor	 esi, esi
  00145	8b 08		 mov	 ecx, DWORD PTR [eax]
  00147	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0014a	89 4d 0c	 mov	 DWORD PTR __Dest$[ebp], ecx
  0014d	89 55 10	 mov	 DWORD PTR __Dest$[ebp+4], edx
  00150	eb 06		 jmp	 SHORT $LN9@do_put
$LN203@do_put:

; 1301 :             }
; 1302 : 
; 1303 :             if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left) { // put leading fill

  00152	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp+4]
  00155	8b 4d 0c	 mov	 ecx, DWORD PTR __Dest$[ebp]
$LN9@do_put:

; 1307 :             _Dest = _Put(_Dest, _Str.c_str(), _Str.size()); // put field

  00158	ff 75 e8	 push	 DWORD PTR __Str$7[ebp+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  0015b	83 7d ec 07	 cmp	 DWORD PTR __Str$7[ebp+20], 7

; 444  :         const value_type* _Result = _Bx._Buf;

  0015f	8d 45 d8	 lea	 eax, DWORD PTR __Str$7[ebp]

; 445  :         if (_Large_mode_engaged()) {

  00162	0f 47 45 d8	 cmova	 eax, DWORD PTR __Str$7[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1307 :             _Dest = _Put(_Dest, _Str.c_str(), _Str.size()); // put field

  00166	50		 push	 eax
  00167	52		 push	 edx
  00168	51		 push	 ecx
  00169	8d 45 b0	 lea	 eax, DWORD PTR $T4[ebp]
  0016c	50		 push	 eax
  0016d	ff 75 b8	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  00170	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put

; 1309 :             return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

  00175	56		 push	 esi
  00176	ff 75 bc	 push	 DWORD PTR __Fill$GSCopy$1$[ebp]
  00179	8b 75 ac	 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  0017c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0017e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00181	50		 push	 eax
  00182	51		 push	 ecx
  00183	56		 push	 esi
  00184	ff 75 b8	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  00187	89 4d 0c	 mov	 DWORD PTR __Dest$[ebp], ecx
  0018a	89 45 10	 mov	 DWORD PTR __Dest$[ebp+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 284  :         _Wide                      = _Newwidth;

  0018d	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], 0
  00194	c7 47 24 00 00
	00 00		 mov	 DWORD PTR [edi+36], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1309 :             return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

  0019b	e8 00 00 00 00	 call	 ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  001a0	8b 45 ec	 mov	 eax, DWORD PTR __Str$7[ebp+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1309 :             return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

  001a3	83 c4 30	 add	 esp, 48			; 00000030H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  001a6	83 f8 07	 cmp	 eax, 7

; 3083 :         if (_My_data._Large_mode_engaged()) {

  001a9	76 2e		 jbe	 SHORT $LN82@do_put
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001ab	8b 55 d8	 mov	 edx, DWORD PTR __Str$7[ebp]
  001ae	8d 0c 45 02 00
	00 00		 lea	 ecx, DWORD PTR [eax*2+2]
  001b5	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  001b7	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  001bd	72 10		 jb	 SHORT $LN87@do_put

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001bf	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  001c2	83 c1 23	 add	 ecx, 35			; 00000023H
  001c5	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001c7	83 c0 fc	 add	 eax, -4			; fffffffcH
  001ca	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001cd	77 29		 ja	 SHORT $LN208@do_put
$LN87@do_put:

; 289  :         ::operator delete(_Ptr, _Bytes);

  001cf	51		 push	 ecx
  001d0	52		 push	 edx
  001d1	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001d6	83 c4 08	 add	 esp, 8
$LN82@do_put:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1311 :     }

  001d9	8b c6		 mov	 eax, esi
  001db	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001de	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e5	59		 pop	 ecx
  001e6	5f		 pop	 edi
  001e7	5e		 pop	 esi
  001e8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001eb	33 cd		 xor	 ecx, ebp
  001ed	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f2	8b e5		 mov	 esp, ebp
  001f4	5d		 pop	 ebp
  001f5	c2 18 00	 ret	 24			; 00000018H
$LN208@do_put:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001f8	6a 00		 push	 0
  001fa	6a 00		 push	 0
  001fc	6a 00		 push	 0
  001fe	6a 00		 push	 0
  00200	6a 00		 push	 0
  00202	e8 00 00 00 00	 call	 __invoke_watson
$LN205@do_put:
  00207	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z$0:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR __Str$7[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
;	COMDAT ??1?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT
??1?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAE@XZ PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::~num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >, COMDAT
; _this$ = ecx

; 1224 :     __CLR_OR_THIS_CALL ~num_put() noexcept override {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
  00006	c3		 ret	 0
??1?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAE@XZ ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::~num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -76						; size = 52
__Lock$3 = -24						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
__Psave$1$ = -20					; size = 4
__Lock$6 = -16						; size = 4
$T7 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
__Psave_guard$8 = 8					; size = 4
??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > >, COMDAT

; 435  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	33 db		 xor	 ebx, ebx

; 436  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

  0002a	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0002d	53		 push	 ebx
  0002e	89 5d e8	 mov	 DWORD PTR $T4[ebp], ebx
  00031	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 91   :             if (_Id == 0) { // still zero, allocate stamp

  00036	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::id

; 437  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

  0003c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > >::_Psave
  00041	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00044	89 45 ec	 mov	 DWORD PTR __Psave$1$[ebp], eax

; 91   :             if (_Id == 0) { // still zero, allocate stamp

  00047	85 ff		 test	 edi, edi
  00049	75 2f		 jne	 SHORT $LN11@use_facet

; 92   :                 _BEGIN_LOCK(_LOCK_LOCALE)

  0004b	57		 push	 edi
  0004c	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$6[ebp]
  0004f	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 93   :                 if (_Id == 0) {

  00054	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?id@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@2V0locale@2@A, edi ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::id
  0005a	75 10		 jne	 SHORT $LN12@use_facet

; 94   :                     _Id = static_cast<size_t>(++_Id_cnt);

  0005c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00061	40		 inc	 eax
  00062	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00067	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@2V0locale@2@A, eax ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::id
$LN12@use_facet:

; 95   :                 }
; 96   :                 _END_LOCK()

  0006c	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$6[ebp]
  0006f	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00074	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::id
$LN11@use_facet:

; 377  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  0007a	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  0007d	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
  00084	89 4d f0	 mov	 DWORD PTR $T7[ebp], ecx
  00087	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008a	3b 7a 0c	 cmp	 edi, DWORD PTR [edx+12]
  0008d	73 16		 jae	 SHORT $LN19@use_facet
  0008f	0f ae e8	 lfence
  00092	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00095	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00098	8b 34 01	 mov	 esi, DWORD PTR [ecx+eax]

; 378  :         if (_Facptr || !_Ptr->_Xparent) {

  0009b	85 f6		 test	 esi, esi
  0009d	0f 85 b1 00 00
	00		 jne	 $LN68@use_facet
  000a3	eb 05		 jmp	 SHORT $LN72@use_facet
$LN19@use_facet:

; 374  :     }
; 375  : 
; 376  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object
; 377  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  000a5	33 f6		 xor	 esi, esi
  000a7	89 4d f0	 mov	 DWORD PTR $T7[ebp], ecx
$LN72@use_facet:

; 378  :         if (_Facptr || !_Ptr->_Xparent) {

  000aa	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0
  000ae	74 16		 je	 SHORT $LN14@use_facet

; 379  :             return _Facptr; // found facet or not transparent
; 380  :         }
; 381  : 
; 382  :         // look in current locale
; 383  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

  000b0	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 384  :         if (_Id < _Ptr0->_Facetcount) {

  000b5	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  000b8	73 14		 jae	 SHORT $LN73@use_facet

; 385  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

  000ba	0f ae e8	 lfence
  000bd	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c0	8b 75 f0	 mov	 esi, DWORD PTR $T7[ebp]
  000c3	8b 34 06	 mov	 esi, DWORD PTR [esi+eax]
$LN14@use_facet:

; 438  : 
; 439  :     const size_t _Id         = _Facet::id._Get_index();
; 440  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);
; 441  : 
; 442  :     if (!_Pf) {

  000c6	85 f6		 test	 esi, esi
  000c8	0f 85 86 00 00
	00		 jne	 $LN68@use_facet
$LN73@use_facet:

; 443  :         if (_Psave) {

  000ce	8b 45 ec	 mov	 eax, DWORD PTR __Psave$1$[ebp]
  000d1	85 c0		 test	 eax, eax
  000d3	74 04		 je	 SHORT $LN3@use_facet

; 444  :             _Pf = _Psave; // lazy facet already allocated

  000d5	8b f0		 mov	 esi, eax

; 445  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

  000d7	eb 7b		 jmp	 SHORT $LN68@use_facet
$LN3@use_facet:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1215 :             *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->_C_str()));

  000d9	6a 08		 push	 8
  000db	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000e0	8b f0		 mov	 esi, eax
  000e2	83 c4 04	 add	 esp, 4
  000e5	89 75 ec	 mov	 DWORD PTR $T5[ebp], esi
  000e8	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000ec	85 f6		 test	 esi, esi
  000ee	74 38		 je	 SHORT $LN24@use_facet
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 373  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  000f0	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  000f3	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000f6	85 c9		 test	 ecx, ecx
  000f8	74 0c		 je	 SHORT $LN32@use_facet
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo

; 190  :         return _Myptr ? _Myptr : &_Nul;

  000fa	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  000fd	85 c0		 test	 eax, eax
  000ff	75 0a		 jne	 SHORT $LN33@use_facet
  00101	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 373  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  00104	eb 05		 jmp	 SHORT $LN33@use_facet
$LN32@use_facet:
  00106	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@@
$LN33@use_facet:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1215 :             *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->_C_str()));

  0010b	50		 push	 eax
  0010c	8d 4d b4	 lea	 ecx, DWORD PTR $T2[ebp]
  0010f	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00114	bb 01 00 00 00	 mov	 ebx, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 143  :             : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs)) // non-atomic initialization

  00119	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1235 :     __CLR_OR_THIS_CALL num_put(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs) {

  00120	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@6B@

; 1215 :             *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->_C_str()));

  00126	eb 02		 jmp	 SHORT $LN25@use_facet
$LN24@use_facet:
  00128	33 f6		 xor	 esi, esi
$LN25@use_facet:
  0012a	f6 c3 01	 test	 bl, 1
  0012d	74 08		 je	 SHORT $LN29@use_facet
  0012f	8d 4d b4	 lea	 ecx, DWORD PTR $T2[ebp]
  00132	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN29@use_facet:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00137	89 75 08	 mov	 DWORD PTR __Psave_guard$8[ebp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 458  :             _Facet_Register(_Pfmod);

  0013a	56		 push	 esi
  0013b	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0013f	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register

; 459  : #endif // ^^^ !defined(_M_CEE) ^^^
; 460  : 
; 461  :             _Pfmod->_Incref();

  00144	8b 16		 mov	 edx, DWORD PTR [esi]
  00146	83 c4 04	 add	 esp, 4
  00149	8b ce		 mov	 ecx, esi
  0014b	ff 52 04	 call	 DWORD PTR [edx+4]

; 462  :             _Facetptr<_Facet>::_Psave = _Psave;

  0014e	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > >::_Psave
$LN68@use_facet:

; 463  :             _Pf                       = _Psave;
; 464  : 
; 465  :             (void) _Psave_guard.release();
; 466  :         }
; 467  :     }
; 468  : 
; 469  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

  00154	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00157	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0015c	8b c6		 mov	 eax, esi

; 470  :     _END_LOCK()
; 471  : } // end of use_facet body

  0015e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00161	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00168	59		 pop	 ecx
  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	5b		 pop	 ebx
  0016c	8b e5		 mov	 esp, ebp
  0016e	5d		 pop	 ebp
  0016f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z$2:
  00008	6a 08		 push	 8
  0000a	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00013	83 c4 08	 add	 esp, 8
  00016	c3		 ret	 0
__unwindfunclet$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z$1:
  00017	8d 4d 08	 lea	 ecx, DWORD PTR __Psave_guard$8[ebp]
  0001a	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
  0001f	cc		 int	 3
  00020	cc		 int	 3
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
__ehhandler$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z:
  00024	90		 npad	 1
  00025	90		 npad	 1
  00026	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002d	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  00030	33 c8		 xor	 ecx, eax
  00032	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00037	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z
  0003c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > >
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Arg$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>, COMDAT
; _this$ = ecx

; 871  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	57		 push	 edi

; 872  :         auto& _My_data = _Mypair._Myval2;
; 873  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 874  : 
; 875  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 876  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 877  :         } else {
; 878  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 879  :         }
; 880  : 
; 881  :         if (_Count > max_size()) {

  00006	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00009	8b d9		 mov	 ebx, ecx
  0000b	89 5d fc	 mov	 DWORD PTR _this$1$[ebp], ebx
  0000e	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  00014	77 77		 ja	 SHORT $LN30@Construct

; 883  :         }
; 884  : 
; 885  :         auto& _Al       = _Getal();
; 886  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 887  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 888  : 
; 889  :         if (_Count <= _Small_string_capacity) {

  00016	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  00019	77 23		 ja	 SHORT $LN3@Construct
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0001b	57		 push	 edi
  0001c	ff 75 08	 push	 DWORD PTR __Arg$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 890  :             _My_data._Mysize = _Count;

  0001f	89 7b 10	 mov	 DWORD PTR [ebx+16], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00022	53		 push	 ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 891  :             _My_data._Myres  = _Small_string_capacity;

  00023	c7 43 14 0f 00
	00 00		 mov	 DWORD PTR [ebx+20], 15	; 0000000fH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0002a	e8 00 00 00 00	 call	 _memcpy
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 898  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  00032	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0
  00036	5f		 pop	 edi

; 923  :         } else { // _Strat == _Construct_strategy::_From_string
; 924  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 925  :         }
; 926  : 
; 927  :         _ASAN_STRING_CREATE(*this);
; 928  :         _Proxy._Release();
; 929  :     }

  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
$LN3@Construct:

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

  0003e	8b df		 mov	 ebx, edi
  00040	83 cb 0f	 or	 ebx, 15			; 0000000fH
  00043	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00049	76 07		 jbe	 SHORT $LN9@Construct

; 2980 :             return _Max;

  0004b	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  00050	eb 0a		 jmp	 SHORT $LN8@Construct
$LN9@Construct:

; 2981 :         }
; 2982 : 
; 2983 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 2984 :             return _Max;
; 2985 :         }
; 2986 : 
; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00052	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  00057	3b d8		 cmp	 ebx, eax
  00059	0f 42 d8	 cmovb	 ebx, eax
$LN8@Construct:

; 825  :         ++_Capacity; // Take null terminator into consideration

  0005c	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  0005f	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 912  :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

  00066	8b f0		 mov	 esi, eax

; 913  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00068	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0006b	57		 push	 edi
  0006c	ff 75 08	 push	 DWORD PTR __Arg$[ebp]
  0006f	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 913  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00070	89 30		 mov	 DWORD PTR [eax], esi

; 914  : 
; 915  :         _My_data._Mysize = _Count;

  00072	89 78 10	 mov	 DWORD PTR [eax+16], edi

; 916  :         _My_data._Myres  = _New_capacity;

  00075	89 58 14	 mov	 DWORD PTR [eax+20], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00078	e8 00 00 00 00	 call	 _memcpy
  0007d	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 922  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  00080	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0
  00084	5e		 pop	 esi
  00085	5f		 pop	 edi

; 923  :         } else { // _Strat == _Construct_strategy::_From_string
; 924  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 925  :         }
; 926  : 
; 927  :         _ASAN_STRING_CREATE(*this);
; 928  :         _Proxy._Release();
; 929  :     }

  00086	5b		 pop	 ebx
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c2 08 00	 ret	 8
$LN30@Construct:

; 882  :             _Xlen_string(); // result too long

  0008d	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN28@Construct:
  00092	cc		 int	 3
??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$_Construct@$00PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXQB_WI@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Arg$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Construct@$00PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXQB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>, COMDAT
; _this$ = ecx

; 871  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 872  :         auto& _My_data = _Mypair._Myval2;
; 873  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 874  : 
; 875  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 876  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 877  :         } else {
; 878  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 879  :         }
; 880  : 
; 881  :         if (_Count > max_size()) {

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	89 7d fc	 mov	 DWORD PTR _this$1$[ebp], edi
  0000f	81 fb fe ff ff
	7f		 cmp	 ebx, 2147483646		; 7ffffffeH
  00015	0f 87 95 00 00
	00		 ja	 $LN39@Construct

; 883  :         }
; 884  : 
; 885  :         auto& _Al       = _Getal();
; 886  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 887  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 888  : 
; 889  :         if (_Count <= _Small_string_capacity) {

  0001b	83 fb 07	 cmp	 ebx, 7
  0001e	77 29		 ja	 SHORT $LN3@Construct
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00020	8d 34 1b	 lea	 esi, DWORD PTR [ebx+ebx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 890  :             _My_data._Mysize = _Count;

  00023	89 5f 10	 mov	 DWORD PTR [edi+16], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00026	56		 push	 esi
  00027	ff 75 08	 push	 DWORD PTR __Arg$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 891  :             _My_data._Myres  = _Small_string_capacity;

  0002a	c7 47 14 07 00
	00 00		 mov	 DWORD PTR [edi+20], 7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00031	57		 push	 edi
  00032	e8 00 00 00 00	 call	 _memcpy
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 929  :     }

  0003a	33 c0		 xor	 eax, eax
  0003c	66 89 04 3e	 mov	 WORD PTR [esi+edi], ax
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
$LN3@Construct:

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

  00049	8b f3		 mov	 esi, ebx
  0004b	83 ce 07	 or	 esi, 7
  0004e	81 fe fe ff ff
	7f		 cmp	 esi, 2147483646		; 7ffffffeH

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00054	76 41		 jbe	 SHORT $LN9@Construct

; 2980 :             return _Max;

  00056	be fe ff ff 7f	 mov	 esi, 2147483646		; 7ffffffeH
  0005b	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN23@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 122  :     return _Count * _Ty_size;

  00060	03 c0		 add	 eax, eax

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00062	50		 push	 eax

; 122  :     return _Count * _Ty_size;

  00063	0f ae e8	 lfence

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00066	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 912  :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

  0006b	8b f8		 mov	 edi, eax

; 913  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]

; 916  :         _My_data._Myres  = _New_capacity;

  00070	89 70 14	 mov	 DWORD PTR [eax+20], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00073	8d 34 1b	 lea	 esi, DWORD PTR [ebx+ebx]
  00076	56		 push	 esi
  00077	ff 75 08	 push	 DWORD PTR __Arg$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 913  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  0007a	89 38		 mov	 DWORD PTR [eax], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0007c	57		 push	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 915  :         _My_data._Mysize = _Count;

  0007d	89 58 10	 mov	 DWORD PTR [eax+16], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00080	e8 00 00 00 00	 call	 _memcpy
  00085	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 929  :     }

  00088	33 c0		 xor	 eax, eax
  0008a	66 89 04 3e	 mov	 WORD PTR [esi+edi], ax
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 08 00	 ret	 8
$LN9@Construct:

; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00097	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  0009c	3b f0		 cmp	 esi, eax
  0009e	0f 42 f0	 cmovb	 esi, eax

; 825  :         ++_Capacity; // Take null terminator into consideration

  000a1	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  000a4	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  000a9	76 b5		 jbe	 SHORT $LN23@Construct

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  000ab	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN39@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 882  :             _Xlen_string(); // result too long

  000b0	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN36@Construct:
  000b5	cc		 int	 3
??$_Construct@$00PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXQB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z
_TEXT	SEGMENT
__Guard$ = -24						; size = 4
__New_ptr$1$ = -20					; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Count$ = 24						; size = 4
??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_from_iter<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> >,std::nullptr_t>, COMDAT
; _this$ = ecx

; 932  :     _CONSTEXPR20 void _Construct_from_iter(_Iter _First, const _Sent _Last, _Size _Count = {}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx

; 933  :         // Pre: _Iter models input_iterator or meets the Cpp17InputIterator requirements.
; 934  :         // Pre: [_First, _Last) is a valid range.
; 935  :         // Pre: if _Iter models forward_iterator or meets the Cpp17ForwardIterator requirements,
; 936  :         //      then is_same_v<_Size, size_type> holds.
; 937  :         // Pre: if is_same_v<_Size, size_type>, _Count is the length of [_First, _Last).
; 938  :         // Pre: *this is in small mode; the lifetime of the SSO elements has already begun.
; 939  : 
; 940  :         auto& _My_data  = _Mypair._Myval2;
; 941  :         auto& _Al       = _Getal();
; 942  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 943  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 944  : 
; 945  :         _My_data._Mysize = 0;

  0002a	8d 77 10	 lea	 esi, DWORD PTR [edi+16]

; 946  :         _My_data._Myres  = _Small_string_capacity;

  0002d	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
  00034	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0003a	89 75 f0	 mov	 DWORD PTR $T2[ebp], esi

; 961  :         _Tidy_deallocate_guard<basic_string> _Guard{this};

  0003d	89 7d e8	 mov	 DWORD PTR __Guard$[ebp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 495  :     return !(_Left == _Right);

  00040	8d 45 10	 lea	 eax, DWORD PTR __Last$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 961  :         _Tidy_deallocate_guard<basic_string> _Guard{this};

  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 495  :     return !(_Left == _Right);

  0004a	50		 push	 eax
  0004b	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
  00054	83 c4 08	 add	 esp, 8
  00057	84 c0		 test	 al, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 972  :             for (; _First != _Last; ++_First) {

  00059	0f 85 5c 01 00
	00		 jne	 $LN137@Construct_
  0005f	90		 npad	 1
$LL4@Construct_:

; 973  :                 if constexpr (!is_same_v<_Size, size_type>) {
; 974  :                     if (_My_data._Mysize == _My_data._Myres) { // Need to grow

  00060	8b 06		 mov	 eax, DWORD PTR [esi]
  00062	8b 77 14	 mov	 esi, DWORD PTR [edi+20]
  00065	3b c6		 cmp	 eax, esi
  00067	0f 85 9f 00 00
	00		 jne	 $LN146@Construct_

; 975  :                         if (_My_data._Mysize == max_size()) {

  0006d	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00072	0f 84 65 01 00
	00		 je	 $LN134@Construct_

; 435  :         value_type* _Result = _Bx._Buf;

  00078	8b df		 mov	 ebx, edi

; 453  :         return _Myres > _Small_string_capacity;

  0007a	83 fe 0f	 cmp	 esi, 15			; 0000000fH

; 436  :         if (_Large_mode_engaged()) {

  0007d	76 02		 jbe	 SHORT $LN145@Construct_

; 437  :             _Result = _Unfancy(_Bx._Ptr);

  0007f	8b 1f		 mov	 ebx, DWORD PTR [edi]
$LN145@Construct_:

; 2991 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00081	8b d6		 mov	 edx, esi

; 977  :                         }
; 978  : 
; 979  :                         _Elem* const _Old_ptr   = _My_data._Myptr();
; 980  :                         size_type _New_capacity = _Calculate_growth(_My_data._Mysize + 1);

  00083	8d 70 01	 lea	 esi, DWORD PTR [eax+1]

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

  00086	83 ce 0f	 or	 esi, 15			; 0000000fH
  00089	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0008f	76 07		 jbe	 SHORT $LN96@Construct_

; 2980 :             return _Max;

  00091	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  00096	eb 1e		 jmp	 SHORT $LN95@Construct_
$LN96@Construct_:

; 2981 :         }
; 2982 : 
; 2983 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00098	8b ca		 mov	 ecx, edx
  0009a	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0009f	d1 e9		 shr	 ecx, 1
  000a1	2b c1		 sub	 eax, ecx
  000a3	3b d0		 cmp	 edx, eax
  000a5	76 07		 jbe	 SHORT $LN97@Construct_

; 2984 :             return _Max;

  000a7	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  000ac	eb 08		 jmp	 SHORT $LN95@Construct_
$LN97@Construct_:

; 2985 :         }
; 2986 : 
; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

  000ae	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  000b1	3b f0		 cmp	 esi, eax
  000b3	0f 42 f0	 cmovb	 esi, eax
$LN95@Construct_:

; 825  :         ++_Capacity; // Take null terminator into consideration

  000b6	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000bf	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 981  :                         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

  000c2	89 45 ec	 mov	 DWORD PTR __New_ptr$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c5	ff 31		 push	 DWORD PTR [ecx]
  000c7	53		 push	 ebx
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  000ce	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d1	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  000d4	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 982  : 
; 983  :                         _Traits::copy(_Unfancy(_New_ptr), _Old_ptr, _My_data._Mysize);
; 984  :                         if (_My_data._Large_mode_engaged()) { // Need to deallocate old storage

  000d7	76 2b		 jbe	 SHORT $LN7@Construct_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000d9	8b 07		 mov	 eax, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  000db	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000dc	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000e2	72 16		 jb	 SHORT $LN128@Construct_

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000e4	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000e7	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000ea	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000ec	83 c0 fc	 add	 eax, -4			; fffffffcH
  000ef	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000f2	0f 87 ea 00 00
	00		 ja	 $LN135@Construct_

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000f8	8b c2		 mov	 eax, edx
$LN128@Construct_:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000fa	51		 push	 ecx
  000fb	50		 push	 eax
  000fc	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00101	83 c4 08	 add	 esp, 8
$LN7@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 990  :                         _My_data._Myres = _New_capacity;

  00104	8b 45 ec	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
  00107	89 07		 mov	 DWORD PTR [edi], eax
  00109	89 77 14	 mov	 DWORD PTR [edi+20], esi
$LN146@Construct_:

; 435  :         value_type* _Result = _Bx._Buf;

  0010c	8b df		 mov	 ebx, edi

; 453  :         return _Myres > _Small_string_capacity;

  0010e	83 fe 0f	 cmp	 esi, 15			; 0000000fH

; 436  :         if (_Large_mode_engaged()) {

  00111	76 02		 jbe	 SHORT $LN144@Construct_

; 437  :             _Result = _Unfancy(_Bx._Ptr);

  00113	8b 1f		 mov	 ebx, DWORD PTR [edi]
$LN144@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 406  :         if (!_Got) {

  00115	80 7d 0c 00	 cmp	 BYTE PTR __First$[ebp+4], 0
  00119	75 33		 jne	 SHORT $LN148@Construct_

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0011b	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0011e	85 c9		 test	 ecx, ecx
  00120	74 25		 je	 SHORT $LN62@Construct_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00122	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00125	8b 10		 mov	 edx, DWORD PTR [eax]
  00127	85 d2		 test	 edx, edx
  00129	74 0d		 je	 SHORT $LN66@Construct_
  0012b	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0012e	83 38 00	 cmp	 DWORD PTR [eax], 0
  00131	7e 05		 jle	 SHORT $LN66@Construct_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00133	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00136	eb 05		 jmp	 SHORT $LN67@Construct_
$LN66@Construct_:
  00138	8b 01		 mov	 eax, DWORD PTR [ecx]
  0013a	ff 50 18	 call	 DWORD PTR [eax+24]
$LN67@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  0013d	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00140	74 05		 je	 SHORT $LN62@Construct_

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00142	88 45 0d	 mov	 BYTE PTR __First$[ebp+5], al
  00145	eb 07		 jmp	 SHORT $LN148@Construct_
$LN62@Construct_:

; 471  :             _Strbuf = nullptr;

  00147	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __First$[ebp], 0
$LN148@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 995  :                 _Traits::assign(_Ptr[_My_data._Mysize], *_First);

  0014e	8b 75 f0	 mov	 esi, DWORD PTR $T2[ebp]
  00151	8a 45 0d	 mov	 al, BYTE PTR __First$[ebp+5]
  00154	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00156	88 04 0b	 mov	 BYTE PTR [ebx+ecx], al

; 996  :                 ++_My_data._Mysize;

  00159	ff 06		 inc	 DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  0015b	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0015e	85 c9		 test	 ecx, ecx
  00160	74 33		 je	 SHORT $LN143@Construct_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00162	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00165	83 38 00	 cmp	 DWORD PTR [eax], 0
  00168	74 1b		 je	 SHORT $LN33@Construct_
  0016a	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0016d	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  0016f	85 c0		 test	 eax, eax
  00171	7e 12		 jle	 SHORT $LN33@Construct_

; 222  :         --*_IGcount;

  00173	48		 dec	 eax
  00174	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  00176	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00179	8b 11		 mov	 edx, DWORD PTR [ecx]
  0017b	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0017e	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00180	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  00183	eb 05		 jmp	 SHORT $LN34@Construct_
$LN33@Construct_:
  00185	8b 01		 mov	 eax, DWORD PTR [ecx]
  00187	ff 50 1c	 call	 DWORD PTR [eax+28]
$LN34@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  0018a	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  0018d	74 06		 je	 SHORT $LN143@Construct_

; 463  :         } else {
; 464  :             _Got = false;

  0018f	c6 45 0c 00	 mov	 BYTE PTR __First$[ebp+4], 0
  00193	eb 0b		 jmp	 SHORT $LN136@Construct_
$LN143@Construct_:

; 461  :             _Strbuf = nullptr;

  00195	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __First$[ebp], 0

; 462  :             _Got    = true;

  0019c	c6 45 0c 01	 mov	 BYTE PTR __First$[ebp+4], 1
$LN136@Construct_:

; 495  :     return !(_Left == _Right);

  001a0	8d 45 10	 lea	 eax, DWORD PTR __Last$[ebp]
  001a3	50		 push	 eax
  001a4	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  001a7	50		 push	 eax
  001a8	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
  001ad	83 c4 08	 add	 esp, 8
  001b0	84 c0		 test	 al, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 972  :             for (; _First != _Last; ++_First) {

  001b2	0f 84 a8 fe ff
	ff		 je	 $LL4@Construct_

; 990  :                         _My_data._Myres = _New_capacity;

  001b8	8d 77 10	 lea	 esi, DWORD PTR [edi+16]
$LN137@Construct_:

; 453  :         return _Myres > _Small_string_capacity;

  001bb	83 7f 14 0f	 cmp	 DWORD PTR [edi+20], 15	; 0000000fH

; 436  :         if (_Large_mode_engaged()) {

  001bf	76 02		 jbe	 SHORT $LN12@Construct_

; 437  :             _Result = _Unfancy(_Bx._Ptr);

  001c1	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN12@Construct_:

; 997  :             }
; 998  : 
; 999  :             _Elem* const _Ptr = _My_data._Myptr();
; 1000 :             _Traits::assign(_Ptr[_My_data._Mysize], _Elem());

  001c3	8b 06		 mov	 eax, DWORD PTR [esi]
  001c5	c6 04 07 00	 mov	 BYTE PTR [edi+eax], 0

; 1006 :     }

  001c9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001cc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d3	59		 pop	 ecx
  001d4	5f		 pop	 edi
  001d5	5e		 pop	 esi
  001d6	5b		 pop	 ebx
  001d7	8b e5		 mov	 esp, ebp
  001d9	5d		 pop	 ebp
  001da	c2 14 00	 ret	 20			; 00000014H
$LN134@Construct_:

; 976  :                             _Xlen_string(); // result too long

  001dd	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN135@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001e2	6a 00		 push	 0
  001e4	6a 00		 push	 0
  001e6	6a 00		 push	 0
  001e8	6a 00		 push	 0
  001ea	6a 00		 push	 0
  001ec	e8 00 00 00 00	 call	 __invoke_watson
$LN150@Construct_:
  001f1	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Guard$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_from_iter<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> >,std::nullptr_t>
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
;	COMDAT ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z PROC ; std::operator==<char,std::char_traits<char> >, COMDAT

; 487  :     const istreambuf_iterator<_Elem, _Traits>& _Left, const istreambuf_iterator<_Elem, _Traits>& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 0c	 mov	 esi, DWORD PTR __Right$[ebp]
  00007	57		 push	 edi

; 437  :         if (!_Got) {

  00008	8b 7d 08	 mov	 edi, DWORD PTR __Left$[ebp]
  0000b	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  0000f	75 35		 jne	 SHORT $LN66@operator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00011	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00013	85 c9		 test	 ecx, ecx
  00015	74 25		 je	 SHORT $LN14@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00017	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0001a	8b 10		 mov	 edx, DWORD PTR [eax]
  0001c	85 d2		 test	 edx, edx
  0001e	74 0d		 je	 SHORT $LN18@operator
  00020	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00023	83 38 00	 cmp	 DWORD PTR [eax], 0
  00026	7e 05		 jle	 SHORT $LN18@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00028	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0002b	eb 05		 jmp	 SHORT $LN19@operator
$LN18@operator:
  0002d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002f	ff 50 18	 call	 DWORD PTR [eax+24]
$LN19@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00032	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00035	74 05		 je	 SHORT $LN14@operator

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00037	88 47 05	 mov	 BYTE PTR [edi+5], al
  0003a	eb 06		 jmp	 SHORT $LN13@operator
$LN14@operator:

; 471  :             _Strbuf = nullptr;

  0003c	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN13@operator:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00042	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN66@operator:

; 441  :         if (!_Right._Got) {

  00046	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  0004a	75 35		 jne	 SHORT $LN5@operator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0004c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0004e	85 c9		 test	 ecx, ecx
  00050	74 25		 je	 SHORT $LN40@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00052	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	85 d2		 test	 edx, edx
  00059	74 0d		 je	 SHORT $LN44@operator
  0005b	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0005e	83 38 00	 cmp	 DWORD PTR [eax], 0
  00061	7e 05		 jle	 SHORT $LN44@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00063	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00066	eb 05		 jmp	 SHORT $LN45@operator
$LN44@operator:
  00068	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006a	ff 50 18	 call	 DWORD PTR [eax+24]
$LN45@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  0006d	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00070	74 05		 je	 SHORT $LN40@operator

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  00072	88 46 05	 mov	 BYTE PTR [esi+5], al
  00075	eb 06		 jmp	 SHORT $LN39@operator
$LN40@operator:

; 471  :             _Strbuf = nullptr;

  00077	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN39@operator:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  0007d	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN5@operator:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  00081	83 3f 00	 cmp	 DWORD PTR [edi], 0
  00084	8b 06		 mov	 eax, DWORD PTR [esi]
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	75 08		 jne	 SHORT $LN65@operator
  0008a	85 c0		 test	 eax, eax
  0008c	74 08		 je	 SHORT $LN9@operator
$LN8@operator:
  0008e	32 c0		 xor	 al, al

; 488  :     return _Left.equal(_Right);
; 489  : }

  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
$LN65@operator:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

  00092	85 c0		 test	 eax, eax
  00094	74 f8		 je	 SHORT $LN8@operator
$LN9@operator:
  00096	b0 01		 mov	 al, 1

; 488  :     return _Left.equal(_Right);
; 489  : }

  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ENDP ; std::operator==<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z
_TEXT	SEGMENT
$T2 = -60						; size = 20
__Ok$ = -40						; size = 8
$T3 = -32						; size = 8
tv756 = -28						; size = 4
$T4 = -28						; size = 4
tv751 = -24						; size = 4
$T5 = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Data$ = 12						; size = 4
__Size$ = 16						; size = 4
??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z PROC ; std::_Insert_string<wchar_t,std::char_traits<wchar_t>,unsigned int>, COMDAT

; 547  :     basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 30	 sub	 esp, 48			; 00000030H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 548  :     // insert a character-type sequence into _Ostr as if through a basic_string copy
; 549  :     using _Ostr_t                    = basic_ostream<_Elem, _Traits>;
; 550  :     typename _Ostr_t::iostate _State = _Ostr_t::goodbit;
; 551  : 
; 552  :     _SizeT _Pad;
; 553  :     if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {

  0002b	8b 5d 08	 mov	 ebx, DWORD PTR __Ostr$[ebp]
  0002e	33 ff		 xor	 edi, edi
  00030	89 7d ec	 mov	 DWORD PTR __State$[ebp], edi
  00033	8b 03		 mov	 eax, DWORD PTR [ebx]
  00035	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00038	8b 74 18 20	 mov	 esi, DWORD PTR [eax+ebx+32]
  0003c	39 7c 18 24	 cmp	 DWORD PTR [eax+ebx+36], edi
  00040	7c 11		 jl	 SHORT $LN10@Insert_str
  00042	7f 04		 jg	 SHORT $LN101@Insert_str
  00044	85 f6		 test	 esi, esi
  00046	74 0b		 je	 SHORT $LN10@Insert_str
$LN101@Insert_str:
  00048	8b 45 10	 mov	 eax, DWORD PTR __Size$[ebp]
  0004b	3b f0		 cmp	 esi, eax
  0004d	76 04		 jbe	 SHORT $LN10@Insert_str

; 555  :     } else {
; 556  :         _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;

  0004f	2b f0		 sub	 esi, eax
  00051	eb 02		 jmp	 SHORT $LN9@Insert_str
$LN10@Insert_str:

; 554  :         _Pad = 0;

  00053	33 f6		 xor	 esi, esi
$LN9@Insert_str:

; 557  :     }
; 558  : 
; 559  :     const typename _Ostr_t::sentry _Ok(_Ostr);

  00055	53		 push	 ebx
  00056	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00059	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry

; 560  : 
; 561  :     if (!_Ok) {

  0005e	80 7d dc 00	 cmp	 BYTE PTR __Ok$[ebp+4], 0
  00062	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00069	75 0a		 jne	 SHORT $LN11@Insert_str

; 562  :         _State |= _Ostr_t::badbit;

  0006b	bf 04 00 00 00	 mov	 edi, 4

; 563  :     } else { // state okay, insert characters

  00070	e9 2f 01 00 00	 jmp	 $LN23@Insert_str
$LN11@Insert_str:

; 564  :         _TRY_IO_BEGIN
; 565  :         if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {

  00075	8b 03		 mov	 eax, DWORD PTR [ebx]
  00077	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0007b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007e	8b 44 18 14	 mov	 eax, DWORD PTR [eax+ebx+20]
  00082	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00087	83 f8 40	 cmp	 eax, 64			; 00000040H
  0008a	74 62		 je	 SHORT $LN98@Insert_str
  0008c	0f 1f 40 00	 npad	 4
$LL4@Insert_str:

; 566  :             for (; 0 < _Pad; --_Pad) { // pad on left

  00090	85 f6		 test	 esi, esi
  00092	74 5a		 je	 SHORT $LN98@Insert_str

; 567  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00094	8b 03		 mov	 eax, DWORD PTR [ebx]
  00096	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00099	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]
  0009d	0f b7 54 18 40	 movzx	 edx, WORD PTR [eax+ebx+64]
  000a2	89 55 e4	 mov	 DWORD PTR $T4[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 261  :         return *_IPnext ? *_IPcount : 0;

  000a5	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  000a8	83 38 00	 cmp	 DWORD PTR [eax], 0
  000ab	74 21		 je	 SHORT $LN72@Insert_str
  000ad	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  000b0	8b 00		 mov	 eax, DWORD PTR [eax]

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  000b2	85 c0		 test	 eax, eax
  000b4	7e 18		 jle	 SHORT $LN72@Insert_str

; 256  :         --*_IPcount;

  000b6	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000b9	48		 dec	 eax
  000ba	89 02		 mov	 DWORD PTR [edx], eax

; 257  :         return (*_IPnext)++;

  000bc	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  000bf	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c1	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  000c4	89 01		 mov	 DWORD PTR [ecx], eax

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  000c6	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  000c9	66 89 02	 mov	 WORD PTR [edx], ax
  000cc	eb 06		 jmp	 SHORT $LN109@Insert_str
$LN72@Insert_str:
  000ce	8b 01		 mov	 eax, DWORD PTR [ecx]
  000d0	52		 push	 edx
  000d1	ff 50 0c	 call	 DWORD PTR [eax+12]
$LN109@Insert_str:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 367  :         return _Left == _Right;

  000d4	0f b7 c0	 movzx	 eax, ax
  000d7	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  000dc	66 3b c8	 cmp	 cx, ax

; 567  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  000df	75 0a		 jne	 SHORT $LN2@Insert_str

; 568  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

  000e1	bf 04 00 00 00	 mov	 edi, 4
  000e6	89 7d ec	 mov	 DWORD PTR __State$[ebp], edi

; 569  :                     break;

  000e9	eb 25		 jmp	 SHORT $LL7@Insert_str
$LN2@Insert_str:

; 566  :             for (; 0 < _Pad; --_Pad) { // pad on left

  000eb	4e		 dec	 esi
  000ec	eb a2		 jmp	 SHORT $LL4@Insert_str
$LN98@Insert_str:

; 575  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {

  000ee	8b 03		 mov	 eax, DWORD PTR [ebx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 171  :         return xsputn(_Ptr, _Count);

  000f0	6a 00		 push	 0
  000f2	ff 75 10	 push	 DWORD PTR __Size$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 575  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {

  000f5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 171  :         return xsputn(_Ptr, _Count);

  000f8	ff 75 0c	 push	 DWORD PTR __Data$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 575  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {

  000fb	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 171  :         return xsputn(_Ptr, _Count);

  000ff	8b 01		 mov	 eax, DWORD PTR [ecx]
  00101	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00104	ff d0		 call	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 575  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {

  00106	3b 45 10	 cmp	 eax, DWORD PTR __Size$[ebp]
  00109	75 59		 jne	 SHORT $LN102@Insert_str
  0010b	85 d2		 test	 edx, edx
  0010d	75 55		 jne	 SHORT $LN102@Insert_str
  0010f	90		 npad	 1
$LL7@Insert_str:

; 576  :             _State |= _Ostr_t::badbit;
; 577  :         } else {
; 578  :             for (; 0 < _Pad; --_Pad) { // pad on right

  00110	85 f6		 test	 esi, esi
  00112	74 53		 je	 SHORT $LN6@Insert_str

; 579  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00114	8b 03		 mov	 eax, DWORD PTR [ebx]
  00116	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00119	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]
  0011d	0f b7 54 18 40	 movzx	 edx, WORD PTR [eax+ebx+64]
  00122	89 55 e8	 mov	 DWORD PTR $T5[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 261  :         return *_IPnext ? *_IPcount : 0;

  00125	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00128	83 38 00	 cmp	 DWORD PTR [eax], 0
  0012b	74 21		 je	 SHORT $LN57@Insert_str
  0012d	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00130	8b 00		 mov	 eax, DWORD PTR [eax]

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  00132	85 c0		 test	 eax, eax
  00134	7e 18		 jle	 SHORT $LN57@Insert_str

; 256  :         --*_IPcount;

  00136	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00139	48		 dec	 eax
  0013a	89 02		 mov	 DWORD PTR [edx], eax

; 257  :         return (*_IPnext)++;

  0013c	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  0013f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00141	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  00144	89 01		 mov	 DWORD PTR [ecx], eax

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  00146	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00149	66 89 02	 mov	 WORD PTR [edx], ax
  0014c	eb 06		 jmp	 SHORT $LN110@Insert_str
$LN57@Insert_str:
  0014e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00150	52		 push	 edx
  00151	ff 50 0c	 call	 DWORD PTR [eax+12]
$LN110@Insert_str:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 367  :         return _Left == _Right;

  00154	0f b7 c0	 movzx	 eax, ax
  00157	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0015c	66 3b c8	 cmp	 cx, ax

; 579  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  0015f	74 03		 je	 SHORT $LN102@Insert_str

; 576  :             _State |= _Ostr_t::badbit;
; 577  :         } else {
; 578  :             for (; 0 < _Pad; --_Pad) { // pad on right

  00161	4e		 dec	 esi
  00162	eb ac		 jmp	 SHORT $LL7@Insert_str
$LN102@Insert_str:

; 580  :                     _State |= _Ostr_t::badbit; // insertion failed, quit
; 581  :                     break;
; 582  :                 }
; 583  :             }
; 584  :         }
; 585  : 
; 586  :         _Ostr.width(0);

  00164	83 cf 04	 or	 edi, 4
$LN6@Insert_str:
  00167	8b 03		 mov	 eax, DWORD PTR [ebx]
  00169	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 284  :         _Wide                      = _Newwidth;

  0016c	c7 44 18 20 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+32], 0
  00174	c7 44 18 24 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+36], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
  0017c	eb 1f		 jmp	 SHORT $LN111@Insert_str
__catch$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z$0:

; 587  :         _CATCH_IO_(_Ostr_t, _Ostr)

  0017e	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00181	6a 01		 push	 1
  00183	6a 04		 push	 4
  00185	8b 02		 mov	 eax, DWORD PTR [edx]
  00187	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0018a	03 ca		 add	 ecx, edx
  0018c	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::setstate
  00191	b8 00 00 00 00	 mov	 eax, $LN24@Insert_str
  00196	c3		 ret	 0
$LN24@Insert_str:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
  00197	8b 5d 08	 mov	 ebx, DWORD PTR __Ostr$[ebp]
  0019a	8b 7d ec	 mov	 edi, DWORD PTR __State$[ebp]
$LN111@Insert_str:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 590  :     _Ostr.setstate(_State);

  0019d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN23@Insert_str:
  001a4	8b 03		 mov	 eax, DWORD PTR [ebx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  001a6	33 f6		 xor	 esi, esi
  001a8	b9 04 00 00 00	 mov	 ecx, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 590  :     _Ostr.setstate(_State);

  001ad	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 51   :         clear(rdstate() | _State, _Reraise);

  001b0	8b 44 1a 0c	 mov	 eax, DWORD PTR [edx+ebx+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 590  :     _Ostr.setstate(_State);

  001b4	03 d3		 add	 edx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 51   :         clear(rdstate() | _State, _Reraise);

  001b6	0b c7		 or	 eax, edi

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  001b8	39 72 38	 cmp	 DWORD PTR [edx+56], esi
  001bb	0f 45 ce	 cmovne	 ecx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 155  :         _State &= _Statmask;

  001be	0b c8		 or	 ecx, eax

; 156  :         _Mystate             = _State;
; 157  :         const auto _Filtered = _State & _Except;

  001c0	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  001c3	83 e1 17	 and	 ecx, 23			; 00000017H
  001c6	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  001c9	23 c1		 and	 eax, ecx

; 158  :         if (_Filtered) {

  001cb	75 41		 jne	 SHORT $LN113@Insert_str
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 111  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  001cd	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception

; 112  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 113  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 114  : #endif // ^^^ !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION ^^^
; 115  : 
; 116  :             if (_Zero_uncaught_exceptions) {

  001d2	84 c0		 test	 al, al
  001d4	75 08		 jne	 SHORT $LN41@Insert_str

; 117  :                 this->_Myostr._Osfx();

  001d6	8b 4d d8	 mov	 ecx, DWORD PTR __Ok$[ebp]
  001d9	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
$LN41@Insert_str:

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

  001de	8b 4d d8	 mov	 ecx, DWORD PTR __Ok$[ebp]
  001e1	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3
  001e8	8b 01		 mov	 eax, DWORD PTR [ecx]
  001ea	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001ed	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]

; 78   :             if (_Rdbuf) {

  001f1	85 c9		 test	 ecx, ecx
  001f3	74 05		 je	 SHORT $LN47@Insert_str

; 79   :                 _Rdbuf->_Unlock();

  001f5	8b 11		 mov	 edx, DWORD PTR [ecx]
  001f7	ff 52 08	 call	 DWORD PTR [edx+8]
$LN47@Insert_str:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 591  :     return _Ostr;

  001fa	8b c3		 mov	 eax, ebx

; 592  : }

  001fc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001ff	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00206	59		 pop	 ecx
  00207	5f		 pop	 edi
  00208	5e		 pop	 esi
  00209	5b		 pop	 ebx
  0020a	8b e5		 mov	 esp, ebp
  0020c	5d		 pop	 ebp
  0020d	c3		 ret	 0
$LN113@Insert_str:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 164  :             if (_Filtered & ios_base::badbit) {

  0020e	a8 04		 test	 al, 4
  00210	74 07		 je	 SHORT $LN32@Insert_str

; 165  :                 _Msg = "ios_base::badbit set";

  00212	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  00217	eb 0f		 jmp	 SHORT $LN34@Insert_str
$LN32@Insert_str:

; 166  :             } else if (_Filtered & ios_base::failbit) {

  00219	a8 02		 test	 al, 2
  0021b	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
  00220	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
  00225	0f 44 f0	 cmove	 esi, eax
$LN34@Insert_str:

; 167  :                 _Msg = "ios_base::failbit set";
; 168  :             } else {
; 169  :                 _Msg = "ios_base::eofbit set";
; 170  :             }
; 171  : 
; 172  :             _THROW(failure(_Msg));

  00228	8d 45 e0	 lea	 eax, DWORD PTR $T3[ebp]
  0022b	6a 01		 push	 1
  0022d	50		 push	 eax
  0022e	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  00233	83 c4 08	 add	 esp, 8
  00236	8d 4d c4	 lea	 ecx, DWORD PTR $T2[ebp]
  00239	50		 push	 eax
  0023a	56		 push	 esi
  0023b	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  00240	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00245	8d 45 c4	 lea	 eax, DWORD PTR $T2[ebp]
  00248	50		 push	 eax
  00249	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN108@Insert_str:
  0024e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z$2:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a c0	 mov	 ecx, DWORD PTR [edx-64]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z ENDP ; std::_Insert_string<wchar_t,std::char_traits<wchar_t>,unsigned int>
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -140						; size = 52
$T3 = -88						; size = 44
$T4 = -44						; size = 16
__Lock$5 = -28						; size = 4
$T6 = -24						; size = 4
__Psave$1$ = -24					; size = 4
$T7 = -20						; size = 4
__Lock$8 = -16						; size = 4
$T9 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
__Psave_guard$10 = 8					; size = 4
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<wchar_t> >, COMDAT

; 435  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 436  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

  0002a	6a 00		 push	 0
  0002c	8d 4d e4	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  0002f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T7[ebp], 0
  00036	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 91   :             if (_Id == 0) { // still zero, allocate stamp

  0003b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$ctype@_W@std@@2V0locale@2@A ; std::ctype<wchar_t>::id

; 437  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

  00041	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
  00046	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004d	89 45 e8	 mov	 DWORD PTR __Psave$1$[ebp], eax

; 91   :             if (_Id == 0) { // still zero, allocate stamp

  00050	85 ff		 test	 edi, edi
  00052	75 2f		 jne	 SHORT $LN11@use_facet

; 92   :                 _BEGIN_LOCK(_LOCK_LOCALE)

  00054	57		 push	 edi
  00055	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$8[ebp]
  00058	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 93   :                 if (_Id == 0) {

  0005d	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?id@?$ctype@_W@std@@2V0locale@2@A, edi ; std::ctype<wchar_t>::id
  00063	75 10		 jne	 SHORT $LN12@use_facet

; 94   :                     _Id = static_cast<size_t>(++_Id_cnt);

  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  0006a	40		 inc	 eax
  0006b	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00070	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$ctype@_W@std@@2V0locale@2@A, eax ; std::ctype<wchar_t>::id
$LN12@use_facet:

; 95   :                 }
; 96   :                 _END_LOCK()

  00075	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$8[ebp]
  00078	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0007d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$ctype@_W@std@@2V0locale@2@A ; std::ctype<wchar_t>::id
$LN11@use_facet:

; 377  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  00083	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00086	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
  0008d	89 4d f0	 mov	 DWORD PTR $T9[ebp], ecx
  00090	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00093	3b 7a 0c	 cmp	 edi, DWORD PTR [edx+12]
  00096	73 16		 jae	 SHORT $LN19@use_facet
  00098	0f ae e8	 lfence
  0009b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0009e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000a1	8b 34 01	 mov	 esi, DWORD PTR [ecx+eax]

; 378  :         if (_Facptr || !_Ptr->_Xparent) {

  000a4	85 f6		 test	 esi, esi
  000a6	0f 85 f8 00 00
	00		 jne	 $LN79@use_facet
  000ac	eb 05		 jmp	 SHORT $LN83@use_facet
$LN19@use_facet:

; 374  :     }
; 375  : 
; 376  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object
; 377  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  000ae	33 f6		 xor	 esi, esi
  000b0	89 4d f0	 mov	 DWORD PTR $T9[ebp], ecx
$LN83@use_facet:

; 378  :         if (_Facptr || !_Ptr->_Xparent) {

  000b3	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0
  000b7	74 16		 je	 SHORT $LN14@use_facet

; 379  :             return _Facptr; // found facet or not transparent
; 380  :         }
; 381  : 
; 382  :         // look in current locale
; 383  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

  000b9	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 384  :         if (_Id < _Ptr0->_Facetcount) {

  000be	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  000c1	73 14		 jae	 SHORT $LN84@use_facet

; 385  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

  000c3	0f ae e8	 lfence
  000c6	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c9	8b 75 f0	 mov	 esi, DWORD PTR $T9[ebp]
  000cc	8b 34 06	 mov	 esi, DWORD PTR [esi+eax]
$LN14@use_facet:

; 438  : 
; 439  :     const size_t _Id         = _Facet::id._Get_index();
; 440  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);
; 441  : 
; 442  :     if (!_Pf) {

  000cf	85 f6		 test	 esi, esi
  000d1	0f 85 cd 00 00
	00		 jne	 $LN79@use_facet
$LN84@use_facet:

; 443  :         if (_Psave) {

  000d7	8b 45 e8	 mov	 eax, DWORD PTR __Psave$1$[ebp]
  000da	85 c0		 test	 eax, eax
  000dc	74 07		 je	 SHORT $LN3@use_facet

; 444  :             _Pf = _Psave; // lazy facet already allocated

  000de	8b f0		 mov	 esi, eax

; 445  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

  000e0	e9 bf 00 00 00	 jmp	 $LN79@use_facet
$LN3@use_facet:

; 2962 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->_C_str()));

  000e5	6a 44		 push	 68			; 00000044H
  000e7	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ec	8b f0		 mov	 esi, eax
  000ee	83 c4 04	 add	 esp, 4
  000f1	89 75 e8	 mov	 DWORD PTR $T6[ebp], esi
  000f4	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000f8	85 f6		 test	 esi, esi
  000fa	74 78		 je	 SHORT $LN24@use_facet

; 373  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  000fc	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  000ff	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00102	85 c9		 test	 ecx, ecx
  00104	74 0c		 je	 SHORT $LN32@use_facet
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo

; 190  :         return _Myptr ? _Myptr : &_Nul;

  00106	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00109	85 c0		 test	 eax, eax
  0010b	75 0a		 jne	 SHORT $LN33@use_facet
  0010d	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 373  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  00110	eb 05		 jmp	 SHORT $LN33@use_facet
$LN32@use_facet:
  00112	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@@
$LN33@use_facet:

; 2962 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->_C_str()));

  00117	50		 push	 eax
  00118	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0011e	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo

; 277  :         return ::_Getctype();

  00123	8d 45 d4	 lea	 eax, DWORD PTR $T4[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 2962 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->_C_str()));

  00126	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR $T7[ebp], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo

; 277  :         return ::_Getctype();

  0012d	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 143  :             : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs)) // non-atomic initialization

  0012e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 2956 :     __CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {

  00135	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@_W@std@@6B@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo

; 277  :         return ::_Getctype();

  0013b	e8 00 00 00 00	 call	 __Getctype
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 2978 :         _Ctype = _Lobj._Getctype();

  00140	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo

; 281  :         return ::_Getcvt();

  00143	8d 45 a8	 lea	 eax, DWORD PTR $T3[ebp]
  00146	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 2978 :         _Ctype = _Lobj._Getctype();

  00147	0f 11 46 08	 movups	 XMMWORD PTR [esi+8], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo

; 281  :         return ::_Getcvt();

  0014b	e8 00 00 00 00	 call	 __Getcvt
  00150	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 2979 :         _Cvt   = _Lobj._Getcvt();

  00153	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00156	0f 11 46 18	 movups	 XMMWORD PTR [esi+24], xmm0
  0015a	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  0015e	0f 11 46 28	 movups	 XMMWORD PTR [esi+40], xmm0
  00162	f3 0f 7e 40 20	 movq	 xmm0, QWORD PTR [eax+32]
  00167	66 0f d6 46 38	 movq	 QWORD PTR [esi+56], xmm0
  0016c	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0016f	89 46 40	 mov	 DWORD PTR [esi+64], eax

; 2962 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->_C_str()));

  00172	eb 02		 jmp	 SHORT $LN25@use_facet
$LN24@use_facet:
  00174	33 f6		 xor	 esi, esi
$LN25@use_facet:
  00176	f6 45 ec 01	 test	 BYTE PTR $T7[ebp], 1
  0017a	74 0b		 je	 SHORT $LN29@use_facet
  0017c	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00182	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN29@use_facet:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00187	89 75 08	 mov	 DWORD PTR __Psave_guard$10[ebp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 458  :             _Facet_Register(_Pfmod);

  0018a	56		 push	 esi
  0018b	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0018f	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register

; 459  : #endif // ^^^ !defined(_M_CEE) ^^^
; 460  : 
; 461  :             _Pfmod->_Incref();

  00194	8b 16		 mov	 edx, DWORD PTR [esi]
  00196	83 c4 04	 add	 esp, 4
  00199	8b ce		 mov	 ecx, esi
  0019b	ff 52 04	 call	 DWORD PTR [edx+4]

; 462  :             _Facetptr<_Facet>::_Psave = _Psave;

  0019e	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
$LN79@use_facet:

; 463  :             _Pf                       = _Psave;
; 464  : 
; 465  :             (void) _Psave_guard.release();
; 466  :         }
; 467  :     }
; 468  : 
; 469  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

  001a4	8d 4d e4	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  001a7	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  001ac	8b c6		 mov	 eax, esi

; 470  :     _END_LOCK()
; 471  : } // end of use_facet body

  001ae	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001b1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001b8	59		 pop	 ecx
  001b9	5f		 pop	 edi
  001ba	5e		 pop	 esi
  001bb	8b e5		 mov	 esp, ebp
  001bd	5d		 pop	 ebp
  001be	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z$2:
  00008	6a 44		 push	 68			; 00000044H
  0000a	8b 45 e8	 mov	 eax, DWORD PTR $T6[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00013	83 c4 08	 add	 esp, 8
  00016	c3		 ret	 0
__unwindfunclet$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z$1:
  00017	8d 4d 08	 lea	 ecx, DWORD PTR __Psave_guard$10[ebp]
  0001a	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
  0001f	cc		 int	 3
  00020	cc		 int	 3
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
__ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z:
  00024	90		 npad	 1
  00025	90		 npad	 1
  00026	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002d	8b 8a 74 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-140]
  00033	33 c8		 xor	 ecx, eax
  00035	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
  0003f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<wchar_t> >
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 107  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 108  : #if !_HAS_EXCEPTIONS
; 109  :             const bool _Zero_uncaught_exceptions = true;
; 110  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 111  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  00025	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception

; 112  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 113  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 114  : #endif // ^^^ !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION ^^^
; 115  : 
; 116  :             if (_Zero_uncaught_exceptions) {

  0002a	84 c0		 test	 al, al
  0002c	75 07		 jne	 SHORT $LN2@sentry

; 117  :                 this->_Myostr._Osfx();

  0002e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00030	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
$LN2@sentry:

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

  00035	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00040	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00043	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]

; 78   :             if (_Rdbuf) {

  00047	85 c9		 test	 ecx, ecx
  00049	74 05		 je	 SHORT $LN6@sentry

; 79   :                 _Rdbuf->_Unlock();

  0004b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004d	ff 50 08	 call	 DWORD PTR [eax+8]
$LN6@sentry:

; 118  :             }
; 119  :         }

  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
  00060	cc		 int	 3
  00061	cc		 int	 3
  00062	cc		 int	 3
  00063	cc		 int	 3
  00064	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry, COMDAT
; _this$ = ecx

; 90   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

  0002a	8b 75 08	 mov	 esi, DWORD PTR __Ostr$[ebp]
  0002d	89 37		 mov	 DWORD PTR [edi], esi

; 70   :             const auto _Rdbuf = _Myostr.rdbuf();

  0002f	8b 06		 mov	 eax, DWORD PTR [esi]
  00031	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00034	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]

; 71   :             if (_Rdbuf) {

  00038	85 c9		 test	 ecx, ecx
  0003a	74 05		 je	 SHORT $LN8@sentry

; 72   :                 _Rdbuf->_Lock();

  0003c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003e	ff 50 04	 call	 DWORD PTR [eax+4]
$LN8@sentry:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 206  :         return rdstate() == ios_base::goodbit;

  00041	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 90   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 206  :         return rdstate() == ios_base::goodbit;

  0004a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004d	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  00052	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 91   :             if (!_Ostr.good()) {

  00055	74 04		 je	 SHORT $LN2@sentry

; 92   :                 _Ok = false;

  00057	32 c0		 xor	 al, al

; 93   :                 return;

  00059	eb 21		 jmp	 SHORT $LN17@sentry
$LN2@sentry:

; 94   :             }
; 95   : 
; 96   :             const auto _Tied = _Ostr.tie();

  0005b	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]

; 97   :             if (!_Tied || _Tied == _STD addressof(_Ostr)) {

  0005e	85 c9		 test	 ecx, ecx
  00060	74 18		 je	 SHORT $LN4@sentry
  00062	3b ce		 cmp	 ecx, esi
  00064	74 14		 je	 SHORT $LN4@sentry

; 99   :                 return;
; 100  :             }
; 101  : 
; 102  :             _Tied->flush();

  00066	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 206  :         return rdstate() == ios_base::goodbit;

  0006b	8b 06		 mov	 eax, DWORD PTR [esi]
  0006d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00070	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  00075	0f 94 c0	 sete	 al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 103  :             _Ok = _Ostr.good(); // store test only after flushing tie

  00078	eb 02		 jmp	 SHORT $LN17@sentry
$LN4@sentry:

; 98   :                 _Ok = true;

  0007a	b0 01		 mov	 al, 1
$LN17@sentry:

; 104  :         }

  0007c	88 47 04	 mov	 BYTE PTR [edi+4], al
  0007f	8b c7		 mov	 eax, edi
  00081	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00084	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008b	59		 pop	 ecx
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 76   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

  00022	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00024	8b 01		 mov	 eax, DWORD PTR [ecx]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00029	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]

; 78   :             if (_Rdbuf) {

  0002d	85 c9		 test	 ecx, ecx
  0002f	74 05		 je	 SHORT $LN2@Sentry_bas

; 79   :                 _Rdbuf->_Unlock();

  00031	8b 01		 mov	 eax, DWORD PTR [ecx]
  00033	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 80   :             }
; 81   :         }

  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
  00045	cc		 int	 3
  00046	cc		 int	 3
  00047	cc		 int	 3
  00048	cc		 int	 3
  00049	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 107  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 108  : #if !_HAS_EXCEPTIONS
; 109  :             const bool _Zero_uncaught_exceptions = true;
; 110  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 111  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  00025	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception

; 112  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 113  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 114  : #endif // ^^^ !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION ^^^
; 115  : 
; 116  :             if (_Zero_uncaught_exceptions) {

  0002a	84 c0		 test	 al, al
  0002c	75 07		 jne	 SHORT $LN2@sentry

; 117  :                 this->_Myostr._Osfx();

  0002e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00030	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN2@sentry:

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

  00035	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00040	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00043	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]

; 78   :             if (_Rdbuf) {

  00047	85 c9		 test	 ecx, ecx
  00049	74 05		 je	 SHORT $LN6@sentry

; 79   :                 _Rdbuf->_Unlock();

  0004b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004d	ff 50 08	 call	 DWORD PTR [eax+8]
$LN6@sentry:

; 118  :             }
; 119  :         }

  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
  00060	cc		 int	 3
  00061	cc		 int	 3
  00062	cc		 int	 3
  00063	cc		 int	 3
  00064	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 90   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

  0002a	8b 75 08	 mov	 esi, DWORD PTR __Ostr$[ebp]
  0002d	89 37		 mov	 DWORD PTR [edi], esi

; 70   :             const auto _Rdbuf = _Myostr.rdbuf();

  0002f	8b 06		 mov	 eax, DWORD PTR [esi]
  00031	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00034	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]

; 71   :             if (_Rdbuf) {

  00038	85 c9		 test	 ecx, ecx
  0003a	74 05		 je	 SHORT $LN8@sentry

; 72   :                 _Rdbuf->_Lock();

  0003c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003e	ff 50 04	 call	 DWORD PTR [eax+4]
$LN8@sentry:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 206  :         return rdstate() == ios_base::goodbit;

  00041	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 90   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 206  :         return rdstate() == ios_base::goodbit;

  0004a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004d	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  00052	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 91   :             if (!_Ostr.good()) {

  00055	74 04		 je	 SHORT $LN2@sentry

; 92   :                 _Ok = false;

  00057	32 c0		 xor	 al, al

; 93   :                 return;

  00059	eb 21		 jmp	 SHORT $LN17@sentry
$LN2@sentry:

; 94   :             }
; 95   : 
; 96   :             const auto _Tied = _Ostr.tie();

  0005b	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]

; 97   :             if (!_Tied || _Tied == _STD addressof(_Ostr)) {

  0005e	85 c9		 test	 ecx, ecx
  00060	74 18		 je	 SHORT $LN4@sentry
  00062	3b ce		 cmp	 ecx, esi
  00064	74 14		 je	 SHORT $LN4@sentry

; 99   :                 return;
; 100  :             }
; 101  : 
; 102  :             _Tied->flush();

  00066	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 206  :         return rdstate() == ios_base::goodbit;

  0006b	8b 06		 mov	 eax, DWORD PTR [esi]
  0006d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00070	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  00075	0f 94 c0	 sete	 al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 103  :             _Ok = _Ostr.good(); // store test only after flushing tie

  00078	eb 02		 jmp	 SHORT $LN17@sentry
$LN4@sentry:

; 98   :                 _Ok = true;

  0007a	b0 01		 mov	 al, 1
$LN17@sentry:

; 104  :         }

  0007c	88 47 04	 mov	 BYTE PTR [edi+4], al
  0007f	8b c7		 mov	 eax, edi
  00081	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00084	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008b	59		 pop	 ecx
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 76   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

  00022	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00024	8b 01		 mov	 eax, DWORD PTR [ecx]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00029	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]

; 78   :             if (_Rdbuf) {

  0002d	85 c9		 test	 ecx, ecx
  0002f	74 05		 je	 SHORT $LN2@Sentry_bas

; 79   :                 _Rdbuf->_Unlock();

  00031	8b 01		 mov	 eax, DWORD PTR [ecx]
  00033	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 80   :             }
; 81   :         }

  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
  00045	cc		 int	 3
  00046	cc		 int	 3
  00047	cc		 int	 3
  00048	cc		 int	 3
  00049	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >, COMDAT
; _this$ = ecx

; 3426 :         if (_Mypair._Myval2) {

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	85 c9		 test	 ecx, ecx
  00004	74 06		 je	 SHORT $LN7@unique_ptr

; 3309 :         delete _Ptr;

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	6a 01		 push	 1
  0000a	ff 10		 call	 DWORD PTR [eax]
$LN7@unique_ptr:

; 3427 :             _Mypair._Get_first()(_Mypair._Myval2);
; 3428 :         }
; 3429 : 
; 3430 : #if _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 3431 :         if constexpr (is_pointer_v<pointer>) {
; 3432 :             if (!_STD _Is_constant_evaluated()) {
; 3433 :                 const auto _Tombstone{reinterpret_cast<pointer>(_MSVC_STL_UINTPTR_TOMBSTONE_VALUE)};
; 3434 :                 _Mypair._Myval2 = _Tombstone;
; 3435 :             }
; 3436 :         }
; 3437 : #endif // _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 3438 :     }

  0000c	c3		 ret	 0
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
;	COMDAT _main
_TEXT	SEGMENT
_sidString$1 = -12					; size = 4
_size$2 = -8						; size = 4
_hToken$3 = -4						; size = 4
_main	PROC						; COMDAT

; 481  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi

; 482  :     RetrieveAndWriteErrorLog();

  00008	e8 00 00 00 00	 call	 ?RetrieveAndWriteErrorLog@@YAXXZ ; RetrieveAndWriteErrorLog

; 483  :     ShowErrorPopupIfNeeded();

  0000d	e8 00 00 00 00	 call	 ?ShowErrorPopupIfNeeded@@YAXXZ ; ShowErrorPopupIfNeeded

; 355  :     if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))

  00012	8d 45 fc	 lea	 eax, DWORD PTR _hToken$3[ebp]
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hToken$3[ebp], 0
  0001c	50		 push	 eax
  0001d	6a 08		 push	 8
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0
  00025	50		 push	 eax
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenProcessToken@12
  0002c	85 c0		 test	 eax, eax
  0002e	74 36		 je	 SHORT $LN13@main

; 356  :         return false;
; 357  : 
; 358  :     DWORD size = 0;
; 359  :     GetTokenInformation(hToken, TokenUser, nullptr, 0, &size);

  00030	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetTokenInformation@20
  00036	8d 45 f8	 lea	 eax, DWORD PTR _size$2[ebp]
  00039	50		 push	 eax
  0003a	6a 00		 push	 0
  0003c	6a 00		 push	 0
  0003e	6a 01		 push	 1
  00040	ff 75 fc	 push	 DWORD PTR _hToken$3[ebp]
  00043	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _size$2[ebp], 0
  0004a	ff d6		 call	 esi

; 360  :     PTOKEN_USER ptu = (PTOKEN_USER)malloc(size);

  0004c	ff 75 f8	 push	 DWORD PTR _size$2[ebp]
  0004f	e8 00 00 00 00	 call	 _malloc
  00054	8b f8		 mov	 edi, eax
  00056	83 c4 04	 add	 esp, 4

; 361  :     if (!ptu) {

  00059	85 ff		 test	 edi, edi
  0005b	75 30		 jne	 SHORT $LN8@main

; 362  :         CloseHandle(hToken);

  0005d	ff 75 fc	 push	 DWORD PTR _hToken$3[ebp]
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN13@main:

; 486  :         std::cout << "This application must be run as NT AUTHORITY\\SYSTEM, and disable secure boot and enable test signing.\nPress any key to exit...";

  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0HP@PDHHAOBF@This?5application?5must?5be?5run?5as@
  0006b	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  00070	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00075	83 c4 08	 add	 esp, 8

; 487  :         std::cin.get();

  00078	b9 00 00 00 00	 mov	 ecx, OFFSET ?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A ; std::cin
  0007d	e8 00 00 00 00	 call	 ?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_istream<char,std::char_traits<char> >::get
$LN28@main:

; 503  : }

  00082	5f		 pop	 edi
  00083	b8 01 00 00 00	 mov	 eax, 1
  00088	5e		 pop	 esi
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
$LN8@main:
  0008d	53		 push	 ebx

; 367  :     if (GetTokenInformation(hToken, TokenUser, ptu, size, &size)) {

  0008e	8d 45 f8	 lea	 eax, DWORD PTR _size$2[ebp]
  00091	32 db		 xor	 bl, bl
  00093	50		 push	 eax
  00094	ff 75 f8	 push	 DWORD PTR _size$2[ebp]
  00097	57		 push	 edi
  00098	6a 01		 push	 1
  0009a	ff 75 fc	 push	 DWORD PTR _hToken$3[ebp]
  0009d	ff d6		 call	 esi
  0009f	85 c0		 test	 eax, eax
  000a1	74 57		 je	 SHORT $LN10@main

; 368  :         WCHAR* sidString = nullptr;
; 369  :         if (ConvertSidToStringSidW(ptu->User.Sid, &sidString)) {

  000a3	8d 45 f4	 lea	 eax, DWORD PTR _sidString$1[ebp]
  000a6	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _sidString$1[ebp], 0
  000ad	50		 push	 eax
  000ae	ff 37		 push	 DWORD PTR [edi]
  000b0	e8 00 00 00 00	 call	 _ConvertSidToStringSidW@8
  000b5	85 c0		 test	 eax, eax
  000b7	74 41		 je	 SHORT $LN10@main

; 370  :             // SID for NT AUTHORITY\SYSTEM is S-1-5-18
; 371  :             if (wcscmp(sidString, L"S-1-5-18") == 0)

  000b9	8b 5d f4	 mov	 ebx, DWORD PTR _sidString$1[ebp]
  000bc	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_1BC@FOGOLNOF@?$AAS?$AA?9?$AA1?$AA?9?$AA5?$AA?9?$AA1?$AA8@
  000c1	8b c3		 mov	 eax, ebx
$LL14@main:
  000c3	66 8b 10	 mov	 dx, WORD PTR [eax]
  000c6	66 3b 11	 cmp	 dx, WORD PTR [ecx]
  000c9	75 1e		 jne	 SHORT $LN15@main
  000cb	66 85 d2	 test	 dx, dx
  000ce	74 15		 je	 SHORT $LN16@main
  000d0	66 8b 50 02	 mov	 dx, WORD PTR [eax+2]
  000d4	66 3b 51 02	 cmp	 dx, WORD PTR [ecx+2]
  000d8	75 0f		 jne	 SHORT $LN15@main
  000da	83 c0 04	 add	 eax, 4
  000dd	83 c1 04	 add	 ecx, 4
  000e0	66 85 d2	 test	 dx, dx
  000e3	75 de		 jne	 SHORT $LL14@main
$LN16@main:
  000e5	33 f6		 xor	 esi, esi
  000e7	eb 05		 jmp	 SHORT $LN17@main
$LN15@main:
  000e9	1b f6		 sbb	 esi, esi
  000eb	83 ce 01	 or	 esi, 1
$LN17@main:

; 372  :                 isSystem = true;
; 373  :             LocalFree(sidString);

  000ee	53		 push	 ebx
  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4
  000f5	85 f6		 test	 esi, esi
  000f7	0f 94 c3	 sete	 bl
$LN10@main:

; 374  :         }
; 375  :     }
; 376  :     free(ptu);

  000fa	57		 push	 edi
  000fb	e8 00 00 00 00	 call	 _free
  00100	83 c4 04	 add	 esp, 4

; 377  :     CloseHandle(hToken);

  00103	ff 75 fc	 push	 DWORD PTR _hToken$3[ebp]
  00106	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 484  : 
; 485  :     if (!IsSystemAccount()) {

  0010c	84 db		 test	 bl, bl
  0010e	5b		 pop	 ebx
  0010f	0f 84 51 ff ff
	ff		 je	 $LN13@main

; 488  :         return 1;
; 489  :     }
; 490  : 
; 491  :     if (!EnsureTestSigningAndDisableSecureBoot()) {

  00115	e8 00 00 00 00	 call	 ?EnsureTestSigningAndDisableSecureBoot@@YA_NXZ ; EnsureTestSigningAndDisableSecureBoot
  0011a	84 c0		 test	 al, al
  0011c	0f 84 60 ff ff
	ff		 je	 $LN28@main

; 492  :         return 1;
; 493  :     }
; 494  : 
; 495  :     atexit(CleanupOnExit);

  00122	68 00 00 00 00	 push	 OFFSET ?CleanupOnExit@@YAXXZ ; CleanupOnExit
  00127	e8 00 00 00 00	 call	 _atexit
  0012c	83 c4 04	 add	 esp, 4

; 496  :     SetConsoleCtrlHandler(ConsoleHandler, TRUE);

  0012f	6a 01		 push	 1
  00131	68 00 00 00 00	 push	 OFFSET ?ConsoleHandler@@YGHK@Z ; ConsoleHandler
  00136	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetConsoleCtrlHandler@8

; 497  :     RunMenu();

  0013c	e8 00 00 00 00	 call	 ?RunMenu@@YAXXZ		; RunMenu

; 498  : 
; 499  :     if (g_ServiceInstalled)

  00141	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?g_ServiceInstalled@@3_NA, 0 ; g_ServiceInstalled
  00148	74 05		 je	 SHORT $LN4@main

; 500  :         UnloadDriver();

  0014a	e8 00 00 00 00	 call	 ?UnloadDriver@@YA_NXZ	; UnloadDriver
$LN4@main:
  0014f	5f		 pop	 edi

; 501  : 
; 502  :     return 0;

  00150	33 c0		 xor	 eax, eax

; 503  : }

  00152	5e		 pop	 esi
  00153	8b e5		 mov	 esp, ebp
  00155	5d		 pop	 ebp
  00156	c3		 ret	 0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
;	COMDAT ??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++, COMDAT
; _this$ = ecx

; 417  :     istreambuf_iterator& operator++() {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 36		 je	 SHORT $LN6@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00009	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 1b		 je	 SHORT $LN10@operator
  00011	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00014	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  00016	85 c0		 test	 eax, eax
  00018	7e 12		 jle	 SHORT $LN10@operator

; 222  :         --*_IGcount;

  0001a	48		 dec	 eax
  0001b	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  0001d	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00020	8b 11		 mov	 edx, DWORD PTR [ecx]
  00022	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00025	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00027	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  0002a	eb 05		 jmp	 SHORT $LN11@operator
$LN10@operator:
  0002c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002e	ff 50 1c	 call	 DWORD PTR [eax+28]
$LN11@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00031	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

  00034	74 09		 je	 SHORT $LN6@operator

; 463  :         } else {
; 464  :             _Got = false;

  00036	32 c0		 xor	 al, al

; 418  : #if _ITERATOR_DEBUG_LEVEL == 2
; 419  :         _STL_VERIFY(_Strbuf, "istreambuf_iterator is not incrementable");
; 420  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 421  : 
; 422  :         _Inc();
; 423  :         return *this;
; 424  :     }

  00038	88 46 04	 mov	 BYTE PTR [esi+4], al
  0003b	8b c6		 mov	 eax, esi
  0003d	5e		 pop	 esi
  0003e	c3		 ret	 0
$LN6@operator:

; 462  :             _Got    = true;

  0003f	b0 01		 mov	 al, 1
  00041	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 418  : #if _ITERATOR_DEBUG_LEVEL == 2
; 419  :         _STL_VERIFY(_Strbuf, "istreambuf_iterator is not incrementable");
; 420  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 421  : 
; 422  :         _Inc();
; 423  :         return *this;
; 424  :     }

  00047	88 46 04	 mov	 BYTE PTR [esi+4], al
  0004a	8b c6		 mov	 eax, esi
  0004c	5e		 pop	 esi
  0004d	c3		 ret	 0
??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
;	COMDAT ??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT
??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*, COMDAT
; _this$ = ecx

; 405  :     _NODISCARD _Elem operator*() const {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 406  :         if (!_Got) {

  00003	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  00007	75 39		 jne	 SHORT $LN31@operator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  00009	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 29		 je	 SHORT $LN7@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  0000f	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	85 d2		 test	 edx, edx
  00016	74 0d		 je	 SHORT $LN11@operator
  00018	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0001b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001e	7e 05		 jle	 SHORT $LN11@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00020	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00023	eb 05		 jmp	 SHORT $LN12@operator
$LN11@operator:
  00025	8b 01		 mov	 eax, DWORD PTR [ecx]
  00027	ff 50 18	 call	 DWORD PTR [eax+24]
$LN12@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  0002a	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

  0002d	74 09		 je	 SHORT $LN7@operator

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

  0002f	88 46 05	 mov	 BYTE PTR [esi+5], al

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  00032	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
  00036	5e		 pop	 esi

; 407  :             _Peek();
; 408  :         }
; 409  : 
; 410  : #if _ITERATOR_DEBUG_LEVEL == 2
; 411  :         _STL_VERIFY(_Strbuf, "istreambuf_iterator is not dereferenceable");
; 412  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 413  : 
; 414  :         return _Val;
; 415  :     }

  00037	c3		 ret	 0
$LN7@operator:

; 471  :             _Strbuf = nullptr;

  00038	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 474  :         }
; 475  : 
; 476  :         _Got = true;

  0003e	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
$LN31@operator:

; 407  :             _Peek();
; 408  :         }
; 409  : 
; 410  : #if _ITERATOR_DEBUG_LEVEL == 2
; 411  :         _STL_VERIFY(_Strbuf, "istreambuf_iterator is not dereferenceable");
; 412  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 413  : 
; 414  :         return _Val;
; 415  :     }

  00042	8a 46 05	 mov	 al, BYTE PTR [esi+5]
  00045	5e		 pop	 esi
  00046	c3		 ret	 0
??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
;	COMDAT ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream

; 130  :     __CLR_OR_THIS_CALL ~basic_ifstream() noexcept override {}

  00026	8b 06		 mov	 eax, DWORD PTR [esi]
  00028	8d 7e 70	 lea	 edi, DWORD PTR [esi+112]
  0002b	8d 4f a0	 lea	 ecx, DWORD PTR [edi-96]
  0002e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00031	c7 44 38 90 00
	00 00 00	 mov	 DWORD PTR [eax+edi-112], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  00039	8b 06		 mov	 eax, DWORD PTR [esi]
  0003b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003e	8d 42 90	 lea	 eax, DWORD PTR [edx-112]
  00041	89 44 3a 8c	 mov	 DWORD PTR [edx+edi-116], eax
  00045	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 78   :     __CLR_OR_THIS_CALL ~basic_istream() noexcept override {}

  0004a	8b 06		 mov	 eax, DWORD PTR [esi]
  0004c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004f	c7 44 38 90 00
	00 00 00	 mov	 DWORD PTR [eax+edi-112], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00057	8b 06		 mov	 eax, DWORD PTR [esi]
  00059	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005c	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  0005f	89 44 39 8c	 mov	 DWORD PTR [ecx+edi-116], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 368  :         _Ios_base_dtor(this);

  00063	57		 push	 edi
  00064	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006b	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7ios_base@std@@6B@
  00071	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00076	83 c4 04	 add	 esp, 4
  00079	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00083	59		 pop	 ecx
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
  0008a	cc		 int	 3
  0008b	cc		 int	 3
  0008c	cc		 int	 3
  0008d	cc		 int	 3
  0008e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 71 90	 lea	 esi, DWORD PTR [ecx-112]
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0000e	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00012	74 0e		 je	 SHORT $LN5@scalar
  00014	68 b8 00 00 00	 push	 184			; 000000b8H
  00019	56		 push	 esi
  0001a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001f	83 c4 08	 add	 esp, 8
$LN5@scalar:
  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream
;	COMDAT ??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 130  :     __CLR_OR_THIS_CALL ~basic_ifstream() noexcept override {}

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 46 90	 mov	 eax, DWORD PTR [esi-112]
  00006	8d 4e a0	 lea	 ecx, DWORD PTR [esi-96]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	c7 44 30 90 00
	00 00 00	 mov	 DWORD PTR [eax+esi-112], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  00014	8b 46 90	 mov	 eax, DWORD PTR [esi-112]
  00017	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001a	8d 42 90	 lea	 eax, DWORD PTR [edx-112]
  0001d	89 44 32 8c	 mov	 DWORD PTR [edx+esi-116], eax
  00021	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 78   :     __CLR_OR_THIS_CALL ~basic_istream() noexcept override {}

  00026	8b 46 90	 mov	 eax, DWORD PTR [esi-112]
  00029	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002c	c7 44 30 90 00
	00 00 00	 mov	 DWORD PTR [eax+esi-112], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00034	8b 46 90	 mov	 eax, DWORD PTR [esi-112]
  00037	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003a	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  0003d	89 44 31 8c	 mov	 DWORD PTR [ecx+esi-116], eax
  00041	5e		 pop	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream

; 130  :     __CLR_OR_THIS_CALL ~basic_ifstream() noexcept override {}

  00042	c3		 ret	 0
??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
;	COMDAT ?ShowErrorPopupIfNeeded@@YAXXZ
_TEXT	SEGMENT
$T4 = -260						; size = 20
_logFile$ = -240					; size = 184
__Last$ = -56						; size = 8
__ULast$5 = -56						; size = 8
$T6 = -52						; size = 4
$T1 = -48						; size = 8
$T2 = -48						; size = 8
__First$ = -48						; size = 8
__UFirst$7 = -48					; size = 8
$T8 = -48						; size = 8
_logContent$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?ShowErrorPopupIfNeeded@@YAXXZ PROC			; ShowErrorPopupIfNeeded, COMDAT

; 450  : void ShowErrorPopupIfNeeded() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ShowErrorPopupIfNeeded@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR $T6[ebp], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream

; 33   :         : _Mybase(_STD addressof(_Filebuffer)) {

  00033	8d 4d 80	 lea	 ecx, DWORD PTR _logFile$[ebp+112]
  00036	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _logFile$[ebp], OFFSET ??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
  00040	e8 00 00 00 00	 call	 ??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 49   :     explicit __CLR_OR_THIS_CALL basic_istream(_Mysb* _Strbuf, bool _Isstd = false) : _Chcount(0) {

  00045	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _logFile$[ebp]
  0004b	0f 57 c0	 xorps	 xmm0, xmm0

; 50   :         _Myios::init(_Strbuf, _Isstd);

  0004e	6a 00		 push	 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream

; 33   :         : _Mybase(_STD addressof(_Filebuffer)) {

  00050	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00057	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR $T6[ebp], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 49   :     explicit __CLR_OR_THIS_CALL basic_istream(_Mysb* _Strbuf, bool _Isstd = false) : _Chcount(0) {

  0005e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00061	c7 84 05 10 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _logFile$[ebp+eax], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  0006c	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _logFile$[ebp]
  00072	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00075	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  00078	89 84 0d 0c ff
	ff ff		 mov	 DWORD PTR _logFile$[ebp+ecx-4], eax

; 50   :         _Myios::init(_Strbuf, _Isstd);

  0007f	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _logFile$[ebp]
  00085	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _logFile$[ebp]
  0008b	66 0f 13 85 18
	ff ff ff	 movlpd	 QWORD PTR _logFile$[ebp+8], xmm0
  00093	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00096	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR _logFile$[ebp+16]
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 ?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ; std::basic_ios<char,std::char_traits<char> >::init
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream

; 33   :         : _Mybase(_STD addressof(_Filebuffer)) {

  000a2	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _logFile$[ebp]
  000a8	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  000af	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b2	c7 84 05 10 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _logFile$[ebp+eax], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  000bd	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _logFile$[ebp]
  000c3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c6	8d 41 90	 lea	 eax, DWORD PTR [ecx-112]
  000c9	89 84 0d 0c ff
	ff ff		 mov	 DWORD PTR _logFile$[ebp+ecx-4], eax
  000d0	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _logFile$[ebp+16]
  000d6	e8 00 00 00 00	 call	 ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >

; 34   :         // _Prot is an extension
; 35   :         if (!_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot)) {

  000db	6a 40		 push	 64			; 00000040H
  000dd	6a 01		 push	 1
  000df	68 00 00 00 00	 push	 OFFSET ??_C@_0N@BHIHAFGJ@errorlog?4txt@
  000e4	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _logFile$[ebp+16]
  000ea	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000ee	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  000f3	85 c0		 test	 eax, eax
  000f5	75 3c		 jne	 SHORT $LN24@ShowErrorP

; 36   :             _Myios::setstate(ios_base::failbit);

  000f7	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _logFile$[ebp]
  000fd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 155  :         _State &= _Statmask;

  00100	33 c0		 xor	 eax, eax
  00102	39 84 0d 48 ff
	ff ff		 cmp	 DWORD PTR _logFile$[ebp+ecx+56], eax
  00109	0f 94 c0	 sete	 al
  0010c	8d 04 85 02 00
	00 00		 lea	 eax, DWORD PTR [eax*4+2]
  00113	0b 84 0d 1c ff
	ff ff		 or	 eax, DWORD PTR _logFile$[ebp+ecx+12]
  0011a	83 e0 17	 and	 eax, 23			; 00000017H

; 156  :         _Mystate             = _State;

  0011d	89 84 0d 1c ff
	ff ff		 mov	 DWORD PTR _logFile$[ebp+ecx+12], eax

; 157  :         const auto _Filtered = _State & _Except;

  00124	8b 8c 0d 20 ff
	ff ff		 mov	 ecx, DWORD PTR _logFile$[ebp+ecx+16]
  0012b	23 c8		 and	 ecx, eax

; 158  :         if (_Filtered) {

  0012d	0f 85 09 02 00
	00		 jne	 $LN136@ShowErrorP
$LN24@ShowErrorP:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 381  :     istreambuf_iterator(istream_type& _Istr) noexcept : _Strbuf(_Istr.rdbuf()), _Got(!_Strbuf), _Val() {}

  00133	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _logFile$[ebp]
  00139	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 452  :     std::string logContent((std::istreambuf_iterator<char>(logFile)), std::istreambuf_iterator<char>());

  0013c	c6 45 d5 00	 mov	 BYTE PTR __First$[ebp+5], 0
  00140	66 c7 45 cc 01
	00		 mov	 WORD PTR __Last$[ebp+4], 1
  00146	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 381  :     istreambuf_iterator(istream_type& _Istr) noexcept : _Strbuf(_Istr.rdbuf()), _Got(!_Strbuf), _Val() {}

  0014d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00150	0f 11 45 d8	 movups	 XMMWORD PTR _logContent$[ebp], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

  00154	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _logContent$[ebp+16], 0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0015b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _logContent$[ebp+20], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 381  :     istreambuf_iterator(istream_type& _Istr) noexcept : _Strbuf(_Istr.rdbuf()), _Got(!_Strbuf), _Val() {}

  00162	8b 94 05 48 ff
	ff ff		 mov	 edx, DWORD PTR _logFile$[ebp+eax+56]
  00169	85 d2		 test	 edx, edx
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 452  :     std::string logContent((std::istreambuf_iterator<char>(logFile)), std::istreambuf_iterator<char>());

  0016b	0f b7 45 d6	 movzx	 eax, WORD PTR $T1[ebp+6]
  0016f	66 89 45 ce	 mov	 WORD PTR __Last$[ebp+6], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 381  :     istreambuf_iterator(istream_type& _Istr) noexcept : _Strbuf(_Istr.rdbuf()), _Got(!_Strbuf), _Val() {}

  00173	0f 94 c1	 sete	 cl
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 452  :     std::string logContent((std::istreambuf_iterator<char>(logFile)), std::istreambuf_iterator<char>());

  00176	0f b7 45 d6	 movzx	 eax, WORD PTR $T2[ebp+6]
  0017a	66 89 45 d6	 mov	 WORD PTR __First$[ebp+6], ax
  0017e	88 4d d4	 mov	 BYTE PTR __First$[ebp+4], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 801  :         auto _UFirst = _STD _Get_unwrapped(_First);

  00181	8b 45 d4	 mov	 eax, DWORD PTR __First$[ebp+4]
  00184	89 45 d4	 mov	 DWORD PTR __UFirst$7[ebp+4], eax

; 802  :         auto _ULast  = _STD _Get_unwrapped(_Last);

  00187	8b 45 cc	 mov	 eax, DWORD PTR __Last$[ebp+4]
  0018a	89 45 cc	 mov	 DWORD PTR __ULast$5[ebp+4], eax

; 803  :         if (_UFirst == _ULast) {

  0018d	8d 45 c8	 lea	 eax, DWORD PTR __ULast$5[ebp]
  00190	50		 push	 eax
  00191	8d 45 d0	 lea	 eax, DWORD PTR __UFirst$7[ebp]
  00194	89 55 d0	 mov	 DWORD PTR __UFirst$7[ebp], edx
  00197	50		 push	 eax
  00198	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR __ULast$5[ebp], 0
  0019f	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
  001a4	83 c4 08	 add	 esp, 8
  001a7	84 c0		 test	 al, al
  001a9	74 14		 je	 SHORT $LN42@ShowErrorP

; 860  :         _My_data._Mysize = 0;

  001ab	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _logContent$[ebp+16], 0

; 861  :         _My_data._Myres  = _Small_string_capacity;

  001b2	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _logContent$[ebp+20], 15 ; 0000000fH

; 862  :         _My_data._Activate_SSO_buffer();
; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  001b9	c6 45 d8 00	 mov	 BYTE PTR _logContent$[ebp], 0

; 805  :         } else {

  001bd	eb 16		 jmp	 SHORT $LN43@ShowErrorP
$LN42@ShowErrorP:

; 806  :             if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 807  :                 _Construct<_Construct_strategy::_From_ptr>(
; 808  :                     _UFirst, _STD _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 809  :             } else if constexpr (_Is_cpp17_fwd_iter_v<decltype(_UFirst)>) {
; 810  :                 const auto _Length = static_cast<size_t>(_STD distance(_UFirst, _ULast));
; 811  :                 const auto _Count  = _STD _Convert_size<size_type>(_Length);
; 812  :                 _Construct_from_iter(_STD move(_UFirst), _STD move(_ULast), _Count);
; 813  :             } else {
; 814  :                 _Construct_from_iter(_STD move(_UFirst), _STD move(_ULast));

  001bf	6a 00		 push	 0
  001c1	ff 75 cc	 push	 DWORD PTR __ULast$5[ebp+4]
  001c4	8d 4d d8	 lea	 ecx, DWORD PTR _logContent$[ebp]
  001c7	ff 75 c8	 push	 DWORD PTR __ULast$5[ebp]
  001ca	ff 75 d4	 push	 DWORD PTR __UFirst$7[ebp+4]
  001cd	ff 75 d0	 push	 DWORD PTR __UFirst$7[ebp]
  001d0	e8 00 00 00 00	 call	 ??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_from_iter<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> >,std::nullptr_t>
$LN43@ShowErrorP:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream

; 162  :         if (!_Filebuffer.close()) {

  001d5	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _logFile$[ebp+16]
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 452  :     std::string logContent((std::istreambuf_iterator<char>(logFile)), std::istreambuf_iterator<char>());

  001db	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream

; 162  :         if (!_Filebuffer.close()) {

  001df	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  001e4	85 c0		 test	 eax, eax
  001e6	75 4b		 jne	 SHORT $LN68@ShowErrorP

; 163  :             _Myios::setstate(ios_base::failbit);

  001e8	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _logFile$[ebp]
  001ee	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 155  :         _State &= _Statmask;

  001f1	33 c0		 xor	 eax, eax
  001f3	39 84 0d 48 ff
	ff ff		 cmp	 DWORD PTR _logFile$[ebp+ecx+56], eax
  001fa	0f 94 c0	 sete	 al
  001fd	8d 04 85 02 00
	00 00		 lea	 eax, DWORD PTR [eax*4+2]
  00204	0b 84 0d 1c ff
	ff ff		 or	 eax, DWORD PTR _logFile$[ebp+ecx+12]
  0020b	83 e0 17	 and	 eax, 23			; 00000017H

; 156  :         _Mystate             = _State;

  0020e	89 84 0d 1c ff
	ff ff		 mov	 DWORD PTR _logFile$[ebp+ecx+12], eax

; 157  :         const auto _Filtered = _State & _Except;

  00215	8b 8c 0d 20 ff
	ff ff		 mov	 ecx, DWORD PTR _logFile$[ebp+ecx+16]
  0021c	23 c8		 and	 ecx, eax

; 158  :         if (_Filtered) {

  0021e	74 13		 je	 SHORT $LN68@ShowErrorP

; 164  :             if (_Filtered & ios_base::badbit) {

  00220	f6 c1 04	 test	 cl, 4
  00223	0f 84 1f 01 00
	00		 je	 $LN26@ShowErrorP

; 165  :                 _Msg = "ios_base::badbit set";

  00229	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  0022e	e9 25 01 00 00	 jmp	 $LN28@ShowErrorP
$LN68@ShowErrorP:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2494 :         return _Mypair._Myval2._Mysize == 0;

  00233	83 7d e8 00	 cmp	 DWORD PTR _logContent$[ebp+16], 0
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 455  :     if (!logContent.empty()) {

  00237	74 2c		 je	 SHORT $LN2@ShowErrorP

; 456  :         MessageBoxA(nullptr,

  00239	6a 10		 push	 16			; 00000010H
  0023b	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@GAEBIAPC@EzAntiAntiCheat?5Error@
  00240	68 00 00 00 00	 push	 OFFSET ??_C@_0GP@OCNKAPGN@A?5kernel?5security?5error?5was?5det@
  00245	6a 00		 push	 0
  00247	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 457  :             "A kernel security error was detected.\nPlease create an issue on our GitHub repository and attach errorlog.txt.",
; 458  :             "EzAntiAntiCheat Error", MB_OK | MB_ICONERROR);
; 459  : 
; 460  :         ShellExecuteA(nullptr, "open",

  0024d	6a 01		 push	 1
  0024f	6a 00		 push	 0
  00251	6a 00		 push	 0
  00253	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@PPLMEFMH@https?3?1?1github?4com?1PalorderSoft@
  00258	68 00 00 00 00	 push	 OFFSET ??_C@_04PMOCAHAA@open@
  0025d	6a 00		 push	 0
  0025f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShellExecuteA@24
$LN2@ShowErrorP:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00265	8b 4d ec	 mov	 ecx, DWORD PTR _logContent$[ebp+20]
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 464  : }

  00268	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  0026c	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3083 :         if (_My_data._Large_mode_engaged()) {

  0026f	76 2c		 jbe	 SHORT $LN101@ShowErrorP
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00271	8b 55 d8	 mov	 edx, DWORD PTR _logContent$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00274	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00275	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00277	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0027d	72 14		 jb	 SHORT $LN106@ShowErrorP

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0027f	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00282	83 c1 23	 add	 ecx, 35			; 00000023H
  00285	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00287	83 c0 fc	 add	 eax, -4			; fffffffcH
  0028a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0028d	0f 87 f1 00 00
	00		 ja	 $LN137@ShowErrorP
$LN106@ShowErrorP:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00293	51		 push	 ecx
  00294	52		 push	 edx
  00295	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0029a	83 c4 08	 add	 esp, 8
$LN101@ShowErrorP:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream

; 130  :     __CLR_OR_THIS_CALL ~basic_ifstream() noexcept override {}

  0029d	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _logFile$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3090 :         _My_data._Mysize = 0;

  002a3	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _logContent$[ebp+16], 0

; 3091 :         _My_data._Myres  = _Small_string_capacity;

  002aa	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _logContent$[ebp+20], 15 ; 0000000fH

; 3092 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  002b1	c6 45 d8 00	 mov	 BYTE PTR _logContent$[ebp], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream

; 130  :     __CLR_OR_THIS_CALL ~basic_ifstream() noexcept override {}

  002b5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002b8	c7 84 05 10 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _logFile$[ebp+eax], OFFSET ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  002c3	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _logFile$[ebp]
  002c9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002cc	8d 41 90	 lea	 eax, DWORD PTR [ecx-112]
  002cf	89 84 0d 0c ff
	ff ff		 mov	 DWORD PTR _logFile$[ebp+ecx-4], eax
  002d6	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _logFile$[ebp+16]
  002dc	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 78   :     __CLR_OR_THIS_CALL ~basic_istream() noexcept override {}

  002e1	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _logFile$[ebp]
  002e7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002ea	c7 84 05 10 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _logFile$[ebp+eax], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  002f5	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _logFile$[ebp]
  002fb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002fe	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  00301	89 84 0d 0c ff
	ff ff		 mov	 DWORD PTR _logFile$[ebp+ecx-4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 368  :         _Ios_base_dtor(this);

  00308	8d 45 80	 lea	 eax, DWORD PTR _logFile$[ebp+112]
  0030b	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 6
  00312	50		 push	 eax
  00313	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _logFile$[ebp+112], OFFSET ??_7ios_base@std@@6B@
  0031a	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  0031f	83 c4 04	 add	 esp, 4
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 464  : }

  00322	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00325	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0032c	59		 pop	 ecx
  0032d	5e		 pop	 esi
  0032e	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00331	33 cd		 xor	 ecx, ebp
  00333	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00338	8b e5		 mov	 esp, ebp
  0033a	5d		 pop	 ebp
  0033b	c3		 ret	 0
$LN136@ShowErrorP:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 164  :             if (_Filtered & ios_base::badbit) {

  0033c	f6 c1 04	 test	 cl, 4
  0033f	74 07		 je	 SHORT $LN26@ShowErrorP

; 165  :                 _Msg = "ios_base::badbit set";

  00341	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  00346	eb 10		 jmp	 SHORT $LN28@ShowErrorP
$LN26@ShowErrorP:
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 464  : }

  00348	f6 c1 02	 test	 cl, 2
  0034b	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
  00350	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
  00355	0f 44 f0	 cmove	 esi, eax
$LN28@ShowErrorP:
  00358	8d 45 d0	 lea	 eax, DWORD PTR $T8[ebp]
  0035b	6a 01		 push	 1
  0035d	50		 push	 eax
  0035e	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  00363	83 c4 08	 add	 esp, 8
  00366	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  0036c	50		 push	 eax
  0036d	56		 push	 esi
  0036e	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  00373	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00378	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  0037e	50		 push	 eax
  0037f	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN137@ShowErrorP:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00384	6a 00		 push	 0
  00386	6a 00		 push	 0
  00388	6a 00		 push	 0
  0038a	6a 00		 push	 0
  0038c	6a 00		 push	 0
  0038e	e8 00 00 00 00	 call	 __invoke_watson
$LN134@ShowErrorP:
  00393	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ShowErrorPopupIfNeeded@@YAXXZ$2:
  00000	8b 45 cc	 mov	 eax, DWORD PTR $T6[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN11@ShowErrorP
  0000c	83 65 cc fe	 and	 DWORD PTR $T6[ebp], -2	; fffffffeH
  00010	8d 4d 80	 lea	 ecx, DWORD PTR _logFile$[ebp+112]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN11@ShowErrorP:
  00018	c3		 ret	 0
__unwindfunclet$?ShowErrorPopupIfNeeded@@YAXXZ$3:
  00019	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _logFile$[ebp+24]
  0001f	e9 00 00 00 00	 jmp	 ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
__unwindfunclet$?ShowErrorPopupIfNeeded@@YAXXZ$4:
  00024	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _logFile$[ebp+16]
  0002a	e9 00 00 00 00	 jmp	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
__unwindfunclet$?ShowErrorPopupIfNeeded@@YAXXZ$0:
  0002f	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _logFile$[ebp]
  00035	e9 00 00 00 00	 jmp	 ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__unwindfunclet$?ShowErrorPopupIfNeeded@@YAXXZ$1:
  0003a	8d 4d d8	 lea	 ecx, DWORD PTR _logContent$[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00042	cc		 int	 3
  00043	cc		 int	 3
  00044	cc		 int	 3
  00045	cc		 int	 3
  00046	cc		 int	 3
__ehhandler$?ShowErrorPopupIfNeeded@@YAXXZ:
  00047	90		 npad	 1
  00048	90		 npad	 1
  00049	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0004d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00050	8b 8a 00 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-256]
  00056	33 c8		 xor	 ecx, eax
  00058	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00060	33 c8		 xor	 ecx, eax
  00062	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00067	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ShowErrorPopupIfNeeded@@YAXXZ
  0006c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ShowErrorPopupIfNeeded@@YAXXZ ENDP			; ShowErrorPopupIfNeeded
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
;	COMDAT ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream

; 283  :     __CLR_OR_THIS_CALL ~basic_ofstream() noexcept override {}

  00026	8b 06		 mov	 eax, DWORD PTR [esi]
  00028	8d 7e 68	 lea	 edi, DWORD PTR [esi+104]
  0002b	8d 4f 9c	 lea	 ecx, DWORD PTR [edi-100]
  0002e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00031	c7 44 38 98 00
	00 00 00	 mov	 DWORD PTR [eax+edi-104], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  00039	8b 06		 mov	 eax, DWORD PTR [esi]
  0003b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003e	8d 42 98	 lea	 eax, DWORD PTR [edx-104]
  00041	89 44 3a 94	 mov	 DWORD PTR [edx+edi-108], eax
  00045	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 61   :     __CLR_OR_THIS_CALL ~basic_ostream() noexcept override {}

  0004a	8b 06		 mov	 eax, DWORD PTR [esi]
  0004c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004f	c7 44 38 98 00
	00 00 00	 mov	 DWORD PTR [eax+edi-104], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  00057	8b 06		 mov	 eax, DWORD PTR [esi]
  00059	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005c	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  0005f	89 44 39 94	 mov	 DWORD PTR [ecx+edi-108], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 368  :         _Ios_base_dtor(this);

  00063	57		 push	 edi
  00064	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006b	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7ios_base@std@@6B@
  00071	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00076	83 c4 04	 add	 esp, 4
  00079	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00083	59		 pop	 ecx
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
  0008a	cc		 int	 3
  0008b	cc		 int	 3
  0008c	cc		 int	 3
  0008d	cc		 int	 3
  0008e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 71 98	 lea	 esi, DWORD PTR [ecx-104]
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0000e	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00012	74 0e		 je	 SHORT $LN5@scalar
  00014	68 b0 00 00 00	 push	 176			; 000000b0H
  00019	56		 push	 esi
  0001a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001f	83 c4 08	 add	 esp, 8
$LN5@scalar:
  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 58		 push	 88			; 00000058H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back, COMDAT
; _this$ = ecx

; 759  :     void _Reset_back() noexcept { // restore buffer after putback

  00000	57		 push	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 180  :         return *_IGfirst;

  00001	8b 79 0c	 mov	 edi, DWORD PTR [ecx+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 760  :         if (_Mysb::eback() == &_Mychar) {

  00004	8d 41 3c	 lea	 eax, DWORD PTR [ecx+60]
  00007	39 07		 cmp	 DWORD PTR [edi], eax
  00009	75 16		 jne	 SHORT $LN9@Reset_back

; 761  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  0000b	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  0000e	56		 push	 esi
  0000f	8b 71 54	 mov	 esi, DWORD PTR [ecx+84]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 207  :         *_IGfirst = _First;

  00012	89 17		 mov	 DWORD PTR [edi], edx

; 208  :         *_IGnext  = _Next;
; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

  00014	2b f2		 sub	 esi, edx
  00016	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00019	89 10		 mov	 DWORD PTR [eax], edx
  0001b	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0001e	89 30		 mov	 DWORD PTR [eax], esi
  00020	5e		 pop	 esi
$LN9@Reset_back:
  00021	5f		 pop	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 763  :     }

  00022	c3		 ret	 0
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXABV?$codecvt@DDU_Mbstatet@@@2@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Newcvt$ = 8						; size = 4
tv91 = 8						; size = 4
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXABV?$codecvt@DDU_Mbstatet@@@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt, COMDAT
; _this$ = ecx

; 742  :     void _Initcvt(const _Cvt& _Newcvt) noexcept { // initialize codecvt pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 640  :         return do_always_noconv();

  00006	8b 75 08	 mov	 esi, DWORD PTR __Newcvt$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 742  :     void _Initcvt(const _Cvt& _Newcvt) noexcept { // initialize codecvt pointer

  00009	8b d9		 mov	 ebx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 640  :         return do_always_noconv();

  0000b	8b ce		 mov	 ecx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 742  :     void _Initcvt(const _Cvt& _Newcvt) noexcept { // initialize codecvt pointer

  0000d	89 5d fc	 mov	 DWORD PTR _this$1$[ebp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 640  :         return do_always_noconv();

  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00015	ff d0		 call	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 743  :         if (_Newcvt.always_noconv()) {

  00017	84 c0		 test	 al, al
  00019	74 0f		 je	 SHORT $LN2@Initcvt

; 744  :             _Pcvt = nullptr; // nothing to do

  0001b	5e		 pop	 esi
  0001c	c7 43 38 00 00
	00 00		 mov	 DWORD PTR [ebx+56], 0

; 749  :     }

  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN2@Initcvt:

; 746  :             _Pcvt = _STD addressof(_Newcvt);

  0002a	8b c3		 mov	 eax, ebx
  0002c	57		 push	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 267  :         _IGnext  = &_Gnext;

  0002d	8d 78 14	 lea	 edi, DWORD PTR [eax+20]

; 268  :         _IPnext  = &_Pnext;

  00030	8d 48 18	 lea	 ecx, DWORD PTR [eax+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 746  :             _Pcvt = _STD addressof(_Newcvt);

  00033	89 70 38	 mov	 DWORD PTR [eax+56], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 265  :         _IGfirst = &_Gfirst;

  00036	8d 58 04	 lea	 ebx, DWORD PTR [eax+4]
  00039	89 58 0c	 mov	 DWORD PTR [eax+12], ebx

; 266  :         _IPfirst = &_Pfirst;

  0003c	8d 70 08	 lea	 esi, DWORD PTR [eax+8]
  0003f	89 70 10	 mov	 DWORD PTR [eax+16], esi

; 269  :         _IGcount = &_Gcount;

  00042	8d 50 24	 lea	 edx, DWORD PTR [eax+36]
  00045	89 78 1c	 mov	 DWORD PTR [eax+28], edi
  00048	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  0004b	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 270  :         _IPcount = &_Pcount;

  0004e	83 c0 28	 add	 eax, 40			; 00000028H
  00051	89 5d 08	 mov	 DWORD PTR tv91[ebp], ebx
  00054	8b 5d fc	 mov	 ebx, DWORD PTR _this$1$[ebp]
  00057	89 43 30	 mov	 DWORD PTR [ebx+48], eax

; 207  :         *_IGfirst = _First;

  0005a	8b 5d 08	 mov	 ebx, DWORD PTR tv91[ebp]

; 243  :         *_IPfirst = _First;

  0005d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 244  :         *_IPnext  = _First;

  00063	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 245  :         *_IPcount = static_cast<int>(_Last - _First);

  00069	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 207  :         *_IGfirst = _First;

  0006f	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0

; 208  :         *_IGnext  = _Next;

  00075	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 749  :     }

  00083	5b		 pop	 ebx
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c2 04 00	 ret	 4
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXABV?$codecvt@DDU_Mbstatet@@@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
_TEXT	SEGMENT
__Dest$ = -40						; size = 4
__Str$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite, COMDAT
; _this$ = ecx

; 705  :     bool _Endwrite() { // put shift to initial conversion state, as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b f1		 mov	 esi, ecx

; 706  :         if (!_Pcvt || !_Wrotesome) {

  00013	83 7e 38 00	 cmp	 DWORD PTR [esi+56], 0
  00017	0f 84 a2 00 00
	00		 je	 $LN5@Endwrite
  0001d	80 7e 3d 00	 cmp	 BYTE PTR [esi+61], 0
  00021	0f 84 98 00 00
	00		 je	 $LN5@Endwrite

; 711  :         if (_Traits::eq_int_type(_Traits::eof(), overflow())) {

  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	57		 push	 edi
  0002a	6a ff		 push	 -1
  0002c	ff 50 0c	 call	 DWORD PTR [eax+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  0002f	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 711  :         if (_Traits::eq_int_type(_Traits::eof(), overflow())) {

  00032	74 79		 je	 SHORT $LN18@Endwrite

; 718  :         switch (_Pcvt->unshift(_State, _Str, _Str + _Codecvt_temp_buf, _Dest)) { // test result of homing conversion

  00034	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 714  :         return do_unshift(_State, _First2, _Last2, _Mid2);

  00037	8b 01		 mov	 eax, DWORD PTR [ecx]
  00039	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  0003c	8d 45 d8	 lea	 eax, DWORD PTR __Dest$[ebp]
  0003f	50		 push	 eax
  00040	8d 45 fc	 lea	 eax, DWORD PTR __Str$[ebp+32]
  00043	50		 push	 eax
  00044	8d 45 dc	 lea	 eax, DWORD PTR __Str$[ebp]
  00047	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 718  :         switch (_Pcvt->unshift(_State, _Str, _Str + _Codecvt_temp_buf, _Dest)) { // test result of homing conversion

  00048	8d 46 40	 lea	 eax, DWORD PTR [esi+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 714  :         return do_unshift(_State, _First2, _Last2, _Mid2);

  0004b	50		 push	 eax
  0004c	ff d2		 call	 edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 718  :         switch (_Pcvt->unshift(_State, _Str, _Str + _Codecvt_temp_buf, _Dest)) { // test result of homing conversion

  0004e	83 e8 00	 sub	 eax, 0
  00051	74 1f		 je	 SHORT $LN7@Endwrite
  00053	83 e8 01	 sub	 eax, 1
  00056	74 1e		 je	 SHORT $LN8@Endwrite
  00058	83 e8 02	 sub	 eax, 2
  0005b	75 50		 jne	 SHORT $LN18@Endwrite

; 731  :             }
; 732  : 
; 733  :         case codecvt_base::noconv:
; 734  :             _Wrotesome = false; // homed successfully

  0005d	88 46 3d	 mov	 BYTE PTR [esi+61], al

; 735  :             return true; // nothing else to do

  00060	b0 01		 mov	 al, 1
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 736  : 
; 737  :         default:
; 738  :             return false; // conversion failed
; 739  :         }
; 740  :     }

  00064	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00067	33 cd		 xor	 ecx, ebp
  00069	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
$LN7@Endwrite:

; 719  :         case codecvt_base::ok:
; 720  :             _Wrotesome = false; // homed successfully

  00072	c6 46 3d 00	 mov	 BYTE PTR [esi+61], 0
$LN8@Endwrite:

; 721  :             _FALLTHROUGH;
; 722  : 
; 723  :         case codecvt_base::partial:
; 724  :             { // put any generated bytes
; 725  :                 const auto _Count = static_cast<size_t>(_Dest - _Str);

  00076	8b 7d d8	 mov	 edi, DWORD PTR __Dest$[ebp]
  00079	8d 45 dc	 lea	 eax, DWORD PTR __Str$[ebp]
  0007c	2b f8		 sub	 edi, eax

; 726  :                 if (0 < _Count && _Count != static_cast<size_t>(_CSTD fwrite(_Str, 1, _Count, _Myfile))) {

  0007e	74 16		 je	 SHORT $LN9@Endwrite
  00080	0f ae e8	 lfence
  00083	ff 76 4c	 push	 DWORD PTR [esi+76]
  00086	57		 push	 edi
  00087	6a 01		 push	 1
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 _fwrite
  0008f	83 c4 10	 add	 esp, 16			; 00000010H
  00092	3b f8		 cmp	 edi, eax
  00094	75 17		 jne	 SHORT $LN18@Endwrite
$LN9@Endwrite:

; 728  :                 }
; 729  : 
; 730  :                 return !_Wrotesome;

  00096	80 7e 3d 00	 cmp	 BYTE PTR [esi+61], 0
  0009a	5f		 pop	 edi
  0009b	0f 94 c0	 sete	 al
  0009e	5e		 pop	 esi

; 736  : 
; 737  :         default:
; 738  :             return false; // conversion failed
; 739  :         }
; 740  :     }

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	33 cd		 xor	 ecx, ebp
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN18@Endwrite:
  000ad	5f		 pop	 edi

; 727  :                     return false; // write failed

  000ae	32 c0		 xor	 al, al
  000b0	5e		 pop	 esi

; 736  : 
; 737  :         default:
; 738  :             return false; // conversion failed
; 739  :         }
; 740  :     }

  000b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b4	33 cd		 xor	 ecx, ebp
  000b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
$LN5@Endwrite:
  000bf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c2	b0 01		 mov	 al, 1
  000c4	33 cd		 xor	 ecx, ebp
  000c6	5e		 pop	 esi
  000c7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c3		 ret	 0
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z
_TEXT	SEGMENT
__Nr$1 = -8						; size = 4
_this$1$ = -4						; size = 4
__File$ = 8						; size = 4
__Pn$2 = 8						; size = 4
__Which$ = 12						; size = 4
__Pb$3 = 12						; size = 4
tv225 = 12						; size = 4
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Init, COMDAT
; _this$ = ecx

; 678  :     void _Init(FILE* _File, _Initfl _Which) noexcept { // initialize to C stream _File after {new, open, close}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 679  :         using _State_type = typename _Traits::state_type;
; 680  : 
; 681  :         __PURE_APPDOMAIN_GLOBAL static _State_type _Stinit; // initial state
; 682  : 
; 683  :         _Closef    = _Which == _Openfl;

  00006	83 7d 0c 01	 cmp	 DWORD PTR __Which$[ebp], 1
  0000a	8b d1		 mov	 edx, ecx
  0000c	53		 push	 ebx
  0000d	0f 94 c0	 sete	 al
  00010	89 55 fc	 mov	 DWORD PTR _this$1$[ebp], edx
  00013	56		 push	 esi
  00014	88 42 48	 mov	 BYTE PTR [edx+72], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 265  :         _IGfirst = &_Gfirst;

  00017	8d 5a 04	 lea	 ebx, DWORD PTR [edx+4]

; 269  :         _IGcount = &_Gcount;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  0001d	8d 72 08	 lea	 esi, DWORD PTR [edx+8]
  00020	89 5a 0c	 mov	 DWORD PTR [edx+12], ebx
  00023	8d 4a 18	 lea	 ecx, DWORD PTR [edx+24]
  00026	89 72 10	 mov	 DWORD PTR [edx+16], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 684  :         _Wrotesome = false;

  00029	c6 42 3d 00	 mov	 BYTE PTR [edx+61], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 268  :         _IPnext  = &_Pnext;

  0002d	89 4a 20	 mov	 DWORD PTR [edx+32], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 678  :     void _Init(FILE* _File, _Initfl _Which) noexcept { // initialize to C stream _File after {new, open, close}

  00030	57		 push	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 267  :         _IGnext  = &_Gnext;

  00031	8d 7a 14	 lea	 edi, DWORD PTR [edx+20]
  00034	89 5d 0c	 mov	 DWORD PTR tv225[ebp], ebx

; 270  :         _IPcount = &_Pcount;

  00037	8b 5d fc	 mov	 ebx, DWORD PTR _this$1$[ebp]
  0003a	89 7a 1c	 mov	 DWORD PTR [edx+28], edi
  0003d	83 c2 24	 add	 edx, 36			; 00000024H
  00040	89 50 2c	 mov	 DWORD PTR [eax+44], edx
  00043	83 c0 28	 add	 eax, 40			; 00000028H
  00046	89 43 30	 mov	 DWORD PTR [ebx+48], eax

; 207  :         *_IGfirst = _First;

  00049	8b 5d 0c	 mov	 ebx, DWORD PTR tv225[ebp]

; 243  :         *_IPfirst = _First;

  0004c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 688  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer

  00052	8b 75 08	 mov	 esi, DWORD PTR __File$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 244  :         *_IPnext  = _First;

  00055	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 245  :         *_IPcount = static_cast<int>(_Last - _First);

  0005b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 207  :         *_IGfirst = _First;

  00061	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0

; 208  :         *_IGnext  = _Next;

  00067	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

  0006d	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 688  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer

  00073	85 f6		 test	 esi, esi
  00075	74 4a		 je	 SHORT $LN17@Init

; 693  :             ::_get_stream_buffer_pointers(

  00077	8d 45 f8	 lea	 eax, DWORD PTR __Nr$1[ebp]
  0007a	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR __Pb$3[ebp], 0
  00081	50		 push	 eax
  00082	8d 45 08	 lea	 eax, DWORD PTR __Pn$2[ebp]
  00085	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Pn$2[ebp], 0
  0008c	50		 push	 eax
  0008d	8d 45 0c	 lea	 eax, DWORD PTR __Pb$3[ebp]
  00090	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __Nr$1[ebp], 0
  00097	50		 push	 eax
  00098	56		 push	 esi
  00099	e8 00 00 00 00	 call	 __get_stream_buffer_pointers
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 277  :         _IGfirst = _Gf;

  0009e	8b 55 fc	 mov	 edx, DWORD PTR _this$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 693  :             ::_get_stream_buffer_pointers(

  000a1	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 277  :         _IGfirst = _Gf;

  000a4	8b 45 0c	 mov	 eax, DWORD PTR __Pb$3[ebp]
  000a7	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 278  :         _IPfirst = _Pf;

  000aa	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 279  :         _IGnext  = _Gn;

  000ad	8b 45 08	 mov	 eax, DWORD PTR __Pn$2[ebp]
  000b0	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 280  :         _IPnext  = _Pn;

  000b3	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 281  :         _IGcount = _Gc;

  000b6	8b 45 f8	 mov	 eax, DWORD PTR __Nr$1[ebp]
  000b9	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 282  :         _IPcount = _Pc;

  000bc	89 42 30	 mov	 DWORD PTR [edx+48], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 688  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer

  000bf	eb 03		 jmp	 SHORT $LN15@Init
$LN17@Init:
  000c1	8b 55 fc	 mov	 edx, DWORD PTR _this$1$[ebp]
$LN15@Init:

; 694  :                 _File, reinterpret_cast<char***>(&_Pb), reinterpret_cast<char***>(&_Pn), &_Nr);
; 695  :             int* _Nw = _Nr;
; 696  : 
; 697  :             _Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 698  :         }
; 699  : 
; 700  :         _Myfile = _File;

  000c4	89 72 4c	 mov	 DWORD PTR [edx+76], esi

; 701  :         _State  = _Stinit;

  000c7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
  000cc	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4

; 702  :         _Pcvt   = nullptr; // pointer to codecvt facet

  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	89 42 40	 mov	 DWORD PTR [edx+64], eax
  000d7	89 4a 44	 mov	 DWORD PTR [edx+68], ecx
  000da	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], 0
  000e1	5b		 pop	 ebx

; 703  :     }

  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c2 08 00	 ret	 8
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT
__Loc$ = 8						; size = 4
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::imbue, COMDAT
; _this$ = ecx

; 673  :     void __CLR_OR_THIS_CALL imbue(const locale& _Loc) override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 674  :         // set locale to argument (capture nontrivial codecvt facet)
; 675  :         _Initcvt(_STD use_facet<_Cvt>(_Loc));

  00004	ff 75 08	 push	 DWORD PTR __Loc$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
  0000e	83 c4 04	 add	 esp, 4
  00011	8b ce		 mov	 ecx, esi
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXABV?$codecvt@DDU_Mbstatet@@@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
  00019	5e		 pop	 esi

; 676  :     }

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::imbue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::sync, COMDAT
; _this$ = ecx

; 665  :     int __CLR_OR_THIS_CALL sync() override { // synchronize C stream with external file

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 666  :         if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), overflow()) || 0 <= _CSTD fflush(_Myfile)) {

  00003	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00007	74 23		 je	 SHORT $LN3@sync
  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	6a ff		 push	 -1
  0000d	ff 50 0c	 call	 DWORD PTR [eax+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00010	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 666  :         if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), overflow()) || 0 <= _CSTD fflush(_Myfile)) {

  00013	74 17		 je	 SHORT $LN3@sync
  00015	ff 76 4c	 push	 DWORD PTR [esi+76]
  00018	e8 00 00 00 00	 call	 _fflush
  0001d	33 c9		 xor	 ecx, ecx
  0001f	83 c4 04	 add	 esp, 4
  00022	85 c0		 test	 eax, eax
  00024	0f 99 c1	 setns	 cl
  00027	5e		 pop	 esi
  00028	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]

; 668  :         }
; 669  : 
; 670  :         return -1;
; 671  :     }

  0002b	c3		 ret	 0
$LN3@sync:

; 667  :             return 0;

  0002c	33 c0		 xor	 eax, eax
  0002e	5e		 pop	 esi

; 668  :         }
; 669  : 
; 670  :         return -1;
; 671  :     }

  0002f	c3		 ret	 0
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::sync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Count$ = 12						; size = 8
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::setbuf, COMDAT
; _this$ = ecx

; 646  :     _Mysb* __CLR_OR_THIS_CALL setbuf(_Elem* _Buffer, streamsize _Count) override { // offer _Buffer to C stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 647  :         int _Mode;
; 648  :         if (!_Buffer && _Count == 0) {

  00003	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000c	85 d2		 test	 edx, edx
  0000e	75 0e		 jne	 SHORT $LN2@setbuf
  00010	8b c1		 mov	 eax, ecx
  00012	0b 45 10	 or	 eax, DWORD PTR __Count$[ebp+4]
  00015	75 07		 jne	 SHORT $LN2@setbuf

; 649  :             _Mode = _IONBF;

  00017	b8 04 00 00 00	 mov	 eax, 4

; 650  :         } else {

  0001c	eb 02		 jmp	 SHORT $LN3@setbuf
$LN2@setbuf:

; 651  :             _Mode = _IOFBF;

  0001e	33 c0		 xor	 eax, eax
$LN3@setbuf:

; 652  :         }
; 653  : 
; 654  :         const size_t _Size = static_cast<size_t>(_Count) * sizeof(_Elem);
; 655  : 
; 656  :         if (!_Myfile || _CSTD setvbuf(_Myfile, reinterpret_cast<char*>(_Buffer), _Mode, _Size) != 0) {

  00020	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00024	74 25		 je	 SHORT $LN5@setbuf
  00026	51		 push	 ecx
  00027	50		 push	 eax
  00028	52		 push	 edx
  00029	ff 76 4c	 push	 DWORD PTR [esi+76]
  0002c	e8 00 00 00 00	 call	 _setvbuf
  00031	83 c4 10	 add	 esp, 16			; 00000010H
  00034	85 c0		 test	 eax, eax
  00036	75 13		 jne	 SHORT $LN5@setbuf

; 658  :         }
; 659  : 
; 660  :         // new buffer, reinitialize pointers
; 661  :         _Init(_Myfile, _Openfl);

  00038	6a 01		 push	 1
  0003a	ff 76 4c	 push	 DWORD PTR [esi+76]
  0003d	8b ce		 mov	 ecx, esi
  0003f	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init

; 662  :         return this;

  00044	8b c6		 mov	 eax, esi
  00046	5e		 pop	 esi

; 663  :     }

  00047	5d		 pop	 ebp
  00048	c2 0c 00	 ret	 12			; 0000000cH
$LN5@setbuf:

; 657  :             return nullptr; // failed

  0004b	33 c0		 xor	 eax, eax
  0004d	5e		 pop	 esi

; 663  :     }

  0004e	5d		 pop	 ebp
  0004f	c2 0c 00	 ret	 12			; 0000000cH
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iosfwd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iosfwd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iosfwd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iosfwd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iosfwd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Pos$ = 12						; size = 24
___formal$ = 36						; size = 4
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekpos, COMDAT
; _this$ = ecx

; 633  :     pos_type __CLR_OR_THIS_CALL seekpos(pos_type _Pos, ios_base::openmode = ios_base::in | ios_base::out) override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iosfwd

; 67   :         return _Myoff + _Fpos;

  00006	8b 55 14	 mov	 edx, DWORD PTR __Pos$[ebp+8]
  00009	03 55 0c	 add	 edx, DWORD PTR __Pos$[ebp]
  0000c	8b 45 18	 mov	 eax, DWORD PTR __Pos$[ebp+12]
  0000f	13 45 10	 adc	 eax, DWORD PTR __Pos$[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 633  :     pos_type __CLR_OR_THIS_CALL seekpos(pos_type _Pos, ios_base::openmode = ios_base::in | ios_base::out) override {

  00012	57		 push	 edi
  00013	8b f9		 mov	 edi, ecx

; 634  :         // change position to _Pos
; 635  :         off_type _Off = static_cast<off_type>(_Pos);

  00015	89 55 f8	 mov	 DWORD PTR __Off$[ebp], edx
  00018	89 45 fc	 mov	 DWORD PTR __Off$[ebp+4], eax

; 636  : 
; 637  :         if (!_Myfile || !_Endwrite() || _CSTD fsetpos(_Myfile, &_Off) != 0) {

  0001b	83 7f 4c 00	 cmp	 DWORD PTR [edi+76], 0
  0001f	74 77		 je	 SHORT $LN3@seekpos
  00021	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  00026	84 c0		 test	 al, al
  00028	74 6e		 je	 SHORT $LN3@seekpos
  0002a	8d 45 f8	 lea	 eax, DWORD PTR __Off$[ebp]
  0002d	50		 push	 eax
  0002e	ff 77 4c	 push	 DWORD PTR [edi+76]
  00031	e8 00 00 00 00	 call	 _fsetpos
  00036	83 c4 08	 add	 esp, 8
  00039	85 c0		 test	 eax, eax
  0003b	75 5b		 jne	 SHORT $LN3@seekpos

; 641  :         _State = _Pos.state();

  0003d	8b 45 1c	 mov	 eax, DWORD PTR __Pos$[ebp+16]
  00040	8b 4d 20	 mov	 ecx, DWORD PTR __Pos$[ebp+20]
  00043	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 180  :         return *_IGfirst;

  00044	8b 77 0c	 mov	 esi, DWORD PTR [edi+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 641  :         _State = _Pos.state();

  00047	89 47 40	 mov	 DWORD PTR [edi+64], eax

; 760  :         if (_Mysb::eback() == &_Mychar) {

  0004a	8d 47 3c	 lea	 eax, DWORD PTR [edi+60]

; 641  :         _State = _Pos.state();

  0004d	89 4f 44	 mov	 DWORD PTR [edi+68], ecx

; 760  :         if (_Mysb::eback() == &_Mychar) {

  00050	39 06		 cmp	 DWORD PTR [esi], eax
  00052	75 14		 jne	 SHORT $LN20@seekpos

; 761  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00054	8b 57 54	 mov	 edx, DWORD PTR [edi+84]
  00057	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

  0005a	2b d1		 sub	 edx, ecx
  0005c	89 0e		 mov	 DWORD PTR [esi], ecx
  0005e	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00061	89 08		 mov	 DWORD PTR [eax], ecx
  00063	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00066	89 10		 mov	 DWORD PTR [eax], edx
$LN20@seekpos:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 643  :         return pos_type{_State, _Off}; // return new position

  00068	8b 77 40	 mov	 esi, DWORD PTR [edi+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iosfwd

; 54   :     fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

  0006b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 643  :         return pos_type{_State, _Off}; // return new position

  0006e	8b 7f 44	 mov	 edi, DWORD PTR [edi+68]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iosfwd

; 54   :     fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

  00071	8b 4d f8	 mov	 ecx, DWORD PTR __Off$[ebp]
  00074	8b 55 fc	 mov	 edx, DWORD PTR __Off$[ebp+4]
  00077	89 70 10	 mov	 DWORD PTR [eax+16], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 643  :         return pos_type{_State, _Off}; // return new position

  0007a	5e		 pop	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iosfwd

; 54   :     fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

  0007b	89 78 14	 mov	 DWORD PTR [eax+20], edi
  0007e	89 08		 mov	 DWORD PTR [eax], ecx
  00080	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00083	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0008a	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  00091	5f		 pop	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 644  :     }

  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 20 00	 ret	 32			; 00000020H
$LN3@seekpos:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iosfwd

; 52   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

  00098	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0009b	0f 57 c0	 xorps	 xmm0, xmm0
  0009e	5f		 pop	 edi
  0009f	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  000a5	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1
  000ac	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  000b3	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  000ba	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 644  :     }

  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c2 20 00	 ret	 32			; 00000020H
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iosfwd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iosfwd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iosfwd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iosfwd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iosfwd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 8
__Fileposition$ = 12					; size = 8
__Way$ = 20						; size = 4
___formal$ = 24						; size = 4
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekoff, COMDAT
; _this$ = ecx

; 614  :         ios_base::openmode = ios_base::in | ios_base::out) override { // change position by _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 184  :         return *_IGnext;

  00008	8b 57 1c	 mov	 edx, DWORD PTR [edi+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 619  :             && !_Pcvt) { // not converting

  0000b	8d 47 3c	 lea	 eax, DWORD PTR [edi+60]
  0000e	39 02		 cmp	 DWORD PTR [edx], eax
  00010	75 1a		 jne	 SHORT $LN15@seekoff
  00012	83 7d 14 01	 cmp	 DWORD PTR __Way$[ebp], 1
  00016	75 14		 jne	 SHORT $LN15@seekoff
  00018	83 7f 38 00	 cmp	 DWORD PTR [edi+56], 0
  0001c	75 0e		 jne	 SHORT $LN15@seekoff

; 620  :             _Off -= static_cast<off_type>(sizeof(_Elem)); // back up over _Elem bytes

  0001e	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00021	8b 5d 10	 mov	 ebx, DWORD PTR __Off$[ebp+4]
  00024	83 c6 ff	 add	 esi, -1
  00027	83 d3 ff	 adc	 ebx, -1
  0002a	eb 06		 jmp	 SHORT $LN2@seekoff
$LN15@seekoff:

; 619  :             && !_Pcvt) { // not converting

  0002c	8b 5d 10	 mov	 ebx, DWORD PTR __Off$[ebp+4]
  0002f	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
$LN2@seekoff:

; 621  :         }
; 622  : 
; 623  :         if (!_Myfile || !_Endwrite()
; 624  :             || ((_Off != 0 || _Way != ios_base::cur) && _CSTD _fseeki64(_Myfile, _Off, _Way) != 0)
; 625  :             || _CSTD fgetpos(_Myfile, &_Fileposition) != 0) {

  00032	83 7f 4c 00	 cmp	 DWORD PTR [edi+76], 0
  00036	74 72		 je	 SHORT $LN4@seekoff
  00038	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  0003d	84 c0		 test	 al, al
  0003f	74 69		 je	 SHORT $LN4@seekoff
  00041	8b c6		 mov	 eax, esi
  00043	0b c3		 or	 eax, ebx
  00045	8b 45 14	 mov	 eax, DWORD PTR __Way$[ebp]
  00048	75 05		 jne	 SHORT $LN6@seekoff
  0004a	83 f8 01	 cmp	 eax, 1
  0004d	74 12		 je	 SHORT $LN5@seekoff
$LN6@seekoff:
  0004f	50		 push	 eax
  00050	53		 push	 ebx
  00051	56		 push	 esi
  00052	ff 77 4c	 push	 DWORD PTR [edi+76]
  00055	e8 00 00 00 00	 call	 __fseeki64
  0005a	83 c4 10	 add	 esp, 16			; 00000010H
  0005d	85 c0		 test	 eax, eax
  0005f	75 49		 jne	 SHORT $LN4@seekoff
$LN5@seekoff:
  00061	8d 45 0c	 lea	 eax, DWORD PTR __Fileposition$[ebp]
  00064	50		 push	 eax
  00065	ff 77 4c	 push	 DWORD PTR [edi+76]
  00068	e8 00 00 00 00	 call	 _fgetpos
  0006d	83 c4 08	 add	 esp, 8
  00070	85 c0		 test	 eax, eax
  00072	75 36		 jne	 SHORT $LN4@seekoff

; 626  :             return pos_type{off_type{-1}}; // report failure
; 627  :         }
; 628  : 
; 629  :         _Reset_back(); // revert from _Mychar buffer, discarding any putback

  00074	8b cf		 mov	 ecx, edi
  00076	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back

; 630  :         return pos_type{_State, _Fileposition}; // return new position

  0007b	8b 77 40	 mov	 esi, DWORD PTR [edi+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iosfwd

; 54   :     fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

  0007e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 630  :         return pos_type{_State, _Fileposition}; // return new position

  00081	8b 7f 44	 mov	 edi, DWORD PTR [edi+68]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iosfwd

; 54   :     fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

  00084	8b 4d 0c	 mov	 ecx, DWORD PTR __Fileposition$[ebp]
  00087	8b 55 10	 mov	 edx, DWORD PTR __Fileposition$[ebp+4]
  0008a	89 78 14	 mov	 DWORD PTR [eax+20], edi
  0008d	5f		 pop	 edi
  0008e	89 70 10	 mov	 DWORD PTR [eax+16], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 631  :     }

  00091	5e		 pop	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iosfwd

; 54   :     fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

  00092	89 08		 mov	 DWORD PTR [eax], ecx
  00094	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00097	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0009e	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 631  :     }

  000a5	5b		 pop	 ebx
  000a6	5d		 pop	 ebp
  000a7	c2 14 00	 ret	 20			; 00000014H
$LN4@seekoff:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iosfwd

; 52   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

  000aa	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000ad	0f 57 c0	 xorps	 xmm0, xmm0
  000b0	5f		 pop	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 631  :     }

  000b1	5e		 pop	 esi
  000b2	5b		 pop	 ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iosfwd

; 52   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

  000b3	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  000b9	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1
  000c0	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  000c7	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  000ce	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 631  :     }

  000d3	5d		 pop	 ebp
  000d4	c2 14 00	 ret	 20			; 00000014H
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
_TEXT	SEGMENT
__Start_count$2$ = -20					; size = 4
tv328 = -16						; size = 4
$T1 = -16						; size = 4
tv329 = -12						; size = 4
__Start_count$1$ = -12					; size = 4
__Size$2$ = -8						; size = 4
$T2 = -8						; size = 4
_this$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Ptr$1$ = 8						; size = 4
__Count$ = 12						; size = 8
__Size$2$ = 16						; size = 4
?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::xsputn, COMDAT
; _this$ = ecx

; 583  :     streamsize __CLR_OR_THIS_CALL xsputn(const _Elem* _Ptr, streamsize _Count) override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 584  :         // put _Count characters to stream
; 585  :         if constexpr (sizeof(_Elem) == 1) {
; 586  :             if (_Pcvt) { // if we need a nontrivial codecvt transform, do the default expensive thing

  00006	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00010	0f 84 d8 00 00
	00		 je	 $LN2@xsputn

; 587  :                 return _Mysb::xsputn(_Ptr, _Count);

  00016	8b 75 10	 mov	 esi, DWORD PTR __Count$[ebp+4]
  00019	8b de		 mov	 ebx, esi
  0001b	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0001e	8b fa		 mov	 edi, edx
  00020	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00023	89 45 08	 mov	 DWORD PTR __Ptr$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 338  :         while (0 < _Count) {

  00026	85 f6		 test	 esi, esi
  00028	0f 8c af 00 00
	00		 jl	 $LN58@xsputn
  0002e	7f 08		 jg	 SHORT $LN55@xsputn
  00030	85 d2		 test	 edx, edx
  00032	0f 84 a5 00 00
	00		 je	 $LN58@xsputn
$LN55@xsputn:
  00038	8d 51 30	 lea	 edx, DWORD PTR [ecx+48]
  0003b	0f 1f 44 00 00	 npad	 5
$LL8@xsputn:

; 261  :         return *_IPnext ? *_IPcount : 0;

  00040	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00043	89 55 f0	 mov	 DWORD PTR $T1[ebp], edx
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
  00048	89 45 f4	 mov	 DWORD PTR tv329[ebp], eax
  0004b	85 c0		 test	 eax, eax
  0004d	74 06		 je	 SHORT $LN18@xsputn
  0004f	8b 02		 mov	 eax, DWORD PTR [edx]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	eb 02		 jmp	 SHORT $LN19@xsputn
$LN18@xsputn:
  00055	33 c0		 xor	 eax, eax
$LN19@xsputn:
  00057	99		 cdq

; 339  :             streamsize _Size = _Pnavail();

  00058	8b f0		 mov	 esi, eax
  0005a	8b c2		 mov	 eax, edx
  0005c	89 45 f8	 mov	 DWORD PTR __Size$2$[ebp], eax

; 340  :             if (0 < _Size) { // copy to write buffer

  0005f	85 c0		 test	 eax, eax
  00061	7c 3b		 jl	 SHORT $LN10@xsputn
  00063	7f 04		 jg	 SHORT $LN56@xsputn
  00065	85 f6		 test	 esi, esi
  00067	74 35		 je	 SHORT $LN10@xsputn
$LN56@xsputn:

; 341  :                 if (_Count < _Size) {

  00069	3b d8		 cmp	 ebx, eax
  0006b	7f 0b		 jg	 SHORT $LN12@xsputn
  0006d	7c 04		 jl	 SHORT $LN57@xsputn
  0006f	3b fe		 cmp	 edi, esi
  00071	73 05		 jae	 SHORT $LN12@xsputn
$LN57@xsputn:

; 342  :                     _Size = _Count;

  00073	8b f7		 mov	 esi, edi
  00075	89 5d f8	 mov	 DWORD PTR __Size$2$[ebp], ebx
$LN12@xsputn:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00078	8b 45 08	 mov	 eax, DWORD PTR __Ptr$1$[ebp]
  0007b	56		 push	 esi
  0007c	50		 push	 eax
  0007d	ff 75 f4	 push	 DWORD PTR tv329[ebp]
  00080	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 237  :         *_IPcount -= _Off;

  00085	8b 55 f0	 mov	 edx, DWORD PTR $T1[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00088	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 238  :         *_IPnext += _Off;

  0008b	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]

; 347  :                 _Count -= _Size;

  0008e	2b fe		 sub	 edi, esi
  00090	1b 5d f8	 sbb	 ebx, DWORD PTR __Size$2$[ebp]

; 237  :         *_IPcount -= _Off;

  00093	8b 02		 mov	 eax, DWORD PTR [edx]
  00095	29 30		 sub	 DWORD PTR [eax], esi

; 238  :         *_IPnext += _Off;

  00097	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0009a	01 30		 add	 DWORD PTR [eax], esi

; 239  :     }

  0009c	eb 24		 jmp	 SHORT $LN14@xsputn
$LN10@xsputn:

; 349  :             } else if (_Traits::eq_int_type(_Traits::eof(), overflow(_Traits::to_int_type(*_Ptr)))) {

  0009e	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a0	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  000a3	8b 45 08	 mov	 eax, DWORD PTR __Ptr$1$[ebp]
  000a6	0f b6 00	 movzx	 eax, BYTE PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 349  :             } else if (_Traits::eq_int_type(_Traits::eof(), overflow(_Traits::to_int_type(*_Ptr)))) {

  000a9	50		 push	 eax
  000aa	ff d2		 call	 edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  000ac	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 349  :             } else if (_Traits::eq_int_type(_Traits::eof(), overflow(_Traits::to_int_type(*_Ptr)))) {

  000af	74 26		 je	 SHORT $LN64@xsputn

; 350  :                 break; // single character put failed, quit
; 351  :             } else { // count character successfully put
; 352  :                 ++_Ptr;
; 353  :                 --_Count;

  000b1	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000b4	83 c7 ff	 add	 edi, -1
  000b7	be 01 00 00 00	 mov	 esi, 1
  000bc	83 d3 ff	 adc	 ebx, -1
  000bf	8d 51 30	 lea	 edx, DWORD PTR [ecx+48]
$LN14@xsputn:

; 338  :         while (0 < _Count) {

  000c2	01 75 08	 add	 DWORD PTR __Ptr$1$[ebp], esi
  000c5	85 db		 test	 ebx, ebx
  000c7	0f 8f 73 ff ff
	ff		 jg	 $LL8@xsputn
  000cd	7c 08		 jl	 SHORT $LN64@xsputn
  000cf	85 ff		 test	 edi, edi
  000d1	0f 85 69 ff ff
	ff		 jne	 $LL8@xsputn
$LN64@xsputn:
  000d7	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  000da	8b 75 10	 mov	 esi, DWORD PTR __Count$[ebp+4]
$LN58@xsputn:

; 354  :             }
; 355  :         }
; 356  : 
; 357  :         return _Start_count - _Count;

  000dd	2b d7		 sub	 edx, edi
  000df	5f		 pop	 edi
  000e0	1b f3		 sbb	 esi, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 587  :                 return _Mysb::xsputn(_Ptr, _Count);

  000e2	8b c2		 mov	 eax, edx
  000e4	8b d6		 mov	 edx, esi

; 608  :         } else { // non-chars always get element-by-element processing
; 609  :             return _Mysb::xsputn(_Ptr, _Count);
; 610  :         }
; 611  :     }

  000e6	5e		 pop	 esi
  000e7	5b		 pop	 ebx
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c2 0c 00	 ret	 12			; 0000000cH
$LN2@xsputn:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 261  :         return *_IPnext ? *_IPcount : 0;

  000ee	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 590  :             const streamsize _Start_count = _Count;

  000f1	8b 75 0c	 mov	 esi, DWORD PTR __Count$[ebp]
  000f4	8b 7d 10	 mov	 edi, DWORD PTR __Count$[ebp+4]
  000f7	89 75 f4	 mov	 DWORD PTR __Start_count$1$[ebp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 261  :         return *_IPnext ? *_IPcount : 0;

  000fa	8b 10		 mov	 edx, DWORD PTR [eax]
  000fc	8d 41 30	 lea	 eax, DWORD PTR [ecx+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 590  :             const streamsize _Start_count = _Count;

  000ff	89 7d ec	 mov	 DWORD PTR __Start_count$2$[ebp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 261  :         return *_IPnext ? *_IPcount : 0;

  00102	89 55 f0	 mov	 DWORD PTR tv328[ebp], edx
  00105	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
  00108	85 d2		 test	 edx, edx
  0010a	74 06		 je	 SHORT $LN38@xsputn
  0010c	8b 00		 mov	 eax, DWORD PTR [eax]
  0010e	8b 10		 mov	 edx, DWORD PTR [eax]
  00110	eb 05		 jmp	 SHORT $LN39@xsputn
$LN38@xsputn:
  00112	33 d2		 xor	 edx, edx
  00114	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
$LN39@xsputn:
  00117	8b c2		 mov	 eax, edx
  00119	99		 cdq
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 591  :             streamsize _Size              = _Mysb::_Pnavail();

  0011a	8b d8		 mov	 ebx, eax
  0011c	8b c2		 mov	 eax, edx
  0011e	89 45 10	 mov	 DWORD PTR __Size$2$[ebp], eax

; 592  :             if (0 < _Count && 0 < _Size) { // copy to write buffer

  00121	85 ff		 test	 edi, edi
  00123	7c 6f		 jl	 SHORT $LN5@xsputn
  00125	7f 04		 jg	 SHORT $LN59@xsputn
  00127	85 f6		 test	 esi, esi
  00129	74 69		 je	 SHORT $LN5@xsputn
$LN59@xsputn:
  0012b	85 c0		 test	 eax, eax
  0012d	7c 49		 jl	 SHORT $LN63@xsputn
  0012f	7f 04		 jg	 SHORT $LN60@xsputn
  00131	85 db		 test	 ebx, ebx
  00133	74 43		 je	 SHORT $LN63@xsputn
$LN60@xsputn:

; 593  :                 if (_Count < _Size) {

  00135	3b f8		 cmp	 edi, eax
  00137	7f 0b		 jg	 SHORT $LN4@xsputn
  00139	7c 04		 jl	 SHORT $LN61@xsputn
  0013b	3b f3		 cmp	 esi, ebx
  0013d	73 05		 jae	 SHORT $LN4@xsputn
$LN61@xsputn:

; 594  :                     _Size = _Count;

  0013f	8b de		 mov	 ebx, esi
  00141	89 7d 10	 mov	 DWORD PTR __Size$2$[ebp], edi
$LN4@xsputn:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00144	53		 push	 ebx
  00145	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00148	ff 75 f0	 push	 DWORD PTR tv328[ebp]
  0014b	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 237  :         *_IPcount -= _Off;

  00150	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00153	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 598  :                 _Ptr += _Size;

  00156	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 238  :         *_IPnext += _Off;

  00159	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 598  :                 _Ptr += _Size;

  0015c	03 d3		 add	 edx, ebx

; 599  :                 _Count -= _Size;

  0015e	2b f3		 sub	 esi, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 237  :         *_IPcount -= _Off;

  00160	8b 00		 mov	 eax, DWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 599  :                 _Count -= _Size;

  00162	1b 7d 10	 sbb	 edi, DWORD PTR __Size$2$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 237  :         *_IPcount -= _Off;

  00165	29 18		 sub	 DWORD PTR [eax], ebx

; 238  :         *_IPnext += _Off;

  00167	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0016a	01 18		 add	 DWORD PTR [eax], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 603  :             if (0 < _Count && _Myfile) { // open C stream, attempt write

  0016c	85 ff		 test	 edi, edi
  0016e	7c 24		 jl	 SHORT $LN5@xsputn
  00170	7f 09		 jg	 SHORT $LN62@xsputn
  00172	85 f6		 test	 esi, esi
  00174	74 1e		 je	 SHORT $LN5@xsputn

; 592  :             if (0 < _Count && 0 < _Size) { // copy to write buffer

  00176	eb 03		 jmp	 SHORT $LN62@xsputn
$LN63@xsputn:
  00178	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
$LN62@xsputn:

; 603  :             if (0 < _Count && _Myfile) { // open C stream, attempt write

  0017b	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  0017e	85 c0		 test	 eax, eax
  00180	74 12		 je	 SHORT $LN5@xsputn

; 604  :                 _Count -= _CSTD fwrite(_Ptr, sizeof(_Elem), static_cast<size_t>(_Count), _Myfile);

  00182	50		 push	 eax
  00183	56		 push	 esi
  00184	6a 01		 push	 1
  00186	52		 push	 edx
  00187	e8 00 00 00 00	 call	 _fwrite
  0018c	83 c4 10	 add	 esp, 16			; 00000010H
  0018f	2b f0		 sub	 esi, eax
  00191	83 df 00	 sbb	 edi, 0
$LN5@xsputn:

; 605  :             }
; 606  : 
; 607  :             return _Start_count - _Count;

  00194	8b 45 f4	 mov	 eax, DWORD PTR __Start_count$1$[ebp]
  00197	8b 55 ec	 mov	 edx, DWORD PTR __Start_count$2$[ebp]
  0019a	2b c6		 sub	 eax, esi
  0019c	1b d7		 sbb	 edx, edi
  0019e	5f		 pop	 edi

; 608  :         } else { // non-chars always get element-by-element processing
; 609  :             return _Mysb::xsputn(_Ptr, _Count);
; 610  :         }
; 611  :     }

  0019f	5e		 pop	 esi
  001a0	5b		 pop	 ebx
  001a1	8b e5		 mov	 esp, ebp
  001a3	5d		 pop	 ebp
  001a4	c2 0c 00	 ret	 12			; 0000000cH
?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::xsputn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
tv508 = -16						; size = 4
tv509 = -12						; size = 4
$T2 = -8						; size = 4
__Size$2$ = -8						; size = 4
__Count$2$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Ptr$1$ = 8						; size = 4
__Ptr$1$ = 8						; size = 4
tv499 = 8						; size = 4
__Count$ = 12						; size = 8
?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn, COMDAT
; _this$ = ecx

; 535  :     streamsize __CLR_OR_THIS_CALL xsgetn(_Elem* _Ptr, streamsize _Count) override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 536  :         // get _Count characters from stream
; 537  :         if constexpr (sizeof(_Elem) == 1) {
; 538  :             if (_Count <= 0) {

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp+4]
  00006	83 ec 10	 sub	 esp, 16			; 00000010H
  00009	53		 push	 ebx
  0000a	8b d9		 mov	 ebx, ecx
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000f	85 c0		 test	 eax, eax
  00011	7f 11		 jg	 SHORT $LN4@xsgetn
  00013	7c 04		 jl	 SHORT $LN74@xsgetn
  00015	85 c9		 test	 ecx, ecx
  00017	75 0b		 jne	 SHORT $LN4@xsgetn
$LN74@xsgetn:

; 539  :                 return 0;

  00019	33 c0		 xor	 eax, eax
  0001b	33 d2		 xor	 edx, edx
  0001d	5b		 pop	 ebx

; 581  :     }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 0c 00	 ret	 12			; 0000000cH
$LN4@xsgetn:

; 540  :             }
; 541  : 
; 542  :             if (_Pcvt) { // if we need a nontrivial codecvt transform, do the default expensive thing

  00024	83 7b 38 00	 cmp	 DWORD PTR [ebx+56], 0
  00028	56		 push	 esi
  00029	57		 push	 edi
  0002a	8b f9		 mov	 edi, ecx
  0002c	0f 84 cf 00 00
	00		 je	 $LN5@xsgetn

; 543  :                 return _Mysb::xsgetn(_Ptr, _Count);

  00032	8b c8		 mov	 ecx, eax
  00034	8d 53 2c	 lea	 edx, DWORD PTR [ebx+44]
  00037	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003a	89 4d fc	 mov	 DWORD PTR __Count$2$[ebp], ecx
  0003d	89 45 08	 mov	 DWORD PTR __Ptr$1$[ebp], eax
$LL12@xsgetn:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00040	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00043	89 55 f0	 mov	 DWORD PTR $T1[ebp], edx
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
  00048	89 45 f4	 mov	 DWORD PTR tv509[ebp], eax
  0004b	85 c0		 test	 eax, eax
  0004d	74 06		 je	 SHORT $LN21@xsgetn
  0004f	8b 02		 mov	 eax, DWORD PTR [edx]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	eb 02		 jmp	 SHORT $LN22@xsgetn
$LN21@xsgetn:
  00055	33 c0		 xor	 eax, eax
$LN22@xsgetn:
  00057	99		 cdq

; 310  :             streamsize _Size = _Gnavail();

  00058	8b f0		 mov	 esi, eax
  0005a	8b c2		 mov	 eax, edx
  0005c	89 45 f8	 mov	 DWORD PTR __Size$2$[ebp], eax

; 311  :             if (0 < _Size) { // copy from read buffer

  0005f	85 c0		 test	 eax, eax
  00061	7c 3b		 jl	 SHORT $LN14@xsgetn
  00063	7f 04		 jg	 SHORT $LN75@xsgetn
  00065	85 f6		 test	 esi, esi
  00067	74 35		 je	 SHORT $LN14@xsgetn
$LN75@xsgetn:

; 312  :                 if (_Count < _Size) {

  00069	3b c8		 cmp	 ecx, eax
  0006b	7f 0b		 jg	 SHORT $LN16@xsgetn
  0006d	7c 04		 jl	 SHORT $LN76@xsgetn
  0006f	3b fe		 cmp	 edi, esi
  00071	73 05		 jae	 SHORT $LN16@xsgetn
$LN76@xsgetn:

; 313  :                     _Size = _Count;

  00073	8b f7		 mov	 esi, edi
  00075	89 4d f8	 mov	 DWORD PTR __Size$2$[ebp], ecx
$LN16@xsgetn:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00078	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
  0007b	56		 push	 esi
  0007c	ff 75 f4	 push	 DWORD PTR tv509[ebp]
  0007f	51		 push	 ecx
  00080	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 201  :         *_IGcount -= _Off;

  00085	8b 55 f0	 mov	 edx, DWORD PTR $T1[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00088	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 318  :                 _Count -= _Size;

  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __Count$2$[ebp]
  0008e	2b fe		 sub	 edi, esi
  00090	1b 4d f8	 sbb	 ecx, DWORD PTR __Size$2$[ebp]

; 201  :         *_IGcount -= _Off;

  00093	8b 02		 mov	 eax, DWORD PTR [edx]
  00095	29 30		 sub	 DWORD PTR [eax], esi

; 202  :         *_IGnext += _Off;

  00097	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  0009a	01 30		 add	 DWORD PTR [eax], esi

; 320  :             } else {

  0009c	eb 22		 jmp	 SHORT $LN100@xsgetn
$LN14@xsgetn:

; 321  :                 const int_type _Meta = uflow();

  0009e	8b 03		 mov	 eax, DWORD PTR [ebx]
  000a0	8b cb		 mov	 ecx, ebx
  000a2	ff 50 1c	 call	 DWORD PTR [eax+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  000a5	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 322  :                 if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {

  000a8	74 41		 je	 SHORT $LN79@xsgetn

; 323  :                     break; // end of file, quit
; 324  :                 }
; 325  : 
; 326  :                 // get a single character
; 327  :                 *_Ptr++ = _Traits::to_char_type(_Meta);

  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$1$[ebp]

; 328  :                 --_Count;

  000ad	8d 53 2c	 lea	 edx, DWORD PTR [ebx+44]
  000b0	83 c7 ff	 add	 edi, -1
  000b3	be 01 00 00 00	 mov	 esi, 1
  000b8	88 01		 mov	 BYTE PTR [ecx], al
  000ba	8b 4d fc	 mov	 ecx, DWORD PTR __Count$2$[ebp]
  000bd	83 d1 ff	 adc	 ecx, -1
$LN100@xsgetn:

; 233  :     }
; 234  : 
; 235  :     void __CLR_OR_THIS_CALL pbump(int _Off) noexcept /* strengthened */ {
; 236  :         // alter current position in write buffer by _Off
; 237  :         *_IPcount -= _Off;
; 238  :         *_IPnext += _Off;
; 239  :     }
; 240  : 
; 241  :     void __CLR_OR_THIS_CALL setp(_Elem* _First, _Elem* _Last) noexcept /* strengthened */ {
; 242  :         // set pointers for write buffer
; 243  :         *_IPfirst = _First;
; 244  :         *_IPnext  = _First;
; 245  :         *_IPcount = static_cast<int>(_Last - _First);
; 246  :     }
; 247  : 
; 248  :     void __CLR_OR_THIS_CALL setp(_Elem* _First, _Elem* _Next, _Elem* _Last) noexcept /* strengthened */ {
; 249  :         // set pointers for write buffer, extended version
; 250  :         *_IPfirst = _First;
; 251  :         *_IPnext  = _Next;
; 252  :         *_IPcount = static_cast<int>(_Last - _Next);
; 253  :     }
; 254  : 
; 255  :     _Elem* __CLR_OR_THIS_CALL _Pninc() noexcept { // increment current position in write buffer
; 256  :         --*_IPcount;
; 257  :         return (*_IPnext)++;
; 258  :     }
; 259  : 
; 260  :     streamsize __CLR_OR_THIS_CALL _Pnavail() const noexcept { // count number of available positions in write buffer
; 261  :         return *_IPnext ? *_IPcount : 0;
; 262  :     }
; 263  : 
; 264  :     void __CLR_OR_THIS_CALL _Init() noexcept { // initialize buffer parameters for no buffers
; 265  :         _IGfirst = &_Gfirst;
; 266  :         _IPfirst = &_Pfirst;
; 267  :         _IGnext  = &_Gnext;
; 268  :         _IPnext  = &_Pnext;
; 269  :         _IGcount = &_Gcount;
; 270  :         _IPcount = &_Pcount;
; 271  :         setp(nullptr, nullptr);
; 272  :         setg(nullptr, nullptr, nullptr);
; 273  :     }
; 274  : 
; 275  :     void __CLR_OR_THIS_CALL _Init(_Elem** _Gf, _Elem** _Gn, int* _Gc, _Elem** _Pf, _Elem** _Pn, int* _Pc) noexcept {
; 276  :         // initialize buffer parameters as specified
; 277  :         _IGfirst = _Gf;
; 278  :         _IPfirst = _Pf;
; 279  :         _IGnext  = _Gn;
; 280  :         _IPnext  = _Pn;
; 281  :         _IGcount = _Gc;
; 282  :         _IPcount = _Pc;
; 283  :     }
; 284  : 
; 285  :     virtual int_type __CLR_OR_THIS_CALL overflow(int_type = _Traits::eof()) { // put a character to stream (always fail)
; 286  :         return _Traits::eof();
; 287  :     }
; 288  : 
; 289  :     virtual int_type __CLR_OR_THIS_CALL pbackfail(int_type = _Traits::eof()) {
; 290  :         // put a character back to stream (always fail)
; 291  :         return _Traits::eof();
; 292  :     }
; 293  : 
; 294  :     virtual streamsize __CLR_OR_THIS_CALL showmanyc() {
; 295  :         return 0;
; 296  :     }
; 297  : 
; 298  :     virtual int_type __CLR_OR_THIS_CALL underflow() { // get a character from stream, but don't point past it
; 299  :         return _Traits::eof();
; 300  :     }
; 301  : 
; 302  :     virtual int_type __CLR_OR_THIS_CALL uflow() { // get a character from stream, point past it
; 303  :         return _Traits::eq_int_type(_Traits::eof(), underflow()) ? _Traits::eof() : _Traits::to_int_type(*_Gninc());
; 304  :     }
; 305  : 
; 306  :     virtual streamsize __CLR_OR_THIS_CALL xsgetn(_Elem* _Ptr, streamsize _Count) { // get _Count characters from stream
; 307  :         const streamsize _Start_count = _Count;
; 308  : 
; 309  :         while (0 < _Count) {

  000c0	01 75 08	 add	 DWORD PTR __Ptr$1$[ebp], esi
  000c3	89 4d fc	 mov	 DWORD PTR __Count$2$[ebp], ecx
  000c6	85 c9		 test	 ecx, ecx
  000c8	0f 8f 72 ff ff
	ff		 jg	 $LL12@xsgetn
  000ce	7c 1e		 jl	 SHORT $LN77@xsgetn
  000d0	85 ff		 test	 edi, edi
  000d2	0f 85 68 ff ff
	ff		 jne	 $LL12@xsgetn

; 329  :             }
; 330  :         }
; 331  : 
; 332  :         return _Start_count - _Count;

  000d8	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  000db	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp+4]
  000de	2b c7		 sub	 eax, edi
  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi
  000e2	1b d1		 sbb	 edx, ecx
  000e4	5b		 pop	 ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 581  :     }

  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c2 0c 00	 ret	 12			; 0000000cH
$LN79@xsgetn:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 322  :                 if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {

  000eb	8b 4d fc	 mov	 ecx, DWORD PTR __Count$2$[ebp]
$LN77@xsgetn:

; 329  :             }
; 330  :         }
; 331  : 
; 332  :         return _Start_count - _Count;

  000ee	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  000f1	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp+4]
  000f4	2b c7		 sub	 eax, edi
  000f6	5f		 pop	 edi
  000f7	5e		 pop	 esi
  000f8	1b d1		 sbb	 edx, ecx
  000fa	5b		 pop	 ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 581  :     }

  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c2 0c 00	 ret	 12			; 0000000cH
$LN5@xsgetn:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00101	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00104	8b 00		 mov	 eax, DWORD PTR [eax]
  00106	89 45 f0	 mov	 DWORD PTR tv508[ebp], eax
  00109	85 c0		 test	 eax, eax
  0010b	74 3c		 je	 SHORT $LN41@xsgetn
  0010d	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
  00110	8d 53 2c	 lea	 edx, DWORD PTR [ebx+44]
  00113	89 55 f8	 mov	 DWORD PTR $T2[ebp], edx
  00116	8b 00		 mov	 eax, DWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 549  :             const auto _Available   = static_cast<size_t>(_Mysb::_Gnavail());

  00118	85 c0		 test	 eax, eax

; 550  :             if (0 < _Available) { // copy from get area

  0011a	74 33		 je	 SHORT $LN101@xsgetn
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0011c	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 101  :     return _Right < _Left ? _Right : _Left;

  0011f	3b c1		 cmp	 eax, ecx
  00121	8b f1		 mov	 esi, ecx
  00123	0f 42 f0	 cmovb	 esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00126	56		 push	 esi
  00127	ff 75 f0	 push	 DWORD PTR tv508[ebp]
  0012a	57		 push	 edi
  0012b	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 201  :         *_IGcount -= _Off;

  00130	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 553  :                 _Ptr += _Read_size;

  00133	03 fe		 add	 edi, esi
  00135	89 7d 08	 mov	 DWORD PTR __Ptr$1$[ebp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00138	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 553  :                 _Ptr += _Read_size;

  0013b	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0013e	2b fe		 sub	 edi, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 201  :         *_IGcount -= _Off;

  00140	29 30		 sub	 DWORD PTR [eax], esi

; 202  :         *_IGnext += _Off;

  00142	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00145	01 30		 add	 DWORD PTR [eax], esi
  00147	eb 06		 jmp	 SHORT $LN101@xsgetn
$LN41@xsgetn:

; 232  :         return *_IGnext ? *_IGcount : 0;

  00149	8d 43 2c	 lea	 eax, DWORD PTR [ebx+44]
  0014c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
$LN101@xsgetn:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 558  :             if (_Myfile) { // open C stream, attempt read

  0014f	83 7b 4c 00	 cmp	 DWORD PTR [ebx+76], 0
  00153	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00156	74 62		 je	 SHORT $LN9@xsgetn
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 180  :         return *_IGfirst;

  00158	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 760  :         if (_Mysb::eback() == &_Mychar) {

  0015b	8d 43 3c	 lea	 eax, DWORD PTR [ebx+60]
  0015e	39 01		 cmp	 DWORD PTR [ecx], eax
  00160	75 19		 jne	 SHORT $LN64@xsgetn
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 207  :         *_IGfirst = _First;

  00162	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 761  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00165	8b 53 54	 mov	 edx, DWORD PTR [ebx+84]
  00168	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

  0016b	2b d1		 sub	 edx, ecx
  0016d	89 08		 mov	 DWORD PTR [eax], ecx
  0016f	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00172	89 08		 mov	 DWORD PTR [eax], ecx
  00174	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00177	8b 00		 mov	 eax, DWORD PTR [eax]
  00179	89 10		 mov	 DWORD PTR [eax], edx
$LN64@xsgetn:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 563  :                 while (_Read_size < _Count_s) {

  0017b	81 ff ff 0f 00
	00		 cmp	 edi, 4095		; 00000fffH
  00181	76 22		 jbe	 SHORT $LN3@xsgetn
$LL2@xsgetn:

; 564  :                     const auto _Actual_read = _CSTD fread(_Ptr, sizeof(_Elem), _Read_size, _Myfile);

  00183	ff 73 4c	 push	 DWORD PTR [ebx+76]
  00186	68 ff 0f 00 00	 push	 4095			; 00000fffH
  0018b	6a 01		 push	 1
  0018d	56		 push	 esi
  0018e	e8 00 00 00 00	 call	 _fread
  00193	83 c4 10	 add	 esp, 16			; 00000010H

; 565  :                     _Ptr += _Actual_read;

  00196	03 f0		 add	 esi, eax

; 566  :                     _Count_s -= _Actual_read;

  00198	2b f8		 sub	 edi, eax

; 567  :                     if (_Actual_read != _Read_size) {

  0019a	3d ff 0f 00 00	 cmp	 eax, 4095		; 00000fffH
  0019f	75 19		 jne	 SHORT $LN9@xsgetn

; 563  :                 while (_Read_size < _Count_s) {

  001a1	3b f8		 cmp	 edi, eax
  001a3	77 de		 ja	 SHORT $LL2@xsgetn
$LN3@xsgetn:

; 568  :                         return static_cast<streamsize>(_Start_count - _Count_s);
; 569  :                     }
; 570  :                 }
; 571  : 
; 572  :                 if (0 < _Count_s) {

  001a5	85 ff		 test	 edi, edi
  001a7	74 11		 je	 SHORT $LN9@xsgetn

; 573  :                     _Count_s -= _CSTD fread(_Ptr, sizeof(_Elem), _Count_s, _Myfile);

  001a9	ff 73 4c	 push	 DWORD PTR [ebx+76]
  001ac	57		 push	 edi
  001ad	6a 01		 push	 1
  001af	56		 push	 esi
  001b0	e8 00 00 00 00	 call	 _fread
  001b5	83 c4 10	 add	 esp, 16			; 00000010H
  001b8	2b f8		 sub	 edi, eax
$LN9@xsgetn:

; 574  :                 }
; 575  :             }
; 576  : 
; 577  :             return static_cast<streamsize>(_Start_count - _Count_s);

  001ba	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  001bd	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp+4]
  001c0	2b c7		 sub	 eax, edi
  001c2	5f		 pop	 edi
  001c3	5e		 pop	 esi
  001c4	83 da 00	 sbb	 edx, 0
  001c7	5b		 pop	 ebx

; 581  :     }

  001c8	8b e5		 mov	 esp, ebp
  001ca	5d		 pop	 ebp
  001cb	c2 0c 00	 ret	 12			; 0000000cH
?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
__Dest$2 = -76						; size = 4
__New_size$1$ = -72					; size = 4
__Src$3 = -68						; size = 4
_this$GSCopy$1$ = -64					; size = 4
__Str$6$ = -60						; size = 4
tv1284 = -56						; size = 4
__Old_capacity$1$ = -56					; size = 4
__Meta$1$ = -52						; size = 4
tv1276 = -48						; size = 4
__Old_size$1$ = -48					; size = 4
__New_size$1$ = -48					; size = 4
__Ch$4 = -41						; size = 1
__Str$ = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::uflow, COMDAT
; _this$ = ecx

; 478  :     int_type __CLR_OR_THIS_CALL uflow() override { // get an element from stream, point past it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b f9		 mov	 edi, ecx
  0002c	89 7d c0	 mov	 DWORD PTR _this$GSCopy$1$[ebp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 184  :         return *_IGnext;

  0002f	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 479  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

  00032	8b 08		 mov	 ecx, DWORD PTR [eax]
  00034	85 c9		 test	 ecx, ecx
  00036	74 1f		 je	 SHORT $LN328@uflow
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 196  :         return *_IGnext + *_IGcount;

  00038	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  0003b	8b 02		 mov	 eax, DWORD PTR [edx]
  0003d	03 c1		 add	 eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 479  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

  0003f	3b c8		 cmp	 ecx, eax
  00041	73 14		 jae	 SHORT $LN328@uflow
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 222  :         --*_IGcount;

  00043	ff 0a		 dec	 DWORD PTR [edx]

; 223  :         return (*_IGnext)++;

  00045	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  00048	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004a	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0004d	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0004f	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 480  :             return _Traits::to_int_type(*_Mysb::_Gninc()); // return buffered

  00052	e9 c8 02 00 00	 jmp	 $LN302@uflow
$LN328@uflow:

; 481  :         }
; 482  : 
; 483  :         if (!_Myfile) {

  00057	83 7f 4c 00	 cmp	 DWORD PTR [edi+76], 0
  0005b	75 08		 jne	 SHORT $LN10@uflow
$LN337@uflow:

; 533  :     }

  0005d	83 c8 ff	 or	 eax, -1
  00060	e9 ba 02 00 00	 jmp	 $LN302@uflow
$LN10@uflow:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 180  :         return *_IGfirst;

  00065	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 760  :         if (_Mysb::eback() == &_Mychar) {

  00068	8d 47 3c	 lea	 eax, DWORD PTR [edi+60]
  0006b	39 01		 cmp	 DWORD PTR [ecx], eax
  0006d	75 17		 jne	 SHORT $LN157@uflow
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 207  :         *_IGfirst = _First;

  0006f	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 761  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00072	8b 57 54	 mov	 edx, DWORD PTR [edi+84]
  00075	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

  00078	2b d1		 sub	 edx, ecx
  0007a	89 08		 mov	 DWORD PTR [eax], ecx
  0007c	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  0007f	89 08		 mov	 DWORD PTR [eax], ecx
  00081	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00084	89 10		 mov	 DWORD PTR [eax], edx
$LN157@uflow:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 488  :         if (!_Pcvt) { // no codecvt facet, just get it

  00086	83 7f 38 00	 cmp	 DWORD PTR [edi+56], 0
  0008a	8b 47 4c	 mov	 eax, DWORD PTR [edi+76]
  0008d	75 16		 jne	 SHORT $LN11@uflow

; 75   :     if ((_Meta = _CSTD fgetc(_File)) == EOF) {

  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 _fgetc
  00095	83 c4 04	 add	 esp, 4
  00098	83 f8 ff	 cmp	 eax, -1
  0009b	74 c0		 je	 SHORT $LN337@uflow
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0009d	0f b6 c0	 movzx	 eax, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 490  :             return _Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch) : _Traits::eof();

  000a0	e9 7a 02 00 00	 jmp	 $LN302@uflow
$LN11@uflow:
  000a5	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 860  :         _My_data._Mysize = 0;

  000a8	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Str$[ebp+16], 0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  000af	0f 11 45 d8	 movups	 XMMWORD PTR __Str$[ebp], xmm0

; 861  :         _My_data._Myres  = _Small_string_capacity;

  000b3	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR __Str$[ebp+20], 15 ; 0000000fH

; 862  :         _My_data._Activate_SSO_buffer();
; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  000ba	c6 45 d8 00	 mov	 BYTE PTR __Str$[ebp], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 498  :             int _Meta = _CSTD fgetc(_Myfile);

  000be	50		 push	 eax
  000bf	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000c6	e8 00 00 00 00	 call	 _fgetc
  000cb	83 c4 04	 add	 esp, 4
  000ce	89 45 cc	 mov	 DWORD PTR __Meta$1$[ebp], eax

; 499  : 
; 500  :             if (_Meta == EOF) {

  000d1	83 f8 ff	 cmp	 eax, -1
  000d4	0f 84 c2 01 00
	00		 je	 $LN313@uflow
  000da	66 0f 1f 44 00
	00		 npad	 6
$LL4@uflow:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  000e0	8b 4d e8	 mov	 ecx, DWORD PTR __Str$[ebp+16]
  000e3	8b 55 ec	 mov	 edx, DWORD PTR __Str$[ebp+20]
  000e6	89 4d d0	 mov	 DWORD PTR __Old_size$1$[ebp], ecx
  000e9	89 55 c8	 mov	 DWORD PTR __Old_capacity$1$[ebp], edx
  000ec	3b ca		 cmp	 ecx, edx

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

  000ee	73 23		 jae	 SHORT $LN61@uflow

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  000f0	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 453  :         return _Myres > _Small_string_capacity;

  000f3	83 fa 0f	 cmp	 edx, 15			; 0000000fH

; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  000f6	89 45 e8	 mov	 DWORD PTR __Str$[ebp+16], eax

; 435  :         value_type* _Result = _Bx._Buf;

  000f9	8d 45 d8	 lea	 eax, DWORD PTR __Str$[ebp]

; 436  :         if (_Large_mode_engaged()) {

  000fc	0f 47 45 d8	 cmova	 eax, DWORD PTR __Str$[ebp]

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

  00100	03 c1		 add	 eax, ecx
  00102	8b 4d cc	 mov	 ecx, DWORD PTR __Meta$1$[ebp]

; 2298 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

  00105	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0
  00109	88 08		 mov	 BYTE PTR [eax], cl

; 2299 :             return;

  0010b	8b 7d d8	 mov	 edi, DWORD PTR __Str$[ebp]
  0010e	e9 d8 00 00 00	 jmp	 $LN336@uflow
$LN61@uflow:

; 3028 :         const size_type _Old_size = _My_data._Mysize;

  00113	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00118	2b c1		 sub	 eax, ecx

; 3029 :         if (max_size() - _Old_size < _Size_increase) {

  0011a	83 f8 01	 cmp	 eax, 1
  0011d	0f 82 26 02 00
	00		 jb	 $LN314@uflow

; 3031 :         }
; 3032 : 
; 3033 :         const size_type _New_size     = _Old_size + _Size_increase;

  00123	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

  00126	8b f0		 mov	 esi, eax

; 3033 :         const size_type _New_size     = _Old_size + _Size_increase;

  00128	89 45 b8	 mov	 DWORD PTR __New_size$1$[ebp], eax

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

  0012b	83 ce 0f	 or	 esi, 15			; 0000000fH
  0012e	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00134	76 07		 jbe	 SHORT $LN79@uflow

; 2980 :             return _Max;

  00136	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  0013b	eb 1e		 jmp	 SHORT $LN78@uflow
$LN79@uflow:

; 2981 :         }
; 2982 : 
; 2983 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0013d	8b ca		 mov	 ecx, edx
  0013f	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00144	d1 e9		 shr	 ecx, 1
  00146	2b c1		 sub	 eax, ecx
  00148	3b d0		 cmp	 edx, eax
  0014a	76 07		 jbe	 SHORT $LN80@uflow

; 2984 :             return _Max;

  0014c	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  00151	eb 08		 jmp	 SHORT $LN78@uflow
$LN80@uflow:

; 2985 :         }
; 2986 : 
; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00153	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  00156	3b f0		 cmp	 esi, eax
  00158	0f 42 f0	 cmovb	 esi, eax
$LN78@uflow:

; 825  :         ++_Capacity; // Take null terminator into consideration

  0015b	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0015e	50		 push	 eax
  0015f	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3037 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

  00164	8b f8		 mov	 edi, eax

; 3038 : 
; 3039 :         _My_data._Orphan_all();
; 3040 :         _ASAN_STRING_REMOVE(*this);
; 3041 :         _My_data._Mysize      = _New_size;
; 3042 :         _My_data._Myres       = _New_capacity;

  00166	89 75 ec	 mov	 DWORD PTR __Str$[ebp+20], esi
  00169	8b 45 b8	 mov	 eax, DWORD PTR __New_size$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0016c	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3044 :         if (_Old_capacity > _Small_string_capacity) {

  0016f	83 7d c8 0f	 cmp	 DWORD PTR __Old_capacity$1$[ebp], 15 ; 0000000fH
  00173	89 45 e8	 mov	 DWORD PTR __Str$[ebp+16], eax
  00176	8b 45 d0	 mov	 eax, DWORD PTR __Old_size$1$[ebp]
  00179	89 7d c4	 mov	 DWORD PTR __Str$6$[ebp], edi
  0017c	50		 push	 eax
  0017d	8d 34 38	 lea	 esi, DWORD PTR [eax+edi]
  00180	89 75 d0	 mov	 DWORD PTR tv1276[ebp], esi
  00183	76 4d		 jbe	 SHORT $LN72@uflow

; 3045 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  00185	8b 75 d8	 mov	 esi, DWORD PTR __Str$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00188	56		 push	 esi
  00189	57		 push	 edi
  0018a	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2307 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

  0018f	8b 45 d0	 mov	 eax, DWORD PTR tv1276[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00192	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2307 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

  00195	8b 4d cc	 mov	 ecx, DWORD PTR __Meta$1$[ebp]
  00198	88 08		 mov	 BYTE PTR [eax], cl

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0019a	8b 4d c8	 mov	 ecx, DWORD PTR __Old_capacity$1$[ebp]
  0019d	41		 inc	 ecx

; 2308 :                     _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  0019e	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  001a2	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  001a8	72 16		 jb	 SHORT $LN110@uflow

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001aa	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  001ad	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  001b0	2b f2		 sub	 esi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001b2	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  001b5	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001b8	0f 87 7c 01 00
	00		 ja	 $LN49@uflow

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  001be	8b f2		 mov	 esi, edx
$LN110@uflow:

; 289  :         ::operator delete(_Ptr, _Bytes);

  001c0	51		 push	 ecx
  001c1	56		 push	 esi
  001c2	0f ae e8	 lfence
  001c5	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001ca	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3048 :             _My_data._Bx._Ptr = _New_ptr;

  001cd	89 7d d8	 mov	 DWORD PTR __Str$[ebp], edi

; 3049 :         } else {

  001d0	eb 1c		 jmp	 SHORT $LN73@uflow
$LN72@uflow:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  001d2	8d 45 d8	 lea	 eax, DWORD PTR __Str$[ebp]
  001d5	50		 push	 eax
  001d6	57		 push	 edi
  001d7	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2307 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

  001dc	8b 4d cc	 mov	 ecx, DWORD PTR __Meta$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  001df	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2307 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

  001e2	88 0e		 mov	 BYTE PTR [esi], cl

; 2308 :                     _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  001e4	c6 46 01 00	 mov	 BYTE PTR [esi+1], 0

; 3051 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  001e8	89 7d d8	 mov	 DWORD PTR __Str$[ebp], edi
$LN336@uflow:

; 435  :         value_type* _Result = _Bx._Buf;

  001eb	89 7d c4	 mov	 DWORD PTR __Str$6$[ebp], edi
$LN73@uflow:

; 453  :         return _Myres > _Small_string_capacity;

  001ee	83 7d ec 0f	 cmp	 DWORD PTR __Str$[ebp+20], 15 ; 0000000fH

; 435  :         value_type* _Result = _Bx._Buf;

  001f2	8d 4d d8	 lea	 ecx, DWORD PTR __Str$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 704  :         return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);

  001f5	8b 45 c0	 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 435  :         value_type* _Result = _Bx._Buf;

  001f8	8d 75 d8	 lea	 esi, DWORD PTR __Str$[ebp]

; 436  :         if (_Large_mode_engaged()) {

  001fb	0f 47 cf	 cmova	 ecx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 510  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1, _Dest)) {

  001fe	8b 7d e8	 mov	 edi, DWORD PTR __Str$[ebp+16]
  00201	03 f9		 add	 edi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00203	83 7d ec 0f	 cmp	 DWORD PTR __Str$[ebp+20], 15 ; 0000000fH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 704  :         return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);

  00207	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 436  :         if (_Large_mode_engaged()) {

  0020a	0f 47 75 c4	 cmova	 esi, DWORD PTR __Str$6$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 704  :         return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);

  0020e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00210	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00213	8d 45 b4	 lea	 eax, DWORD PTR __Dest$2[ebp]
  00216	50		 push	 eax
  00217	8d 45 d8	 lea	 eax, DWORD PTR __Ch$4[ebp+1]
  0021a	50		 push	 eax
  0021b	8d 45 d7	 lea	 eax, DWORD PTR __Ch$4[ebp]
  0021e	50		 push	 eax
  0021f	8d 45 bc	 lea	 eax, DWORD PTR __Src$3[ebp]
  00222	50		 push	 eax
  00223	57		 push	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 510  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1, _Dest)) {

  00224	8b 7d c0	 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 704  :         return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);

  00227	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 510  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1, _Dest)) {

  00228	8d 47 40	 lea	 eax, DWORD PTR [edi+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 704  :         return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);

  0022b	50		 push	 eax
  0022c	ff d2		 call	 edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 510  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1, _Dest)) {

  0022e	83 e8 00	 sub	 eax, 0
  00231	74 09		 je	 SHORT $LN13@uflow
  00233	83 e8 01	 sub	 eax, 1
  00236	0f 85 8b 00 00
	00		 jne	 $LN329@uflow
$LN13@uflow:

; 511  :             case codecvt_base::partial:
; 512  :             case codecvt_base::ok:
; 513  :                 if (_Dest != &_Ch) { // got an element, put back excess and deliver it

  0023c	8d 45 d7	 lea	 eax, DWORD PTR __Ch$4[ebp]
  0023f	39 45 b4	 cmp	 DWORD PTR __Dest$2[ebp], eax
  00242	8d 45 d8	 lea	 eax, DWORD PTR __Str$[ebp]
  00245	0f 85 91 00 00
	00		 jne	 $LN316@uflow
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  0024b	83 7d ec 0f	 cmp	 DWORD PTR __Str$[ebp+20], 15 ; 0000000fH

; 435  :         value_type* _Result = _Bx._Buf;

  0024f	8d 4d d8	 lea	 ecx, DWORD PTR __Str$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 522  :                 _Str.erase(0, static_cast<size_t>(_Src - _Str.data())); // partial, discard used input

  00252	8b 7d bc	 mov	 edi, DWORD PTR __Src$3[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 436  :         if (_Large_mode_engaged()) {

  00255	0f 47 45 d8	 cmova	 eax, DWORD PTR __Str$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 522  :                 _Str.erase(0, static_cast<size_t>(_Src - _Str.data())); // partial, discard used input

  00259	2b f8		 sub	 edi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 487  :         return (_STD min)(_Size, _Mysize - _Off);

  0025b	8b 45 e8	 mov	 eax, DWORD PTR __Str$[ebp+16]
  0025e	3b c7		 cmp	 eax, edi
  00260	0f 42 f8	 cmovb	 edi, eax

; 453  :         return _Myres > _Small_string_capacity;

  00263	83 7d ec 0f	 cmp	 DWORD PTR __Str$[ebp+20], 15 ; 0000000fH

; 436  :         if (_Large_mode_engaged()) {

  00267	0f 47 4d d8	 cmova	 ecx, DWORD PTR __Str$[ebp]

; 1881 :         const size_type _New_size = _Old_size - _Count;

  0026b	2b c7		 sub	 eax, edi
  0026d	89 45 d0	 mov	 DWORD PTR __New_size$1$[ebp], eax

; 1882 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00270	40		 inc	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00271	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1882 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00272	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00275	50		 push	 eax
  00276	51		 push	 ecx
  00277	e8 00 00 00 00	 call	 _memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1884 :         _Mypair._Myval2._Mysize = _New_size;

  0027c	8b 45 d0	 mov	 eax, DWORD PTR __New_size$1$[ebp]
  0027f	89 45 e8	 mov	 DWORD PTR __Str$[ebp+16], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 498  :             int _Meta = _CSTD fgetc(_Myfile);

  00282	8b 45 c0	 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  00285	ff 70 4c	 push	 DWORD PTR [eax+76]
  00288	e8 00 00 00 00	 call	 _fgetc
  0028d	83 c4 10	 add	 esp, 16			; 00000010H
  00290	89 45 cc	 mov	 DWORD PTR __Meta$1$[ebp], eax

; 499  : 
; 500  :             if (_Meta == EOF) {

  00293	83 f8 ff	 cmp	 eax, -1
  00296	0f 85 44 fe ff
	ff		 jne	 $LL4@uflow
$LN313@uflow:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  0029c	83 ce ff	 or	 esi, -1
$LN24@uflow:
  0029f	8b 4d ec	 mov	 ecx, DWORD PTR __Str$[ebp+20]
  002a2	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3083 :         if (_My_data._Large_mode_engaged()) {

  002a5	76 76		 jbe	 SHORT $LN45@uflow
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002a7	8b 55 d8	 mov	 edx, DWORD PTR __Str$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  002aa	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002ab	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  002ad	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  002b3	72 5e		 jb	 SHORT $LN50@uflow

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  002b5	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  002b8	83 c1 23	 add	 ecx, 35			; 00000023H
  002bb	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  002bd	83 c0 fc	 add	 eax, -4			; fffffffcH
  002c0	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  002c3	77 75		 ja	 SHORT $LN49@uflow
  002c5	eb 4c		 jmp	 SHORT $LN50@uflow
$LN329@uflow:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 510  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1, _Dest)) {

  002c7	83 e8 02	 sub	 eax, 2
  002ca	75 d0		 jne	 SHORT $LN313@uflow
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  002cc	83 7d ec 0f	 cmp	 DWORD PTR __Str$[ebp+20], 15 ; 0000000fH

; 435  :         value_type* _Result = _Bx._Buf;

  002d0	8d 45 d8	 lea	 eax, DWORD PTR __Str$[ebp]

; 436  :         if (_Large_mode_engaged()) {

  002d3	0f 47 45 d8	 cmova	 eax, DWORD PTR __Str$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 527  :                 return static_cast<int_type>(_Str.front());

  002d7	0f be 30	 movsx	 esi, BYTE PTR [eax]
  002da	eb c3		 jmp	 SHORT $LN24@uflow
$LN316@uflow:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  002dc	83 7d ec 0f	 cmp	 DWORD PTR __Str$[ebp+20], 15 ; 0000000fH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 514  :                     auto _Nleft = _Str.data() + _Str.size() - _Src;

  002e0	8b 75 e8	 mov	 esi, DWORD PTR __Str$[ebp+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 436  :         if (_Large_mode_engaged()) {

  002e3	0f 47 45 d8	 cmova	 eax, DWORD PTR __Str$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 514  :                     auto _Nleft = _Str.data() + _Str.size() - _Src;

  002e7	8b 4d bc	 mov	 ecx, DWORD PTR __Src$3[ebp]
  002ea	2b f1		 sub	 esi, ecx
  002ec	03 f0		 add	 esi, eax

; 515  :                     while (0 < _Nleft) {

  002ee	85 f6		 test	 esi, esi
  002f0	7e 1b		 jle	 SHORT $LN332@uflow
$LL321@uflow:

; 516  :                         _CSTD ungetc(_Src[--_Nleft], _Myfile);

  002f2	ff 77 4c	 push	 DWORD PTR [edi+76]
  002f5	0f be 44 0e ff	 movsx	 eax, BYTE PTR [esi+ecx-1]
  002fa	4e		 dec	 esi
  002fb	50		 push	 eax
  002fc	e8 00 00 00 00	 call	 _ungetc
  00301	83 c4 08	 add	 esp, 8
  00304	85 f6		 test	 esi, esi
  00306	7e 05		 jle	 SHORT $LN332@uflow

; 515  :                     while (0 < _Nleft) {

  00308	8b 4d bc	 mov	 ecx, DWORD PTR __Src$3[ebp]
  0030b	eb e5		 jmp	 SHORT $LL321@uflow
$LN332@uflow:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0030d	0f b6 75 d7	 movzx	 esi, BYTE PTR __Ch$4[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 519  :                     return _Traits::to_int_type(_Ch);

  00311	eb 8c		 jmp	 SHORT $LN24@uflow
$LN50@uflow:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00313	51		 push	 ecx
  00314	52		 push	 edx
  00315	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0031a	83 c4 08	 add	 esp, 8
$LN45@uflow:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 530  :                 return _Traits::eof(); // conversion failed

  0031d	8b c6		 mov	 eax, esi
$LN302@uflow:

; 533  :     }

  0031f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00322	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00329	59		 pop	 ecx
  0032a	5f		 pop	 edi
  0032b	5e		 pop	 esi
  0032c	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0032f	33 cd		 xor	 ecx, ebp
  00331	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00336	8b e5		 mov	 esp, ebp
  00338	5d		 pop	 ebp
  00339	c3		 ret	 0
$LN49@uflow:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0033a	6a 00		 push	 0
  0033c	6a 00		 push	 0
  0033e	6a 00		 push	 0
  00340	6a 00		 push	 0
  00342	6a 00		 push	 0
  00344	e8 00 00 00 00	 call	 __invoke_watson
$LN314@uflow:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3030 :             _Xlen_string(); // result too long

  00349	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN335@uflow:
  0034e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Str$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::uflow
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::underflow, COMDAT
; _this$ = ecx

; 466  :     int_type __CLR_OR_THIS_CALL underflow() override { // get an element from stream, but don't point past it

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 184  :         return *_IGnext;

  00003	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 468  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	85 c9		 test	 ecx, ecx
  0000a	74 10		 je	 SHORT $LN2@underflow
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 196  :         return *_IGnext + *_IGcount;

  0000c	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	03 c1		 add	 eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 468  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

  00013	3b c8		 cmp	 ecx, eax
  00015	73 05		 jae	 SHORT $LN2@underflow
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00017	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  0001a	5e		 pop	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 476  :     }

  0001b	c3		 ret	 0
$LN2@underflow:

; 470  :         } else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow())) {

  0001c	8b 06		 mov	 eax, DWORD PTR [esi]
  0001e	8b ce		 mov	 ecx, esi
  00020	57		 push	 edi
  00021	ff 50 1c	 call	 DWORD PTR [eax+28]
  00024	8b f8		 mov	 edi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00026	83 ff ff	 cmp	 edi, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 470  :         } else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow())) {

  00029	75 05		 jne	 SHORT $LN4@underflow

; 471  :             return _Meta; // uflow failed, return EOF

  0002b	5f		 pop	 edi
  0002c	0b c0		 or	 eax, eax
  0002e	5e		 pop	 esi

; 476  :     }

  0002f	c3		 ret	 0
$LN4@underflow:

; 472  :         } else { // get a char, don't point past it
; 473  :             pbackfail(_Meta);

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	8b ce		 mov	 ecx, esi
  00034	57		 push	 edi
  00035	ff 50 10	 call	 DWORD PTR [eax+16]

; 474  :             return _Meta;

  00038	8b c7		 mov	 eax, edi
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi

; 476  :     }

  0003c	c3		 ret	 0
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail, COMDAT
; _this$ = ecx

; 445  :     int_type __CLR_OR_THIS_CALL pbackfail(int_type _Meta = _Traits::eof()) override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Meta$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 184  :         return *_IGnext;

  0000a	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 448  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	85 c9		 test	 ecx, ecx
  00011	74 2e		 je	 SHORT $LN2@pbackfail
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 180  :         return *_IGfirst;

  00013	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 448  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

  00016	39 08		 cmp	 DWORD PTR [eax], ecx
  00018	73 27		 jae	 SHORT $LN2@pbackfail
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  0001a	83 fb ff	 cmp	 ebx, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 448  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

  0001d	74 08		 je	 SHORT $LN4@pbackfail
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0001f	0f b6 41 ff	 movzx	 eax, BYTE PTR [ecx-1]

; 522  :         return _Left == _Right;

  00023	3b c3		 cmp	 eax, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 448  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

  00025	75 1a		 jne	 SHORT $LN2@pbackfail
$LN4@pbackfail:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 217  :         ++*_IGcount;

  00027	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0002a	ff 00		 inc	 DWORD PTR [eax]

; 218  :         return --*_IGnext;

  0002c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0002f	ff 08		 dec	 DWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 452  :             return _Traits::not_eof(_Meta);

  00031	33 c0		 xor	 eax, eax
  00033	83 fb ff	 cmp	 ebx, -1
  00036	0f 44 d8	 cmove	 ebx, eax
$LN85@pbackfail:

; 461  :         } else {
; 462  :             return _Traits::eof(); // nowhere to put back
; 463  :         }
; 464  :     }

  00039	5e		 pop	 esi
  0003a	8b c3		 mov	 eax, ebx
  0003c	5b		 pop	 ebx
  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
$LN2@pbackfail:

; 453  :         } else if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), _Meta)) {

  00041	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  00044	85 c0		 test	 eax, eax
  00046	74 59		 je	 SHORT $LN7@pbackfail
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00048	83 fb ff	 cmp	 ebx, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 453  :         } else if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), _Meta)) {

  0004b	74 54		 je	 SHORT $LN7@pbackfail

; 455  :         } else if (!_Pcvt && _Ungetc(_Traits::to_char_type(_Meta), _Myfile)) {

  0004d	83 7e 38 00	 cmp	 DWORD PTR [esi+56], 0
  00051	75 12		 jne	 SHORT $LN73@pbackfail

; 136  :     return _CSTD ungetc(static_cast<unsigned char>(_Byte), _File) != EOF;

  00053	50		 push	 eax
  00054	0f b6 cb	 movzx	 ecx, bl
  00057	51		 push	 ecx
  00058	e8 00 00 00 00	 call	 _ungetc
  0005d	83 c4 08	 add	 esp, 8
  00060	83 f8 ff	 cmp	 eax, -1

; 455  :         } else if (!_Pcvt && _Ungetc(_Traits::to_char_type(_Meta), _Myfile)) {

  00063	75 d4		 jne	 SHORT $LN85@pbackfail
$LN73@pbackfail:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 184  :         return *_IGnext;

  00065	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 457  :         } else if (_Mysb::gptr() != &_Mychar) { // putback to _Mychar

  00068	8d 4e 3c	 lea	 ecx, DWORD PTR [esi+60]
  0006b	39 0a		 cmp	 DWORD PTR [edx], ecx
  0006d	74 32		 je	 SHORT $LN7@pbackfail
  0006f	57		 push	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 180  :         return *_IGfirst;

  00070	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 458  :             _Mychar = _Traits::to_char_type(_Meta);

  00073	88 19		 mov	 BYTE PTR [ecx], bl

; 766  :         if (_Mysb::eback() != &_Mychar) { // save current get buffer

  00075	8b 07		 mov	 eax, DWORD PTR [edi]
  00077	3b c1		 cmp	 eax, ecx
  00079	74 0d		 je	 SHORT $LN75@pbackfail

; 767  :             _Set_eback = _Mysb::eback();

  0007b	89 46 50	 mov	 DWORD PTR [esi+80], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 196  :         return *_IGnext + *_IGcount;

  0007e	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00081	8b 00		 mov	 eax, DWORD PTR [eax]
  00083	03 02		 add	 eax, DWORD PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 768  :             _Set_egptr = _Mysb::egptr();

  00085	89 46 54	 mov	 DWORD PTR [esi+84], eax
$LN75@pbackfail:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 207  :         *_IGfirst = _First;

  00088	89 0f		 mov	 DWORD PTR [edi], ecx

; 208  :         *_IGnext  = _Next;

  0008a	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 460  :             return _Meta;

  0008d	5f		 pop	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 208  :         *_IGnext  = _Next;

  0008e	89 08		 mov	 DWORD PTR [eax], ecx

; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

  00090	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00093	5e		 pop	 esi
  00094	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 460  :             return _Meta;

  0009a	8b c3		 mov	 eax, ebx

; 461  :         } else {
; 462  :             return _Traits::eof(); // nowhere to put back
; 463  :         }
; 464  :     }

  0009c	5b		 pop	 ebx
  0009d	5d		 pop	 ebp
  0009e	c2 04 00	 ret	 4
$LN7@pbackfail:
  000a1	5e		 pop	 esi

; 454  :             return _Traits::eof(); // no open C stream or EOF, fail

  000a2	83 c8 ff	 or	 eax, -1

; 461  :         } else {
; 462  :             return _Traits::eof(); // nowhere to put back
; 463  :         }
; 464  :     }

  000a5	5b		 pop	 ebx
  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
__Src$ = -48						; size = 4
__Dest$ = -44						; size = 4
__Ch$ = -40						; size = 1
__Str$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
__Meta$ = 8						; size = 4
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::overflow, COMDAT
; _this$ = ecx

; 392  :     int_type __CLR_OR_THIS_CALL overflow(int_type _Meta = _Traits::eof()) override { // put an element to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR __Meta$[ebp]
  00014	56		 push	 esi
  00015	8b f1		 mov	 esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00017	83 fb ff	 cmp	 ebx, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 393  :         if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {

  0001a	75 14		 jne	 SHORT $LN4@overflow

; 394  :             return _Traits::not_eof(_Meta); // EOF, return success code

  0001c	5e		 pop	 esi
  0001d	33 c0		 xor	 eax, eax

; 439  : 
; 440  :         default:
; 441  :             return _Traits::eof(); // conversion failed
; 442  :         }
; 443  :     }

  0001f	5b		 pop	 ebx
  00020	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00023	33 cd		 xor	 ecx, ebp
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
$LN4@overflow:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 192  :         return *_IPnext;

  00030	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00033	57		 push	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 397  :         if (_Mysb::pptr() && _Mysb::pptr() < _Mysb::epptr()) { // room in buffer, store it

  00034	8b 08		 mov	 ecx, DWORD PTR [eax]
  00036	85 c9		 test	 ecx, ecx
  00038	74 32		 je	 SHORT $LN5@overflow
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 213  :         return *_IPnext + *_IPcount;

  0003a	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  0003d	8b 3a		 mov	 edi, DWORD PTR [edx]
  0003f	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 397  :         if (_Mysb::pptr() && _Mysb::pptr() < _Mysb::epptr()) { // room in buffer, store it

  00042	3b c8		 cmp	 ecx, eax
  00044	73 26		 jae	 SHORT $LN5@overflow
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 256  :         --*_IPcount;

  00046	8d 4f ff	 lea	 ecx, DWORD PTR [edi-1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 399  :             return _Meta;

  00049	8b c3		 mov	 eax, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 256  :         --*_IPcount;

  0004b	89 0a		 mov	 DWORD PTR [edx], ecx

; 257  :         return (*_IPnext)++;

  0004d	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00050	5f		 pop	 edi
  00051	8b 32		 mov	 esi, DWORD PTR [edx]
  00053	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  00056	89 0a		 mov	 DWORD PTR [edx], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 398  :             *_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  00058	88 1e		 mov	 BYTE PTR [esi], bl
  0005a	5e		 pop	 esi

; 439  : 
; 440  :         default:
; 441  :             return _Traits::eof(); // conversion failed
; 442  :         }
; 443  :     }

  0005b	5b		 pop	 ebx
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005f	33 cd		 xor	 ecx, ebp
  00061	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
$LN5@overflow:

; 400  :         }
; 401  : 
; 402  :         if (!_Myfile) {

  0006c	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00070	0f 84 f4 00 00
	00		 je	 $LN11@overflow
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 180  :         return *_IGfirst;

  00076	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 760  :         if (_Mysb::eback() == &_Mychar) {

  00079	8d 46 3c	 lea	 eax, DWORD PTR [esi+60]
  0007c	39 07		 cmp	 DWORD PTR [edi], eax
  0007e	75 14		 jne	 SHORT $LN44@overflow

; 761  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00080	8b 56 54	 mov	 edx, DWORD PTR [esi+84]
  00083	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

  00086	2b d1		 sub	 edx, ecx
  00088	89 0f		 mov	 DWORD PTR [edi], ecx
  0008a	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0008d	89 08		 mov	 DWORD PTR [eax], ecx
  0008f	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00092	89 10		 mov	 DWORD PTR [eax], edx
$LN44@overflow:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 407  :         if (!_Pcvt) { // no codecvt facet, put as is

  00094	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  00097	85 c9		 test	 ecx, ecx
  00099	75 2c		 jne	 SHORT $LN7@overflow

; 114  :     return _CSTD fputc(_Byte, _File) != EOF;

  0009b	ff 76 4c	 push	 DWORD PTR [esi+76]
  0009e	0f be c3	 movsx	 eax, bl
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 _fputc
  000a7	83 c4 08	 add	 esp, 8

; 408  :             return _Fputc(_Traits::to_char_type(_Meta), _Myfile) ? _Meta : _Traits::eof();

  000aa	83 c9 ff	 or	 ecx, -1
  000ad	3b c1		 cmp	 eax, ecx
  000af	0f 44 d9	 cmove	 ebx, ecx
  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	8b c3		 mov	 eax, ebx

; 439  : 
; 440  :         default:
; 441  :             return _Traits::eof(); // conversion failed
; 442  :         }
; 443  :     }

  000b6	5b		 pop	 ebx
  000b7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ba	33 cd		 xor	 ecx, ebp
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 04 00	 ret	 4
$LN7@overflow:

; 409  :         }
; 410  : 
; 411  :         // put using codecvt facet
; 412  :         constexpr size_t _Codecvt_temp_buf = 32;
; 413  :         char _Str[_Codecvt_temp_buf];
; 414  :         const _Elem _Ch = _Traits::to_char_type(_Meta);

  000c7	88 5d d8	 mov	 BYTE PTR __Ch$[ebp], bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 709  :         return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);

  000ca	8b 01		 mov	 eax, DWORD PTR [ecx]
  000cc	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  000cf	8d 45 d4	 lea	 eax, DWORD PTR __Dest$[ebp]
  000d2	50		 push	 eax
  000d3	8d 45 fc	 lea	 eax, DWORD PTR __Str$[ebp+32]
  000d6	50		 push	 eax
  000d7	8d 45 dc	 lea	 eax, DWORD PTR __Str$[ebp]
  000da	50		 push	 eax
  000db	8d 45 d0	 lea	 eax, DWORD PTR __Src$[ebp]
  000de	50		 push	 eax
  000df	8d 45 d9	 lea	 eax, DWORD PTR __Ch$[ebp+1]
  000e2	50		 push	 eax
  000e3	8d 45 d8	 lea	 eax, DWORD PTR __Ch$[ebp]
  000e6	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 419  :         switch (_Pcvt->out(_State, &_Ch, &_Ch + 1, _Src, _Str, _Str + _Codecvt_temp_buf, _Dest)) {

  000e7	8d 46 40	 lea	 eax, DWORD PTR [esi+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 709  :         return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);

  000ea	50		 push	 eax
  000eb	ff d2		 call	 edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 419  :         switch (_Pcvt->out(_State, &_Ch, &_Ch + 1, _Src, _Str, _Str + _Codecvt_temp_buf, _Dest)) {

  000ed	83 e8 00	 sub	 eax, 0
  000f0	74 35		 je	 SHORT $LN8@overflow
  000f2	83 e8 01	 sub	 eax, 1
  000f5	74 30		 je	 SHORT $LN8@overflow
  000f7	83 e8 02	 sub	 eax, 2
  000fa	75 6e		 jne	 SHORT $LN11@overflow

; 430  :                     return _Meta; // converted whole element
; 431  :                 }
; 432  : 
; 433  :                 return _Traits::eof(); // conversion failed
; 434  :             }
; 435  : 
; 436  :         case codecvt_base::noconv:
; 437  :             // no conversion, put as is
; 438  :             return _Fputc(_Ch, _Myfile) ? _Meta : _Traits::eof();

  000fc	ff 76 4c	 push	 DWORD PTR [esi+76]
  000ff	ff 75 d8	 push	 DWORD PTR __Ch$[ebp]
  00102	e8 00 00 00 00	 call	 ??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z ; std::_Fputc<char>
  00107	83 c4 08	 add	 esp, 8
  0010a	83 c9 ff	 or	 ecx, -1
  0010d	84 c0		 test	 al, al
  0010f	0f 44 d9	 cmove	 ebx, ecx
  00112	5f		 pop	 edi
  00113	5e		 pop	 esi
  00114	8b c3		 mov	 eax, ebx

; 439  : 
; 440  :         default:
; 441  :             return _Traits::eof(); // conversion failed
; 442  :         }
; 443  :     }

  00116	5b		 pop	 ebx
  00117	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011a	33 cd		 xor	 ecx, ebp
  0011c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c2 04 00	 ret	 4
$LN8@overflow:

; 420  :         case codecvt_base::partial:
; 421  :         case codecvt_base::ok:
; 422  :             { // converted something, try to put it out
; 423  :                 const auto _Count = static_cast<size_t>(_Dest - _Str);

  00127	8b 7d d4	 mov	 edi, DWORD PTR __Dest$[ebp]
  0012a	8d 45 dc	 lea	 eax, DWORD PTR __Str$[ebp]
  0012d	2b f8		 sub	 edi, eax

; 424  :                 if (0 < _Count && _Count != static_cast<size_t>(_CSTD fwrite(_Str, 1, _Count, _Myfile))) {

  0012f	74 16		 je	 SHORT $LN10@overflow
  00131	0f ae e8	 lfence
  00134	ff 76 4c	 push	 DWORD PTR [esi+76]
  00137	57		 push	 edi
  00138	6a 01		 push	 1
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 _fwrite
  00140	83 c4 10	 add	 esp, 16			; 00000010H
  00143	3b f8		 cmp	 edi, eax
  00145	75 23		 jne	 SHORT $LN11@overflow
$LN10@overflow:

; 425  :                     return _Traits::eof(); // write failed
; 426  :                 }
; 427  : 
; 428  :                 _Wrotesome = true; // write succeeded
; 429  :                 if (_Src != &_Ch) {

  00147	8d 4d d8	 lea	 ecx, DWORD PTR __Ch$[ebp]
  0014a	c6 46 3d 01	 mov	 BYTE PTR [esi+61], 1
  0014e	83 c8 ff	 or	 eax, -1
  00151	39 4d d0	 cmp	 DWORD PTR __Src$[ebp], ecx
  00154	5f		 pop	 edi
  00155	5e		 pop	 esi
  00156	0f 45 c3	 cmovne	 eax, ebx

; 439  : 
; 440  :         default:
; 441  :             return _Traits::eof(); // conversion failed
; 442  :         }
; 443  :     }

  00159	5b		 pop	 ebx
  0015a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015d	33 cd		 xor	 ecx, ebp
  0015f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00164	8b e5		 mov	 esp, ebp
  00166	5d		 pop	 ebp
  00167	c2 04 00	 ret	 4
$LN11@overflow:
  0016a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016d	83 c8 ff	 or	 eax, -1
  00170	5f		 pop	 edi
  00171	5e		 pop	 esi
  00172	33 cd		 xor	 ecx, ebp
  00174	5b		 pop	 ebx
  00175	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017a	8b e5		 mov	 esp, ebp
  0017c	5d		 pop	 ebp
  0017d	c2 04 00	 ret	 4
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock, COMDAT
; _this$ = ecx

; 381  :         if (_Myfile) {

  00000	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  00003	85 c0		 test	 eax, eax
  00005	74 07		 je	 SHORT $LN2@Unlock

; 382  :             _CSTD _unlock_file(_Myfile);

  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 __unlock_file
  0000d	59		 pop	 ecx
$LN2@Unlock:

; 383  :         }
; 384  :     }

  0000e	c3		 ret	 0
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Lock, COMDAT
; _this$ = ecx

; 375  :         if (_Myfile) {

  00000	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  00003	85 c0		 test	 eax, eax
  00005	74 07		 je	 SHORT $LN2@Lock

; 376  :             _CSTD _lock_file(_Myfile);

  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 __lock_file
  0000d	59		 pop	 ecx
$LN2@Lock:

; 377  :         }
; 378  :     }

  0000e	c3		 ret	 0
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ
_TEXT	SEGMENT
__Ans$1$ = -12						; size = 4
tv327 = -12						; size = 4
$T1 = -8						; size = 4
$T2 = -4						; size = 4
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::close, COMDAT
; _this$ = ecx

; 353  :     basic_filebuf* close() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx

; 354  :         basic_filebuf* _Ans;
; 355  :         if (_Myfile) { // put any homing sequence and close file

  0000b	83 7f 4c 00	 cmp	 DWORD PTR [edi+76], 0
  0000f	8d 47 0c	 lea	 eax, DWORD PTR [edi+12]
  00012	8d 77 2c	 lea	 esi, DWORD PTR [edi+44]
  00015	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
  00018	89 75 f8	 mov	 DWORD PTR $T1[ebp], esi
  0001b	74 4f		 je	 SHORT $LN2@close
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 180  :         return *_IGfirst;

  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 760  :         if (_Mysb::eback() == &_Mychar) {

  0001f	8d 47 3c	 lea	 eax, DWORD PTR [edi+60]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 180  :         return *_IGfirst;

  00022	89 4d f4	 mov	 DWORD PTR tv327[ebp], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 760  :         if (_Mysb::eback() == &_Mychar) {

  00025	39 01		 cmp	 DWORD PTR [ecx], eax
  00027	75 18		 jne	 SHORT $LN33@close
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 207  :         *_IGfirst = _First;

  00029	8b 45 f4	 mov	 eax, DWORD PTR tv327[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 761  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  0002c	8b 57 54	 mov	 edx, DWORD PTR [edi+84]
  0002f	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

  00032	2b d1		 sub	 edx, ecx
  00034	89 08		 mov	 DWORD PTR [eax], ecx
  00036	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00039	89 08		 mov	 DWORD PTR [eax], ecx
  0003b	8b 06		 mov	 eax, DWORD PTR [esi]
  0003d	89 10		 mov	 DWORD PTR [eax], edx
  0003f	eb 03		 jmp	 SHORT $LN15@close
$LN33@close:
  00041	89 75 f8	 mov	 DWORD PTR $T1[ebp], esi
$LN15@close:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 359  :             if (!_Endwrite()) {

  00044	8b cf		 mov	 ecx, edi
  00046	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite

; 360  :                 _Ans = nullptr;
; 361  :             }
; 362  : 
; 363  :             if (_CSTD fclose(_Myfile) != 0) {

  0004b	ff 77 4c	 push	 DWORD PTR [edi+76]
  0004e	33 f6		 xor	 esi, esi
  00050	84 c0		 test	 al, al
  00052	0f 45 f7	 cmovne	 esi, edi
  00055	e8 00 00 00 00	 call	 _fclose

; 364  :                 _Ans = nullptr;
; 365  :             }
; 366  :         } else {

  0005a	33 c9		 xor	 ecx, ecx
  0005c	83 c4 04	 add	 esp, 4
  0005f	85 c0		 test	 eax, eax
  00061	0f 44 ce	 cmove	 ecx, esi
  00064	8b 75 f8	 mov	 esi, DWORD PTR $T1[ebp]
  00067	89 4d f4	 mov	 DWORD PTR __Ans$1$[ebp], ecx
  0006a	eb 0a		 jmp	 SHORT $LN3@close
$LN2@close:

; 367  :             _Ans = nullptr;

  0006c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Ans$1$[ebp], 0
  00073	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
$LN3@close:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 265  :         _IGfirst = &_Gfirst;

  00076	8b 4d fc	 mov	 ecx, DWORD PTR $T2[ebp]
  00079	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 683  :         _Closef    = _Which == _Openfl;

  0007c	c6 47 48 00	 mov	 BYTE PTR [edi+72], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 266  :         _IPfirst = &_Pfirst;

  00080	8d 57 08	 lea	 edx, DWORD PTR [edi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 684  :         _Wrotesome = false;

  00083	c6 47 3d 00	 mov	 BYTE PTR [edi+61], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 266  :         _IPfirst = &_Pfirst;

  00087	89 57 10	 mov	 DWORD PTR [edi+16], edx
  0008a	89 01		 mov	 DWORD PTR [ecx], eax

; 267  :         _IGnext  = &_Gnext;

  0008c	8d 47 14	 lea	 eax, DWORD PTR [edi+20]
  0008f	89 47 1c	 mov	 DWORD PTR [edi+28], eax

; 268  :         _IPnext  = &_Pnext;

  00092	8d 4f 18	 lea	 ecx, DWORD PTR [edi+24]
  00095	89 4f 20	 mov	 DWORD PTR [edi+32], ecx

; 269  :         _IGcount = &_Gcount;

  00098	8d 47 24	 lea	 eax, DWORD PTR [edi+36]
  0009b	89 06		 mov	 DWORD PTR [esi], eax

; 270  :         _IPcount = &_Pcount;

  0009d	8d 47 28	 lea	 eax, DWORD PTR [edi+40]
  000a0	89 47 30	 mov	 DWORD PTR [edi+48], eax

; 243  :         *_IPfirst = _First;

  000a3	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 244  :         *_IPnext  = _First;

  000a9	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 245  :         *_IPcount = static_cast<int>(_Last - _First);

  000af	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 207  :         *_IGfirst = _First;

  000b5	8b 45 fc	 mov	 eax, DWORD PTR $T2[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 208  :         *_IGnext  = _Next;

  000c0	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 371  :         return _Ans;

  000c3	8b 45 f4	 mov	 eax, DWORD PTR __Ans$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 208  :         *_IGnext  = _Next;

  000c6	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

  000cc	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000ce	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 700  :         _Myfile = _File;

  000d4	c7 47 4c 00 00
	00 00		 mov	 DWORD PTR [edi+76], 0

; 701  :         _State  = _Stinit;

  000db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
  000e1	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  000e7	89 4f 40	 mov	 DWORD PTR [edi+64], ecx
  000ea	89 57 44	 mov	 DWORD PTR [edi+68], edx

; 702  :         _Pcvt   = nullptr; // pointer to codecvt facet

  000ed	c7 47 38 00 00
	00 00		 mov	 DWORD PTR [edi+56], 0

; 371  :         return _Ans;

  000f4	5f		 pop	 edi
  000f5	5e		 pop	 esi
  000f6	5b		 pop	 ebx

; 372  :     }

  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::close
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
_TEXT	SEGMENT
$T2 = -20						; size = 8
__$EHRec$ = -12						; size = 12
__Filename$ = 8						; size = 4
__Mode$ = 12						; size = 4
__Prot$ = 16						; size = 4
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::open, COMDAT
; _this$ = ecx

; 280  :     basic_filebuf* open(const char* _Filename, ios_base::openmode _Mode, int _Prot = ios_base::_Default_open_prot) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f1		 mov	 esi, ecx

; 281  :         // _Prot is an extension
; 282  :         if (_Myfile) {

  00029	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  0002d	75 76		 jne	 SHORT $LN20@open

; 283  :             return nullptr;
; 284  :         }
; 285  : 
; 286  :         const auto _File = _Fiopen(_Filename, _Mode, _Prot);

  0002f	ff 75 10	 push	 DWORD PTR __Prot$[ebp]
  00032	ff 75 0c	 push	 DWORD PTR __Mode$[ebp]
  00035	ff 75 08	 push	 DWORD PTR __Filename$[ebp]
  00038	e8 00 00 00 00	 call	 ?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z ; std::_Fiopen
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 287  :         if (!_File) {

  00040	85 c0		 test	 eax, eax
  00042	74 61		 je	 SHORT $LN20@open

; 289  :         }
; 290  : 
; 291  :         _Init(_File, _Openfl);

  00044	6a 01		 push	 1
  00046	50		 push	 eax
  00047	8b ce		 mov	 ecx, esi
  00049	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 112  :         return *_Plocale;

  0004e	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  00051	8b 78 04	 mov	 edi, DWORD PTR [eax+4]

; 269  :         _Ptr->_Incref();

  00054	8b cf		 mov	 ecx, edi
  00056	89 7d f0	 mov	 DWORD PTR $T2[ebp+4], edi
  00059	8b 07		 mov	 eax, DWORD PTR [edi]
  0005b	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 292  :         _Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

  0005e	8d 45 ec	 lea	 eax, DWORD PTR $T2[ebp]
  00061	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
  0006e	83 c4 04	 add	 esp, 4
  00071	8b ce		 mov	 ecx, esi
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXABV?$codecvt@DDU_Mbstatet@@@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
  00079	85 ff		 test	 edi, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  0007b	74 13		 je	 SHORT $LN17@open

; 355  :             delete _Ptr->_Decref();

  0007d	8b 07		 mov	 eax, DWORD PTR [edi]
  0007f	8b cf		 mov	 ecx, edi
  00081	ff 50 08	 call	 DWORD PTR [eax+8]
  00084	85 c0		 test	 eax, eax
  00086	74 08		 je	 SHORT $LN17@open
  00088	8b 10		 mov	 edx, DWORD PTR [eax]
  0008a	8b c8		 mov	 ecx, eax
  0008c	6a 01		 push	 1
  0008e	ff 12		 call	 DWORD PTR [edx]
$LN17@open:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 293  :         return this; // open succeeded

  00090	8b c6		 mov	 eax, esi

; 294  :     }

  00092	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00095	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009c	59		 pop	 ecx
  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c2 0c 00	 ret	 12			; 0000000cH
$LN20@open:

; 288  :             return nullptr; // open failed

  000a5	33 c0		 xor	 eax, eax

; 294  :     }

  000a7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000aa	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b1	59		 pop	 ecx
  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::open
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 175  :     __CLR_OR_THIS_CALL ~basic_filebuf() noexcept override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx

; 176  :         if (_Myfile) {

  00026	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  0002a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00030	74 1e		 je	 SHORT $LN14@basic_file
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 180  :         return *_IGfirst;

  00032	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 760  :         if (_Mysb::eback() == &_Mychar) {

  00035	8d 46 3c	 lea	 eax, DWORD PTR [esi+60]
  00038	39 07		 cmp	 DWORD PTR [edi], eax
  0003a	75 14		 jne	 SHORT $LN14@basic_file

; 761  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  0003c	8b 56 54	 mov	 edx, DWORD PTR [esi+84]
  0003f	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

  00042	2b d1		 sub	 edx, ecx
  00044	89 0f		 mov	 DWORD PTR [edi], ecx
  00046	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00049	89 08		 mov	 DWORD PTR [eax], ecx
  0004b	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0004e	89 10		 mov	 DWORD PTR [eax], edx
$LN14@basic_file:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 180  :         if (_Closef) {

  00050	80 7e 48 00	 cmp	 BYTE PTR [esi+72], 0
  00054	74 07		 je	 SHORT $LN3@basic_file

; 181  :             close();

  00056	8b ce		 mov	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
$LN3@basic_file:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 67   :     virtual __CLR_OR_THIS_CALL ~basic_streambuf() noexcept {

  0005d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@

; 68   :         delete _Plocale;

  00063	8b 76 34	 mov	 esi, DWORD PTR [esi+52]
  00066	85 f6		 test	 esi, esi
  00068	74 23		 je	 SHORT $LN22@basic_file
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  0006a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0006d	85 c9		 test	 ecx, ecx
  0006f	74 11		 je	 SHORT $LN28@basic_file

; 355  :             delete _Ptr->_Decref();

  00071	8b 01		 mov	 eax, DWORD PTR [ecx]
  00073	ff 50 08	 call	 DWORD PTR [eax+8]
  00076	85 c0		 test	 eax, eax
  00078	74 08		 je	 SHORT $LN28@basic_file
  0007a	8b 10		 mov	 edx, DWORD PTR [eax]
  0007c	8b c8		 mov	 ecx, eax
  0007e	6a 01		 push	 1
  00080	ff 12		 call	 DWORD PTR [edx]
$LN28@basic_file:
  00082	6a 08		 push	 8
  00084	56		 push	 esi
  00085	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0008a	83 c4 08	 add	 esp, 8
$LN22@basic_file:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 183  :     }

  0008d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00090	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00097	59		 pop	 ecx
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
  0009e	cc		 int	 3
  0009f	cc		 int	 3
  000a0	cc		 int	 3
  000a1	cc		 int	 3
  000a2	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 167  :     basic_filebuf() : _Mysb() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 383  :     _Elem* _Gfirst{}; // beginning of read buffer

  0002b	8d 5e 04	 lea	 ebx, DWORD PTR [esi+4]
  0002e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
  00034	6a 08		 push	 8
  00036	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0

; 384  :     _Elem* _Pfirst{}; // beginning of write buffer

  0003c	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 385  :     _Elem** _IGfirst{}; // pointer to beginning of read buffer

  00043	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 386  :     _Elem** _IPfirst{}; // pointer to beginning of write buffer

  0004a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 387  :     _Elem* _Gnext{}; // current position in read buffer

  00051	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 388  :     _Elem* _Pnext{}; // current position in write buffer

  00058	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0

; 389  :     _Elem** _IGnext{}; // pointer to current position in read buffer

  0005f	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 390  :     _Elem** _IPnext{}; // pointer to current position in write buffer

  00066	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0

; 391  : 
; 392  :     int _Gcount{}; // length of read buffer

  0006d	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0

; 393  :     int _Pcount{}; // length of write buffer

  00074	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0

; 394  :     int* _IGcount{}; // pointer to length of read buffer

  0007b	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0

; 395  :     int* _IPcount{}; // pointer to length of write buffer

  00082	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
  00089	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0008e	8b f8		 mov	 edi, eax
  00090	83 c4 04	 add	 esp, 4
  00093	85 ff		 test	 edi, edi
  00095	74 16		 je	 SHORT $LN6@basic_file
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 272  :     locale() noexcept : _Ptr(_Init(true)) {}

  00097	6a 01		 push	 1
  00099	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000a0	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@_N@Z ; std::locale::_Init
  000a5	83 c4 04	 add	 esp, 4
  000a8	89 47 04	 mov	 DWORD PTR [edi+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 23   :     __CLR_OR_THIS_CALL basic_streambuf() : _Plocale(new locale) {

  000ab	eb 02		 jmp	 SHORT $LN7@basic_file
$LN6@basic_file:
  000ad	33 ff		 xor	 edi, edi
$LN7@basic_file:

; 24   :         _Init();

  000af	8b ce		 mov	 ecx, esi
  000b1	89 7e 34	 mov	 DWORD PTR [esi+52], edi
  000b4	e8 00 00 00 00	 call	 ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Init

; 265  :         _IGfirst = &_Gfirst;

  000b9	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx

; 266  :         _IPfirst = &_Pfirst;

  000bc	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  000bf	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 267  :         _IGnext  = &_Gnext;

  000c2	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 167  :     basic_filebuf() : _Mysb() {

  000c5	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 268  :         _IPnext  = &_Pnext;

  000cb	8d 56 18	 lea	 edx, DWORD PTR [esi+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 683  :         _Closef    = _Which == _Openfl;

  000ce	c6 46 48 00	 mov	 BYTE PTR [esi+72], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 269  :         _IGcount = &_Gcount;

  000d2	8d 7e 24	 lea	 edi, DWORD PTR [esi+36]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 684  :         _Wrotesome = false;

  000d5	c6 46 3d 00	 mov	 BYTE PTR [esi+61], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 270  :         _IPcount = &_Pcount;

  000d9	8d 5e 28	 lea	 ebx, DWORD PTR [esi+40]
  000dc	89 4e 1c	 mov	 DWORD PTR [esi+28], ecx
  000df	89 56 20	 mov	 DWORD PTR [esi+32], edx
  000e2	89 7e 2c	 mov	 DWORD PTR [esi+44], edi
  000e5	89 5e 30	 mov	 DWORD PTR [esi+48], ebx

; 243  :         *_IPfirst = _First;

  000e8	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 244  :         *_IPnext  = _First;

  000ee	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 245  :         *_IPcount = static_cast<int>(_Last - _First);

  000f4	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0

; 207  :         *_IGfirst = _First;

  000fb	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 208  :         *_IGnext  = _Next;

  00102	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

  00108	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 700  :         _Myfile = _File;

  0010e	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0

; 701  :         _State  = _Stinit;

  00115	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
  0011a	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  00120	89 46 40	 mov	 DWORD PTR [esi+64], eax

; 168  :         _Init(nullptr, _Newfl);
; 169  :     }

  00123	8b c6		 mov	 eax, esi

; 701  :         _State  = _Stinit;

  00125	89 4e 44	 mov	 DWORD PTR [esi+68], ecx

; 702  :         _Pcvt   = nullptr; // pointer to codecvt facet

  00128	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 168  :         _Init(nullptr, _Newfl);
; 169  :     }

  0012f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00132	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00139	59		 pop	 ecx
  0013a	5f		 pop	 edi
  0013b	5e		 pop	 esi
  0013c	5b		 pop	 ebx
  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	c3		 ret	 0
  00141	cc		 int	 3
  00142	cc		 int	 3
  00143	cc		 int	 3
  00144	cc		 int	 3
  00145	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 67   :     virtual __CLR_OR_THIS_CALL ~basic_streambuf() noexcept {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 68   :         delete _Plocale;

  00007	8b 7e 34	 mov	 edi, DWORD PTR [esi+52]
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
  00010	85 ff		 test	 edi, edi
  00012	74 23		 je	 SHORT $LN11@scalar
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  00014	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00017	85 c9		 test	 ecx, ecx
  00019	74 11		 je	 SHORT $LN17@scalar

; 355  :             delete _Ptr->_Decref();

  0001b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001d	ff 50 08	 call	 DWORD PTR [eax+8]
  00020	85 c0		 test	 eax, eax
  00022	74 08		 je	 SHORT $LN17@scalar
  00024	8b 10		 mov	 edx, DWORD PTR [eax]
  00026	8b c8		 mov	 ecx, eax
  00028	6a 01		 push	 1
  0002a	ff 12		 call	 DWORD PTR [edx]
$LN17@scalar:
  0002c	6a 08		 push	 8
  0002e	57		 push	 edi
  0002f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00034	83 c4 08	 add	 esp, 8
$LN11@scalar:
  00037	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0003b	74 0b		 je	 SHORT $LN20@scalar
  0003d	6a 38		 push	 56			; 00000038H
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	83 c4 08	 add	 esp, 8
$LN20@scalar:
  00048	5f		 pop	 edi
  00049	8b c6		 mov	 eax, esi
  0004b	5e		 pop	 esi
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::imbue, COMDAT
; _this$ = ecx

; 380  :     virtual void __CLR_OR_THIS_CALL imbue(const locale&) {} // set locale to argument (do nothing)

  00000	c2 04 00	 ret	 4
?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::imbue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sync, COMDAT
; _this$ = ecx

; 377  :         return 0;

  00000	33 c0		 xor	 eax, eax

; 378  :     }

  00002	c3		 ret	 0
?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 8
?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setbuf, COMDAT
; _this$ = ecx

; 372  :         // offer buffer to external agent (do nothing)
; 373  :         return this;

  00000	8b c1		 mov	 eax, ecx

; 374  :     }

  00002	c2 0c 00	 ret	 12			; 0000000cH
?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iosfwd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 24
___formal$ = 36						; size = 4
?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::seekpos, COMDAT
; _this$ = ecx

; 366  :     virtual pos_type __CLR_OR_THIS_CALL seekpos(pos_type, ios_base::openmode = ios_base::in | ios_base::out) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iosfwd

; 52   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0000f	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1
  00016	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0001d	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  00024	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 369  :     }

  00029	5d		 pop	 ebp
  0002a	c2 20 00	 ret	 32			; 00000020H
?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iosfwd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 8
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::seekoff, COMDAT
; _this$ = ecx

; 361  :         off_type, ios_base::seekdir, ios_base::openmode = ios_base::in | ios_base::out) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iosfwd

; 52   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0000f	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1
  00016	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0001d	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  00024	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 364  :     }

  00029	5d		 pop	 ebp
  0002a	c2 14 00	 ret	 20			; 00000014H
?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
_TEXT	SEGMENT
__Start_count$2$ = -16					; size = 4
__Start_count$1$ = -12					; size = 4
tv237 = -8						; size = 4
_this$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
__Size$2$ = 16						; size = 4
?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsputn, COMDAT
; _this$ = ecx

; 335  :     virtual streamsize __CLR_OR_THIS_CALL xsputn(const _Elem* _Ptr, streamsize _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 336  :         // put _Count characters to stream
; 337  :         const streamsize _Start_count = _Count;

  00007	8b 5d 10	 mov	 ebx, DWORD PTR __Count$[ebp+4]
  0000a	8b d3		 mov	 edx, ebx
  0000c	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000f	89 55 f0	 mov	 DWORD PTR __Start_count$2$[ebp], edx
  00012	57		 push	 edi
  00013	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00016	8b c7		 mov	 eax, edi
  00018	89 45 f4	 mov	 DWORD PTR __Start_count$1$[ebp], eax

; 338  :         while (0 < _Count) {

  0001b	85 db		 test	 ebx, ebx
  0001d	0f 8c a4 00 00
	00		 jl	 $LN37@xsputn
  00023	7f 08		 jg	 SHORT $LN49@xsputn
  00025	85 ff		 test	 edi, edi
  00027	0f 84 9a 00 00
	00		 je	 $LN37@xsputn
$LN49@xsputn:
  0002d	56		 push	 esi
  0002e	66 90		 npad	 2
$LL2@xsputn:

; 261  :         return *_IPnext ? *_IPcount : 0;

  00030	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00033	8b 00		 mov	 eax, DWORD PTR [eax]
  00035	89 45 f8	 mov	 DWORD PTR tv237[ebp], eax
  00038	85 c0		 test	 eax, eax
  0003a	74 07		 je	 SHORT $LN12@xsputn
  0003c	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	eb 02		 jmp	 SHORT $LN13@xsputn
$LN12@xsputn:
  00043	33 c0		 xor	 eax, eax
$LN13@xsputn:
  00045	99		 cdq

; 339  :             streamsize _Size = _Pnavail();

  00046	8b f0		 mov	 esi, eax
  00048	8b c2		 mov	 eax, edx
  0004a	89 45 10	 mov	 DWORD PTR __Size$2$[ebp], eax

; 340  :             if (0 < _Size) { // copy to write buffer

  0004d	85 c0		 test	 eax, eax
  0004f	7c 39		 jl	 SHORT $LN4@xsputn
  00051	7f 04		 jg	 SHORT $LN35@xsputn
  00053	85 f6		 test	 esi, esi
  00055	74 33		 je	 SHORT $LN4@xsputn
$LN35@xsputn:

; 341  :                 if (_Count < _Size) {

  00057	3b d8		 cmp	 ebx, eax
  00059	7f 0b		 jg	 SHORT $LN6@xsputn
  0005b	7c 04		 jl	 SHORT $LN36@xsputn
  0005d	3b fe		 cmp	 edi, esi
  0005f	73 05		 jae	 SHORT $LN6@xsputn
$LN36@xsputn:

; 342  :                     _Size = _Count;

  00061	8b f7		 mov	 esi, edi
  00063	89 5d 10	 mov	 DWORD PTR __Size$2$[ebp], ebx
$LN6@xsputn:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00066	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00069	56		 push	 esi
  0006a	50		 push	 eax
  0006b	ff 75 f8	 push	 DWORD PTR tv237[ebp]
  0006e	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 237  :         *_IPcount -= _Off;

  00073	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 347  :                 _Count -= _Size;

  00079	2b fe		 sub	 edi, esi
  0007b	1b 5d 10	 sbb	 ebx, DWORD PTR __Size$2$[ebp]

; 237  :         *_IPcount -= _Off;

  0007e	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00081	29 30		 sub	 DWORD PTR [eax], esi

; 238  :         *_IPnext += _Off;

  00083	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00086	01 30		 add	 DWORD PTR [eax], esi

; 239  :     }

  00088	eb 21		 jmp	 SHORT $LN8@xsputn
$LN4@xsputn:

; 349  :             } else if (_Traits::eq_int_type(_Traits::eof(), overflow(_Traits::to_int_type(*_Ptr)))) {

  0008a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0008c	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0008f	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00092	0f b6 00	 movzx	 eax, BYTE PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 349  :             } else if (_Traits::eq_int_type(_Traits::eof(), overflow(_Traits::to_int_type(*_Ptr)))) {

  00095	50		 push	 eax
  00096	ff d2		 call	 edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00098	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 349  :             } else if (_Traits::eq_int_type(_Traits::eof(), overflow(_Traits::to_int_type(*_Ptr)))) {

  0009b	74 23		 je	 SHORT $LN38@xsputn

; 350  :                 break; // single character put failed, quit
; 351  :             } else { // count character successfully put
; 352  :                 ++_Ptr;
; 353  :                 --_Count;

  0009d	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000a0	83 c7 ff	 add	 edi, -1
  000a3	be 01 00 00 00	 mov	 esi, 1
  000a8	83 d3 ff	 adc	 ebx, -1
$LN8@xsputn:

; 338  :         while (0 < _Count) {

  000ab	01 75 08	 add	 DWORD PTR __Ptr$[ebp], esi
  000ae	85 db		 test	 ebx, ebx
  000b0	0f 8f 7a ff ff
	ff		 jg	 $LL2@xsputn
  000b6	7c 08		 jl	 SHORT $LN38@xsputn
  000b8	85 ff		 test	 edi, edi
  000ba	0f 85 70 ff ff
	ff		 jne	 $LL2@xsputn
$LN38@xsputn:
  000c0	8b 45 f4	 mov	 eax, DWORD PTR __Start_count$1$[ebp]
  000c3	8b 55 f0	 mov	 edx, DWORD PTR __Start_count$2$[ebp]
  000c6	5e		 pop	 esi
$LN37@xsputn:

; 354  :             }
; 355  :         }
; 356  : 
; 357  :         return _Start_count - _Count;

  000c7	2b c7		 sub	 eax, edi
  000c9	5f		 pop	 edi
  000ca	1b d3		 sbb	 edx, ebx
  000cc	5b		 pop	 ebx

; 358  :     }

  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c2 0c 00	 ret	 12			; 0000000cH
?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
_TEXT	SEGMENT
__Start_count$2$ = -16					; size = 4
__Start_count$1$ = -12					; size = 4
tv240 = -8						; size = 4
_this$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
__Size$2$ = 16						; size = 4
?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn, COMDAT
; _this$ = ecx

; 306  :     virtual streamsize __CLR_OR_THIS_CALL xsgetn(_Elem* _Ptr, streamsize _Count) { // get _Count characters from stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 307  :         const streamsize _Start_count = _Count;

  00007	8b 5d 10	 mov	 ebx, DWORD PTR __Count$[ebp+4]
  0000a	8b d3		 mov	 edx, ebx
  0000c	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000f	89 55 f0	 mov	 DWORD PTR __Start_count$2$[ebp], edx
  00012	57		 push	 edi
  00013	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00016	8b c7		 mov	 eax, edi
  00018	89 45 f4	 mov	 DWORD PTR __Start_count$1$[ebp], eax

; 308  : 
; 309  :         while (0 < _Count) {

  0001b	85 db		 test	 ebx, ebx
  0001d	0f 8c 9c 00 00
	00		 jl	 $LN36@xsgetn
  00023	7f 08		 jg	 SHORT $LN48@xsgetn
  00025	85 ff		 test	 edi, edi
  00027	0f 84 92 00 00
	00		 je	 $LN36@xsgetn
$LN48@xsgetn:
  0002d	56		 push	 esi
  0002e	66 90		 npad	 2
$LL2@xsgetn:

; 232  :         return *_IGnext ? *_IGcount : 0;

  00030	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00033	8b 00		 mov	 eax, DWORD PTR [eax]
  00035	89 45 f8	 mov	 DWORD PTR tv240[ebp], eax
  00038	85 c0		 test	 eax, eax
  0003a	74 07		 je	 SHORT $LN11@xsgetn
  0003c	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	eb 02		 jmp	 SHORT $LN12@xsgetn
$LN11@xsgetn:
  00043	33 c0		 xor	 eax, eax
$LN12@xsgetn:
  00045	99		 cdq

; 310  :             streamsize _Size = _Gnavail();

  00046	8b f0		 mov	 esi, eax
  00048	8b c2		 mov	 eax, edx
  0004a	89 45 10	 mov	 DWORD PTR __Size$2$[ebp], eax

; 311  :             if (0 < _Size) { // copy from read buffer

  0004d	85 c0		 test	 eax, eax
  0004f	7c 39		 jl	 SHORT $LN4@xsgetn
  00051	7f 04		 jg	 SHORT $LN34@xsgetn
  00053	85 f6		 test	 esi, esi
  00055	74 33		 je	 SHORT $LN4@xsgetn
$LN34@xsgetn:

; 312  :                 if (_Count < _Size) {

  00057	3b d8		 cmp	 ebx, eax
  00059	7f 0b		 jg	 SHORT $LN6@xsgetn
  0005b	7c 04		 jl	 SHORT $LN35@xsgetn
  0005d	3b fe		 cmp	 edi, esi
  0005f	73 05		 jae	 SHORT $LN6@xsgetn
$LN35@xsgetn:

; 313  :                     _Size = _Count;

  00061	8b f7		 mov	 esi, edi
  00063	89 5d 10	 mov	 DWORD PTR __Size$2$[ebp], ebx
$LN6@xsgetn:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00066	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00069	56		 push	 esi
  0006a	ff 75 f8	 push	 DWORD PTR tv240[ebp]
  0006d	51		 push	 ecx
  0006e	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 201  :         *_IGcount -= _Off;

  00073	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 318  :                 _Count -= _Size;

  00079	2b fe		 sub	 edi, esi
  0007b	1b 5d 10	 sbb	 ebx, DWORD PTR __Size$2$[ebp]

; 201  :         *_IGcount -= _Off;

  0007e	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00081	29 30		 sub	 DWORD PTR [eax], esi

; 202  :         *_IGnext += _Off;

  00083	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00086	01 30		 add	 DWORD PTR [eax], esi

; 319  :                 gbump(static_cast<int>(_Size));
; 320  :             } else {

  00088	eb 1d		 jmp	 SHORT $LN5@xsgetn
$LN4@xsgetn:

; 321  :                 const int_type _Meta = uflow();

  0008a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0008c	ff 50 1c	 call	 DWORD PTR [eax+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  0008f	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 322  :                 if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {

  00092	74 24		 je	 SHORT $LN37@xsgetn

; 323  :                     break; // end of file, quit
; 324  :                 }
; 325  : 
; 326  :                 // get a single character
; 327  :                 *_Ptr++ = _Traits::to_char_type(_Meta);

  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 328  :                 --_Count;

  00097	83 c7 ff	 add	 edi, -1
  0009a	be 01 00 00 00	 mov	 esi, 1
  0009f	83 d3 ff	 adc	 ebx, -1
  000a2	88 01		 mov	 BYTE PTR [ecx], al
  000a4	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN5@xsgetn:

; 308  : 
; 309  :         while (0 < _Count) {

  000a7	01 75 08	 add	 DWORD PTR __Ptr$[ebp], esi
  000aa	85 db		 test	 ebx, ebx
  000ac	7f 82		 jg	 SHORT $LL2@xsgetn
  000ae	7c 08		 jl	 SHORT $LN37@xsgetn
  000b0	85 ff		 test	 edi, edi
  000b2	0f 85 78 ff ff
	ff		 jne	 $LL2@xsgetn
$LN37@xsgetn:
  000b8	8b 45 f4	 mov	 eax, DWORD PTR __Start_count$1$[ebp]
  000bb	8b 55 f0	 mov	 edx, DWORD PTR __Start_count$2$[ebp]
  000be	5e		 pop	 esi
$LN36@xsgetn:

; 329  :             }
; 330  :         }
; 331  : 
; 332  :         return _Start_count - _Count;

  000bf	2b c7		 sub	 eax, edi
  000c1	5f		 pop	 edi
  000c2	1b d3		 sbb	 edx, ebx
  000c4	5b		 pop	 ebx

; 333  :     }

  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c2 0c 00	 ret	 12			; 0000000cH
?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::uflow, COMDAT
; _this$ = ecx

; 302  :     virtual int_type __CLR_OR_THIS_CALL uflow() { // get a character from stream, point past it

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 303  :         return _Traits::eq_int_type(_Traits::eof(), underflow()) ? _Traits::eof() : _Traits::to_int_type(*_Gninc());

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 50 18	 call	 DWORD PTR [eax+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00008	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 303  :         return _Traits::eq_int_type(_Traits::eof(), underflow()) ? _Traits::eof() : _Traits::to_int_type(*_Gninc());

  0000b	75 04		 jne	 SHORT $LN3@uflow
  0000d	0b c0		 or	 eax, eax
  0000f	5e		 pop	 esi

; 304  :     }

  00010	c3		 ret	 0
$LN3@uflow:

; 222  :         --*_IGcount;

  00011	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00014	ff 08		 dec	 DWORD PTR [eax]

; 223  :         return (*_IGnext)++;

  00016	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00019	5e		 pop	 esi
  0001a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001c	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0001f	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00021	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 304  :     }

  00024	c3		 ret	 0
?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::uflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::underflow, COMDAT
; _this$ = ecx

; 299  :         return _Traits::eof();

  00000	83 c8 ff	 or	 eax, -1

; 300  :     }

  00003	c3		 ret	 0
?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
_TEXT	SEGMENT
?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc, COMDAT
; _this$ = ecx

; 295  :         return 0;

  00000	33 c0		 xor	 eax, eax
  00002	33 d2		 xor	 edx, edx

; 296  :     }

  00004	c3		 ret	 0
?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail, COMDAT
; _this$ = ecx

; 290  :         // put a character back to stream (always fail)
; 291  :         return _Traits::eof();

  00000	83 c8 ff	 or	 eax, -1

; 292  :     }

  00003	c2 04 00	 ret	 4
?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::overflow, COMDAT
; _this$ = ecx

; 286  :         return _Traits::eof();

  00000	83 c8 ff	 or	 eax, -1

; 287  :     }

  00003	c2 04 00	 ret	 4
?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Init, COMDAT
; _this$ = ecx

; 264  :     void __CLR_OR_THIS_CALL _Init() noexcept { // initialize buffer parameters for no buffers

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx
  00003	56		 push	 esi
  00004	57		 push	 edi

; 265  :         _IGfirst = &_Gfirst;
; 266  :         _IPfirst = &_Pfirst;

  00005	8d 73 08	 lea	 esi, DWORD PTR [ebx+8]
  00008	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  0000b	89 73 10	 mov	 DWORD PTR [ebx+16], esi
  0000e	89 43 0c	 mov	 DWORD PTR [ebx+12], eax

; 267  :         _IGnext  = &_Gnext;

  00011	8d 7b 14	 lea	 edi, DWORD PTR [ebx+20]
  00014	89 7b 1c	 mov	 DWORD PTR [ebx+28], edi

; 268  :         _IPnext  = &_Pnext;

  00017	8d 53 18	 lea	 edx, DWORD PTR [ebx+24]
  0001a	89 53 20	 mov	 DWORD PTR [ebx+32], edx

; 269  :         _IGcount = &_Gcount;

  0001d	8d 4b 24	 lea	 ecx, DWORD PTR [ebx+36]
  00020	89 4b 2c	 mov	 DWORD PTR [ebx+44], ecx

; 270  :         _IPcount = &_Pcount;

  00023	8d 43 28	 lea	 eax, DWORD PTR [ebx+40]
  00026	89 43 30	 mov	 DWORD PTR [ebx+48], eax

; 243  :         *_IPfirst = _First;

  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 244  :         *_IPnext  = _First;

  0002f	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 245  :         *_IPcount = static_cast<int>(_Last - _First);

  00035	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 207  :         *_IGfirst = _First;

  0003b	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 208  :         *_IGnext  = _Next;

  00042	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00050	5b		 pop	 ebx

; 271  :         setp(nullptr, nullptr);
; 272  :         setg(nullptr, nullptr, nullptr);
; 273  :     }

  00051	c3		 ret	 0
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock, COMDAT
; _this$ = ecx

; 176  :     virtual void __CLR_OR_THIS_CALL _Unlock() {} // clear the thread lock (overridden by basic_filebuf)

  00000	c2 00 00	 ret	 0
?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Lock, COMDAT
; _this$ = ecx

; 174  :     virtual void __CLR_OR_THIS_CALL _Lock() {} // set the thread lock (overridden by basic_filebuf)

  00000	c2 00 00	 ret	 0
?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
;	COMDAT ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 67   :     virtual __CLR_OR_THIS_CALL ~basic_streambuf() noexcept {

  00000	56		 push	 esi

; 68   :         delete _Plocale;

  00001	8b 71 34	 mov	 esi, DWORD PTR [ecx+52]
  00004	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
  0000a	85 f6		 test	 esi, esi
  0000c	74 23		 je	 SHORT $LN7@basic_stre
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  0000e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00011	85 c9		 test	 ecx, ecx
  00013	74 11		 je	 SHORT $LN13@basic_stre

; 355  :             delete _Ptr->_Decref();

  00015	8b 01		 mov	 eax, DWORD PTR [ecx]
  00017	ff 50 08	 call	 DWORD PTR [eax+8]
  0001a	85 c0		 test	 eax, eax
  0001c	74 08		 je	 SHORT $LN13@basic_stre
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	8b c8		 mov	 ecx, eax
  00022	6a 01		 push	 1
  00024	ff 12		 call	 DWORD PTR [edx]
$LN13@basic_stre:
  00026	6a 08		 push	 8
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002e	83 c4 08	 add	 esp, 8
$LN7@basic_stre:
  00031	5e		 pop	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 69   :     }

  00032	c3		 ret	 0
??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream
;	COMDAT ??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 283  :     __CLR_OR_THIS_CALL ~basic_ofstream() noexcept override {}

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 46 98	 mov	 eax, DWORD PTR [esi-104]
  00006	8d 4e 9c	 lea	 ecx, DWORD PTR [esi-100]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	c7 44 30 98 00
	00 00 00	 mov	 DWORD PTR [eax+esi-104], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  00014	8b 46 98	 mov	 eax, DWORD PTR [esi-104]
  00017	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001a	8d 42 98	 lea	 eax, DWORD PTR [edx-104]
  0001d	89 44 32 94	 mov	 DWORD PTR [edx+esi-108], eax
  00021	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 61   :     __CLR_OR_THIS_CALL ~basic_ostream() noexcept override {}

  00026	8b 46 98	 mov	 eax, DWORD PTR [esi-104]
  00029	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002c	c7 44 30 98 00
	00 00 00	 mov	 DWORD PTR [eax+esi-104], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  00034	8b 46 98	 mov	 eax, DWORD PTR [esi-104]
  00037	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003a	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  0003d	89 44 31 94	 mov	 DWORD PTR [ecx+esi-108], eax
  00041	5e		 pop	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream

; 283  :     __CLR_OR_THIS_CALL ~basic_ofstream() noexcept override {}

  00042	c3		 ret	 0
??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
;	COMDAT ?RetrieveAndWriteErrorLog@@YAXXZ
_TEXT	SEGMENT
_logFile$2 = -480					; size = 176
$T3 = -304						; size = 20
$T4 = -284						; size = 8
$T5 = -276						; size = 4
_errorLog$ = -272					; size = 256
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?RetrieveAndWriteErrorLog@@YAXXZ PROC			; RetrieveAndWriteErrorLog, COMDAT

; 439  : void RetrieveAndWriteErrorLog() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RetrieveAndWriteErrorLog@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d4 01 00
	00		 sub	 esp, 468		; 000001d4H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 440  :     char errorLog[256] = {0};

  0002c	68 00 01 00 00	 push	 256			; 00000100H
  00031	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _errorLog$[ebp]
  00037	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp], 0
  00041	6a 00		 push	 0
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 _memset

; 441  :     if (SendIoctl(IOCTL_GET_LAST_ERROR_LOG, nullptr, 0, errorLog, sizeof(errorLog))) {

  00049	68 00 01 00 00	 push	 256			; 00000100H
  0004e	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _errorLog$[ebp]
  00054	50		 push	 eax
  00055	6a 00		 push	 0
  00057	6a 00		 push	 0
  00059	68 0c 60 22 00	 push	 2252812			; 0022600cH
  0005e	e8 00 00 00 00	 call	 ?SendIoctl@@YA_NKPAXK0K@Z ; SendIoctl
  00063	83 c4 20	 add	 esp, 32			; 00000020H
  00066	84 c0		 test	 al, al
  00068	0f 84 8f 01 00
	00		 je	 $LN3@RetrieveAn

; 442  :         if (strlen(errorLog) > 0) {

  0006e	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _errorLog$[ebp]
  00074	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL53@RetrieveAn:
  00077	8a 01		 mov	 al, BYTE PTR [ecx]
  00079	41		 inc	 ecx
  0007a	84 c0		 test	 al, al
  0007c	75 f9		 jne	 SHORT $LL53@RetrieveAn
  0007e	2b ca		 sub	 ecx, edx
  00080	0f 84 77 01 00
	00		 je	 $LN3@RetrieveAn
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream

; 187  :         : _Mybase(_STD addressof(_Filebuffer)) { // _Prot is an extension

  00086	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR _logFile$2[ebp+104]
  0008c	c7 85 20 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _logFile$2[ebp], OFFSET ??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@
  00096	e8 00 00 00 00	 call	 ??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 30   :     explicit __CLR_OR_THIS_CALL basic_ostream(basic_streambuf<_Elem, _Traits>* _Strbuf, bool _Isstd = false) {

  0009b	8b 85 20 fe ff
	ff		 mov	 eax, DWORD PTR _logFile$2[ebp]

; 31   :         _Myios::init(_Strbuf, _Isstd);

  000a1	6a 00		 push	 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream

; 187  :         : _Mybase(_STD addressof(_Filebuffer)) { // _Prot is an extension

  000a3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000aa	c7 85 ec fe ff
	ff 01 00 00 00	 mov	 DWORD PTR $T5[ebp], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 30   :     explicit __CLR_OR_THIS_CALL basic_ostream(basic_streambuf<_Elem, _Traits>* _Strbuf, bool _Isstd = false) {

  000b4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b7	c7 84 05 20 fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _logFile$2[ebp+eax], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  000c2	8b 85 20 fe ff
	ff		 mov	 eax, DWORD PTR _logFile$2[ebp]
  000c8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000cb	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  000ce	89 84 0d 1c fe
	ff ff		 mov	 DWORD PTR _logFile$2[ebp+ecx-4], eax

; 31   :         _Myios::init(_Strbuf, _Isstd);

  000d5	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _logFile$2[ebp]
  000db	8b 85 20 fe ff
	ff		 mov	 eax, DWORD PTR _logFile$2[ebp]
  000e1	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  000e4	8d 85 24 fe ff
	ff		 lea	 eax, DWORD PTR _logFile$2[ebp+4]
  000ea	50		 push	 eax
  000eb	e8 00 00 00 00	 call	 ?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ; std::basic_ios<char,std::char_traits<char> >::init
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream

; 187  :         : _Mybase(_STD addressof(_Filebuffer)) { // _Prot is an extension

  000f0	8b 85 20 fe ff
	ff		 mov	 eax, DWORD PTR _logFile$2[ebp]
  000f6	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  000fd	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00100	c7 84 05 20 fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _logFile$2[ebp+eax], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  0010b	8b 85 20 fe ff
	ff		 mov	 eax, DWORD PTR _logFile$2[ebp]
  00111	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00114	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  00117	89 84 0d 1c fe
	ff ff		 mov	 DWORD PTR _logFile$2[ebp+ecx-4], eax
  0011e	8d 8d 24 fe ff
	ff		 lea	 ecx, DWORD PTR _logFile$2[ebp+4]
  00124	e8 00 00 00 00	 call	 ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >

; 188  :         if (!_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot)) {

  00129	6a 40		 push	 64			; 00000040H
  0012b	6a 12		 push	 18			; 00000012H
  0012d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@BHIHAFGJ@errorlog?4txt@
  00132	8d 8d 24 fe ff
	ff		 lea	 ecx, DWORD PTR _logFile$2[ebp+4]
  00138	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0013c	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  00141	85 c0		 test	 eax, eax
  00143	75 3c		 jne	 SHORT $LN24@RetrieveAn

; 189  :             _Myios::setstate(ios_base::failbit);

  00145	8b 85 20 fe ff
	ff		 mov	 eax, DWORD PTR _logFile$2[ebp]
  0014b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 155  :         _State &= _Statmask;

  0014e	33 c0		 xor	 eax, eax
  00150	39 84 0d 58 fe
	ff ff		 cmp	 DWORD PTR _logFile$2[ebp+ecx+56], eax
  00157	0f 94 c0	 sete	 al
  0015a	8d 04 85 02 00
	00 00		 lea	 eax, DWORD PTR [eax*4+2]
  00161	0b 84 0d 2c fe
	ff ff		 or	 eax, DWORD PTR _logFile$2[ebp+ecx+12]
  00168	83 e0 17	 and	 eax, 23			; 00000017H

; 156  :         _Mystate             = _State;

  0016b	89 84 0d 2c fe
	ff ff		 mov	 DWORD PTR _logFile$2[ebp+ecx+12], eax

; 157  :         const auto _Filtered = _State & _Except;

  00172	8b 8c 0d 30 fe
	ff ff		 mov	 ecx, DWORD PTR _logFile$2[ebp+ecx+16]
  00179	23 c8		 and	 ecx, eax

; 158  :         if (_Filtered) {

  0017b	0f 85 96 00 00
	00		 jne	 $LN57@RetrieveAn
$LN24@RetrieveAn:
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 444  :             logFile << errorLog;

  00181	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _errorLog$[ebp]
  00187	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
  0018e	50		 push	 eax
  0018f	8d 85 20 fe ff
	ff		 lea	 eax, DWORD PTR _logFile$2[ebp]
  00195	50		 push	 eax
  00196	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0019b	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream

; 315  :         if (!_Filebuffer.close()) {

  0019e	8d 8d 24 fe ff
	ff		 lea	 ecx, DWORD PTR _logFile$2[ebp+4]
  001a4	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  001a9	85 c0		 test	 eax, eax
  001ab	75 45		 jne	 SHORT $LN43@RetrieveAn

; 316  :             _Myios::setstate(ios_base::failbit);

  001ad	8b 85 20 fe ff
	ff		 mov	 eax, DWORD PTR _logFile$2[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  001b3	33 d2		 xor	 edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\fstream

; 316  :             _Myios::setstate(ios_base::failbit);

  001b5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  001b8	b8 04 00 00 00	 mov	 eax, 4
  001bd	39 94 0d 58 fe
	ff ff		 cmp	 DWORD PTR _logFile$2[ebp+ecx+56], edx
  001c4	0f 45 c2	 cmovne	 eax, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 155  :         _State &= _Statmask;

  001c7	0b 84 0d 2c fe
	ff ff		 or	 eax, DWORD PTR _logFile$2[ebp+ecx+12]
  001ce	83 e0 15	 and	 eax, 21			; 00000015H
  001d1	83 c8 02	 or	 eax, 2

; 156  :         _Mystate             = _State;

  001d4	89 84 0d 2c fe
	ff ff		 mov	 DWORD PTR _logFile$2[ebp+ecx+12], eax

; 157  :         const auto _Filtered = _State & _Except;

  001db	8b 8c 0d 30 fe
	ff ff		 mov	 ecx, DWORD PTR _logFile$2[ebp+ecx+16]
  001e2	23 c8		 and	 ecx, eax

; 158  :         if (_Filtered) {

  001e4	74 0c		 je	 SHORT $LN43@RetrieveAn

; 164  :             if (_Filtered & ios_base::badbit) {

  001e6	f6 c1 04	 test	 cl, 4
  001e9	74 38		 je	 SHORT $LN26@RetrieveAn

; 165  :                 _Msg = "ios_base::badbit set";

  001eb	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  001f0	eb 41		 jmp	 SHORT $LN28@RetrieveAn
$LN43@RetrieveAn:
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 446  :         }

  001f2	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _logFile$2[ebp]
  001f8	e8 00 00 00 00	 call	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN3@RetrieveAn:

; 448  : }

  001fd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00200	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00207	59		 pop	 ecx
  00208	5e		 pop	 esi
  00209	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0020c	33 cd		 xor	 ecx, ebp
  0020e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00213	8b e5		 mov	 esp, ebp
  00215	5d		 pop	 ebp
  00216	c3		 ret	 0
$LN57@RetrieveAn:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 164  :             if (_Filtered & ios_base::badbit) {

  00217	f6 c1 04	 test	 cl, 4
  0021a	74 07		 je	 SHORT $LN26@RetrieveAn

; 165  :                 _Msg = "ios_base::badbit set";

  0021c	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  00221	eb 10		 jmp	 SHORT $LN28@RetrieveAn
$LN26@RetrieveAn:
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 448  : }

  00223	f6 c1 02	 test	 cl, 2
  00226	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
  0022b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
  00230	0f 44 f0	 cmove	 esi, eax
$LN28@RetrieveAn:
  00233	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  00239	6a 01		 push	 1
  0023b	50		 push	 eax
  0023c	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  00241	83 c4 08	 add	 esp, 8
  00244	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0024a	50		 push	 eax
  0024b	56		 push	 esi
  0024c	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  00251	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00256	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0025c	50		 push	 eax
  0025d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN55@RetrieveAn:
  00262	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RetrieveAndWriteErrorLog@@YAXXZ$1:
  00000	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR $T5[ebp]
  00006	83 e0 01	 and	 eax, 1
  00009	0f 84 12 00 00
	00		 je	 $LN11@RetrieveAn
  0000f	83 a5 ec fe ff
	ff fe		 and	 DWORD PTR $T5[ebp], -2	; fffffffeH
  00016	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR _logFile$2[ebp+104]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN11@RetrieveAn:
  00021	c3		 ret	 0
__unwindfunclet$?RetrieveAndWriteErrorLog@@YAXXZ$2:
  00022	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR _logFile$2[ebp+8]
  00028	e9 00 00 00 00	 jmp	 ??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >
__unwindfunclet$?RetrieveAndWriteErrorLog@@YAXXZ$3:
  0002d	8d 8d 24 fe ff
	ff		 lea	 ecx, DWORD PTR _logFile$2[ebp+4]
  00033	e9 00 00 00 00	 jmp	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
__unwindfunclet$?RetrieveAndWriteErrorLog@@YAXXZ$0:
  00038	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _logFile$2[ebp]
  0003e	e9 00 00 00 00	 jmp	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
  00043	cc		 int	 3
  00044	cc		 int	 3
  00045	cc		 int	 3
  00046	cc		 int	 3
  00047	cc		 int	 3
__ehhandler$?RetrieveAndWriteErrorLog@@YAXXZ:
  00048	90		 npad	 1
  00049	90		 npad	 1
  0004a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0004e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00051	8b 8a 24 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-476]
  00057	33 c8		 xor	 ecx, eax
  00059	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005e	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00061	33 c8		 xor	 ecx, eax
  00063	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00068	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RetrieveAndWriteErrorLog@@YAXXZ
  0006d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RetrieveAndWriteErrorLog@@YAXXZ ENDP			; RetrieveAndWriteErrorLog
; Function compile flags: /Ogtp
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
;	COMDAT ?EnsureTestSigningAndDisableSecureBoot@@YA_NXZ
_TEXT	SEGMENT
_optionsSize$1 = -560					; size = 4
tv554 = -556						; size = 4
_valueSize$ = -552					; size = 4
_value$ = -548						; size = 4
_hKey$ = -544						; size = 4
_opts$2 = -540						; size = 24
_options$3 = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
?EnsureTestSigningAndDisableSecureBoot@@YA_NXZ PROC	; EnsureTestSigningAndDisableSecureBoot, COMDAT

; 381  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 30 02 00
	00		 sub	 esp, 560		; 00000230H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi

; 382  :     // Check Secure Boot status
; 383  :     bool secureBootEnabled = false;
; 384  :     HKEY hKey;
; 385  :     DWORD value = 0, valueSize = sizeof(DWORD);
; 386  :     LONG status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,

  00015	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__RegOpenKeyExW@20
  0001b	8d 85 e0 fd ff
	ff		 lea	 eax, DWORD PTR _hKey$[ebp]
  00021	57		 push	 edi
  00022	50		 push	 eax
  00023	6a 01		 push	 1
  00025	6a 00		 push	 0
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_1GE@KLOHNIPO@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAC@
  0002c	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00031	32 ff		 xor	 bh, bh
  00033	c7 85 dc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _value$[ebp], 0
  0003d	c7 85 d8 fd ff
	ff 04 00 00 00	 mov	 DWORD PTR _valueSize$[ebp], 4
  00047	ff d6		 call	 esi

; 387  :         L"SYSTEM\\CurrentControlSet\\Control\\SecureBoot\\State",
; 388  :         0, KEY_QUERY_VALUE, &hKey);
; 389  :     if (status == ERROR_SUCCESS) {

  00049	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__RegQueryValueExW@24
  0004f	85 c0		 test	 eax, eax
  00051	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__RegCloseKey@4
  00056	89 85 d4 fd ff
	ff		 mov	 DWORD PTR tv554[ebp], eax
  0005c	75 38		 jne	 SHORT $LN2@EnsureTest

; 390  :         if (RegQueryValueExW(hKey, L"UEFISecureBootEnabled", nullptr, nullptr, (LPBYTE)&value, &valueSize) == ERROR_SUCCESS) {

  0005e	8d 85 d8 fd ff
	ff		 lea	 eax, DWORD PTR _valueSize$[ebp]
  00064	50		 push	 eax
  00065	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _value$[ebp]
  0006b	50		 push	 eax
  0006c	6a 00		 push	 0
  0006e	6a 00		 push	 0
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_1CM@DKFPDMAB@?$AAU?$AAE?$AAF?$AAI?$AAS?$AAe?$AAc?$AAu?$AAr?$AAe?$AAB?$AAo?$AAo?$AAt?$AAE@
  00075	ff b5 e0 fd ff
	ff		 push	 DWORD PTR _hKey$[ebp]
  0007b	ff d7		 call	 edi
  0007d	85 c0		 test	 eax, eax
  0007f	75 09		 jne	 SHORT $LN3@EnsureTest

; 391  :             secureBootEnabled = (value != 0);

  00081	39 85 dc fd ff
	ff		 cmp	 DWORD PTR _value$[ebp], eax
  00087	0f 95 c7	 setne	 bh
$LN3@EnsureTest:

; 392  :         }
; 393  :         RegCloseKey(hKey);

  0008a	ff b5 e0 fd ff
	ff		 push	 DWORD PTR _hKey$[ebp]
  00090	ff 95 d4 fd ff
	ff		 call	 DWORD PTR tv554[ebp]
$LN2@EnsureTest:

; 394  :     }
; 395  : 
; 396  :     // Check Test Signing status
; 397  :     bool testSigningEnabled = false;
; 398  :     valueSize = sizeof(DWORD);
; 399  :     status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,

  00096	8d 85 e0 fd ff
	ff		 lea	 eax, DWORD PTR _hKey$[ebp]
  0009c	c7 85 d8 fd ff
	ff 04 00 00 00	 mov	 DWORD PTR _valueSize$[ebp], 4
  000a6	50		 push	 eax
  000a7	6a 01		 push	 1
  000a9	6a 00		 push	 0
  000ab	68 00 00 00 00	 push	 OFFSET ??_C@_1GI@HJODJPCN@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?2?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAC@
  000b0	68 02 00 00 80	 push	 -2147483646		; 80000002H
  000b5	32 db		 xor	 bl, bl
  000b7	ff d6		 call	 esi

; 400  :         L"SYSTEM\\CurrentControlSet\\Control\\SystemStartOptions",
; 401  :         0, KEY_QUERY_VALUE, &hKey);
; 402  :     if (status == ERROR_SUCCESS) {

  000b9	85 c0		 test	 eax, eax
  000bb	0f 85 1b 01 00
	00		 jne	 $LN4@EnsureTest

; 403  :         WCHAR options[256] = {0};

  000c1	68 00 02 00 00	 push	 512			; 00000200H
  000c6	50		 push	 eax
  000c7	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _options$3[ebp]
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 _memset
  000d3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 404  :         DWORD optionsSize = sizeof(options);

  000d6	c7 85 d0 fd ff
	ff 00 02 00 00	 mov	 DWORD PTR _optionsSize$1[ebp], 512 ; 00000200H

; 405  :         if (RegQueryValueExW(hKey, L"SystemStartOptions", nullptr, nullptr, (LPBYTE)options, &optionsSize) == ERROR_SUCCESS) {

  000e0	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _optionsSize$1[ebp]
  000e6	50		 push	 eax
  000e7	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _options$3[ebp]
  000ed	50		 push	 eax
  000ee	6a 00		 push	 0
  000f0	6a 00		 push	 0
  000f2	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@BLIBLCJE@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AAS?$AAt?$AAa?$AAr?$AAt?$AAO?$AAp?$AAt?$AAi@
  000f7	ff b5 e0 fd ff
	ff		 push	 DWORD PTR _hKey$[ebp]
  000fd	ff d7		 call	 edi
  000ff	85 c0		 test	 eax, eax
  00101	0f 85 c9 00 00
	00		 jne	 $LN97@EnsureTest
  00107	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 517  :     size_type _Mysize = 0; // current length of string (size)

  0010a	89 85 f4 fd ff
	ff		 mov	 DWORD PTR _opts$2[ebp+16], eax

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00110	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _options$3[ebp]
  00116	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _opts$2[ebp+20], eax

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0011c	0f 11 85 e4 fd
	ff ff		 movups	 XMMWORD PTR _opts$2[ebp], xmm0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00123	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
$LL123@EnsureTest:
  00126	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00129	83 c1 02	 add	 ecx, 2
  0012c	66 85 c0	 test	 ax, ax
  0012f	75 f5		 jne	 SHORT $LL123@EnsureTest
  00131	2b ca		 sub	 ecx, edx

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00133	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _options$3[ebp]

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00139	d1 f9		 sar	 ecx, 1

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0013b	51		 push	 ecx
  0013c	50		 push	 eax
  0013d	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR _opts$2[ebp]
  00143	e8 00 00 00 00	 call	 ??$_Construct@$00PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>

; 453  :         return _Myres > _Small_string_capacity;

  00148	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR _opts$2[ebp+20]

; 444  :         const value_type* _Result = _Bx._Buf;

  0014e	8d bd e4 fd ff
	ff		 lea	 edi, DWORD PTR _opts$2[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 641  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

  00154	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _opts$2[ebp+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  0015a	83 f9 07	 cmp	 ecx, 7

; 445  :         if (_Large_mode_engaged()) {

  0015d	0f 47 bd e4 fd
	ff ff		 cmova	 edi, DWORD PTR _opts$2[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 641  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

  00164	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00167	72 24		 jb	 SHORT $LN50@EnsureTest
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 252  :         return const_cast<_Ty1*>(static_cast<const _Ty1*>(::__std_search_2(_First1, _Last1, _First2, _Count2)));

  00169	6a 0b		 push	 11			; 0000000bH
  0016b	68 00 00 00 00	 push	 OFFSET ??_C@_1BI@MHOMIIJN@?$AAT?$AAE?$AAS?$AAT?$AAS?$AAI?$AAG?$AAN?$AAI?$AAN?$AAG@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 660  :             const auto _End = _Haystack + _Hay_size;

  00170	8d 34 47	 lea	 esi, DWORD PTR [edi+eax*2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 252  :         return const_cast<_Ty1*>(static_cast<const _Ty1*>(::__std_search_2(_First1, _Last1, _First2, _Count2)));

  00173	56		 push	 esi
  00174	57		 push	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 653  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible

  00175	0f ae e8	 lfence
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 252  :         return const_cast<_Ty1*>(static_cast<const _Ty1*>(::__std_search_2(_First1, _Last1, _First2, _Count2)));

  00178	e8 00 00 00 00	 call	 ___std_search_2@16
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 663  :             if (_Ptr != _End) {

  0017d	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR _opts$2[ebp+20]
  00183	3b c6		 cmp	 eax, esi
  00185	74 06		 je	 SHORT $LN50@EnsureTest

; 664  :                 return static_cast<size_t>(_Ptr - _Haystack);

  00187	2b c7		 sub	 eax, edi
  00189	d1 f8		 sar	 eax, 1
  0018b	eb 03		 jmp	 SHORT $LN47@EnsureTest
$LN50@EnsureTest:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  0018d	83 c8 ff	 or	 eax, -1
$LN47@EnsureTest:
  00190	83 f8 ff	 cmp	 eax, -1
  00193	0f 95 c3	 setne	 bl
  00196	83 f9 07	 cmp	 ecx, 7

; 3083 :         if (_My_data._Large_mode_engaged()) {

  00199	76 35		 jbe	 SHORT $LN97@EnsureTest
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0019b	8b 95 e4 fd ff
	ff		 mov	 edx, DWORD PTR _opts$2[ebp]
  001a1	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]
  001a8	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  001aa	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  001b0	72 14		 jb	 SHORT $LN102@EnsureTest

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001b2	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  001b5	83 c1 23	 add	 ecx, 35			; 00000023H
  001b8	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001ba	83 c0 fc	 add	 eax, -4			; fffffffcH
  001bd	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001c0	0f 87 a0 00 00
	00		 ja	 $LN140@EnsureTest
$LN102@EnsureTest:

; 289  :         ::operator delete(_Ptr, _Bytes);

  001c6	51		 push	 ecx
  001c7	52		 push	 edx
  001c8	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001cd	83 c4 08	 add	 esp, 8
$LN97@EnsureTest:
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 410  :         RegCloseKey(hKey);

  001d0	ff b5 e0 fd ff
	ff		 push	 DWORD PTR _hKey$[ebp]
  001d6	ff 95 d4 fd ff
	ff		 call	 DWORD PTR tv554[ebp]
$LN4@EnsureTest:

; 411  :     }
; 412  : 
; 413  :     // If Secure Boot is enabled, attempt to disable it (requires firmware interaction)
; 414  :     if (secureBootEnabled) {

  001dc	84 ff		 test	 bh, bh
  001de	74 2f		 je	 SHORT $LN7@EnsureTest

; 415  :         std::cout << "Secure Boot is enabled. Please disable it in your UEFI firmware settings.\n";

  001e0	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@CNFJKCBJ@Secure?5Boot?5is?5enabled?4?5Please?5@
$LN138@EnsureTest:

; 437  : }

  001e5	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  001ea	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001ef	83 c4 08	 add	 esp, 8
  001f2	b9 00 00 00 00	 mov	 ecx, OFFSET ?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A ; std::cin
  001f7	e8 00 00 00 00	 call	 ?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_istream<char,std::char_traits<char> >::get
  001fc	5f		 pop	 edi
  001fd	5e		 pop	 esi
  001fe	32 c0		 xor	 al, al
  00200	5b		 pop	 ebx
  00201	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00204	33 cd		 xor	 ecx, ebp
  00206	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0020b	8b e5		 mov	 esp, ebp
  0020d	5d		 pop	 ebp
  0020e	c3		 ret	 0
$LN7@EnsureTest:

; 416  :         std::cin.get();
; 417  :         return false;
; 418  :     }
; 419  : 
; 420  :     // If Test Signing is not enabled, enable it
; 421  :     if (!testSigningEnabled) {

  0020f	84 db		 test	 bl, bl
  00211	75 2e		 jne	 SHORT $LN8@EnsureTest

; 422  :         std::cout << "Test Signing is not enabled. Attempting to enable...\n";

  00213	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@HBHIFBKB@Test?5Signing?5is?5not?5enabled?4?5At@
  00218	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  0021d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 423  :         // Enable test signing using bcdedit
; 424  :         int ret = system("bcdedit /set testsigning on");

  00222	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@BMDEHBF@bcdedit?5?1set?5testsigning?5on@
  00227	e8 00 00 00 00	 call	 _system
  0022c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 425  :         if (ret != 0) {

  0022f	85 c0		 test	 eax, eax
  00231	74 07		 je	 SHORT $LN9@EnsureTest

; 426  :             std::cout << "Failed to enable test signing. Run as administrator.\n";

  00233	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@KGFCFPMJ@Failed?5to?5enable?5test?5signing?4?5@

; 427  :             std::cin.get();
; 428  :             return false;

  00238	eb ab		 jmp	 SHORT $LN138@EnsureTest
$LN9@EnsureTest:

; 429  :         }
; 430  :         std::cout << "Test signing enabled. Please reboot your system for changes to take effect.\n";

  0023a	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@FHCHMDNF@Test?5signing?5enabled?4?5Please?5re@

; 431  :         std::cin.get();
; 432  :         return false;

  0023f	eb a4		 jmp	 SHORT $LN138@EnsureTest
$LN8@EnsureTest:

; 433  :     }
; 434  : 
; 435  :     std::cout << "Secure Boot is disabled and Test Signing is enabled.\n";

  00241	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@KKDPEODH@Secure?5Boot?5is?5disabled?5and?5Tes@
  00246	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  0024b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 437  : }

  00250	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00253	83 c4 08	 add	 esp, 8
  00256	33 cd		 xor	 ecx, ebp
  00258	b0 01		 mov	 al, 1
  0025a	5f		 pop	 edi
  0025b	5e		 pop	 esi
  0025c	5b		 pop	 ebx
  0025d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00262	8b e5		 mov	 esp, ebp
  00264	5d		 pop	 ebp
  00265	c3		 ret	 0
$LN140@EnsureTest:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00266	6a 00		 push	 0
  00268	6a 00		 push	 0
  0026a	6a 00		 push	 0
  0026c	6a 00		 push	 0
  0026e	6a 00		 push	 0
  00270	e8 00 00 00 00	 call	 __invoke_watson
$LN137@EnsureTest:
  00275	cc		 int	 3
?EnsureTestSigningAndDisableSecureBoot@@YA_NXZ ENDP	; EnsureTestSigningAndDisableSecureBoot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
;	COMDAT ?IsSystemAccount@@YA_NXZ
_TEXT	SEGMENT
_sidString$1 = -12					; size = 4
_size$ = -8						; size = 4
_hToken$ = -4						; size = 4
?IsSystemAccount@@YA_NXZ PROC				; IsSystemAccount, COMDAT

; 353  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 354  :     HANDLE hToken = nullptr;
; 355  :     if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _hToken$[ebp]
  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hToken$[ebp], 0
  00010	50		 push	 eax
  00011	6a 08		 push	 8
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0
  00019	50		 push	 eax
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenProcessToken@12
  00020	85 c0		 test	 eax, eax
  00022	75 06		 jne	 SHORT $LN2@IsSystemAc

; 356  :         return false;

  00024	32 c0		 xor	 al, al

; 379  : }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
$LN2@IsSystemAc:
  0002a	56		 push	 esi

; 357  : 
; 358  :     DWORD size = 0;
; 359  :     GetTokenInformation(hToken, TokenUser, nullptr, 0, &size);

  0002b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetTokenInformation@20
  00031	8d 45 f8	 lea	 eax, DWORD PTR _size$[ebp]
  00034	57		 push	 edi
  00035	50		 push	 eax
  00036	6a 00		 push	 0
  00038	6a 00		 push	 0
  0003a	6a 01		 push	 1
  0003c	ff 75 fc	 push	 DWORD PTR _hToken$[ebp]
  0003f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _size$[ebp], 0
  00046	ff d6		 call	 esi

; 360  :     PTOKEN_USER ptu = (PTOKEN_USER)malloc(size);

  00048	ff 75 f8	 push	 DWORD PTR _size$[ebp]
  0004b	e8 00 00 00 00	 call	 _malloc
  00050	8b f8		 mov	 edi, eax
  00052	83 c4 04	 add	 esp, 4

; 361  :     if (!ptu) {

  00055	85 ff		 test	 edi, edi
  00057	75 11		 jne	 SHORT $LN3@IsSystemAc

; 362  :         CloseHandle(hToken);

  00059	ff 75 fc	 push	 DWORD PTR _hToken$[ebp]
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  00062	5f		 pop	 edi

; 363  :         return false;

  00063	32 c0		 xor	 al, al
  00065	5e		 pop	 esi

; 379  : }

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
$LN3@IsSystemAc:
  0006a	53		 push	 ebx

; 364  :     }
; 365  : 
; 366  :     bool isSystem = false;
; 367  :     if (GetTokenInformation(hToken, TokenUser, ptu, size, &size)) {

  0006b	8d 45 f8	 lea	 eax, DWORD PTR _size$[ebp]
  0006e	32 db		 xor	 bl, bl
  00070	50		 push	 eax
  00071	ff 75 f8	 push	 DWORD PTR _size$[ebp]
  00074	57		 push	 edi
  00075	6a 01		 push	 1
  00077	ff 75 fc	 push	 DWORD PTR _hToken$[ebp]
  0007a	ff d6		 call	 esi
  0007c	85 c0		 test	 eax, eax
  0007e	74 57		 je	 SHORT $LN5@IsSystemAc

; 368  :         WCHAR* sidString = nullptr;
; 369  :         if (ConvertSidToStringSidW(ptu->User.Sid, &sidString)) {

  00080	8d 45 f4	 lea	 eax, DWORD PTR _sidString$1[ebp]
  00083	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _sidString$1[ebp], 0
  0008a	50		 push	 eax
  0008b	ff 37		 push	 DWORD PTR [edi]
  0008d	e8 00 00 00 00	 call	 _ConvertSidToStringSidW@8
  00092	85 c0		 test	 eax, eax
  00094	74 41		 je	 SHORT $LN5@IsSystemAc

; 370  :             // SID for NT AUTHORITY\SYSTEM is S-1-5-18
; 371  :             if (wcscmp(sidString, L"S-1-5-18") == 0)

  00096	8b 5d f4	 mov	 ebx, DWORD PTR _sidString$1[ebp]
  00099	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_1BC@FOGOLNOF@?$AAS?$AA?9?$AA1?$AA?9?$AA5?$AA?9?$AA1?$AA8@
  0009e	8b c3		 mov	 eax, ebx
$LL8@IsSystemAc:
  000a0	66 8b 10	 mov	 dx, WORD PTR [eax]
  000a3	66 3b 11	 cmp	 dx, WORD PTR [ecx]
  000a6	75 1e		 jne	 SHORT $LN9@IsSystemAc
  000a8	66 85 d2	 test	 dx, dx
  000ab	74 15		 je	 SHORT $LN10@IsSystemAc
  000ad	66 8b 50 02	 mov	 dx, WORD PTR [eax+2]
  000b1	66 3b 51 02	 cmp	 dx, WORD PTR [ecx+2]
  000b5	75 0f		 jne	 SHORT $LN9@IsSystemAc
  000b7	83 c0 04	 add	 eax, 4
  000ba	83 c1 04	 add	 ecx, 4
  000bd	66 85 d2	 test	 dx, dx
  000c0	75 de		 jne	 SHORT $LL8@IsSystemAc
$LN10@IsSystemAc:
  000c2	33 f6		 xor	 esi, esi
  000c4	eb 05		 jmp	 SHORT $LN11@IsSystemAc
$LN9@IsSystemAc:
  000c6	1b f6		 sbb	 esi, esi
  000c8	83 ce 01	 or	 esi, 1
$LN11@IsSystemAc:

; 372  :                 isSystem = true;
; 373  :             LocalFree(sidString);

  000cb	53		 push	 ebx
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4
  000d2	85 f6		 test	 esi, esi
  000d4	0f 94 c3	 sete	 bl
$LN5@IsSystemAc:

; 374  :         }
; 375  :     }
; 376  :     free(ptu);

  000d7	57		 push	 edi
  000d8	e8 00 00 00 00	 call	 _free
  000dd	83 c4 04	 add	 esp, 4

; 377  :     CloseHandle(hToken);

  000e0	ff 75 fc	 push	 DWORD PTR _hToken$[ebp]
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 378  :     return isSystem;

  000e9	8a c3		 mov	 al, bl
  000eb	5b		 pop	 ebx
  000ec	5f		 pop	 edi
  000ed	5e		 pop	 esi

; 379  : }

  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c3		 ret	 0
?IsSystemAccount@@YA_NXZ ENDP				; IsSystemAccount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z
_TEXT	SEGMENT
$T2 = -64						; size = 20
__Pad$ = -44						; size = 8
__Ok$ = -44						; size = 8
$T3 = -36						; size = 8
$T4 = -32						; size = 4
tv746 = -32						; size = 4
$T5 = -28						; size = 4
tv741 = -28						; size = 4
__Count$2$ = -24					; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z PROC ; std::operator<<<wchar_t,std::char_traits<wchar_t> >, COMDAT

; 851  : basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* _Val) { // insert NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 34	 sub	 esp, 52			; 00000034H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 852  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 853  : 
; 854  :     ios_base::iostate _State = ios_base::goodbit;

  0002b	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  0002e	33 db		 xor	 ebx, ebx
  00030	89 5d ec	 mov	 DWORD PTR __State$[ebp], ebx
  00033	8d 4a 02	 lea	 ecx, DWORD PTR [edx+2]
$LL100@operator:
  00036	66 8b 02	 mov	 ax, WORD PTR [edx]
  00039	83 c2 02	 add	 edx, 2
  0003c	66 85 c0	 test	 ax, ax
  0003f	75 f5		 jne	 SHORT $LL100@operator
  00041	2b d1		 sub	 edx, ecx

; 855  :     streamsize _Count        = static_cast<streamsize>(_Traits::length(_Val));
; 856  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  00043	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00046	d1 fa		 sar	 edx, 1
  00048	89 55 e8	 mov	 DWORD PTR __Count$2$[ebp], edx
  0004b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00050	8b 7c 08 24	 mov	 edi, DWORD PTR [eax+ecx+36]
  00054	8b 74 08 20	 mov	 esi, DWORD PTR [eax+ecx+32]
  00058	85 ff		 test	 edi, edi
  0005a	7c 16		 jl	 SHORT $LN17@operator
  0005c	7f 0e		 jg	 SHORT $LN102@operator
  0005e	85 f6		 test	 esi, esi
  00060	74 10		 je	 SHORT $LN17@operator
  00062	85 ff		 test	 edi, edi
  00064	7c 0c		 jl	 SHORT $LN17@operator
  00066	7f 04		 jg	 SHORT $LN102@operator
  00068	3b f2		 cmp	 esi, edx
  0006a	76 06		 jbe	 SHORT $LN17@operator
$LN102@operator:
  0006c	2b f2		 sub	 esi, edx
  0006e	1b fb		 sbb	 edi, ebx
  00070	eb 0e		 jmp	 SHORT $LN18@operator
$LN17@operator:
  00072	0f 57 c0	 xorps	 xmm0, xmm0
  00075	66 0f 13 45 d4	 movlpd	 QWORD PTR __Pad$[ebp], xmm0
  0007a	8b 7d d8	 mov	 edi, DWORD PTR __Pad$[ebp+4]
  0007d	8b 75 d4	 mov	 esi, DWORD PTR __Pad$[ebp]
$LN18@operator:

; 857  :     const typename _Myos::sentry _Ok(_Ostr);

  00080	51		 push	 ecx
  00081	8d 4d d4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00084	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry

; 858  : 
; 859  :     if (!_Ok) {

  00089	80 7d d8 00	 cmp	 BYTE PTR __Ok$[ebp+4], 0
  0008d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00094	75 0a		 jne	 SHORT $LN8@operator

; 860  :         _State |= ios_base::badbit;

  00096	bb 04 00 00 00	 mov	 ebx, 4

; 861  :     } else { // state okay, insert

  0009b	e9 59 01 00 00	 jmp	 $LN113@operator
$LN8@operator:

; 862  :         _TRY_IO_BEGIN
; 863  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  000a0	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000a3	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  000a7	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000ac	8b 44 08 14	 mov	 eax, DWORD PTR [eax+ecx+20]
  000b0	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000b5	83 f8 40	 cmp	 eax, 64			; 00000040H
  000b8	74 74		 je	 SHORT $LN97@operator
  000ba	66 0f 1f 44 00
	00		 npad	 6
$LL4@operator:

; 864  :             for (; 0 < _Pad; --_Pad) { // pad on left

  000c0	85 ff		 test	 edi, edi
  000c2	7c 6a		 jl	 SHORT $LN97@operator
  000c4	7f 04		 jg	 SHORT $LN103@operator
  000c6	85 f6		 test	 esi, esi
  000c8	74 64		 je	 SHORT $LN97@operator
$LN103@operator:

; 865  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  000ca	8b 01		 mov	 eax, DWORD PTR [ecx]
  000cc	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000cf	8b 54 08 38	 mov	 edx, DWORD PTR [eax+ecx+56]
  000d3	0f b7 4c 08 40	 movzx	 ecx, WORD PTR [eax+ecx+64]
  000d8	89 4d e0	 mov	 DWORD PTR $T4[ebp], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 261  :         return *_IPnext ? *_IPcount : 0;

  000db	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  000de	83 38 00	 cmp	 DWORD PTR [eax], 0
  000e1	74 21		 je	 SHORT $LN96@operator
  000e3	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  000e6	8b 00		 mov	 eax, DWORD PTR [eax]

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  000e8	85 c0		 test	 eax, eax
  000ea	7e 18		 jle	 SHORT $LN96@operator

; 256  :         --*_IPcount;

  000ec	8b 4a 30	 mov	 ecx, DWORD PTR [edx+48]
  000ef	48		 dec	 eax
  000f0	89 01		 mov	 DWORD PTR [ecx], eax

; 257  :         return (*_IPnext)++;

  000f2	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  000f5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f7	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  000fa	89 01		 mov	 DWORD PTR [ecx], eax

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  000fc	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  000ff	66 89 02	 mov	 WORD PTR [edx], ax
  00102	eb 08		 jmp	 SHORT $LN114@operator
$LN96@operator:
  00104	8b 02		 mov	 eax, DWORD PTR [edx]
  00106	51		 push	 ecx
  00107	8b ca		 mov	 ecx, edx
  00109	ff 50 0c	 call	 DWORD PTR [eax+12]
$LN114@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 367  :         return _Left == _Right;

  0010c	0f b7 c0	 movzx	 eax, ax
  0010f	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00114	66 3b c8	 cmp	 cx, ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 865  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00117	75 0a		 jne	 SHORT $LN2@operator

; 866  :                     _State |= ios_base::badbit; // insertion failed, quit

  00119	bb 04 00 00 00	 mov	 ebx, 4

; 867  :                     break;

  0011e	e9 92 00 00 00	 jmp	 $LN6@operator
$LN2@operator:

; 864  :             for (; 0 < _Pad; --_Pad) { // pad on left

  00123	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00126	83 c6 ff	 add	 esi, -1
  00129	83 d7 ff	 adc	 edi, -1
  0012c	eb 92		 jmp	 SHORT $LL4@operator
$LN97@operator:

; 872  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  0012e	8b 01		 mov	 eax, DWORD PTR [ecx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 171  :         return xsputn(_Ptr, _Count);

  00130	6a 00		 push	 0
  00132	ff 75 e8	 push	 DWORD PTR __Count$2$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 872  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  00135	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 171  :         return xsputn(_Ptr, _Count);

  00138	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 872  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  0013b	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 171  :         return xsputn(_Ptr, _Count);

  0013f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00141	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00144	ff d0		 call	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 872  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  00146	3b 45 e8	 cmp	 eax, DWORD PTR __Count$2$[ebp]
  00149	75 67		 jne	 SHORT $LN104@operator
  0014b	85 d2		 test	 edx, edx
  0014d	75 63		 jne	 SHORT $LN104@operator
  0014f	90		 npad	 1
$LL7@operator:

; 873  :             _State |= ios_base::badbit;
; 874  :         }
; 875  : 
; 876  :         if (_State == ios_base::goodbit) {
; 877  :             for (; 0 < _Pad; --_Pad) { // pad on right

  00150	85 ff		 test	 edi, edi
  00152	7c 61		 jl	 SHORT $LN6@operator
  00154	7f 04		 jg	 SHORT $LN105@operator
  00156	85 f6		 test	 esi, esi
  00158	74 5b		 je	 SHORT $LN6@operator
$LN105@operator:

; 878  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  0015a	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0015d	8b 02		 mov	 eax, DWORD PTR [edx]
  0015f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00162	8b 4c 10 38	 mov	 ecx, DWORD PTR [eax+edx+56]
  00166	0f b7 54 10 40	 movzx	 edx, WORD PTR [eax+edx+64]
  0016b	89 55 e4	 mov	 DWORD PTR $T5[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 261  :         return *_IPnext ? *_IPcount : 0;

  0016e	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00171	83 38 00	 cmp	 DWORD PTR [eax], 0
  00174	74 21		 je	 SHORT $LN56@operator
  00176	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00179	8b 00		 mov	 eax, DWORD PTR [eax]

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  0017b	85 c0		 test	 eax, eax
  0017d	7e 18		 jle	 SHORT $LN56@operator

; 256  :         --*_IPcount;

  0017f	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00182	48		 dec	 eax
  00183	89 02		 mov	 DWORD PTR [edx], eax

; 257  :         return (*_IPnext)++;

  00185	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00188	8b 11		 mov	 edx, DWORD PTR [ecx]
  0018a	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  0018d	89 01		 mov	 DWORD PTR [ecx], eax

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  0018f	8b 45 e4	 mov	 eax, DWORD PTR $T5[ebp]
  00192	66 89 02	 mov	 WORD PTR [edx], ax
  00195	eb 06		 jmp	 SHORT $LN115@operator
$LN56@operator:
  00197	8b 01		 mov	 eax, DWORD PTR [ecx]
  00199	52		 push	 edx
  0019a	ff 50 0c	 call	 DWORD PTR [eax+12]
$LN115@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 367  :         return _Left == _Right;

  0019d	0f b7 c0	 movzx	 eax, ax
  001a0	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  001a5	66 3b c8	 cmp	 cx, ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 878  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  001a8	74 08		 je	 SHORT $LN104@operator

; 873  :             _State |= ios_base::badbit;
; 874  :         }
; 875  : 
; 876  :         if (_State == ios_base::goodbit) {
; 877  :             for (; 0 < _Pad; --_Pad) { // pad on right

  001aa	83 c6 ff	 add	 esi, -1
  001ad	83 d7 ff	 adc	 edi, -1
  001b0	eb 9e		 jmp	 SHORT $LL7@operator
$LN104@operator:

; 879  :                     _State |= ios_base::badbit; // insertion failed, quit
; 880  :                     break;
; 881  :                 }
; 882  :             }
; 883  :         }
; 884  : 
; 885  :         _Ostr.width(0);

  001b2	83 cb 04	 or	 ebx, 4
$LN6@operator:
  001b5	8b 75 08	 mov	 esi, DWORD PTR __Ostr$[ebp]
  001b8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  001bf	8b 06		 mov	 eax, DWORD PTR [esi]
  001c1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 284  :         _Wide                      = _Newwidth;

  001c4	c7 44 30 20 00
	00 00 00	 mov	 DWORD PTR [eax+esi+32], 0
  001cc	c7 44 30 24 00
	00 00 00	 mov	 DWORD PTR [eax+esi+36], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
  001d4	eb 26		 jmp	 SHORT $LN22@operator
__catch$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$0:

; 886  :         _CATCH_IO_(ios_base, _Ostr)

  001d6	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  001d9	6a 01		 push	 1
  001db	6a 04		 push	 4
  001dd	8b 02		 mov	 eax, DWORD PTR [edx]
  001df	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001e2	03 ca		 add	 ecx, edx
  001e4	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::setstate
  001e9	b8 00 00 00 00	 mov	 eax, $LN23@operator
  001ee	c3		 ret	 0
$LN23@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
  001ef	8b 5d ec	 mov	 ebx, DWORD PTR __State$[ebp]
  001f2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN113@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 889  :     _Ostr.setstate(_State);

  001f9	8b 75 08	 mov	 esi, DWORD PTR __Ostr$[ebp]
$LN22@operator:
  001fc	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  001fe	33 ff		 xor	 edi, edi
  00200	b9 04 00 00 00	 mov	 ecx, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 889  :     _Ostr.setstate(_State);

  00205	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 51   :         clear(rdstate() | _State, _Reraise);

  00208	8b 44 32 0c	 mov	 eax, DWORD PTR [edx+esi+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 889  :     _Ostr.setstate(_State);

  0020c	03 d6		 add	 edx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 51   :         clear(rdstate() | _State, _Reraise);

  0020e	0b c3		 or	 eax, ebx

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  00210	39 7a 38	 cmp	 DWORD PTR [edx+56], edi
  00213	0f 45 cf	 cmovne	 ecx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 155  :         _State &= _Statmask;

  00216	0b c8		 or	 ecx, eax

; 156  :         _Mystate             = _State;
; 157  :         const auto _Filtered = _State & _Except;

  00218	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0021b	83 e1 17	 and	 ecx, 23			; 00000017H
  0021e	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00221	23 c1		 and	 eax, ecx

; 158  :         if (_Filtered) {

  00223	75 41		 jne	 SHORT $LN117@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 111  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  00225	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception

; 112  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 113  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 114  : #endif // ^^^ !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION ^^^
; 115  : 
; 116  :             if (_Zero_uncaught_exceptions) {

  0022a	84 c0		 test	 al, al
  0022c	75 08		 jne	 SHORT $LN40@operator

; 117  :                 this->_Myostr._Osfx();

  0022e	8b 4d d4	 mov	 ecx, DWORD PTR __Ok$[ebp]
  00231	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
$LN40@operator:

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

  00236	8b 4d d4	 mov	 ecx, DWORD PTR __Ok$[ebp]
  00239	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3
  00240	8b 01		 mov	 eax, DWORD PTR [ecx]
  00242	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00245	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]

; 78   :             if (_Rdbuf) {

  00249	85 c9		 test	 ecx, ecx
  0024b	74 05		 je	 SHORT $LN46@operator

; 79   :                 _Rdbuf->_Unlock();

  0024d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0024f	ff 52 08	 call	 DWORD PTR [edx+8]
$LN46@operator:

; 890  :     return _Ostr;

  00252	8b c6		 mov	 eax, esi

; 891  : }

  00254	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00257	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0025e	59		 pop	 ecx
  0025f	5f		 pop	 edi
  00260	5e		 pop	 esi
  00261	5b		 pop	 ebx
  00262	8b e5		 mov	 esp, ebp
  00264	5d		 pop	 ebp
  00265	c3		 ret	 0
$LN117@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 164  :             if (_Filtered & ios_base::badbit) {

  00266	a8 04		 test	 al, 4
  00268	74 07		 je	 SHORT $LN31@operator

; 165  :                 _Msg = "ios_base::badbit set";

  0026a	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  0026f	eb 0f		 jmp	 SHORT $LN33@operator
$LN31@operator:

; 166  :             } else if (_Filtered & ios_base::failbit) {

  00271	a8 02		 test	 al, 2
  00273	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
  00278	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
  0027d	0f 44 f0	 cmove	 esi, eax
$LN33@operator:

; 167  :                 _Msg = "ios_base::failbit set";
; 168  :             } else {
; 169  :                 _Msg = "ios_base::eofbit set";
; 170  :             }
; 171  : 
; 172  :             _THROW(failure(_Msg));

  00280	8d 45 dc	 lea	 eax, DWORD PTR $T3[ebp]
  00283	6a 01		 push	 1
  00285	50		 push	 eax
  00286	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  0028b	83 c4 08	 add	 esp, 8
  0028e	8d 4d c0	 lea	 ecx, DWORD PTR $T2[ebp]
  00291	50		 push	 eax
  00292	56		 push	 esi
  00293	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  00298	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  0029d	8d 45 c0	 lea	 eax, DWORD PTR $T2[ebp]
  002a0	50		 push	 eax
  002a1	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN110@operator:
  002a6	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$2:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ENDP ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
;	COMDAT ??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_istream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b d1		 mov	 edx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 78   :     __CLR_OR_THIS_CALL ~basic_istream() noexcept override {}

  00025	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  00028	8d 72 e8	 lea	 esi, DWORD PTR [edx-24]
  0002b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002e	c7 44 10 e8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-24], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003b	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  0003e	89 44 11 e4	 mov	 DWORD PTR [ecx+edx-28], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 368  :         _Ios_base_dtor(this);

  00042	52		 push	 edx
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  00050	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00055	83 c4 04	 add	 esp, 4
  00058	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0005c	74 0b		 je	 SHORT $LN21@scalar
  0005e	6a 60		 push	 96			; 00000060H
  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00066	83 c4 08	 add	 esp, 8
$LN21@scalar:
  00069	8b c6		 mov	 eax, esi
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5e		 pop	 esi
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
  0007d	cc		 int	 3
  0007e	cc		 int	 3
  0007f	cc		 int	 3
  00080	cc		 int	 3
  00081	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
;	COMDAT ?ignore@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z
_TEXT	SEGMENT
$T2 = -52						; size = 20
__Ok$ = -32						; size = 8
__State$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 8
$T3 = 8							; size = 8
__Metadelim$ = 16					; size = 4
?ignore@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z PROC ; std::basic_istream<char,std::char_traits<char> >::ignore, COMDAT
; _this$ = ecx

; 501  :     basic_istream& __CLR_OR_THIS_CALL ignore(streamsize _Count = 1, int_type _Metadelim = _Traits::eof()) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ignore@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 502  :         // ignore up to _Count characters, discarding delimiter
; 503  :         ios_base::iostate _State = ios_base::goodbit;

  00030	33 ff		 xor	 edi, edi

; 86   :         __CLR_OR_THIS_CALL _Sentry_base(basic_istream& _Istr) : _Myistr(_Istr) {

  00032	8b de		 mov	 ebx, esi

; 504  :         _Chcount                 = 0;

  00034	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00037	89 7e 0c	 mov	 DWORD PTR [esi+12], edi

; 87   :             const auto _Rdbuf = _Myistr.rdbuf();

  0003a	8b 06		 mov	 eax, DWORD PTR [esi]

; 502  :         // ignore up to _Count characters, discarding delimiter
; 503  :         ios_base::iostate _State = ios_base::goodbit;

  0003c	89 7d e8	 mov	 DWORD PTR __State$[ebp], edi

; 86   :         __CLR_OR_THIS_CALL _Sentry_base(basic_istream& _Istr) : _Myistr(_Istr) {

  0003f	89 5d e0	 mov	 DWORD PTR __Ok$[ebp], ebx

; 87   :             const auto _Rdbuf = _Myistr.rdbuf();

  00042	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00045	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]

; 88   :             if (_Rdbuf) {

  00049	85 c9		 test	 ecx, ecx
  0004b	74 05		 je	 SHORT $LN22@ignore

; 89   :                 _Rdbuf->_Lock();

  0004d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004f	ff 50 04	 call	 DWORD PTR [eax+4]
$LN22@ignore:

; 108  :             : _Sentry_base(_Istr), _Ok(_Sentry_base::_Myistr._Ipfx(_Noskip)) {}

  00052	6a 01		 push	 1
  00054	8b ce		 mov	 ecx, esi
  00056	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0005d	e8 00 00 00 00	 call	 ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
  00062	88 45 e4	 mov	 BYTE PTR __Ok$[ebp+4], al

; 505  :         const sentry _Ok(*this, true);

  00065	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  0006c	84 c0		 test	 al, al

; 506  : 
; 507  :         if (_Ok && 0 < _Count) { // state okay, use facet to extract

  0006e	0f 84 d4 00 00
	00		 je	 $LN16@ignore
  00074	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp+4]
  00077	85 db		 test	 ebx, ebx
  00079	0f 8c c6 00 00
	00		 jl	 $LN84@ignore
  0007f	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
  00082	7f 08		 jg	 SHORT $LN76@ignore
  00084	85 ff		 test	 edi, edi
  00086	0f 84 b7 00 00
	00		 je	 $LN81@ignore
$LN76@ignore:

; 508  :             _TRY_IO_BEGIN

  0008c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
$LL4@ignore:

; 509  :             for (;;) { // get a metacharacter if more room in buffer
; 510  :                 int_type _Meta;
; 511  :                 if (_Count != _STD _Max_limit<streamsize>() && --_Count < 0) {

  00090	83 ff ff	 cmp	 edi, -1
  00093	75 08		 jne	 SHORT $LN77@ignore
  00095	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  0009b	74 10		 je	 SHORT $LN78@ignore
$LN77@ignore:
  0009d	83 c7 ff	 add	 edi, -1
  000a0	83 d3 ff	 adc	 ebx, -1
  000a3	85 db		 test	 ebx, ebx
  000a5	7c 69		 jl	 SHORT $LN83@ignore
  000a7	7f 04		 jg	 SHORT $LN78@ignore
  000a9	85 ff		 test	 edi, edi
  000ab	72 63		 jb	 SHORT $LN83@ignore
$LN78@ignore:

; 513  :                 } else if (_Traits::eq_int_type(_Traits::eof(),

  000ad	8b 06		 mov	 eax, DWORD PTR [esi]
  000af	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b2	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  000b6	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  000b9	83 38 00	 cmp	 DWORD PTR [eax], 0
  000bc	74 1b		 je	 SHORT $LN75@ignore
  000be	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  000c1	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  000c3	85 c0		 test	 eax, eax
  000c5	7e 12		 jle	 SHORT $LN75@ignore

; 222  :         --*_IGcount;

  000c7	48		 dec	 eax
  000c8	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  000ca	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  000cd	8b 11		 mov	 edx, DWORD PTR [ecx]
  000cf	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  000d2	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  000d4	0f b6 12	 movzx	 edx, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  000d7	eb 07		 jmp	 SHORT $LN27@ignore
$LN75@ignore:
  000d9	8b 01		 mov	 eax, DWORD PTR [ecx]
  000db	ff 50 1c	 call	 DWORD PTR [eax+28]
  000de	8b d0		 mov	 edx, eax
$LN27@ignore:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  000e0	83 fa ff	 cmp	 edx, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 513  :                 } else if (_Traits::eq_int_type(_Traits::eof(),

  000e3	75 08		 jne	 SHORT $LN9@ignore

; 514  :                                _Meta = _Myios::rdbuf()->sbumpc())) { // end of file, quit
; 515  :                     _State |= ios_base::eofbit;

  000e5	8d 7a 02	 lea	 edi, DWORD PTR [edx+2]
  000e8	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], edi
  000eb	eb 58		 jmp	 SHORT $LN84@ignore
$LN9@ignore:

; 223  :         if (_Chcount != _STD _Max_limit<streamsize>()) {

  000ed	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000f0	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  000f3	83 f9 ff	 cmp	 ecx, -1
  000f6	75 07		 jne	 SHORT $LN79@ignore
  000f8	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  000fd	74 0c		 je	 SHORT $LN43@ignore
$LN79@ignore:

; 224  :             ++_Chcount;

  000ff	83 c1 01	 add	 ecx, 1
  00102	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00105	83 d0 00	 adc	 eax, 0
  00108	89 46 0c	 mov	 DWORD PTR [esi+12], eax
$LN43@ignore:

; 516  :                     break;
; 517  :                 } else { // got a character, count it
; 518  :                     _Increment_gcount();
; 519  :                     if (_Meta == _Metadelim) {

  0010b	3b 55 10	 cmp	 edx, DWORD PTR __Metadelim$[ebp]
  0010e	75 80		 jne	 SHORT $LL4@ignore
$LN83@ignore:
  00110	33 ff		 xor	 edi, edi
  00112	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 506  : 
; 507  :         if (_Ok && 0 < _Count) { // state okay, use facet to extract

  00119	eb 2a		 jmp	 SHORT $LN84@ignore
__catch$?ignore@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z$0:

; 520  :                         break; // got a delimiter, quit
; 521  :                     }
; 522  :                 }
; 523  :             }
; 524  :             _CATCH_IO_END

  0011b	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0011e	6a 01		 push	 1
  00120	6a 04		 push	 4
  00122	8b 02		 mov	 eax, DWORD PTR [edx]
  00124	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00127	03 ca		 add	 ecx, edx
  00129	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
  0012e	b8 00 00 00 00	 mov	 eax, $LN17@ignore
  00133	c3		 ret	 0
$LN17@ignore:
  00134	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00137	8b 7d e8	 mov	 edi, DWORD PTR __State$[ebp]
  0013a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  00141	eb 02		 jmp	 SHORT $LN84@ignore
$LN81@ignore:

; 506  : 
; 507  :         if (_Ok && 0 < _Count) { // state okay, use facet to extract

  00143	33 ff		 xor	 edi, edi
$LN84@ignore:

; 527  :         _Myios::setstate(_State);

  00145	8b 5d e0	 mov	 ebx, DWORD PTR __Ok$[ebp]
$LN16@ignore:
  00148	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  0014a	b9 04 00 00 00	 mov	 ecx, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 527  :         _Myios::setstate(_State);

  0014f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 51   :         clear(rdstate() | _State, _Reraise);

  00152	8b 44 32 0c	 mov	 eax, DWORD PTR [edx+esi+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 527  :         _Myios::setstate(_State);

  00156	03 d6		 add	 edx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 51   :         clear(rdstate() | _State, _Reraise);

  00158	0b c7		 or	 eax, edi

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  0015a	33 ff		 xor	 edi, edi
  0015c	39 7a 38	 cmp	 DWORD PTR [edx+56], edi
  0015f	0f 45 cf	 cmovne	 ecx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 155  :         _State &= _Statmask;

  00162	0b c8		 or	 ecx, eax

; 156  :         _Mystate             = _State;
; 157  :         const auto _Filtered = _State & _Except;

  00164	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00167	83 e1 17	 and	 ecx, 23			; 00000017H
  0016a	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  0016d	23 c1		 and	 eax, ecx

; 158  :         if (_Filtered) {

  0016f	75 2f		 jne	 SHORT $LN88@ignore
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 94   :             const auto _Rdbuf = _Myistr.rdbuf();

  00171	8b 03		 mov	 eax, DWORD PTR [ebx]
  00173	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4
  0017a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0017d	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]

; 95   :             if (_Rdbuf) {

  00181	85 c9		 test	 ecx, ecx
  00183	74 05		 je	 SHORT $LN67@ignore

; 96   :                 _Rdbuf->_Unlock();

  00185	8b 01		 mov	 eax, DWORD PTR [ecx]
  00187	ff 50 08	 call	 DWORD PTR [eax+8]
$LN67@ignore:

; 528  :         return *this;

  0018a	8b c6		 mov	 eax, esi

; 529  :     }

  0018c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0018f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00196	59		 pop	 ecx
  00197	5f		 pop	 edi
  00198	5e		 pop	 esi
  00199	5b		 pop	 ebx
  0019a	8b e5		 mov	 esp, ebp
  0019c	5d		 pop	 ebp
  0019d	c2 0c 00	 ret	 12			; 0000000cH
$LN88@ignore:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 164  :             if (_Filtered & ios_base::badbit) {

  001a0	a8 04		 test	 al, 4
  001a2	74 07		 je	 SHORT $LN53@ignore

; 165  :                 _Msg = "ios_base::badbit set";

  001a4	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  001a9	eb 0f		 jmp	 SHORT $LN55@ignore
$LN53@ignore:

; 166  :             } else if (_Filtered & ios_base::failbit) {

  001ab	a8 02		 test	 al, 2
  001ad	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
  001b2	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
  001b7	0f 44 f0	 cmove	 esi, eax
$LN55@ignore:

; 167  :                 _Msg = "ios_base::failbit set";
; 168  :             } else {
; 169  :                 _Msg = "ios_base::eofbit set";
; 170  :             }
; 171  : 
; 172  :             _THROW(failure(_Msg));

  001ba	8d 45 08	 lea	 eax, DWORD PTR $T3[ebp]
  001bd	6a 01		 push	 1
  001bf	50		 push	 eax
  001c0	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  001c5	83 c4 08	 add	 esp, 8
  001c8	8d 4d cc	 lea	 ecx, DWORD PTR $T2[ebp]
  001cb	50		 push	 eax
  001cc	56		 push	 esi
  001cd	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  001d2	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  001d7	8d 45 cc	 lea	 eax, DWORD PTR $T2[ebp]
  001da	50		 push	 eax
  001db	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN86@ignore:
  001e0	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ignore@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z$3:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$?ignore@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z$2:
  00008	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?ignore@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ignore@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ignore@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::ignore
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
;	COMDAT ?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
$T2 = -60						; size = 20
__Ok$ = -40						; size = 8
$T3 = -32						; size = 8
__State$ = -28						; size = 4
__Meta$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_istream<char,std::char_traits<char> >::get, COMDAT
; _this$ = ecx

; 347  :     int_type __CLR_OR_THIS_CALL get() { // extract a metacharacter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 30	 sub	 esp, 48			; 00000030H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 348  :         int_type _Meta           = 0;
; 349  :         ios_base::iostate _State = ios_base::goodbit;

  00030	33 db		 xor	 ebx, ebx
  00032	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Meta$[ebp], 0

; 350  :         _Chcount                 = 0;

  00039	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  0003c	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx

; 87   :             const auto _Rdbuf = _Myistr.rdbuf();

  0003f	8b 06		 mov	 eax, DWORD PTR [esi]

; 348  :         int_type _Meta           = 0;
; 349  :         ios_base::iostate _State = ios_base::goodbit;

  00041	89 5d e4	 mov	 DWORD PTR __State$[ebp], ebx

; 86   :         __CLR_OR_THIS_CALL _Sentry_base(basic_istream& _Istr) : _Myistr(_Istr) {

  00044	89 75 d8	 mov	 DWORD PTR __Ok$[ebp], esi

; 87   :             const auto _Rdbuf = _Myistr.rdbuf();

  00047	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004a	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]

; 88   :             if (_Rdbuf) {

  0004e	85 c9		 test	 ecx, ecx
  00050	74 05		 je	 SHORT $LN17@get

; 89   :                 _Rdbuf->_Lock();

  00052	8b 01		 mov	 eax, DWORD PTR [ecx]
  00054	ff 50 04	 call	 DWORD PTR [eax+4]
$LN17@get:

; 108  :             : _Sentry_base(_Istr), _Ok(_Sentry_base::_Myistr._Ipfx(_Noskip)) {}

  00057	6a 01		 push	 1
  00059	8b ce		 mov	 ecx, esi
  0005b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00062	e8 00 00 00 00	 call	 ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
  00067	88 45 dc	 mov	 BYTE PTR __Ok$[ebp+4], al

; 351  :         const sentry _Ok(*this, true);

  0006a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  00071	84 c0		 test	 al, al

; 352  : 
; 353  :         if (!_Ok) {

  00073	75 08		 jne	 SHORT $LN2@get

; 354  :             _Meta = _Traits::eof(); // state not okay, return EOF

  00075	83 cf ff	 or	 edi, -1

; 355  :         } else { // state okay, extract a character

  00078	e9 a7 00 00 00	 jmp	 $LN11@get
$LN2@get:

; 357  :             _Meta = _Myios::rdbuf()->sgetc();

  0007d	8b 06		 mov	 eax, DWORD PTR [esi]
  0007f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00083	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00086	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  0008a	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0008d	8b 10		 mov	 edx, DWORD PTR [eax]
  0008f	85 d2		 test	 edx, edx
  00091	74 0d		 je	 SHORT $LN21@get
  00093	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00096	83 38 00	 cmp	 DWORD PTR [eax], 0
  00099	7e 05		 jle	 SHORT $LN21@get
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0009b	0f b6 3a	 movzx	 edi, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0009e	eb 07		 jmp	 SHORT $LN22@get
$LN21@get:
  000a0	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a2	ff 50 18	 call	 DWORD PTR [eax+24]
  000a5	8b f8		 mov	 edi, eax
$LN22@get:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 357  :             _Meta = _Myios::rdbuf()->sgetc();

  000a7	89 7d e8	 mov	 DWORD PTR __Meta$[ebp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  000aa	83 ff ff	 cmp	 edi, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 359  :             if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {

  000ad	75 05		 jne	 SHORT $LN5@get

; 360  :                 _State |= ios_base::eofbit | ios_base::failbit; // end of file

  000af	8d 5f 04	 lea	 ebx, DWORD PTR [edi+4]

; 361  :             } else { // got a character, count it

  000b2	eb 69		 jmp	 SHORT $LN6@get
$LN5@get:

; 362  :                 _Myios::rdbuf()->sbumpc();

  000b4	8b 06		 mov	 eax, DWORD PTR [esi]
  000b6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b9	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  000bd	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  000c0	83 38 00	 cmp	 DWORD PTR [eax], 0
  000c3	74 21		 je	 SHORT $LN39@get
  000c5	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  000c8	8b 02		 mov	 eax, DWORD PTR [edx]

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  000ca	85 c0		 test	 eax, eax
  000cc	7e 18		 jle	 SHORT $LN39@get

; 222  :         --*_IGcount;

  000ce	48		 dec	 eax
  000cf	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  000d1	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  000d4	ff 00		 inc	 DWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 363  :                 _Chcount = 1;

  000d6	c7 46 08 01 00
	00 00		 mov	 DWORD PTR [esi+8], 1
  000dd	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  000e4	eb 37		 jmp	 SHORT $LN6@get
$LN39@get:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  000e6	8b 01		 mov	 eax, DWORD PTR [ecx]
  000e8	ff 50 1c	 call	 DWORD PTR [eax+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 363  :                 _Chcount = 1;

  000eb	c7 46 08 01 00
	00 00		 mov	 DWORD PTR [esi+8], 1
  000f2	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  000f9	eb 22		 jmp	 SHORT $LN6@get
__catch$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$0:

; 364  :             }
; 365  :             _CATCH_IO_END

  000fb	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000fe	6a 01		 push	 1
  00100	6a 04		 push	 4
  00102	8b 02		 mov	 eax, DWORD PTR [edx]
  00104	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00107	03 ca		 add	 ecx, edx
  00109	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
  0010e	b8 00 00 00 00	 mov	 eax, $LN12@get
  00113	c3		 ret	 0
$LN12@get:
  00114	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00117	8b 7d e8	 mov	 edi, DWORD PTR __Meta$[ebp]
  0011a	8b 5d e4	 mov	 ebx, DWORD PTR __State$[ebp]
$LN6@get:

; 368  :         _Myios::setstate(_State);

  0011d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
$LN11@get:
  00124	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  00126	b9 04 00 00 00	 mov	 ecx, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 368  :         _Myios::setstate(_State);

  0012b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 51   :         clear(rdstate() | _State, _Reraise);

  0012e	8b 44 32 0c	 mov	 eax, DWORD PTR [edx+esi+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 368  :         _Myios::setstate(_State);

  00132	03 d6		 add	 edx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 51   :         clear(rdstate() | _State, _Reraise);

  00134	0b c3		 or	 eax, ebx

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  00136	33 db		 xor	 ebx, ebx
  00138	39 5a 38	 cmp	 DWORD PTR [edx+56], ebx
  0013b	0f 45 cb	 cmovne	 ecx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 155  :         _State &= _Statmask;

  0013e	0b c8		 or	 ecx, eax

; 156  :         _Mystate             = _State;
; 157  :         const auto _Filtered = _State & _Except;

  00140	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00143	83 e1 17	 and	 ecx, 23			; 00000017H
  00146	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00149	23 c1		 and	 eax, ecx

; 158  :         if (_Filtered) {

  0014b	75 2d		 jne	 SHORT $LN81@get
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 94   :             const auto _Rdbuf = _Myistr.rdbuf();

  0014d	8b 06		 mov	 eax, DWORD PTR [esi]
  0014f	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4
  00156	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00159	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]

; 95   :             if (_Rdbuf) {

  0015d	85 c9		 test	 ecx, ecx
  0015f	74 05		 je	 SHORT $LN73@get

; 96   :                 _Rdbuf->_Unlock();

  00161	8b 11		 mov	 edx, DWORD PTR [ecx]
  00163	ff 52 08	 call	 DWORD PTR [edx+8]
$LN73@get:

; 369  :         return _Meta;

  00166	8b c7		 mov	 eax, edi

; 370  :     }

  00168	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0016b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00172	59		 pop	 ecx
  00173	5f		 pop	 edi
  00174	5e		 pop	 esi
  00175	5b		 pop	 ebx
  00176	8b e5		 mov	 esp, ebp
  00178	5d		 pop	 ebp
  00179	c3		 ret	 0
$LN81@get:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 164  :             if (_Filtered & ios_base::badbit) {

  0017a	a8 04		 test	 al, 4
  0017c	74 07		 je	 SHORT $LN59@get

; 165  :                 _Msg = "ios_base::badbit set";

  0017e	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  00183	eb 0f		 jmp	 SHORT $LN61@get
$LN59@get:

; 166  :             } else if (_Filtered & ios_base::failbit) {

  00185	a8 02		 test	 al, 2
  00187	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
  0018c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
  00191	0f 44 f0	 cmove	 esi, eax
$LN61@get:

; 167  :                 _Msg = "ios_base::failbit set";
; 168  :             } else {
; 169  :                 _Msg = "ios_base::eofbit set";
; 170  :             }
; 171  : 
; 172  :             _THROW(failure(_Msg));

  00194	8d 45 e0	 lea	 eax, DWORD PTR $T3[ebp]
  00197	6a 01		 push	 1
  00199	50		 push	 eax
  0019a	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  0019f	83 c4 08	 add	 esp, 8
  001a2	8d 4d c4	 lea	 ecx, DWORD PTR $T2[ebp]
  001a5	50		 push	 eax
  001a6	56		 push	 esi
  001a7	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  001ac	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  001b1	8d 45 c4	 lea	 eax, DWORD PTR $T2[ebp]
  001b4	50		 push	 eax
  001b5	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN79@get:
  001ba	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$3:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$2:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a c0	 mov	 ecx, DWORD PTR [edx-64]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::get
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
;	COMDAT ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT
$T2 = -76						; size = 20
$T3 = -56						; size = 20
$T4 = -36						; size = 8
$T5 = -36						; size = 8
$T6 = -28						; size = 8
_this$ = -24						; size = 4
__Eof$1$ = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Noskip$ = 8						; size = 1
__Ctype_fac$1$ = 8					; size = 4
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Ipfx, COMDAT
; _this$ = ecx

; 121  :     bool __CLR_OR_THIS_CALL _Ipfx(bool _Noskip = false) { // test stream state and skip whitespace as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d9		 mov	 ebx, ecx
  0002d	89 5d e8	 mov	 DWORD PTR _this$[ebp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 206  :         return rdstate() == ios_base::goodbit;

  00030	8b 03		 mov	 eax, DWORD PTR [ebx]
  00032	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00035	03 cb		 add	 ecx, ebx
  00037	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0003a	85 d2		 test	 edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 122  :         if (!this->good()) {

  0003c	74 39		 je	 SHORT $LN5@Ipfx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  0003e	33 f6		 xor	 esi, esi
  00040	b8 04 00 00 00	 mov	 eax, 4
  00045	39 71 38	 cmp	 DWORD PTR [ecx+56], esi
  00048	0f 45 c6	 cmovne	 eax, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 155  :         _State &= _Statmask;

  0004b	0b c2		 or	 eax, edx
  0004d	83 e0 15	 and	 eax, 21			; 00000015H
  00050	83 c8 02	 or	 eax, 2

; 156  :         _Mystate             = _State;

  00053	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 157  :         const auto _Filtered = _State & _Except;

  00056	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00059	23 c8		 and	 ecx, eax

; 158  :         if (_Filtered) {

  0005b	0f 85 d5 01 00
	00		 jne	 $LN147@Ipfx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 124  :             return false;

  00061	32 c0		 xor	 al, al

; 156  :     }

  00063	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00066	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006d	59		 pop	 ecx
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c2 04 00	 ret	 4
$LN5@Ipfx:

; 125  :         }
; 126  : 
; 127  :         // state okay, flush tied stream and skip whitespace
; 128  :         const auto _Tied = _Myios::tie();

  00077	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]

; 129  :         if (_Tied) {

  0007a	85 c9		 test	 ecx, ecx
  0007c	74 05		 je	 SHORT $LN6@Ipfx

; 130  :             _Tied->flush();

  0007e	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN6@Ipfx:

; 131  :         }
; 132  : 
; 133  :         bool _Eof = false;
; 134  :         if (!_Noskip && this->flags() & ios_base::skipws) { // skip whitespace

  00083	80 7d 08 00	 cmp	 BYTE PTR __Noskip$[ebp], 0
  00087	c6 45 ef 00	 mov	 BYTE PTR __Eof$1$[ebp], 0
  0008b	0f 85 84 01 00
	00		 jne	 $LN30@Ipfx
  00091	8b 03		 mov	 eax, DWORD PTR [ebx]
  00093	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00096	f6 44 18 14 01	 test	 BYTE PTR [eax+ebx+20], 1
  0009b	0f 84 74 01 00
	00		 je	 $LN30@Ipfx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 289  :         return *_Ploc;

  000a1	8b 44 18 30	 mov	 eax, DWORD PTR [eax+ebx+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  000a5	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 269  :         _Ptr->_Incref();

  000a8	8b ce		 mov	 ecx, esi
  000aa	89 75 e0	 mov	 DWORD PTR $T4[ebp+4], esi
  000ad	8b 06		 mov	 eax, DWORD PTR [esi]
  000af	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 135  :             const _Ctype& _Ctype_fac = _STD use_facet<_Ctype>(this->getloc());

  000b2	8d 45 dc	 lea	 eax, DWORD PTR $T4[ebp]
  000b5	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  000c2	83 c4 04	 add	 esp, 4
  000c5	8b f8		 mov	 edi, eax
  000c7	89 7d 08	 mov	 DWORD PTR __Ctype_fac$1$[ebp], edi
  000ca	85 f6		 test	 esi, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  000cc	74 15		 je	 SHORT $LN123@Ipfx

; 355  :             delete _Ptr->_Decref();

  000ce	8b 16		 mov	 edx, DWORD PTR [esi]
  000d0	8b ce		 mov	 ecx, esi
  000d2	ff 52 08	 call	 DWORD PTR [edx+8]
  000d5	85 c0		 test	 eax, eax
  000d7	74 0a		 je	 SHORT $LN123@Ipfx
  000d9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000db	6a 01		 push	 1
  000dd	8b 11		 mov	 edx, DWORD PTR [ecx]
  000df	8b c8		 mov	 ecx, eax
  000e1	ff d2		 call	 edx
$LN123@Ipfx:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 138  :             int_type _Meta = _Myios::rdbuf()->sgetc();

  000e3	8b 03		 mov	 eax, DWORD PTR [ebx]
  000e5	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  000ec	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000ef	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  000f3	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  000f6	8b 10		 mov	 edx, DWORD PTR [eax]
  000f8	85 d2		 test	 edx, edx
  000fa	74 0d		 je	 SHORT $LN128@Ipfx
  000fc	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  000ff	83 38 00	 cmp	 DWORD PTR [eax], 0
  00102	7e 05		 jle	 SHORT $LN128@Ipfx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00104	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00107	eb 07		 jmp	 SHORT $LL4@Ipfx
$LN128@Ipfx:
  00109	8b 01		 mov	 eax, DWORD PTR [ecx]
  0010b	ff 50 18	 call	 DWORD PTR [eax+24]
  0010e	66 90		 npad	 2
$LL4@Ipfx:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00110	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 141  :                 if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit

  00113	75 04		 jne	 SHORT $LN9@Ipfx

; 142  :                     _Eof = true;

  00115	b0 01		 mov	 al, 1

; 143  :                     break;

  00117	eb 0f		 jmp	 SHORT $LN3@Ipfx
$LN9@Ipfx:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 2703 :         return (_Ctype._Table[static_cast<unsigned char>(_Ch)] & _Maskval) != 0;

  00119	0f b6 c8	 movzx	 ecx, al
  0011c	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0011f	f6 04 48 48	 test	 BYTE PTR [eax+ecx*2], 72 ; 00000048H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 144  :                 } else if (!_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta))) {

  00123	75 42		 jne	 SHORT $LN2@Ipfx
  00125	8a 45 ef	 mov	 al, BYTE PTR __Eof$1$[ebp]
$LN3@Ipfx:
  00128	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 149  :         }
; 150  : 
; 151  :         if (_Eof) {

  0012f	84 c0		 test	 al, al
  00131	0f 84 de 00 00
	00		 je	 $LN30@Ipfx

; 152  :             _Myios::setstate(ios_base::eofbit | ios_base::failbit);

  00137	8b 03		 mov	 eax, DWORD PTR [ebx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  00139	33 d2		 xor	 edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 152  :             _Myios::setstate(ios_base::eofbit | ios_base::failbit);

  0013b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  0013e	b8 04 00 00 00	 mov	 eax, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 152  :             _Myios::setstate(ios_base::eofbit | ios_base::failbit);

  00143	03 cb		 add	 ecx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  00145	39 51 38	 cmp	 DWORD PTR [ecx+56], edx
  00148	0f 45 c2	 cmovne	 eax, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 155  :         _State &= _Statmask;

  0014b	0b 41 0c	 or	 eax, DWORD PTR [ecx+12]
  0014e	83 e0 14	 and	 eax, 20			; 00000014H
  00151	83 c8 03	 or	 eax, 3

; 156  :         _Mystate             = _State;

  00154	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 157  :         const auto _Filtered = _State & _Except;

  00157	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0015a	23 c8		 and	 ecx, eax

; 158  :         if (_Filtered) {

  0015c	0f 85 16 01 00
	00		 jne	 $LN148@Ipfx
  00162	e9 ae 00 00 00	 jmp	 $LN30@Ipfx
$LN2@Ipfx:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 140  :             for (;; _Meta = _Myios::rdbuf()->snextc()) {

  00167	8b 03		 mov	 eax, DWORD PTR [ebx]
  00169	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0016c	8b 74 18 38	 mov	 esi, DWORD PTR [eax+ebx+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  00170	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00173	83 38 00	 cmp	 DWORD PTR [eax], 0
  00176	74 39		 je	 SHORT $LN70@Ipfx

; 138  :         return 1 < _Gnavail()                                 ? _Traits::to_int_type(*_Gnpreinc())

  00178	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  0017b	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0017d	83 f9 01	 cmp	 ecx, 1
  00180	7e 17		 jle	 SHORT $LN66@Ipfx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 140  :             for (;; _Meta = _Myios::rdbuf()->snextc()) {

  00182	8b 7d 08	 mov	 edi, DWORD PTR __Ctype_fac$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 227  :         --*_IGcount;

  00185	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00188	89 02		 mov	 DWORD PTR [edx], eax

; 228  :         return ++(*_IGnext);

  0018a	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0018d	ff 00		 inc	 DWORD PTR [eax]
  0018f	8b 00		 mov	 eax, DWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00191	0f b6 00	 movzx	 eax, BYTE PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 140  :             for (;; _Meta = _Myios::rdbuf()->snextc()) {

  00194	e9 77 ff ff ff	 jmp	 $LL4@Ipfx
$LN66@Ipfx:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  00199	85 c9		 test	 ecx, ecx
  0019b	7e 14		 jle	 SHORT $LN70@Ipfx

; 222  :         --*_IGcount;

  0019d	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  001a0	89 02		 mov	 DWORD PTR [edx], eax

; 223  :         return (*_IGnext)++;

  001a2	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  001a5	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a7	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  001aa	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  001ac	0f b6 02	 movzx	 eax, BYTE PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  001af	eb 07		 jmp	 SHORT $LN82@Ipfx
$LN70@Ipfx:
  001b1	8b 06		 mov	 eax, DWORD PTR [esi]
  001b3	8b ce		 mov	 ecx, esi
  001b5	ff 50 1c	 call	 DWORD PTR [eax+28]
$LN82@Ipfx:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  001b8	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 138  :         return 1 < _Gnavail()                                 ? _Traits::to_int_type(*_Gnpreinc())

  001bb	75 0a		 jne	 SHORT $LN64@Ipfx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 140  :             for (;; _Meta = _Myios::rdbuf()->snextc()) {

  001bd	8b 7d 08	 mov	 edi, DWORD PTR __Ctype_fac$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 138  :         return 1 < _Gnavail()                                 ? _Traits::to_int_type(*_Gnpreinc())

  001c0	0b c0		 or	 eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 140  :             for (;; _Meta = _Myios::rdbuf()->snextc()) {

  001c2	e9 49 ff ff ff	 jmp	 $LL4@Ipfx
$LN64@Ipfx:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

  001c7	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  001ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  001cc	85 c9		 test	 ecx, ecx
  001ce	74 13		 je	 SHORT $LN99@Ipfx
  001d0	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  001d3	83 38 00	 cmp	 DWORD PTR [eax], 0
  001d6	7e 0b		 jle	 SHORT $LN99@Ipfx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  001d8	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 140  :             for (;; _Meta = _Myios::rdbuf()->snextc()) {

  001db	8b 7d 08	 mov	 edi, DWORD PTR __Ctype_fac$1$[ebp]
  001de	e9 2d ff ff ff	 jmp	 $LL4@Ipfx
$LN99@Ipfx:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  001e3	8b 06		 mov	 eax, DWORD PTR [esi]
  001e5	8b ce		 mov	 ecx, esi
  001e7	ff 50 18	 call	 DWORD PTR [eax+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 140  :             for (;; _Meta = _Myios::rdbuf()->snextc()) {

  001ea	8b 7d 08	 mov	 edi, DWORD PTR __Ctype_fac$1$[ebp]
  001ed	e9 1e ff ff ff	 jmp	 $LL4@Ipfx
__catch$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$0:

; 145  :                     break; // not whitespace, quit
; 146  :                 }
; 147  :             }
; 148  :             _CATCH_IO_END

  001f2	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  001f5	6a 01		 push	 1
  001f7	6a 04		 push	 4
  001f9	8b 02		 mov	 eax, DWORD PTR [edx]
  001fb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001fe	03 ca		 add	 ecx, edx
  00200	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
  00205	b8 00 00 00 00	 mov	 eax, $LN18@Ipfx
  0020a	c3		 ret	 0
$LN18@Ipfx:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
  0020b	8b 5d e8	 mov	 ebx, DWORD PTR _this$[ebp]
  0020e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN30@Ipfx:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 206  :         return rdstate() == ios_base::goodbit;

  00215	8b 03		 mov	 eax, DWORD PTR [ebx]
  00217	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0021a	83 7c 18 0c 00	 cmp	 DWORD PTR [eax+ebx+12], 0
  0021f	0f 94 c0	 sete	 al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 156  :     }

  00222	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00225	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0022c	59		 pop	 ecx
  0022d	5f		 pop	 edi
  0022e	5e		 pop	 esi
  0022f	5b		 pop	 ebx
  00230	8b e5		 mov	 esp, ebp
  00232	5d		 pop	 ebp
  00233	c2 04 00	 ret	 4
$LN147@Ipfx:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 164  :             if (_Filtered & ios_base::badbit) {

  00236	f6 c1 04	 test	 cl, 4
  00239	74 07		 je	 SHORT $LN52@Ipfx

; 165  :                 _Msg = "ios_base::badbit set";

  0023b	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  00240	eb 10		 jmp	 SHORT $LN54@Ipfx
$LN52@Ipfx:

; 166  :             } else if (_Filtered & ios_base::failbit) {

  00242	f6 c1 02	 test	 cl, 2
  00245	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
  0024a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
  0024f	0f 44 f0	 cmove	 esi, eax
$LN54@Ipfx:

; 167  :                 _Msg = "ios_base::failbit set";
; 168  :             } else {
; 169  :                 _Msg = "ios_base::eofbit set";
; 170  :             }
; 171  : 
; 172  :             _THROW(failure(_Msg));

  00252	8d 45 dc	 lea	 eax, DWORD PTR $T5[ebp]
  00255	6a 01		 push	 1
  00257	50		 push	 eax
  00258	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  0025d	83 c4 08	 add	 esp, 8
  00260	8d 4d c8	 lea	 ecx, DWORD PTR $T3[ebp]
  00263	50		 push	 eax
  00264	56		 push	 esi
  00265	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  0026a	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  0026f	8d 45 c8	 lea	 eax, DWORD PTR $T3[ebp]
  00272	50		 push	 eax
  00273	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN148@Ipfx:

; 164  :             if (_Filtered & ios_base::badbit) {

  00278	f6 c1 04	 test	 cl, 4
  0027b	74 07		 je	 SHORT $LN32@Ipfx

; 165  :                 _Msg = "ios_base::badbit set";

  0027d	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  00282	eb 10		 jmp	 SHORT $LN34@Ipfx
$LN32@Ipfx:

; 166  :             } else if (_Filtered & ios_base::failbit) {

  00284	f6 c1 02	 test	 cl, 2
  00287	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
  0028c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
  00291	0f 44 f0	 cmove	 esi, eax
$LN34@Ipfx:

; 167  :                 _Msg = "ios_base::failbit set";
; 168  :             } else {
; 169  :                 _Msg = "ios_base::eofbit set";
; 170  :             }
; 171  : 
; 172  :             _THROW(failure(_Msg));

  00294	8d 45 e4	 lea	 eax, DWORD PTR $T6[ebp]
  00297	6a 01		 push	 1
  00299	50		 push	 eax
  0029a	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  0029f	83 c4 08	 add	 esp, 8
  002a2	8d 4d b4	 lea	 ecx, DWORD PTR $T2[ebp]
  002a5	50		 push	 eax
  002a6	56		 push	 esi
  002a7	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  002ac	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  002b1	8d 45 b4	 lea	 eax, DWORD PTR $T2[ebp]
  002b4	50		 push	 eax
  002b5	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN145@Ipfx:
  002ba	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$2:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR $T4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
;	COMDAT ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 78   :     __CLR_OR_THIS_CALL ~basic_istream() noexcept override {}

  00000	8b 41 e8	 mov	 eax, DWORD PTR [ecx-24]
  00003	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00006	c7 44 08 e8 00
	00 00 00	 mov	 DWORD PTR [eax+ecx-24], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  0000e	8b 41 e8	 mov	 eax, DWORD PTR [ecx-24]
  00011	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00014	8d 42 e8	 lea	 eax, DWORD PTR [edx-24]
  00017	89 44 0a e4	 mov	 DWORD PTR [edx+ecx-28], eax
  0001b	c3		 ret	 0
??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 3445 :     basic_ostream<_Elem, _Traits>& _Ostr, const basic_string<_Elem, _Traits, _Alloc>& _Str) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3446 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Str$[ebp]

; 453  :         return _Myres > _Small_string_capacity;

  00006	83 78 14 07	 cmp	 DWORD PTR [eax+20], 7

; 3446 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

  0000a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]

; 445  :         if (_Large_mode_engaged()) {

  0000d	76 02		 jbe	 SHORT $LN7@operator

; 446  :             _Result = _Unfancy(_Bx._Ptr);

  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN7@operator:

; 3446 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

  00011	51		 push	 ecx
  00012	50		 push	 eax
  00013	ff 75 08	 push	 DWORD PTR __Ostr$[ebp]
  00016	e8 00 00 00 00	 call	 ??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z ; std::_Insert_string<wchar_t,std::char_traits<wchar_t>,unsigned int>
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3447 : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
$T2 = -76						; size = 20
__Pad$ = -56						; size = 8
__Ok$ = -56						; size = 8
$T3 = -48						; size = 8
$T4 = -48						; size = 8
tv980 = -44						; size = 4
$T5 = -44						; size = 4
__Ctype_fac$1$ = -40					; size = 4
$T6 = -40						; size = 4
__Byte$ = -36						; size = 1
$T7 = -36						; size = 4
__Count$1$ = -32					; size = 4
tv942 = -28						; size = 4
tv984 = -28						; size = 4
$T8 = -28						; size = 4
__State$ = -24						; size = 4
__Count$2$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<wchar_t,std::char_traits<wchar_t> >, COMDAT

; 688  : basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const char* _Val) { // insert NTBS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 689  :     ios_base::iostate _State = ios_base::goodbit;
; 690  :     streamsize _Count        = static_cast<streamsize>(_CSTD strlen(_Val));

  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0002e	33 f6		 xor	 esi, esi
  00030	89 75 e8	 mov	 DWORD PTR __State$[ebp], esi
  00033	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL151@operator:
  00036	8a 01		 mov	 al, BYTE PTR [ecx]
  00038	41		 inc	 ecx
  00039	84 c0		 test	 al, al
  0003b	75 f9		 jne	 SHORT $LL151@operator
  0003d	2b ca		 sub	 ecx, edx
  0003f	89 75 e0	 mov	 DWORD PTR __Count$1$[ebp], esi

; 691  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  00042	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00045	89 4d ec	 mov	 DWORD PTR __Count$2$[ebp], ecx
  00048	8b 02		 mov	 eax, DWORD PTR [edx]
  0004a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004d	8b 5c 10 24	 mov	 ebx, DWORD PTR [eax+edx+36]
  00051	8b 7c 10 20	 mov	 edi, DWORD PTR [eax+edx+32]
  00055	85 db		 test	 ebx, ebx
  00057	7c 18		 jl	 SHORT $LN133@operator
  00059	7f 04		 jg	 SHORT $LN152@operator
  0005b	85 ff		 test	 edi, edi
  0005d	74 12		 je	 SHORT $LN133@operator
$LN152@operator:
  0005f	33 c0		 xor	 eax, eax
  00061	3b d8		 cmp	 ebx, eax
  00063	7c 0c		 jl	 SHORT $LN133@operator
  00065	7f 04		 jg	 SHORT $LN153@operator
  00067	3b f9		 cmp	 edi, ecx
  00069	76 06		 jbe	 SHORT $LN133@operator
$LN153@operator:
  0006b	2b f9		 sub	 edi, ecx
  0006d	1b d8		 sbb	 ebx, eax
  0006f	eb 0e		 jmp	 SHORT $LN21@operator
$LN133@operator:
  00071	0f 57 c0	 xorps	 xmm0, xmm0
  00074	66 0f 13 45 c8	 movlpd	 QWORD PTR __Pad$[ebp], xmm0
  00079	8b 5d cc	 mov	 ebx, DWORD PTR __Pad$[ebp+4]
  0007c	8b 7d c8	 mov	 edi, DWORD PTR __Pad$[ebp]
$LN21@operator:

; 692  :     const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

  0007f	52		 push	 edx
  00080	8d 4d c8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00083	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry

; 693  : 
; 694  :     if (!_Ok) {

  00088	80 7d cc 00	 cmp	 BYTE PTR __Ok$[ebp+4], 0
  0008c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00093	75 0c		 jne	 SHORT $LN11@operator

; 695  :         _State |= ios_base::badbit;

  00095	be 04 00 00 00	 mov	 esi, 4

; 696  :     } else { // state okay, insert characters

  0009a	8b d6		 mov	 edx, esi
  0009c	e9 2a 02 00 00	 jmp	 $LN163@operator
$LN11@operator:

; 698  :         const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Ostr.getloc());

  000a1	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000a4	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 289  :         return *_Ploc;

  000a9	8b 44 08 30	 mov	 eax, DWORD PTR [eax+ecx+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  000ad	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b0	89 4d e4	 mov	 DWORD PTR $T8[ebp], ecx
  000b3	89 4d d4	 mov	 DWORD PTR $T3[ebp+4], ecx

; 269  :         _Ptr->_Incref();

  000b6	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b8	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 698  :         const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Ostr.getloc());

  000bb	8d 45 d0	 lea	 eax, DWORD PTR $T3[ebp]
  000be	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
  000c8	8b 4d e4	 mov	 ecx, DWORD PTR $T8[ebp]
  000cb	83 c4 04	 add	 esp, 4
  000ce	89 45 d8	 mov	 DWORD PTR __Ctype_fac$1$[ebp], eax
  000d1	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  000d5	85 c9		 test	 ecx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  000d7	74 11		 je	 SHORT $LN116@operator

; 355  :             delete _Ptr->_Decref();

  000d9	8b 01		 mov	 eax, DWORD PTR [ecx]
  000db	ff 50 08	 call	 DWORD PTR [eax+8]
  000de	8b c8		 mov	 ecx, eax
  000e0	85 c9		 test	 ecx, ecx
  000e2	74 06		 je	 SHORT $LN116@operator
  000e4	8b 01		 mov	 eax, DWORD PTR [ecx]
  000e6	6a 01		 push	 1
  000e8	ff 10		 call	 DWORD PTR [eax]
$LN116@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 699  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  000ea	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000ed	8b 02		 mov	 eax, DWORD PTR [edx]
  000ef	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000f2	8b 44 10 14	 mov	 eax, DWORD PTR [eax+edx+20]
  000f6	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000fb	83 f8 40	 cmp	 eax, 64			; 00000040H
  000fe	74 62		 je	 SHORT $LN157@operator
$LL4@operator:

; 700  :             for (; 0 < _Pad; --_Pad) { // pad on left

  00100	85 db		 test	 ebx, ebx
  00102	7c 5e		 jl	 SHORT $LN157@operator
  00104	7f 04		 jg	 SHORT $LN154@operator
  00106	85 ff		 test	 edi, edi
  00108	74 58		 je	 SHORT $LN157@operator
$LN154@operator:

; 701  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  0010a	8b 02		 mov	 eax, DWORD PTR [edx]
  0010c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0010f	8b 4c 10 38	 mov	 ecx, DWORD PTR [eax+edx+56]
  00113	0f b7 54 10 40	 movzx	 edx, WORD PTR [eax+edx+64]
  00118	89 55 dc	 mov	 DWORD PTR $T7[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 261  :         return *_IPnext ? *_IPcount : 0;

  0011b	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0011e	83 38 00	 cmp	 DWORD PTR [eax], 0
  00121	74 21		 je	 SHORT $LN144@operator
  00123	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00126	8b 00		 mov	 eax, DWORD PTR [eax]

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  00128	85 c0		 test	 eax, eax
  0012a	7e 18		 jle	 SHORT $LN144@operator

; 256  :         --*_IPcount;

  0012c	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0012f	48		 dec	 eax
  00130	89 02		 mov	 DWORD PTR [edx], eax

; 257  :         return (*_IPnext)++;

  00132	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00135	8b 11		 mov	 edx, DWORD PTR [ecx]
  00137	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  0013a	89 01		 mov	 DWORD PTR [ecx], eax

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  0013c	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  0013f	66 89 02	 mov	 WORD PTR [edx], ax
  00142	eb 06		 jmp	 SHORT $LN164@operator
$LN144@operator:
  00144	8b 01		 mov	 eax, DWORD PTR [ecx]
  00146	52		 push	 edx
  00147	ff 50 0c	 call	 DWORD PTR [eax+12]
$LN164@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 701  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  0014a	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 367  :         return _Left == _Right;

  0014d	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00152	0f b7 c0	 movzx	 eax, ax
  00155	66 3b c8	 cmp	 cx, ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 701  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00158	75 75		 jne	 SHORT $LN2@operator

; 702  :                     _State |= ios_base::badbit; // insertion failed, quit

  0015a	be 04 00 00 00	 mov	 esi, 4
  0015f	89 75 e8	 mov	 DWORD PTR __State$[ebp], esi
$LN157@operator:
  00162	8b 45 ec	 mov	 eax, DWORD PTR __Count$2$[ebp]
  00165	33 c9		 xor	 ecx, ecx
$LL7@operator:

; 708  :         for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val) {

  00167	85 f6		 test	 esi, esi
  00169	0f 85 00 01 00
	00		 jne	 $LN9@operator
  0016f	85 c9		 test	 ecx, ecx
  00171	0f 8c 9e 00 00
	00		 jl	 $LL10@operator
  00177	7f 08		 jg	 SHORT $LN155@operator
  00179	85 c0		 test	 eax, eax
  0017b	0f 84 94 00 00
	00		 je	 $LL10@operator
$LN155@operator:

; 709  :             if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val)))) {

  00181	8b 02		 mov	 eax, DWORD PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 2931 :         return do_widen(_Byte);

  00183	8b 4d d8	 mov	 ecx, DWORD PTR __Ctype_fac$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 709  :             if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val)))) {

  00186	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00189	8b 44 10 38	 mov	 eax, DWORD PTR [eax+edx+56]
  0018d	89 45 d4	 mov	 DWORD PTR $T5[ebp], eax
  00190	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00193	8a 00		 mov	 al, BYTE PTR [eax]
  00195	88 45 dc	 mov	 BYTE PTR __Byte$[ebp], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 2931 :         return do_widen(_Byte);

  00198	8b 01		 mov	 eax, DWORD PTR [ecx]
  0019a	ff 75 dc	 push	 DWORD PTR __Byte$[ebp]
  0019d	ff 50 30	 call	 DWORD PTR [eax+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 261  :         return *_IPnext ? *_IPcount : 0;

  001a0	8b 4d d4	 mov	 ecx, DWORD PTR $T5[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 2931 :         return do_widen(_Byte);

  001a3	0f b7 c0	 movzx	 eax, ax
  001a6	89 45 e4	 mov	 DWORD PTR tv942[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 261  :         return *_IPnext ? *_IPcount : 0;

  001a9	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  001ac	83 38 00	 cmp	 DWORD PTR [eax], 0
  001af	74 29		 je	 SHORT $LN145@operator
  001b1	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  001b4	8b 02		 mov	 eax, DWORD PTR [edx]

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  001b6	85 c0		 test	 eax, eax
  001b8	7e 20		 jle	 SHORT $LN145@operator

; 256  :         --*_IPcount;

  001ba	48		 dec	 eax
  001bb	89 02		 mov	 DWORD PTR [edx], eax

; 257  :         return (*_IPnext)++;

  001bd	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  001c0	8b 11		 mov	 edx, DWORD PTR [ecx]
  001c2	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  001c5	89 01		 mov	 DWORD PTR [ecx], eax

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  001c7	8b 45 e4	 mov	 eax, DWORD PTR tv942[ebp]
  001ca	66 89 02	 mov	 WORD PTR [edx], ax
  001cd	eb 13		 jmp	 SHORT $LN165@operator
$LN2@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 700  :             for (; 0 < _Pad; --_Pad) { // pad on left

  001cf	83 c7 ff	 add	 edi, -1
  001d2	83 d3 ff	 adc	 ebx, -1
  001d5	e9 26 ff ff ff	 jmp	 $LL4@operator
$LN145@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  001da	8b 01		 mov	 eax, DWORD PTR [ecx]
  001dc	ff 75 e4	 push	 DWORD PTR tv942[ebp]
  001df	ff 50 0c	 call	 DWORD PTR [eax+12]
$LN165@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 708  :         for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val) {

  001e2	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 367  :         return _Left == _Right;

  001e5	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  001ea	0f b7 c0	 movzx	 eax, ax
  001ed	66 3b c8	 cmp	 cx, ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 708  :         for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val) {

  001f0	8b 4d e0	 mov	 ecx, DWORD PTR __Count$1$[ebp]

; 709  :             if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val)))) {

  001f3	b8 04 00 00 00	 mov	 eax, 4
  001f8	0f 44 f0	 cmove	 esi, eax
  001fb	8b 45 ec	 mov	 eax, DWORD PTR __Count$2$[ebp]
  001fe	83 c0 ff	 add	 eax, -1
  00201	89 75 e8	 mov	 DWORD PTR __State$[ebp], esi
  00204	89 45 ec	 mov	 DWORD PTR __Count$2$[ebp], eax
  00207	83 d1 ff	 adc	 ecx, -1
  0020a	ff 45 0c	 inc	 DWORD PTR __Val$[ebp]
  0020d	89 4d e0	 mov	 DWORD PTR __Count$1$[ebp], ecx
  00210	e9 52 ff ff ff	 jmp	 $LL7@operator
$LL10@operator:

; 715  :             for (; 0 < _Pad; --_Pad) { // pad on right

  00215	85 db		 test	 ebx, ebx
  00217	7c 56		 jl	 SHORT $LN9@operator
  00219	7f 04		 jg	 SHORT $LN156@operator
  0021b	85 ff		 test	 edi, edi
  0021d	74 50		 je	 SHORT $LN9@operator
$LN156@operator:

; 716  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  0021f	8b 02		 mov	 eax, DWORD PTR [edx]
  00221	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00224	8b 4c 10 38	 mov	 ecx, DWORD PTR [eax+edx+56]
  00228	0f b7 54 10 40	 movzx	 edx, WORD PTR [eax+edx+64]
  0022d	89 55 d8	 mov	 DWORD PTR $T6[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 261  :         return *_IPnext ? *_IPcount : 0;

  00230	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00233	83 38 00	 cmp	 DWORD PTR [eax], 0
  00236	74 21		 je	 SHORT $LN146@operator
  00238	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0023b	8b 00		 mov	 eax, DWORD PTR [eax]

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  0023d	85 c0		 test	 eax, eax
  0023f	7e 18		 jle	 SHORT $LN146@operator

; 256  :         --*_IPcount;

  00241	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00244	48		 dec	 eax
  00245	89 02		 mov	 DWORD PTR [edx], eax

; 257  :         return (*_IPnext)++;

  00247	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  0024a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0024c	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  0024f	89 01		 mov	 DWORD PTR [ecx], eax

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  00251	8b 45 d8	 mov	 eax, DWORD PTR $T6[ebp]
  00254	66 89 02	 mov	 WORD PTR [edx], ax
  00257	eb 06		 jmp	 SHORT $LN166@operator
$LN146@operator:
  00259	8b 01		 mov	 eax, DWORD PTR [ecx]
  0025b	52		 push	 edx
  0025c	ff 50 0c	 call	 DWORD PTR [eax+12]
$LN166@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 367  :         return _Left == _Right;

  0025f	0f b7 c0	 movzx	 eax, ax
  00262	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00267	66 3b c8	 cmp	 cx, ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 716  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  0026a	75 29		 jne	 SHORT $LN8@operator

; 717  :                     _State |= ios_base::badbit; // insertion failed, quit

  0026c	83 ce 04	 or	 esi, 4
$LN9@operator:

; 718  :                     break;
; 719  :                 }
; 720  :             }
; 721  :         }
; 722  : 
; 723  :         _Ostr.width(0);

  0026f	8b 5d 08	 mov	 ebx, DWORD PTR __Ostr$[ebp]
  00272	ba 04 00 00 00	 mov	 edx, 4
  00277	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0027e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00280	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 284  :         _Wide                      = _Newwidth;

  00283	c7 44 18 20 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+32], 0
  0028b	c7 44 18 24 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+36], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
  00293	eb 39		 jmp	 SHORT $LN26@operator
$LN8@operator:

; 715  :             for (; 0 < _Pad; --_Pad) { // pad on right

  00295	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00298	83 c7 ff	 add	 edi, -1
  0029b	83 d3 ff	 adc	 ebx, -1
  0029e	e9 72 ff ff ff	 jmp	 $LL10@operator
__catch$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$0:

; 724  :         _CATCH_IO_(ios_base, _Ostr)

  002a3	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  002a6	6a 01		 push	 1
  002a8	6a 04		 push	 4
  002aa	8b 02		 mov	 eax, DWORD PTR [edx]
  002ac	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002af	03 ca		 add	 ecx, edx
  002b1	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::setstate
  002b6	b8 00 00 00 00	 mov	 eax, $LN27@operator
  002bb	c3		 ret	 0
$LN27@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
  002bc	8b 75 e8	 mov	 esi, DWORD PTR __State$[ebp]
  002bf	ba 04 00 00 00	 mov	 edx, 4
  002c4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN163@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 727  :     _Ostr.setstate(_State);

  002cb	8b 5d 08	 mov	 ebx, DWORD PTR __Ostr$[ebp]
$LN26@operator:
  002ce	8b 03		 mov	 eax, DWORD PTR [ebx]
  002d0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 51   :         clear(rdstate() | _State, _Reraise);

  002d3	8b 44 19 0c	 mov	 eax, DWORD PTR [ecx+ebx+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 727  :     _Ostr.setstate(_State);

  002d7	03 cb		 add	 ecx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 51   :         clear(rdstate() | _State, _Reraise);

  002d9	0b c6		 or	 eax, esi

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  002db	33 f6		 xor	 esi, esi
  002dd	39 71 38	 cmp	 DWORD PTR [ecx+56], esi
  002e0	0f 45 d6	 cmovne	 edx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 155  :         _State &= _Statmask;

  002e3	0b d0		 or	 edx, eax

; 156  :         _Mystate             = _State;
; 157  :         const auto _Filtered = _State & _Except;

  002e5	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  002e8	83 e2 17	 and	 edx, 23			; 00000017H
  002eb	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  002ee	23 c2		 and	 eax, edx

; 158  :         if (_Filtered) {

  002f0	75 41		 jne	 SHORT $LN168@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 111  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  002f2	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception

; 112  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 113  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 114  : #endif // ^^^ !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION ^^^
; 115  : 
; 116  :             if (_Zero_uncaught_exceptions) {

  002f7	84 c0		 test	 al, al
  002f9	75 08		 jne	 SHORT $LN44@operator

; 117  :                 this->_Myostr._Osfx();

  002fb	8b 4d c8	 mov	 ecx, DWORD PTR __Ok$[ebp]
  002fe	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
$LN44@operator:

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

  00303	8b 4d c8	 mov	 ecx, DWORD PTR __Ok$[ebp]
  00306	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4
  0030d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0030f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00312	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]

; 78   :             if (_Rdbuf) {

  00316	85 c9		 test	 ecx, ecx
  00318	74 05		 je	 SHORT $LN50@operator

; 79   :                 _Rdbuf->_Unlock();

  0031a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0031c	ff 52 08	 call	 DWORD PTR [edx+8]
$LN50@operator:

; 728  :     return _Ostr;

  0031f	8b c3		 mov	 eax, ebx

; 729  : }

  00321	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00324	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0032b	59		 pop	 ecx
  0032c	5f		 pop	 edi
  0032d	5e		 pop	 esi
  0032e	5b		 pop	 ebx
  0032f	8b e5		 mov	 esp, ebp
  00331	5d		 pop	 ebp
  00332	c3		 ret	 0
$LN168@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 164  :             if (_Filtered & ios_base::badbit) {

  00333	a8 04		 test	 al, 4
  00335	74 07		 je	 SHORT $LN35@operator

; 165  :                 _Msg = "ios_base::badbit set";

  00337	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  0033c	eb 0f		 jmp	 SHORT $LN37@operator
$LN35@operator:

; 166  :             } else if (_Filtered & ios_base::failbit) {

  0033e	a8 02		 test	 al, 2
  00340	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
  00345	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
  0034a	0f 44 f0	 cmove	 esi, eax
$LN37@operator:

; 167  :                 _Msg = "ios_base::failbit set";
; 168  :             } else {
; 169  :                 _Msg = "ios_base::eofbit set";
; 170  :             }
; 171  : 
; 172  :             _THROW(failure(_Msg));

  0034d	8d 45 d0	 lea	 eax, DWORD PTR $T4[ebp]
  00350	6a 01		 push	 1
  00352	50		 push	 eax
  00353	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  00358	83 c4 08	 add	 esp, 8
  0035b	8d 4d b4	 lea	 ecx, DWORD PTR $T2[ebp]
  0035e	50		 push	 eax
  0035f	56		 push	 esi
  00360	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  00365	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  0036a	8d 45 b4	 lea	 eax, DWORD PTR $T2[ebp]
  0036d	50		 push	 eax
  0036e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN162@operator:
  00373	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$2:
  00000	8d 4d c8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$3:
  00008	8d 4d d0	 lea	 ecx, DWORD PTR $T3[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
$T2 = -56						; size = 20
__Ok$3 = -36						; size = 8
$T4 = -28						; size = 8
__State$5 = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush, COMDAT
; _this$ = ecx

; 562  :     basic_ostream& __CLR_OR_THIS_CALL flush() { // flush output stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 563  :         const auto _Rdbuf = _Myios::rdbuf();

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00035	8b 7c 30 38	 mov	 edi, DWORD PTR [eax+esi+56]

; 564  :         if (_Rdbuf) { // buffer exists, flush it

  00039	85 ff		 test	 edi, edi
  0003b	0f 84 b8 00 00
	00		 je	 $LN75@flush

; 565  :             const sentry _Ok(*this);

  00041	56		 push	 esi
  00042	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$3[ebp]
  00045	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry

; 566  : 
; 567  :             if (_Ok) {

  0004a	80 7d e0 00	 cmp	 BYTE PTR __Ok$3[ebp+4], 0
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00055	74 75		 je	 SHORT $LN58@flush
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 121  :         return sync();

  00057	8b 07		 mov	 eax, DWORD PTR [edi]
  00059	8b cf		 mov	 ecx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 568  :                 ios_base::iostate _State = ios_base::goodbit;

  0005b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __State$5[ebp], 0

; 569  :                 _TRY_IO_BEGIN

  00062	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 121  :         return sync();

  00066	ff 50 34	 call	 DWORD PTR [eax+52]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 571  :                     _State |= ios_base::badbit; // sync failed

  00069	33 c9		 xor	 ecx, ecx
  0006b	ba 04 00 00 00	 mov	 edx, 4
  00070	83 f8 ff	 cmp	 eax, -1
  00073	89 4d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ecx
  00076	8b fa		 mov	 edi, edx
  00078	0f 45 f9	 cmovne	 edi, ecx
  0007b	eb 2b		 jmp	 SHORT $LN10@flush
__catch$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ$0:

; 572  :                 }
; 573  :                 _CATCH_IO_END

  0007d	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00080	6a 01		 push	 1
  00082	6a 04		 push	 4
  00084	8b 02		 mov	 eax, DWORD PTR [edx]
  00086	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00089	03 ca		 add	 ecx, edx
  0008b	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::setstate
  00090	b8 00 00 00 00	 mov	 eax, $LN11@flush
  00095	c3		 ret	 0
$LN11@flush:
  00096	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00099	ba 04 00 00 00	 mov	 edx, 4
  0009e	8b 7d e8	 mov	 edi, DWORD PTR __State$5[ebp]
  000a1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN10@flush:

; 574  :                 _Myios::setstate(_State);

  000a8	8b 06		 mov	 eax, DWORD PTR [esi]
  000aa	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 51   :         clear(rdstate() | _State, _Reraise);

  000ad	8b 44 31 0c	 mov	 eax, DWORD PTR [ecx+esi+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 574  :                 _Myios::setstate(_State);

  000b1	03 ce		 add	 ecx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 51   :         clear(rdstate() | _State, _Reraise);

  000b3	0b c7		 or	 eax, edi

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  000b5	33 ff		 xor	 edi, edi
  000b7	39 79 38	 cmp	 DWORD PTR [ecx+56], edi
  000ba	0f 45 d7	 cmovne	 edx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 155  :         _State &= _Statmask;

  000bd	0b d0		 or	 edx, eax

; 156  :         _Mystate             = _State;
; 157  :         const auto _Filtered = _State & _Except;

  000bf	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  000c2	83 e2 17	 and	 edx, 23			; 00000017H
  000c5	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  000c8	23 c2		 and	 eax, edx

; 158  :         if (_Filtered) {

  000ca	75 41		 jne	 SHORT $LN83@flush
$LN58@flush:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 111  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  000cc	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  000d1	84 c0		 test	 al, al

; 112  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 113  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 114  : #endif // ^^^ !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION ^^^
; 115  : 
; 116  :             if (_Zero_uncaught_exceptions) {

  000d3	75 08		 jne	 SHORT $LN69@flush

; 117  :                 this->_Myostr._Osfx();

  000d5	8b 4d dc	 mov	 ecx, DWORD PTR __Ok$3[ebp]
  000d8	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
$LN69@flush:

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

  000dd	8b 4d dc	 mov	 ecx, DWORD PTR __Ok$3[ebp]
  000e0	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3
  000e7	8b 01		 mov	 eax, DWORD PTR [ecx]
  000e9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000ec	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]

; 78   :             if (_Rdbuf) {

  000f0	85 c9		 test	 ecx, ecx
  000f2	74 05		 je	 SHORT $LN75@flush

; 79   :                 _Rdbuf->_Unlock();

  000f4	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f6	ff 50 08	 call	 DWORD PTR [eax+8]
$LN75@flush:

; 575  :             }
; 576  :         }
; 577  :         return *this;

  000f9	8b c6		 mov	 eax, esi

; 578  :     }

  000fb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000fe	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00105	59		 pop	 ecx
  00106	5f		 pop	 edi
  00107	5e		 pop	 esi
  00108	5b		 pop	 ebx
  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c3		 ret	 0
$LN83@flush:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 164  :             if (_Filtered & ios_base::badbit) {

  0010d	a8 04		 test	 al, 4
  0010f	74 07		 je	 SHORT $LN60@flush

; 165  :                 _Msg = "ios_base::badbit set";

  00111	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  00116	eb 0f		 jmp	 SHORT $LN62@flush
$LN60@flush:

; 166  :             } else if (_Filtered & ios_base::failbit) {

  00118	a8 02		 test	 al, 2
  0011a	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
  0011f	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
  00124	0f 44 f0	 cmove	 esi, eax
$LN62@flush:

; 167  :                 _Msg = "ios_base::failbit set";
; 168  :             } else {
; 169  :                 _Msg = "ios_base::eofbit set";
; 170  :             }
; 171  : 
; 172  :             _THROW(failure(_Msg));

  00127	8d 45 e4	 lea	 eax, DWORD PTR $T4[ebp]
  0012a	6a 01		 push	 1
  0012c	50		 push	 eax
  0012d	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  00132	83 c4 08	 add	 esp, 8
  00135	8d 4d c8	 lea	 ecx, DWORD PTR $T2[ebp]
  00138	50		 push	 eax
  00139	56		 push	 esi
  0013a	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  0013f	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00144	8d 45 c8	 lea	 eax, DWORD PTR $T2[ebp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN81@flush:
  0014d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ$2:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z
_TEXT	SEGMENT
$T2 = -68						; size = 20
__Ok$ = -48						; size = 8
__State$ = -40						; size = 4
$T3 = -36						; size = 8
$T4 = -36						; size = 8
$T5 = -36						; size = 8
$T6 = -32						; size = 4
_this$ = -28						; size = 4
$T7 = -24						; size = 8
__Nput_fac$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::operator<<, COMDAT
; _this$ = ecx

; 340  :     basic_ostream& __CLR_OR_THIS_CALL operator<<(unsigned long _Val) { // insert an unsigned long

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 e4	 mov	 DWORD PTR _this$[ebp], esi

; 341  :         ios_base::iostate _State = ios_base::goodbit;

  00030	33 ff		 xor	 edi, edi

; 342  :         const sentry _Ok(*this);

  00032	8d 4d d0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00035	56		 push	 esi
  00036	89 7d d8	 mov	 DWORD PTR __State$[ebp], edi
  00039	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry

; 343  : 
; 344  :         if (_Ok) { // state okay, use facet to insert

  0003e	80 7d d4 00	 cmp	 BYTE PTR __Ok$[ebp+4], 0
  00042	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], edi
  00045	0f 84 ae 00 00
	00		 je	 $LN58@operator

; 345  :             const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

  0004b	8b 06		 mov	 eax, DWORD PTR [esi]
  0004d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 289  :         return *_Ploc;

  00050	8b 44 30 30	 mov	 eax, DWORD PTR [eax+esi+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  00054	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00057	89 4d e0	 mov	 DWORD PTR $T6[ebp], ecx
  0005a	89 4d ec	 mov	 DWORD PTR $T7[ebp+4], ecx

; 269  :         _Ptr->_Incref();

  0005d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005f	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 345  :             const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

  00062	8d 45 e8	 lea	 eax, DWORD PTR $T7[ebp]
  00065	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 ??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > >
  0006f	8b 4d e0	 mov	 ecx, DWORD PTR $T6[ebp]
  00072	83 c4 04	 add	 esp, 4
  00075	89 45 ec	 mov	 DWORD PTR __Nput_fac$1$[ebp], eax
  00078	85 c9		 test	 ecx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  0007a	74 15		 je	 SHORT $LN23@operator

; 355  :             delete _Ptr->_Decref();

  0007c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007e	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00081	ff d2		 call	 edx
  00083	85 c0		 test	 eax, eax
  00085	74 0a		 je	 SHORT $LN23@operator
  00087	8b 08		 mov	 ecx, DWORD PTR [eax]
  00089	6a 01		 push	 1
  0008b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008d	8b c8		 mov	 ecx, eax
  0008f	ff d2		 call	 edx
$LN23@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 348  :             if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {

  00091	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1254 :         return do_put(_Dest, _Iosbase, _Fill, _Val);

  00093	ff 75 08	 push	 DWORD PTR __Val$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 347  :             _TRY_IO_BEGIN

  00096	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 348  :             if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {

  0009a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1254 :         return do_put(_Dest, _Iosbase, _Fill, _Val);

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Nput_fac$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 348  :             if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {

  000a0	03 d6		 add	 edx, esi
  000a2	0f b7 4a 40	 movzx	 ecx, WORD PTR [edx+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1254 :         return do_put(_Dest, _Iosbase, _Fill, _Val);

  000a6	8b 00		 mov	 eax, DWORD PTR [eax]
  000a8	51		 push	 ecx
  000a9	52		 push	 edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 550  :     bool _Failed = false; // true if any stores have failed

  000aa	c6 45 dc 00	 mov	 BYTE PTR $T3[ebp], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1254 :         return do_put(_Dest, _Iosbase, _Fill, _Val);

  000ae	8d 4d dc	 lea	 ecx, DWORD PTR $T4[ebp]
  000b1	ff 72 38	 push	 DWORD PTR [edx+56]
  000b4	ff 75 dc	 push	 DWORD PTR $T3[ebp]
  000b7	51		 push	 ecx
  000b8	8b 4d ec	 mov	 ecx, DWORD PTR __Nput_fac$1$[ebp]
  000bb	ff 50 20	 call	 DWORD PTR [eax+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 348  :             if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {

  000be	80 7d dc 00	 cmp	 BYTE PTR $T4[ebp], 0
  000c2	ba 04 00 00 00	 mov	 edx, 4
  000c7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000ce	0f 45 fa	 cmovne	 edi, edx
  000d1	eb 2b		 jmp	 SHORT $LN10@operator
__catch$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z$0:

; 349  :                 _State |= ios_base::badbit;
; 350  :             }
; 351  :             _CATCH_IO_END

  000d3	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  000d6	6a 01		 push	 1
  000d8	6a 04		 push	 4
  000da	8b 02		 mov	 eax, DWORD PTR [edx]
  000dc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000df	03 ca		 add	 ecx, edx
  000e1	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::setstate
  000e6	b8 00 00 00 00	 mov	 eax, $LN11@operator
  000eb	c3		 ret	 0
$LN11@operator:

; 343  : 
; 344  :         if (_Ok) { // state okay, use facet to insert

  000ec	8b 75 e4	 mov	 esi, DWORD PTR _this$[ebp]
  000ef	8b 7d d8	 mov	 edi, DWORD PTR __State$[ebp]
  000f2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN58@operator:

; 354  :         _Myios::setstate(_State);

  000f9	ba 04 00 00 00	 mov	 edx, 4
$LN10@operator:
  000fe	8b 06		 mov	 eax, DWORD PTR [esi]
  00100	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 51   :         clear(rdstate() | _State, _Reraise);

  00103	8b 44 31 0c	 mov	 eax, DWORD PTR [ecx+esi+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 354  :         _Myios::setstate(_State);

  00107	03 ce		 add	 ecx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 51   :         clear(rdstate() | _State, _Reraise);

  00109	0b c7		 or	 eax, edi

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  0010b	33 ff		 xor	 edi, edi
  0010d	39 79 38	 cmp	 DWORD PTR [ecx+56], edi
  00110	0f 45 d7	 cmovne	 edx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 155  :         _State &= _Statmask;

  00113	0b d0		 or	 edx, eax

; 156  :         _Mystate             = _State;
; 157  :         const auto _Filtered = _State & _Except;

  00115	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00118	83 e2 17	 and	 edx, 23			; 00000017H
  0011b	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  0011e	23 c2		 and	 eax, edx

; 158  :         if (_Filtered) {

  00120	75 43		 jne	 SHORT $LN62@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 111  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  00122	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception

; 112  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 113  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 114  : #endif // ^^^ !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION ^^^
; 115  : 
; 116  :             if (_Zero_uncaught_exceptions) {

  00127	84 c0		 test	 al, al
  00129	75 08		 jne	 SHORT $LN47@operator

; 117  :                 this->_Myostr._Osfx();

  0012b	8b 4d d0	 mov	 ecx, DWORD PTR __Ok$[ebp]
  0012e	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
$LN47@operator:

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

  00133	8b 4d d0	 mov	 ecx, DWORD PTR __Ok$[ebp]
  00136	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4
  0013d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0013f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00142	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]

; 78   :             if (_Rdbuf) {

  00146	85 c9		 test	 ecx, ecx
  00148	74 05		 je	 SHORT $LN53@operator

; 79   :                 _Rdbuf->_Unlock();

  0014a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0014c	ff 50 08	 call	 DWORD PTR [eax+8]
$LN53@operator:

; 355  :         return *this;

  0014f	8b c6		 mov	 eax, esi

; 356  :     }

  00151	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00154	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0015b	59		 pop	 ecx
  0015c	5f		 pop	 edi
  0015d	5e		 pop	 esi
  0015e	5b		 pop	 ebx
  0015f	8b e5		 mov	 esp, ebp
  00161	5d		 pop	 ebp
  00162	c2 04 00	 ret	 4
$LN62@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 164  :             if (_Filtered & ios_base::badbit) {

  00165	a8 04		 test	 al, 4
  00167	74 07		 je	 SHORT $LN38@operator

; 165  :                 _Msg = "ios_base::badbit set";

  00169	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  0016e	eb 0f		 jmp	 SHORT $LN40@operator
$LN38@operator:

; 166  :             } else if (_Filtered & ios_base::failbit) {

  00170	a8 02		 test	 al, 2
  00172	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
  00177	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
  0017c	0f 44 f0	 cmove	 esi, eax
$LN40@operator:

; 167  :                 _Msg = "ios_base::failbit set";
; 168  :             } else {
; 169  :                 _Msg = "ios_base::eofbit set";
; 170  :             }
; 171  : 
; 172  :             _THROW(failure(_Msg));

  0017f	8d 45 dc	 lea	 eax, DWORD PTR $T5[ebp]
  00182	6a 01		 push	 1
  00184	50		 push	 eax
  00185	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  0018a	83 c4 08	 add	 esp, 8
  0018d	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  00190	50		 push	 eax
  00191	56		 push	 esi
  00192	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  00197	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  0019c	8d 45 bc	 lea	 eax, DWORD PTR $T2[ebp]
  0019f	50		 push	 eax
  001a0	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN60@operator:
  001a5	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z$2:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z$3:
  00008	8d 4d e8	 lea	 ecx, DWORD PTR $T7[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::operator<<
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
$T2 = -68						; size = 20
__Ok$ = -48						; size = 8
__State$ = -40						; size = 4
$T3 = -36						; size = 8
$T4 = -36						; size = 8
$T5 = -36						; size = 8
$T6 = -32						; size = 4
_this$ = -28						; size = 4
$T7 = -24						; size = 8
__Nput_fac$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@H@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::operator<<, COMDAT
; _this$ = ecx

; 277  :     basic_ostream& __CLR_OR_THIS_CALL operator<<(int _Val) { // insert an int

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 e4	 mov	 DWORD PTR _this$[ebp], esi

; 278  :         ios_base::iostate _State = ios_base::goodbit;

  00030	33 ff		 xor	 edi, edi

; 279  :         const sentry _Ok(*this);

  00032	8d 4d d0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00035	56		 push	 esi
  00036	89 7d d8	 mov	 DWORD PTR __State$[ebp], edi
  00039	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry

; 280  : 
; 281  :         if (_Ok) { // state okay, use facet to insert

  0003e	80 7d d4 00	 cmp	 BYTE PTR __Ok$[ebp+4], 0
  00042	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], edi
  00045	0f 84 ae 00 00
	00		 je	 $LN61@operator

; 282  :             const _Nput& _Nput_fac  = _STD use_facet<_Nput>(this->getloc());

  0004b	8b 06		 mov	 eax, DWORD PTR [esi]
  0004d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 289  :         return *_Ploc;

  00050	8b 44 30 30	 mov	 eax, DWORD PTR [eax+esi+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  00054	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00057	89 4d e0	 mov	 DWORD PTR $T6[ebp], ecx
  0005a	89 4d ec	 mov	 DWORD PTR $T7[ebp+4], ecx

; 269  :         _Ptr->_Incref();

  0005d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005f	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 282  :             const _Nput& _Nput_fac  = _STD use_facet<_Nput>(this->getloc());

  00062	8d 45 e8	 lea	 eax, DWORD PTR $T7[ebp]
  00065	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 ??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > >
  0006f	8b 4d e0	 mov	 ecx, DWORD PTR $T6[ebp]
  00072	83 c4 04	 add	 esp, 4
  00075	89 45 ec	 mov	 DWORD PTR __Nput_fac$1$[ebp], eax
  00078	85 c9		 test	 ecx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  0007a	74 15		 je	 SHORT $LN26@operator

; 355  :             delete _Ptr->_Decref();

  0007c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007e	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00081	ff d2		 call	 edx
  00083	85 c0		 test	 eax, eax
  00085	74 0a		 je	 SHORT $LN26@operator
  00087	8b 08		 mov	 ecx, DWORD PTR [eax]
  00089	6a 01		 push	 1
  0008b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008d	8b c8		 mov	 ecx, eax
  0008f	ff d2		 call	 edx
$LN26@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 283  :             ios_base::fmtflags _Bfl = this->flags() & ios_base::basefield;

  00091	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1249 :         return do_put(_Dest, _Iosbase, _Fill, _Val);

  00093	ff 75 08	 push	 DWORD PTR __Val$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 292  :             _TRY_IO_BEGIN

  00096	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  0009a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1249 :         return do_put(_Dest, _Iosbase, _Fill, _Val);

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Nput_fac$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 283  :             ios_base::fmtflags _Bfl = this->flags() & ios_base::basefield;

  000a0	03 d6		 add	 edx, esi

; 293  :             if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Tmp).failed()) {

  000a2	0f b7 4a 40	 movzx	 ecx, WORD PTR [edx+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1249 :         return do_put(_Dest, _Iosbase, _Fill, _Val);

  000a6	8b 00		 mov	 eax, DWORD PTR [eax]
  000a8	51		 push	 ecx
  000a9	52		 push	 edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator

; 550  :     bool _Failed = false; // true if any stores have failed

  000aa	c6 45 dc 00	 mov	 BYTE PTR $T3[ebp], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum

; 1249 :         return do_put(_Dest, _Iosbase, _Fill, _Val);

  000ae	8d 4d dc	 lea	 ecx, DWORD PTR $T4[ebp]
  000b1	ff 72 38	 push	 DWORD PTR [edx+56]
  000b4	ff 75 dc	 push	 DWORD PTR $T3[ebp]
  000b7	51		 push	 ecx
  000b8	8b 4d ec	 mov	 ecx, DWORD PTR __Nput_fac$1$[ebp]
  000bb	ff 50 24	 call	 DWORD PTR [eax+36]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 293  :             if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Tmp).failed()) {

  000be	80 7d dc 00	 cmp	 BYTE PTR $T4[ebp], 0
  000c2	ba 04 00 00 00	 mov	 edx, 4
  000c7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000ce	0f 45 fa	 cmovne	 edi, edx
  000d1	eb 2b		 jmp	 SHORT $LN13@operator
__catch$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@H@Z$0:

; 294  :                 _State |= ios_base::badbit;
; 295  :             }
; 296  :             _CATCH_IO_END

  000d3	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  000d6	6a 01		 push	 1
  000d8	6a 04		 push	 4
  000da	8b 02		 mov	 eax, DWORD PTR [edx]
  000dc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000df	03 ca		 add	 ecx, edx
  000e1	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::setstate
  000e6	b8 00 00 00 00	 mov	 eax, $LN14@operator
  000eb	c3		 ret	 0
$LN14@operator:

; 280  : 
; 281  :         if (_Ok) { // state okay, use facet to insert

  000ec	8b 75 e4	 mov	 esi, DWORD PTR _this$[ebp]
  000ef	8b 7d d8	 mov	 edi, DWORD PTR __State$[ebp]
  000f2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN61@operator:

; 299  :         _Myios::setstate(_State);

  000f9	ba 04 00 00 00	 mov	 edx, 4
$LN13@operator:
  000fe	8b 06		 mov	 eax, DWORD PTR [esi]
  00100	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 51   :         clear(rdstate() | _State, _Reraise);

  00103	8b 44 31 0c	 mov	 eax, DWORD PTR [ecx+esi+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 299  :         _Myios::setstate(_State);

  00107	03 ce		 add	 ecx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 51   :         clear(rdstate() | _State, _Reraise);

  00109	0b c7		 or	 eax, edi

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  0010b	33 ff		 xor	 edi, edi
  0010d	39 79 38	 cmp	 DWORD PTR [ecx+56], edi
  00110	0f 45 d7	 cmovne	 edx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 155  :         _State &= _Statmask;

  00113	0b d0		 or	 edx, eax

; 156  :         _Mystate             = _State;
; 157  :         const auto _Filtered = _State & _Except;

  00115	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00118	83 e2 17	 and	 edx, 23			; 00000017H
  0011b	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  0011e	23 c2		 and	 eax, edx

; 158  :         if (_Filtered) {

  00120	75 43		 jne	 SHORT $LN65@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 111  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  00122	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception

; 112  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 113  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 114  : #endif // ^^^ !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION ^^^
; 115  : 
; 116  :             if (_Zero_uncaught_exceptions) {

  00127	84 c0		 test	 al, al
  00129	75 08		 jne	 SHORT $LN50@operator

; 117  :                 this->_Myostr._Osfx();

  0012b	8b 4d d0	 mov	 ecx, DWORD PTR __Ok$[ebp]
  0012e	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
$LN50@operator:

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

  00133	8b 4d d0	 mov	 ecx, DWORD PTR __Ok$[ebp]
  00136	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4
  0013d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0013f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00142	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]

; 78   :             if (_Rdbuf) {

  00146	85 c9		 test	 ecx, ecx
  00148	74 05		 je	 SHORT $LN56@operator

; 79   :                 _Rdbuf->_Unlock();

  0014a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0014c	ff 50 08	 call	 DWORD PTR [eax+8]
$LN56@operator:

; 300  :         return *this;

  0014f	8b c6		 mov	 eax, esi

; 301  :     }

  00151	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00154	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0015b	59		 pop	 ecx
  0015c	5f		 pop	 edi
  0015d	5e		 pop	 esi
  0015e	5b		 pop	 ebx
  0015f	8b e5		 mov	 esp, ebp
  00161	5d		 pop	 ebp
  00162	c2 04 00	 ret	 4
$LN65@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 164  :             if (_Filtered & ios_base::badbit) {

  00165	a8 04		 test	 al, 4
  00167	74 07		 je	 SHORT $LN41@operator

; 165  :                 _Msg = "ios_base::badbit set";

  00169	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  0016e	eb 0f		 jmp	 SHORT $LN43@operator
$LN41@operator:

; 166  :             } else if (_Filtered & ios_base::failbit) {

  00170	a8 02		 test	 al, 2
  00172	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
  00177	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
  0017c	0f 44 f0	 cmove	 esi, eax
$LN43@operator:

; 167  :                 _Msg = "ios_base::failbit set";
; 168  :             } else {
; 169  :                 _Msg = "ios_base::eofbit set";
; 170  :             }
; 171  : 
; 172  :             _THROW(failure(_Msg));

  0017f	8d 45 dc	 lea	 eax, DWORD PTR $T5[ebp]
  00182	6a 01		 push	 1
  00184	50		 push	 eax
  00185	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  0018a	83 c4 08	 add	 esp, 8
  0018d	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  00190	50		 push	 eax
  00191	56		 push	 esi
  00192	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  00197	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  0019c	8d 45 bc	 lea	 eax, DWORD PTR $T2[ebp]
  0019f	50		 push	 eax
  001a0	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN63@operator:
  001a5	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@H@Z$2:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@H@Z$3:
  00008	8d 4d e8	 lea	 ecx, DWORD PTR $T7[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@H@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@H@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@H@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::operator<<
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T2 = -44						; size = 20
$T3 = -24						; size = 8
__$EHRec$ = -16						; size = 16
?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx, COMDAT
; _this$ = ecx

; 159  :     void __CLR_OR_THIS_CALL _Osfx() noexcept { // perform any wrapup

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 206  :         return rdstate() == ios_base::goodbit;

  0002d	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 160  :         _TRY_BEGIN

  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 206  :         return rdstate() == ios_base::goodbit;

  00036	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00039	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 161  :         if (this->good() && this->flags() & ios_base::unitbuf) {

  0003e	75 38		 jne	 SHORT $LN21@Osfx
  00040	f6 44 30 14 02	 test	 BYTE PTR [eax+esi+20], 2
  00045	74 31		 je	 SHORT $LN21@Osfx

; 162  :             if (_Myios::rdbuf()->pubsync() == -1) { // flush stream as needed

  00047	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 121  :         return sync();

  0004b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004d	ff 50 34	 call	 DWORD PTR [eax+52]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 162  :             if (_Myios::rdbuf()->pubsync() == -1) { // flush stream as needed

  00050	83 f8 ff	 cmp	 eax, -1
  00053	75 23		 jne	 SHORT $LN21@Osfx

; 163  :                 _Myios::setstate(ios_base::badbit);

  00055	8b 06		 mov	 eax, DWORD PTR [esi]
  00057	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 155  :         _State &= _Statmask;

  0005a	8b 44 31 0c	 mov	 eax, DWORD PTR [ecx+esi+12]
  0005e	83 e0 13	 and	 eax, 19			; 00000013H
  00061	83 c8 04	 or	 eax, 4

; 156  :         _Mystate             = _State;

  00064	89 44 31 0c	 mov	 DWORD PTR [ecx+esi+12], eax

; 157  :         const auto _Filtered = _State & _Except;

  00068	8b 4c 31 10	 mov	 ecx, DWORD PTR [ecx+esi+16]
  0006c	23 c8		 and	 ecx, eax

; 158  :         if (_Filtered) {

  0006e	75 1a		 jne	 SHORT $LN34@Osfx
  00070	eb 06		 jmp	 SHORT $LN21@Osfx
__catch$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$0:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 167  :         _CATCH_END

  00072	b8 00 00 00 00	 mov	 eax, $LN21@Osfx
  00077	c3		 ret	 0
$LN21@Osfx:

; 168  :     }

  00078	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0007b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00082	59		 pop	 ecx
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
$LN34@Osfx:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 164  :             if (_Filtered & ios_base::badbit) {

  0008a	f6 c1 04	 test	 cl, 4
  0008d	74 07		 je	 SHORT $LN23@Osfx

; 165  :                 _Msg = "ios_base::badbit set";

  0008f	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  00094	eb 10		 jmp	 SHORT $LN25@Osfx
$LN23@Osfx:

; 166  :             } else if (_Filtered & ios_base::failbit) {

  00096	f6 c1 02	 test	 cl, 2
  00099	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
  0009e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
  000a3	0f 44 f0	 cmove	 esi, eax
$LN25@Osfx:

; 167  :                 _Msg = "ios_base::failbit set";
; 168  :             } else {
; 169  :                 _Msg = "ios_base::eofbit set";
; 170  :             }
; 171  : 
; 172  :             _THROW(failure(_Msg));

  000a6	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  000a9	6a 01		 push	 1
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  000b1	83 c4 08	 add	 esp, 8
  000b4	8d 4d d4	 lea	 ecx, DWORD PTR $T2[ebp]
  000b7	50		 push	 eax
  000b8	56		 push	 esi
  000b9	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  000be	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  000c3	8d 45 d4	 lea	 eax, DWORD PTR $T2[ebp]
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN32@Osfx:
  000cc	cc		 int	 3
  000cd	cc		 int	 3
  000ce	cc		 int	 3
  000cf	cc		 int	 3
  000d0	cc		 int	 3
  000d1	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
;	COMDAT ?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::setstate, COMDAT
; _this$ = ecx

; 49   :     void __CLR_OR_THIS_CALL setstate(iostate _State, bool _Reraise = false) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  00003	ff 75 0c	 push	 DWORD PTR __Reraise$[ebp]
  00006	33 d2		 xor	 edx, edx
  00008	b8 04 00 00 00	 mov	 eax, 4
  0000d	39 51 38	 cmp	 DWORD PTR [ecx+56], edx
  00010	0f 45 c2	 cmovne	 eax, edx
  00013	0b 41 0c	 or	 eax, DWORD PTR [ecx+12]
  00016	0b 45 08	 or	 eax, DWORD PTR __State$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 50   :         // merge _State into state, possibly reraise exception
; 51   :         clear(rdstate() | _State, _Reraise);
; 52   :     }

  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::setstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?_Xlength@?$vector@KV?$allocator@K@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@KV?$allocator@K@std@@@std@@CAXXZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlength, COMDAT

; 2184 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@KV?$allocator@K@std@@@std@@CAXXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 829  :     _CONSTEXPR20 ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2090 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 40		 je	 SHORT $LN5@vector

; 2091 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2092 :             _ASAN_VECTOR_REMOVE;
; 2093 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000c	2b c8		 sub	 ecx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00011	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN18@vector

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00019	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001c	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 22		 ja	 SHORT $LN17@vector

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00029	8b c2		 mov	 eax, edx
$LN18@vector:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2095 :             _Myfirst = nullptr;

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00038	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2096 :             _Mylast  = nullptr;

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 2097 :             _Myend   = nullptr;

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN5@vector:
  00049	5e		 pop	 esi

; 835  :     }

  0004a	c3		 ret	 0
$LN17@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	6a 00		 push	 0
  00051	6a 00		 push	 0
  00053	6a 00		 push	 0
  00055	e8 00 00 00 00	 call	 __invoke_watson
$LN26@vector:
  0005a	cc		 int	 3
??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??__FallowedExecutables@?1??ListAndWipeProcess@@YAXXZ@YAXXZ
text$yd	SEGMENT
??__FallowedExecutables@?1??ListAndWipeProcess@@YAXXZ@YAXXZ PROC ; `ListAndWipeProcess'::`2'::`dynamic atexit destructor for 'allowedExecutables'', COMDAT

; 830  :         _Tidy();

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?allowedExecutables@?1??ListAndWipeProcess@@YAXXZ@4V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@B
  00005	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Tidy
??__FallowedExecutables@?1??ListAndWipeProcess@@YAXXZ@YAXXZ ENDP ; `ListAndWipeProcess'::`2'::`dynamic atexit destructor for 'allowedExecutables''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?_Xlength@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Xlength, COMDAT

; 2184 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXXZ PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Tidy, COMDAT
; _this$ = ecx

; 2081 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 2082 :         auto& _Al         = _Getal();
; 2083 :         auto& _My_data    = _Mypair._Myval2;
; 2084 :         pointer& _Myfirst = _My_data._Myfirst;
; 2085 :         pointer& _Mylast  = _My_data._Mylast;
; 2086 :         pointer& _Myend   = _My_data._Myend;
; 2087 : 
; 2088 :         _My_data._Orphan_all();
; 2089 : 
; 2090 :         if (_Myfirst) { // destroy and deallocate old array

  00004	8b 37		 mov	 esi, DWORD PTR [edi]
  00006	85 f6		 test	 esi, esi
  00008	74 6d		 je	 SHORT $LN2@Tidy

; 2091 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

  0000a	53		 push	 ebx
  0000b	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1102 :         for (; _First != _Last; ++_First) {

  0000e	3b f3		 cmp	 esi, ebx
  00010	74 0e		 je	 SHORT $LN7@Tidy
$LL8@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1383 :         _Tidy_deallocate();

  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1102 :         for (; _First != _Last; ++_First) {

  00019	83 c6 18	 add	 esi, 24			; 00000018H
  0001c	3b f3		 cmp	 esi, ebx
  0001e	75 f2		 jne	 SHORT $LL8@Tidy
$LN7@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2093 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00020	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00023	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00028	8b 37		 mov	 esi, DWORD PTR [edi]
  0002a	2b ce		 sub	 ecx, esi
  0002c	f7 e9		 imul	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002e	5b		 pop	 ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2093 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0002f	c1 fa 02	 sar	 edx, 2
  00032	8b c2		 mov	 eax, edx
  00034	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00037	03 c2		 add	 eax, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00039	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  0003c	c1 e1 03	 shl	 ecx, 3

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0003f	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00045	72 12		 jb	 SHORT $LN32@Tidy

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00047	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  0004a	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0004d	2b f2		 sub	 esi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004f	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  00052	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00055	77 23		 ja	 SHORT $LN31@Tidy

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b f2		 mov	 esi, edx
$LN32@Tidy:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00059	51		 push	 ecx
  0005a	56		 push	 esi
  0005b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2095 :             _Myfirst = nullptr;

  00060	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00066	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2096 :             _Mylast  = nullptr;

  00069	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 2097 :             _Myend   = nullptr;

  00070	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN2@Tidy:

; 2099 :     }

  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	c3		 ret	 0
$LN31@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0007a	6a 00		 push	 0
  0007c	6a 00		 push	 0
  0007e	6a 00		 push	 0
  00080	6a 00		 push	 0
  00082	6a 00		 push	 0
  00084	e8 00 00 00 00	 call	 __invoke_watson
$LN44@Tidy:
  00089	cc		 int	 3
?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXXZ ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT
; _this$ = ecx

; 830  :         _Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Tidy
??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\initializer_list
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\initializer_list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\initializer_list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\initializer_list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
;	COMDAT ?ListAndWipeProcess@@YAXXZ
_TEXT	SEGMENT
_fileSize$ = -1392					; size = 8
_processIds$ = -1384					; size = 12
_pid$ = -1372						; size = 4
_processNames$ = -1368					; size = 12
$T2 = -1356						; size = 8
__Guard$3 = -1352					; size = 4
_sd$4 = -1352						; size = 4
_hSnap$1$ = -1352					; size = 4
__Result$2$ = -1352					; size = 4
_processNames$1$ = -1352				; size = 4
_sidString$5 = -1348					; size = 4
tv3244 = -1348						; size = 4
__ULast$1$ = -1348					; size = 4
__Result$6 = -1344					; size = 4
_ownerSid$7 = -1344					; size = 4
_hProcess$1$ = -1344					; size = 4
_index$1$ = -1340					; size = 4
tv3261 = -1340						; size = 4
_isSystemOrAdmin$1$ = -1333				; size = 1
_pe32$ = -1332						; size = 556
_exeName$ = -776					; size = 24
$T8 = -752						; size = 120
_exePathStr$ = -632					; size = 24
_bakPath$ = -608					; size = 24
_lowerPath$9 = -584					; size = 24
_exe$10 = -560						; size = 24
$T11 = -556						; size = 20
__Backout$12 = -548					; size = 12
_exePath$ = -536					; size = 520
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?ListAndWipeProcess@@YAXXZ PROC				; ListAndWipeProcess, COMDAT

; 165  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ListAndWipeProcess@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 64 05 00
	00		 sub	 esp, 1380		; 00000564H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 166  :     static const std::vector<std::wstring> allowedExecutables = {

  0002d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__tls_array
  00033	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __tls_index
  00039	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  0003c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS0@?1??ListAndWipeProcess@@YAXXZ@4HA
  00041	3b 81 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[ecx]
  00047	0f 8f 39 0a 00
	00		 jg	 $LN1016@ListAndWip
$LN2@ListAndWip:

; 167  :         L"EasyAntiCheat.exe", L"rbxhyperion.exe", L"vgk.exe", L"Vanguard.exe", L"RobloxPlayerBeta.exe"
; 168  :     };
; 169  : 
; 170  :     HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

  0004d	6a 00		 push	 0
  0004f	6a 02		 push	 2
  00051	e8 00 00 00 00	 call	 _CreateToolhelp32Snapshot@8
  00056	8b f0		 mov	 esi, eax
  00058	89 b5 b8 fa ff
	ff		 mov	 DWORD PTR _hSnap$1$[ebp], esi

; 171  :     if (hSnap == INVALID_HANDLE_VALUE) {

  0005e	83 fe ff	 cmp	 esi, -1
  00061	75 14		 jne	 SHORT $LN6@ListAndWip

; 172  :         std::cout << "Failed to create process snapshot\n";

  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@HMDMDLOM@Failed?5to?5create?5process?5snapsh@
  00068	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  0006d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 173  :         return;

  00072	e9 f1 09 00 00	 jmp	 $LN1010@ListAndWip
$LN6@ListAndWip:

; 174  :     }
; 175  : 
; 176  :     PROCESSENTRY32 pe32{};

  00077	68 28 02 00 00	 push	 552			; 00000228H
  0007c	8d 85 d0 fa ff
	ff		 lea	 eax, DWORD PTR _pe32$[ebp+4]
  00082	6a 00		 push	 0
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 _memset
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 177  :     pe32.dwSize = sizeof(pe32);

  0008d	c7 85 cc fa ff
	ff 2c 02 00 00	 mov	 DWORD PTR _pe32$[ebp], 556 ; 0000022cH

; 178  : 
; 179  :     int index = 1;

  00097	c7 85 c4 fa ff
	ff 01 00 00 00	 mov	 DWORD PTR _index$1$[ebp], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  000a1	c7 85 a8 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _processNames$[ebp], 0
  000ab	c7 85 ac fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _processNames$[ebp+4], 0
  000b5	c7 85 b0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _processNames$[ebp+8], 0
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 180  :     std::vector<std::wstring> processNames;

  000bf	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  000c6	c7 85 98 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _processIds$[ebp], 0
  000d0	c7 85 9c fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _processIds$[ebp+4], 0
  000da	c7 85 a0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _processIds$[ebp+8], 0
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 183  :     if (Process32First(hSnap, &pe32)) {

  000e4	8d 85 cc fa ff
	ff		 lea	 eax, DWORD PTR _pe32$[ebp]
  000ea	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  000ee	50		 push	 eax
  000ef	56		 push	 esi
  000f0	e8 00 00 00 00	 call	 _Process32FirstW@8
  000f5	85 c0		 test	 eax, eax
  000f7	0f 84 00 02 00
	00		 je	 $LN4@ListAndWip
  000fd	0f 1f 00	 npad	 3
$LL5@ListAndWip:
  00100	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 517  :     size_type _Mysize = 0; // current length of string (size)

  00103	c7 85 e0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _exe$10[ebp+16], 0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0010d	8d 8d f0 fa ff
	ff		 lea	 ecx, DWORD PTR _pe32$[ebp+36]
  00113	c7 85 e4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _exe$10[ebp+20], 0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0011d	0f 11 85 d0 fd
	ff ff		 movups	 XMMWORD PTR _exe$10[ebp], xmm0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00124	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
$LL992@ListAndWip:
  00127	66 8b 01	 mov	 ax, WORD PTR [ecx]
  0012a	83 c1 02	 add	 ecx, 2
  0012d	66 85 c0	 test	 ax, ax
  00130	75 f5		 jne	 SHORT $LL992@ListAndWip
  00132	2b ca		 sub	 ecx, edx

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00134	8d 85 f0 fa ff
	ff		 lea	 eax, DWORD PTR _pe32$[ebp+36]

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0013a	d1 f9		 sar	 ecx, 1

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0013c	51		 push	 ecx
  0013d	50		 push	 eax
  0013e	8d 8d d0 fd ff
	ff		 lea	 ecx, DWORD PTR _exe$10[ebp]
  00144	e8 00 00 00 00	 call	 ??$_Construct@$00PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 186  :             if (std::find(allowedExecutables.begin(), allowedExecutables.end(), exe) != allowedExecutables.end()) {

  00149	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?allowedExecutables@?1??ListAndWipeProcess@@YAXXZ@4V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@B+4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 6174 :         _STD _Seek_wrapped(_First, _STD _Find_unchecked(_STD _Get_unwrapped(_First), _STD _Get_unwrapped(_Last), _Val));

  0014f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?allowedExecutables@?1??ListAndWipeProcess@@YAXXZ@4V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@B
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 185  :             std::wstring exe(pe32.szExeFile);

  00155	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 6174 :         _STD _Seek_wrapped(_First, _STD _Find_unchecked(_STD _Get_unwrapped(_First), _STD _Get_unwrapped(_Last), _Val));

  00159	3b f7		 cmp	 esi, edi

; 6159 :     for (; _First != _Last; ++_First) {

  0015b	74 46		 je	 SHORT $LN1002@ListAndWip
  0015d	0f 1f 00	 npad	 3
$LL71@ListAndWip:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00160	83 bd e4 fd ff
	ff 07		 cmp	 DWORD PTR _exe$10[ebp+20], 7

; 444  :         const value_type* _Result = _Bx._Buf;

  00167	8d 8d d0 fd ff
	ff		 lea	 ecx, DWORD PTR _exe$10[ebp]

; 2848 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  0016d	8b 46 10	 mov	 eax, DWORD PTR [esi+16]

; 444  :         const value_type* _Result = _Bx._Buf;

  00170	8b d6		 mov	 edx, esi

; 445  :         if (_Large_mode_engaged()) {

  00172	0f 47 8d d0 fd
	ff ff		 cmova	 ecx, DWORD PTR _exe$10[ebp]

; 453  :         return _Myres > _Small_string_capacity;

  00179	83 7e 14 07	 cmp	 DWORD PTR [esi+20], 7

; 445  :         if (_Large_mode_engaged()) {

  0017d	76 02		 jbe	 SHORT $LN88@ListAndWip

; 446  :             _Result = _Unfancy(_Bx._Ptr);

  0017f	8b 16		 mov	 edx, DWORD PTR [esi]
$LN88@ListAndWip:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 604  :     if (_Left_size != _Right_size) {

  00181	3b 85 e0 fd ff
	ff		 cmp	 eax, DWORD PTR _exe$10[ebp+16]
  00187	75 13		 jne	 SHORT $LN987@ListAndWip

; 605  :         return false;
; 606  :     }
; 607  : 
; 608  :     if (_Left_size == 0u) {

  00189	85 c0		 test	 eax, eax
  0018b	74 16		 je	 SHORT $LN1002@ListAndWip

; 294  :         return _CSTD wmemcmp(

  0018d	50		 push	 eax
  0018e	51		 push	 ecx
  0018f	52		 push	 edx
  00190	e8 00 00 00 00	 call	 _wmemcmp
  00195	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 6160 :         if (*_First == _Val) {

  00198	85 c0		 test	 eax, eax
  0019a	74 07		 je	 SHORT $LN1002@ListAndWip
$LN987@ListAndWip:

; 253  :     } else {
; 254  :         _STL_INTERNAL_STATIC_ASSERT(false); // unexpected size
; 255  :     }
; 256  : }
; 257  : 
; 258  : template <class _Ty1, class _Ty2>
; 259  : _Ty1* _Find_end_vectorized(
; 260  :     _Ty1* const _First1, _Ty1* const _Last1, _Ty2* const _First2, const size_t _Count2) noexcept {
; 261  :     _STL_INTERNAL_STATIC_ASSERT(sizeof(_Ty1) == sizeof(_Ty2));
; 262  :     if constexpr (sizeof(_Ty1) == 1) {
; 263  :         return const_cast<_Ty1*>(static_cast<const _Ty1*>(::__std_find_end_1(_First1, _Last1, _First2, _Count2)));
; 264  :     } else if constexpr (sizeof(_Ty1) == 2) {
; 265  :         return const_cast<_Ty1*>(static_cast<const _Ty1*>(::__std_find_end_2(_First1, _Last1, _First2, _Count2)));
; 266  :     } else {
; 267  :         _STL_INTERNAL_STATIC_ASSERT(false); // unexpected size
; 268  :     }
; 269  : }
; 270  : 
; 271  : template <class _Ty>
; 272  : _Ty* _Min_element_vectorized(_Ty* const _First, _Ty* const _Last) noexcept {
; 273  :     constexpr bool _Signed = is_signed_v<_Ty>;
; 274  : 
; 275  :     if constexpr (is_same_v<remove_const_t<_Ty>, float>) {
; 276  :         return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_min_element_f(_First, _Last, false)));
; 277  :     } else if constexpr (_Is_any_of_v<remove_const_t<_Ty>, double, long double>) {
; 278  :         return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_min_element_d(_First, _Last, false)));
; 279  :     } else if constexpr (sizeof(_Ty) == 1) {
; 280  :         return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_min_element_1(_First, _Last, _Signed)));
; 281  :     } else if constexpr (sizeof(_Ty) == 2) {
; 282  :         return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_min_element_2(_First, _Last, _Signed)));
; 283  :     } else if constexpr (sizeof(_Ty) == 4) {
; 284  :         return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_min_element_4(_First, _Last, _Signed)));
; 285  :     } else if constexpr (sizeof(_Ty) == 8) {
; 286  :         return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_min_element_8(_First, _Last, _Signed)));
; 287  :     } else {
; 288  :         _STL_INTERNAL_STATIC_ASSERT(false); // unexpected size
; 289  :     }
; 290  : }
; 291  : 
; 292  : template <class _Ty>
; 293  : _Ty* _Max_element_vectorized(_Ty* const _First, _Ty* const _Last) noexcept {
; 294  :     constexpr bool _Signed = is_signed_v<_Ty>;
; 295  : 
; 296  :     if constexpr (is_same_v<remove_const_t<_Ty>, float>) {
; 297  :         return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_max_element_f(_First, _Last, false)));
; 298  :     } else if constexpr (_Is_any_of_v<remove_const_t<_Ty>, double, long double>) {
; 299  :         return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_max_element_d(_First, _Last, false)));
; 300  :     } else if constexpr (sizeof(_Ty) == 1) {
; 301  :         return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_max_element_1(_First, _Last, _Signed)));
; 302  :     } else if constexpr (sizeof(_Ty) == 2) {
; 303  :         return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_max_element_2(_First, _Last, _Signed)));
; 304  :     } else if constexpr (sizeof(_Ty) == 4) {
; 305  :         return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_max_element_4(_First, _Last, _Signed)));
; 306  :     } else if constexpr (sizeof(_Ty) == 8) {
; 307  :         return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_max_element_8(_First, _Last, _Signed)));
; 308  :     } else {
; 309  :         _STL_INTERNAL_STATIC_ASSERT(false); // unexpected size
; 310  :     }
; 311  : }
; 312  : 
; 313  : template <class _Ty>
; 314  : auto _Min_vectorized(_Ty* const _First, _Ty* const _Last) noexcept {
; 315  :     constexpr bool _Signed = is_signed_v<_Ty>;
; 316  : 
; 317  :     if constexpr (is_pointer_v<_Ty>) {
; 318  : #ifdef _WIN64
; 319  :         return reinterpret_cast<void*>(::__std_min_8u(_First, _Last));
; 320  : #else
; 321  :         return reinterpret_cast<void*>(::__std_min_4u(_First, _Last));
; 322  : #endif
; 323  :     } else if constexpr (is_same_v<remove_const_t<_Ty>, float>) {
; 324  :         return ::__std_min_f(_First, _Last);
; 325  :     } else if constexpr (_Is_any_of_v<remove_const_t<_Ty>, double, long double>) {
; 326  :         return ::__std_min_d(_First, _Last);
; 327  :     } else if constexpr (sizeof(_Ty) == 1) {
; 328  :         if constexpr (_Signed) {
; 329  :             return ::__std_min_1i(_First, _Last);
; 330  :         } else {
; 331  :             return ::__std_min_1u(_First, _Last);
; 332  :         }
; 333  :     } else if constexpr (sizeof(_Ty) == 2) {
; 334  :         if constexpr (_Signed) {
; 335  :             return ::__std_min_2i(_First, _Last);
; 336  :         } else {
; 337  :             return ::__std_min_2u(_First, _Last);
; 338  :         }
; 339  :     } else if constexpr (sizeof(_Ty) == 4) {
; 340  :         if constexpr (_Signed) {
; 341  :             return ::__std_min_4i(_First, _Last);
; 342  :         } else {
; 343  :             return ::__std_min_4u(_First, _Last);
; 344  :         }
; 345  :     } else if constexpr (sizeof(_Ty) == 8) {
; 346  :         if constexpr (_Signed) {
; 347  :             return ::__std_min_8i(_First, _Last);
; 348  :         } else {
; 349  :             return ::__std_min_8u(_First, _Last);
; 350  :         }
; 351  :     } else {
; 352  :         _STL_INTERNAL_STATIC_ASSERT(false); // unexpected size
; 353  :     }
; 354  : }
; 355  : 
; 356  : template <class _Ty>
; 357  : auto _Max_vectorized(_Ty* const _First, _Ty* const _Last) noexcept {
; 358  :     constexpr bool _Signed = is_signed_v<_Ty>;
; 359  : 
; 360  :     if constexpr (is_pointer_v<_Ty>) {
; 361  : #ifdef _WIN64
; 362  :         return reinterpret_cast<void*>(::__std_max_8u(_First, _Last));
; 363  : #else
; 364  :         return reinterpret_cast<void*>(::__std_max_4u(_First, _Last));
; 365  : #endif
; 366  :     } else if constexpr (is_same_v<remove_const_t<_Ty>, float>) {
; 367  :         return ::__std_max_f(_First, _Last);
; 368  :     } else if constexpr (_Is_any_of_v<remove_const_t<_Ty>, double, long double>) {
; 369  :         return ::__std_max_d(_First, _Last);
; 370  :     } else if constexpr (sizeof(_Ty) == 1) {
; 371  :         if constexpr (_Signed) {
; 372  :             return ::__std_max_1i(_First, _Last);
; 373  :         } else {
; 374  :             return ::__std_max_1u(_First, _Last);
; 375  :         }
; 376  :     } else if constexpr (sizeof(_Ty) == 2) {
; 377  :         if constexpr (_Signed) {
; 378  :             return ::__std_max_2i(_First, _Last);
; 379  :         } else {
; 380  :             return ::__std_max_2u(_First, _Last);
; 381  :         }
; 382  :     } else if constexpr (sizeof(_Ty) == 4) {
; 383  :         if constexpr (_Signed) {
; 384  :             return ::__std_max_4i(_First, _Last);
; 385  :         } else {
; 386  :             return ::__std_max_4u(_First, _Last);
; 387  :         }
; 388  :     } else if constexpr (sizeof(_Ty) == 8) {
; 389  :         if constexpr (_Signed) {
; 390  :             return ::__std_max_8i(_First, _Last);
; 391  :         } else {
; 392  :             return ::__std_max_8u(_First, _Last);
; 393  :         }
; 394  :     } else {
; 395  :         _STL_INTERNAL_STATIC_ASSERT(false); // unexpected size
; 396  :     }
; 397  : }
; 398  : 
; 399  : template <size_t _Element_size>
; 400  : inline size_t // TRANSITION, GH-4496
; 401  :     _Mismatch_vectorized(const void* const _First1, const void* const _First2, const size_t _Count) noexcept {
; 402  :     if constexpr (_Element_size == 1) {
; 403  :         return __std_mismatch_1(_First1, _First2, _Count);
; 404  :     } else if constexpr (_Element_size == 2) {
; 405  :         return __std_mismatch_2(_First1, _First2, _Count);
; 406  :     } else if constexpr (_Element_size == 4) {
; 407  :         return __std_mismatch_4(_First1, _First2, _Count);
; 408  :     } else if constexpr (_Element_size == 8) {
; 409  :         return __std_mismatch_8(_First1, _First2, _Count);
; 410  :     } else {
; 411  :         _STL_INTERNAL_STATIC_ASSERT(false); // unexpected size
; 412  :     }
; 413  : }
; 414  : _STD_END
; 415  : 
; 416  : #endif // _USE_STD_VECTOR_ALGORITHMS
; 417  : 
; 418  : _STD_BEGIN
; 419  : 
; 420  : template <class _Ty>
; 421  : struct _Get_first_parameter;
; 422  : 
; 423  : template <template <class, class...> class _Ty, class _First, class... _Rest>
; 424  : struct _Get_first_parameter<_Ty<_First, _Rest...>> { // given _Ty<_First, _Rest...>, extract _First
; 425  :     using type = _First;
; 426  : };
; 427  : 
; 428  : template <class _Newfirst, class _Ty>
; 429  : struct _Replace_first_parameter;
; 430  : 
; 431  : template <class _Newfirst, template <class, class...> class _Ty, class _First, class... _Rest>
; 432  : struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...>> { // given _Ty<_First, _Rest...>, replace _First
; 433  :     using type = _Ty<_Newfirst, _Rest...>;
; 434  : };
; 435  : 
; 436  : template <class _Ty, class = void>
; 437  : struct _Get_ptr_difference_type {
; 438  :     using type = ptrdiff_t;
; 439  : };
; 440  : 
; 441  : template <class _Ty>
; 442  : struct _Get_ptr_difference_type<_Ty, void_t<typename _Ty::difference_type>> {
; 443  :     using type = typename _Ty::difference_type;
; 444  : };
; 445  : 
; 446  : template <class _Ty, class _Other, class = void>
; 447  : struct _Get_rebind_alias {
; 448  :     using type = typename _Replace_first_parameter<_Other, _Ty>::type;
; 449  : };
; 450  : 
; 451  : template <class _Ty, class _Other>
; 452  : struct _Get_rebind_alias<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>>> {
; 453  :     using type = typename _Ty::template rebind<_Other>;
; 454  : };
; 455  : 
; 456  : #if _HAS_CXX20
; 457  : _EXPORT_STD template <class _Ty, class... _Types>
; 458  :     requires requires(_Ty* _Location, _Types&&... _Args) {
; 459  :         ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...); // per LWG-3888
; 460  :     }
; 461  : constexpr _Ty* construct_at(_Ty* const _Location, _Types&&... _Args)
; 462  :     noexcept(noexcept(::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {
; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);
; 464  : }
; 465  : #endif // _HAS_CXX20
; 466  : 
; 467  : template <class _Ty, class... _Types>
; 468  : _CONSTEXPR20 void _Construct_in_place(_Ty& _Obj, _Types&&... _Args)
; 469  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {
; 470  : #if _HAS_CXX20
; 471  :     if (_STD is_constant_evaluated()) {
; 472  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 473  :     } else
; 474  : #endif // _HAS_CXX20
; 475  :     {
; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 477  :     }
; 478  : }
; 479  : 
; 480  : template <class _Ty>
; 481  : void _Default_construct_in_place(_Ty& _Obj) noexcept(is_nothrow_default_constructible_v<_Ty>) {
; 482  :     ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty;
; 483  : }
; 484  : 
; 485  : template <class _Ty, class _Elem>
; 486  : struct _Ptr_traits_base {
; 487  :     using pointer         = _Ty;
; 488  :     using element_type    = _Elem;
; 489  :     using difference_type = typename _Get_ptr_difference_type<_Ty>::type;
; 490  : 
; 491  :     template <class _Other>
; 492  :     using rebind = typename _Get_rebind_alias<_Ty, _Other>::type;
; 493  : 
; 494  :     using _Reftype = conditional_t<is_void_v<_Elem>, char, _Elem>&;
; 495  : 
; 496  :     _NODISCARD static _CONSTEXPR20 pointer pointer_to(_Reftype _Val)
; 497  :         noexcept(noexcept(_Ty::pointer_to(_Val))) /* strengthened */ { // Per LWG-3454
; 498  :         return _Ty::pointer_to(_Val);
; 499  :     }
; 500  : };
; 501  : 
; 502  : template <class, class = void, class = void>
; 503  : struct _Ptr_traits_sfinae_layer {};
; 504  : 
; 505  : template <class _Ty, class _Uty>
; 506  : struct _Ptr_traits_sfinae_layer<_Ty, _Uty, void_t<typename _Get_first_parameter<_Ty>::type>>
; 507  :     : _Ptr_traits_base<_Ty, typename _Get_first_parameter<_Ty>::type> {};
; 508  : 
; 509  : template <class _Ty>
; 510  : struct _Ptr_traits_sfinae_layer<_Ty, void_t<typename _Ty::element_type>, void>
; 511  :     : _Ptr_traits_base<_Ty, typename _Ty::element_type> {};
; 512  : 
; 513  : _EXPORT_STD template <class _Ty>
; 514  : struct pointer_traits : _Ptr_traits_sfinae_layer<_Ty> {};
; 515  : 
; 516  : template <class _Ty>
; 517  : struct pointer_traits<_Ty*> {
; 518  :     using pointer         = _Ty*;
; 519  :     using element_type    = _Ty;
; 520  :     using difference_type = ptrdiff_t;
; 521  : 
; 522  :     template <class _Other>
; 523  :     using rebind = _Other*;
; 524  : 
; 525  :     using _Reftype = conditional_t<is_void_v<_Ty>, char, _Ty>&;
; 526  : 
; 527  :     _NODISCARD static _CONSTEXPR20 pointer pointer_to(_Reftype _Val) noexcept {
; 528  :         return _STD addressof(_Val);
; 529  :     }
; 530  : };
; 531  : 
; 532  : #if _HAS_CXX20
; 533  : template <class _Ty>
; 534  : concept _Has_to_address = requires(const _Ty& _Val) {
; 535  :     typename pointer_traits<_Ty>;
; 536  :     pointer_traits<_Ty>::to_address(_Val);
; 537  : };
; 538  : 
; 539  : _EXPORT_STD template <class _Ty>
; 540  : _NODISCARD constexpr _Ty* to_address(_Ty* const _Val) noexcept {
; 541  :     static_assert(!is_function_v<_Ty>, "N4950 [pointer.conversion]/1: Mandates: T is not a function type.");
; 542  :     return _Val;
; 543  : }
; 544  : 
; 545  : _EXPORT_STD template <class _Ptr>
; 546  : _NODISCARD constexpr auto to_address(const _Ptr& _Val) noexcept {
; 547  :     if constexpr (_Has_to_address<_Ptr>) {
; 548  :         return pointer_traits<_Ptr>::to_address(_Val);
; 549  :     } else {
; 550  :         return _STD to_address(_Val.operator->()); // plain pointer overload must come first
; 551  :     }
; 552  : }
; 553  : 
; 554  : _EXPORT_STD struct identity {
; 555  :     template <class _Ty>
; 556  :     _NODISCARD constexpr _Ty&& operator()(_Ty&& _Left) const noexcept {
; 557  :         return _STD forward<_Ty>(_Left);
; 558  :     }
; 559  : 
; 560  :     using is_transparent = int;
; 561  : };
; 562  : #endif // _HAS_CXX20
; 563  : 
; 564  : _EXPORT_STD template <class _Ty = void>
; 565  : struct plus {
; 566  :     using _FIRST_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS  = _Ty;
; 567  :     using _SECOND_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;
; 568  :     using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS          = _Ty;
; 569  : 
; 570  :     _NODISCARD constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
; 571  :         return _Left + _Right;
; 572  :     }
; 573  : };
; 574  : 
; 575  : _EXPORT_STD template <class _Ty = void>
; 576  : struct minus {
; 577  :     using _FIRST_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS  = _Ty;
; 578  :     using _SECOND_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;
; 579  :     using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS          = _Ty;
; 580  : 
; 581  :     _NODISCARD constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
; 582  :         return _Left - _Right;
; 583  :     }
; 584  : };
; 585  : 
; 586  : _EXPORT_STD template <class _Ty = void>
; 587  : struct multiplies {
; 588  :     using _FIRST_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS  = _Ty;
; 589  :     using _SECOND_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;
; 590  :     using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS          = _Ty;
; 591  : 
; 592  :     _NODISCARD constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
; 593  :         return _Left * _Right;
; 594  :     }
; 595  : };
; 596  : 
; 597  : _EXPORT_STD template <class _Ty = void>
; 598  : struct equal_to {
; 599  :     using _FIRST_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS  = _Ty;
; 600  :     using _SECOND_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;
; 601  :     using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS          = bool;
; 602  : 
; 603  :     _NODISCARD constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
; 604  :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left == _Right))) /* strengthened */ {
; 605  :         return _Left == _Right;
; 606  :     }
; 607  : };
; 608  : 
; 609  : _EXPORT_STD template <class _Ty = void>
; 610  : struct not_equal_to {
; 611  :     using _FIRST_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS  = _Ty;
; 612  :     using _SECOND_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;
; 613  :     using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS          = bool;
; 614  : 
; 615  :     _NODISCARD constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
; 616  :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left != _Right))) /* strengthened */ {
; 617  :         return _Left != _Right;
; 618  :     }
; 619  : };
; 620  : 
; 621  : _EXPORT_STD template <class _Ty = void>
; 622  : struct greater {
; 623  :     using _FIRST_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS  = _Ty;
; 624  :     using _SECOND_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;
; 625  :     using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS          = bool;
; 626  : 
; 627  :     _NODISCARD constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
; 628  :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left > _Right))) /* strengthened */ {
; 629  :         return _Left > _Right;
; 630  :     }
; 631  : };
; 632  : 
; 633  : _EXPORT_STD template <class _Ty = void>
; 634  : struct greater_equal {
; 635  :     using _FIRST_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS  = _Ty;
; 636  :     using _SECOND_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;
; 637  :     using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS          = bool;
; 638  : 
; 639  :     _NODISCARD constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
; 640  :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left >= _Right))) /* strengthened */ {
; 641  :         return _Left >= _Right;
; 642  :     }
; 643  : };
; 644  : 
; 645  : _EXPORT_STD template <class _Ty = void>
; 646  : struct less_equal {
; 647  :     using _FIRST_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS  = _Ty;
; 648  :     using _SECOND_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;
; 649  :     using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS          = bool;
; 650  : 
; 651  :     _NODISCARD constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
; 652  :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left <= _Right))) /* strengthened */ {
; 653  :         return _Left <= _Right;
; 654  :     }
; 655  : };
; 656  : 
; 657  : template <>
; 658  : struct plus<void> {
; 659  :     template <class _Ty1, class _Ty2>
; 660  :     _NODISCARD constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
; 661  :         noexcept(noexcept(static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right))) // strengthened
; 662  :         -> decltype(static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right)) {
; 663  :         return static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right);
; 664  :     }
; 665  : 
; 666  :     using is_transparent = int;
; 667  : };
; 668  : 
; 669  : template <>
; 670  : struct minus<void> {
; 671  :     template <class _Ty1, class _Ty2>
; 672  :     _NODISCARD constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
; 673  :         noexcept(noexcept(static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right))) // strengthened
; 674  :         -> decltype(static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right)) {
; 675  :         return static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right);
; 676  :     }
; 677  : 
; 678  :     using is_transparent = int;
; 679  : };
; 680  : 
; 681  : template <>
; 682  : struct multiplies<void> {
; 683  :     template <class _Ty1, class _Ty2>
; 684  :     _NODISCARD constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
; 685  :         noexcept(noexcept(static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right))) // strengthened
; 686  :         -> decltype(static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right)) {
; 687  :         return static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right);
; 688  :     }
; 689  : 
; 690  :     using is_transparent = int;
; 691  : };
; 692  : 
; 693  : template <>
; 694  : struct equal_to<void> {
; 695  :     template <class _Ty1, class _Ty2>
; 696  :     _NODISCARD constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
; 697  :         noexcept(noexcept(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right))) // strengthened
; 698  :         -> decltype(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right)) {
; 699  :         return static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right);
; 700  :     }
; 701  : 
; 702  :     using is_transparent = int;
; 703  : };
; 704  : 
; 705  : template <>
; 706  : struct not_equal_to<void> {
; 707  :     template <class _Ty1, class _Ty2>
; 708  :     _NODISCARD constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
; 709  :         noexcept(noexcept(static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right))) // strengthened
; 710  :         -> decltype(static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right)) {
; 711  :         return static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right);
; 712  :     }
; 713  : 
; 714  :     using is_transparent = int;
; 715  : };
; 716  : 
; 717  : template <>
; 718  : struct greater<void> {
; 719  :     template <class _Ty1, class _Ty2>
; 720  :     _NODISCARD constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
; 721  :         noexcept(noexcept(static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right))) // strengthened
; 722  :         -> decltype(static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right)) {
; 723  :         return static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right);
; 724  :     }
; 725  : 
; 726  :     using is_transparent = int;
; 727  : };
; 728  : 
; 729  : template <>
; 730  : struct greater_equal<void> {
; 731  :     template <class _Ty1, class _Ty2>
; 732  :     _NODISCARD constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
; 733  :         noexcept(noexcept(static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right))) // strengthened
; 734  :         -> decltype(static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right)) {
; 735  :         return static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right);
; 736  :     }
; 737  : 
; 738  :     using is_transparent = int;
; 739  : };
; 740  : 
; 741  : template <>
; 742  : struct less_equal<void> {
; 743  :     template <class _Ty1, class _Ty2>
; 744  :     _NODISCARD constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
; 745  :         noexcept(noexcept(static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right))) // strengthened
; 746  :         -> decltype(static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right)) {
; 747  :         return static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right);
; 748  :     }
; 749  : 
; 750  :     using is_transparent = int;
; 751  : };
; 752  : 
; 753  : template <class _Fx>
; 754  : struct _Ref_fn { // pass function object by value as a reference
; 755  :     // _Ref_fn is an aggregate so it can be enregistered, unlike reference_wrapper
; 756  : 
; 757  :     template <class... _Args>
; 758  :     constexpr decltype(auto) operator()(_Args&&... _Vals) noexcept(
; 759  :         _Select_invoke_traits<_Fx&, _Args...>::_Is_nothrow_invocable::value) { // forward function call operator
; 760  :         if constexpr (is_member_pointer_v<_Fx>) {
; 761  :             return _STD invoke(_Fn, _STD forward<_Args>(_Vals)...);
; 762  :         } else {
; 763  :             return _Fn(_STD forward<_Args>(_Vals)...);
; 764  :         }
; 765  :     }
; 766  : 
; 767  :     _Fx& _Fn;
; 768  : };
; 769  : 
; 770  : template <class _Fn>
; 771  : _NODISCARD constexpr auto _Pass_fn(_Fn& _Func) noexcept {
; 772  :     constexpr bool _Pass_by_value = conjunction_v<bool_constant<sizeof(_Fn) <= sizeof(void*)>,
; 773  :         is_trivially_copy_constructible<_Fn>, is_trivially_destructible<_Fn>>;
; 774  :     if constexpr (_Pass_by_value) {
; 775  :         return _Func;
; 776  :     } else {
; 777  :         return _Ref_fn<_Fn>{_Func}; // pass functor by "reference"
; 778  :     }
; 779  : }
; 780  : 
; 781  : #if _HAS_CXX23
; 782  : _EXPORT_STD template <class _Result_type, class _Callable, class... _Types>
; 783  :     requires is_invocable_r_v<_Result_type, _Callable, _Types...>
; 784  : _NODISCARD constexpr _Result_type invoke_r(_Callable&& _Obj, _Types&&... _Args)
; 785  :     noexcept(is_nothrow_invocable_r_v<_Result_type, _Callable, _Types...>) {
; 786  :     if constexpr (is_void_v<_Result_type>) {
; 787  :         (void) _STD invoke(static_cast<_Callable&&>(_Obj), static_cast<_Types&&>(_Args)...);
; 788  :     } else {
; 789  :         return _STD invoke(static_cast<_Callable&&>(_Obj), static_cast<_Types&&>(_Args)...);
; 790  :     }
; 791  : }
; 792  : #endif // _HAS_CXX23
; 793  : 
; 794  : struct _Unused_parameter { // generic unused parameter struct
; 795  :     constexpr _Unused_parameter() noexcept = default;
; 796  :     template <class _Ty>
; 797  :     constexpr _Unused_parameter(_Ty&&) noexcept {}
; 798  : };
; 799  : 
; 800  : template <class _Ty>
; 801  : using _Algorithm_int_t = conditional_t<is_integral_v<_Ty>, _Ty, ptrdiff_t>;
; 802  : 
; 803  : #if _HAS_CXX20
; 804  : template <class _Ty>
; 805  : concept _Destructible_object = is_object_v<_Ty> && destructible<_Ty>;
; 806  : 
; 807  : template <template <class...> class _Template, class... _Args>
; 808  : void _Derived_from_specialization_impl(const _Template<_Args...>&);
; 809  : 
; 810  : template <class _Ty, template <class...> class _Template>
; 811  : concept _Derived_from_specialization_of = requires(const _Ty& _Obj) {
; 812  :     _STD _Derived_from_specialization_impl<_Template>(_Obj); // qualified: avoid ADL, handle incomplete types
; 813  : };
; 814  : 
; 815  : namespace ranges {
; 816  :     namespace _Iter_move {
; 817  : #if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1681199
; 818  :         void iter_move() = delete; // Block unqualified name lookup
; 819  : #else // ^^^ no workaround / workaround vvv
; 820  :         void iter_move();
; 821  : #endif // ^^^ workaround ^^^
; 822  : 
; 823  :         template <class _Ty>
; 824  :         concept _Has_ADL = _Has_class_or_enum_type<_Ty> && requires(_Ty&& __t) {
; 825  :             iter_move(static_cast<_Ty&&>(__t)); // intentional ADL
; 826  :         };
; 827  : 
; 828  :         template <class _Ty>
; 829  :         concept _Can_deref = requires(_Ty&& __t) { *static_cast<_Ty&&>(__t); };
; 830  : 
; 831  :         class _Cpo {
; 832  :         private:
; 833  :             enum class _St { _None, _Custom, _Fallback };
; 834  : 
; 835  :             template <class _Ty>
; 836  :             _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
; 837  :                 if constexpr (_Has_ADL<_Ty>) {
; 838  :                     return {_St::_Custom, noexcept(iter_move(_STD declval<_Ty>()))}; // intentional ADL
; 839  :                 } else if constexpr (_Can_deref<_Ty>) {
; 840  :                     return {_St::_Fallback, noexcept(*_STD declval<_Ty>())};
; 841  :                 } else {
; 842  :                     return {_St::_None};
; 843  :                 }
; 844  :             }
; 845  : 
; 846  :             template <class _Ty>
; 847  :             static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();
; 848  : 
; 849  :         public:
; 850  :             template <class _Ty>
; 851  :                 requires (_Choice<_Ty>._Strategy != _St::_None)
; 852  :             _NODISCARD _STATIC_CALL_OPERATOR constexpr decltype(auto) operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
; 853  :                 noexcept(_Choice<_Ty>._No_throw) {
; 854  :                 constexpr _St _Strat = _Choice<_Ty>._Strategy;
; 855  : 
; 856  :                 if constexpr (_Strat == _St::_Custom) {
; 857  :                     return iter_move(static_cast<_Ty&&>(_Val)); // intentional ADL
; 858  :                 } else if constexpr (_Strat == _St::_Fallback) {
; 859  :                     using _Ref = decltype(*static_cast<_Ty&&>(_Val));
; 860  :                     if constexpr (is_lvalue_reference_v<_Ref>) {
; 861  :                         return _STD move(*static_cast<_Ty&&>(_Val));
; 862  :                     } else {
; 863  :                         return *static_cast<_Ty&&>(_Val);
; 864  :                     }
; 865  :                 } else {
; 866  :                     _STL_INTERNAL_STATIC_ASSERT(false); // unexpected strategy
; 867  :                 }
; 868  :             }
; 869  :         };
; 870  :     } // namespace _Iter_move
; 871  : 
; 872  :     inline namespace _Cpos {
; 873  :         _EXPORT_STD inline constexpr _Iter_move::_Cpo iter_move;
; 874  :     }
; 875  : } // namespace ranges
; 876  : 
; 877  : // iter_swap defined below since it depends on indirectly_movable_storable
; 878  : 
; 879  : _EXPORT_STD template <class _Ty>
; 880  :     requires _Dereferenceable<_Ty> && requires(_Ty& __t) {
; 881  :         { _RANGES iter_move(__t) } -> _Can_reference;
; 882  :     }
; 883  : using iter_rvalue_reference_t = decltype(_RANGES iter_move(_STD declval<_Ty&>()));
; 884  : 
; 885  : template <class _It>
; 886  : concept _Indirectly_readable_impl =
; 887  :     requires(const _It __i) {
; 888  :         typename iter_value_t<_It>;
; 889  :         typename iter_reference_t<_It>;
; 890  :         typename iter_rvalue_reference_t<_It>;
; 891  :         { *__i } -> same_as<iter_reference_t<_It>>;
; 892  :         { _RANGES iter_move(__i) } -> same_as<iter_rvalue_reference_t<_It>>;
; 893  :     } && common_reference_with<iter_reference_t<_It>&&, iter_value_t<_It>&>
; 894  :     && common_reference_with<iter_reference_t<_It>&&, iter_rvalue_reference_t<_It>&&>
; 895  :     && common_reference_with<iter_rvalue_reference_t<_It>&&, const iter_value_t<_It>&>;
; 896  : 
; 897  : _EXPORT_STD template <class _It>
; 898  : concept indirectly_readable = _Indirectly_readable_impl<remove_cvref_t<_It>>;
; 899  : 
; 900  : template <class _Ty>
; 901  : struct _Indirect_value_impl {
; 902  :     using type = iter_value_t<_Ty>&;
; 903  : };
; 904  : 
; 905  : template <indirectly_readable _It>
; 906  : using _Indirect_value_t = _Indirect_value_impl<_It>::type;
; 907  : 
; 908  : _EXPORT_STD template <indirectly_readable _Ty>
; 909  : using iter_common_reference_t = common_reference_t<iter_reference_t<_Ty>, _Indirect_value_t<_Ty>>;
; 910  : 
; 911  : _EXPORT_STD template <class _It, class _Ty>
; 912  : concept indirectly_writable = requires(_It&& __i, _Ty&& __t) {
; 913  :     *__i                                                                = static_cast<_Ty&&>(__t);
; 914  :     *static_cast<_It&&>(__i)                                            = static_cast<_Ty&&>(__t);
; 915  :     const_cast<const iter_reference_t<_It>&&>(*__i)                     = static_cast<_Ty&&>(__t);
; 916  :     const_cast<const iter_reference_t<_It>&&>(*static_cast<_It&&>(__i)) = static_cast<_Ty&&>(__t);
; 917  : };
; 918  : 
; 919  : template <bool _Is_integer_class>
; 920  : struct _Make_unsigned_like_impl {
; 921  :     template <class _Ty>
; 922  :     using _Apply = _Ty::_Unsigned_type;
; 923  : };
; 924  : template <>
; 925  : struct _Make_unsigned_like_impl<false> {
; 926  :     template <class _Ty>
; 927  :     using _Apply = make_unsigned_t<_Ty>;
; 928  : };
; 929  : 
; 930  : template <class _Ty>
; 931  : using _Make_unsigned_like_t = _Make_unsigned_like_impl<_Integer_class<_Ty>>::template _Apply<_Ty>;
; 932  : 
; 933  : template <_Integer_like _Ty>
; 934  : _NODISCARD constexpr auto _To_unsigned_like(const _Ty _Value) noexcept {
; 935  :     return static_cast<_Make_unsigned_like_t<_Ty>>(_Value);
; 936  : }
; 937  : 
; 938  : template <bool _Is_integer_class>
; 939  : struct _Make_signed_like_impl {
; 940  :     template <class _Ty>
; 941  :     using _Apply = _Ty::_Signed_type;
; 942  : };
; 943  : template <>
; 944  : struct _Make_signed_like_impl<false> {
; 945  :     template <class _Ty>
; 946  :     using _Apply = make_signed_t<_Ty>;
; 947  : };
; 948  : 
; 949  : template <class _Ty>
; 950  : using _Make_signed_like_t = _Make_signed_like_impl<_Integer_class<_Ty>>::template _Apply<_Ty>;
; 951  : 
; 952  : _EXPORT_STD template <class _Ty>
; 953  : concept incrementable = regular<_Ty> && weakly_incrementable<_Ty> && requires(_Ty __t) {
; 954  :     { __t++ } -> same_as<_Ty>;
; 955  : };
; 956  : 
; 957  : template <bool _Iterator_category_present>
; 958  : struct _Iter_concept_impl2 {
; 959  :     template <class _It, class _Traits>
; 960  :     using _Apply = _Traits::iterator_category;
; 961  : };
; 962  : template <>
; 963  : struct _Iter_concept_impl2<false> {
; 964  :     template <class _It, class _Traits>
; 965  :         requires _Is_from_primary<iterator_traits<_It>>
; 966  :     using _Apply = random_access_iterator_tag;
; 967  : };
; 968  : 
; 969  : template <bool _Iterator_concept_present>
; 970  : struct _Iter_concept_impl1 {
; 971  :     template <class _It, class _Traits>
; 972  :     using _Apply = _Traits::iterator_concept;
; 973  : };
; 974  : template <>
; 975  : struct _Iter_concept_impl1<false> {
; 976  :     template <class _It, class _Traits>
; 977  :     using _Apply = _Iter_concept_impl2<_Has_member_iterator_category<_Traits>>::template _Apply<_It, _Traits>;
; 978  : };
; 979  : 
; 980  : template <class _It, class _Traits = conditional_t<_Is_from_primary<iterator_traits<_It>>, _It, iterator_traits<_It>>>
; 981  : using _Iter_concept = _Iter_concept_impl1<_Has_member_iterator_concept<_Traits>>::template _Apply<_It, _Traits>;
; 982  : 
; 983  : _EXPORT_STD template <class _It>
; 984  : concept input_iterator = input_or_output_iterator<_It> && indirectly_readable<_It> && requires {
; 985  :     typename _Iter_concept<_It>;
; 986  : } && derived_from<_Iter_concept<_It>, input_iterator_tag>;
; 987  : 
; 988  : _EXPORT_STD template <class _It, class _Ty>
; 989  : concept output_iterator = input_or_output_iterator<_It> && indirectly_writable<_It, _Ty>
; 990  :                        && requires(_It __i, _Ty&& __t) { *__i++ = static_cast<_Ty&&>(__t); };
; 991  : 
; 992  : _EXPORT_STD template <class _It>
; 993  : concept forward_iterator = input_iterator<_It> && derived_from<_Iter_concept<_It>, forward_iterator_tag>
; 994  :                         && incrementable<_It> && sentinel_for<_It, _It>;
; 995  : 
; 996  : _EXPORT_STD template <class _It>
; 997  : concept bidirectional_iterator =
; 998  :     forward_iterator<_It> && derived_from<_Iter_concept<_It>, bidirectional_iterator_tag> && requires(_It __i) {
; 999  :         { --__i } -> same_as<_It&>;
; 1000 :         { __i-- } -> same_as<_It>;
; 1001 :     };
; 1002 : 
; 1003 : _EXPORT_STD template <class _It>
; 1004 : concept random_access_iterator =
; 1005 :     bidirectional_iterator<_It> && derived_from<_Iter_concept<_It>, random_access_iterator_tag> && totally_ordered<_It>
; 1006 :     && sized_sentinel_for<_It, _It> && requires(_It __i, const _It __j, const iter_difference_t<_It> __n) {
; 1007 :            { __i += __n } -> same_as<_It&>;
; 1008 :            { __j + __n } -> same_as<_It>;
; 1009 :            { __n + __j } -> same_as<_It>;
; 1010 :            { __i -= __n } -> same_as<_It&>;
; 1011 :            { __j - __n } -> same_as<_It>;
; 1012 :            { __j[__n] } -> same_as<iter_reference_t<_It>>;
; 1013 :        };
; 1014 : 
; 1015 : _EXPORT_STD template <class _It>
; 1016 : concept contiguous_iterator =
; 1017 :     random_access_iterator<_It> && derived_from<_Iter_concept<_It>, contiguous_iterator_tag>
; 1018 :     && is_lvalue_reference_v<iter_reference_t<_It>> && same_as<iter_value_t<_It>, remove_cvref_t<iter_reference_t<_It>>>
; 1019 :     && requires(const _It& __i) {
; 1020 :            { _STD to_address(__i) } -> same_as<add_pointer_t<iter_reference_t<_It>>>;
; 1021 :        };
; 1022 : 
; 1023 : _EXPORT_STD template <class _Fn, class _It>
; 1024 : concept indirectly_unary_invocable = indirectly_readable<_It> && copy_constructible<_Fn>
; 1025 :                                   && invocable<_Fn&, _Indirect_value_t<_It>> && invocable<_Fn&, iter_reference_t<_It>>
; 1026 :                                   && common_reference_with<invoke_result_t<_Fn&, _Indirect_value_t<_It>>,
; 1027 :                                       invoke_result_t<_Fn&, iter_reference_t<_It>>>;
; 1028 : 
; 1029 : _EXPORT_STD template <class _Fn, class _It>
; 1030 : concept indirectly_regular_unary_invocable =
; 1031 :     indirectly_readable<_It> && copy_constructible<_Fn> && regular_invocable<_Fn&, _Indirect_value_t<_It>>
; 1032 :     && regular_invocable<_Fn&, iter_reference_t<_It>>
; 1033 :     && common_reference_with<invoke_result_t<_Fn&, _Indirect_value_t<_It>>,
; 1034 :         invoke_result_t<_Fn&, iter_reference_t<_It>>>;
; 1035 : 
; 1036 : _EXPORT_STD template <class _Fn, class _It>
; 1037 : concept indirect_unary_predicate = indirectly_readable<_It> && copy_constructible<_Fn>
; 1038 :                                 && predicate<_Fn&, _Indirect_value_t<_It>> && predicate<_Fn&, iter_reference_t<_It>>;
; 1039 : 
; 1040 : _EXPORT_STD template <class _Fn, class _It1, class _It2>
; 1041 : concept indirect_binary_predicate = indirectly_readable<_It1> && indirectly_readable<_It2> && copy_constructible<_Fn>
; 1042 :                                  && predicate<_Fn&, _Indirect_value_t<_It1>, _Indirect_value_t<_It2>>
; 1043 :                                  && predicate<_Fn&, _Indirect_value_t<_It1>, iter_reference_t<_It2>>
; 1044 :                                  && predicate<_Fn&, iter_reference_t<_It1>, _Indirect_value_t<_It2>>
; 1045 :                                  && predicate<_Fn&, iter_reference_t<_It1>, iter_reference_t<_It2>>;
; 1046 : 
; 1047 : _EXPORT_STD template <class _Fn, class _It1, class _It2 = _It1>
; 1048 : concept indirect_equivalence_relation =
; 1049 :     indirectly_readable<_It1> && indirectly_readable<_It2> && copy_constructible<_Fn>
; 1050 :     && equivalence_relation<_Fn&, _Indirect_value_t<_It1>, _Indirect_value_t<_It2>>
; 1051 :     && equivalence_relation<_Fn&, _Indirect_value_t<_It1>, iter_reference_t<_It2>>
; 1052 :     && equivalence_relation<_Fn&, iter_reference_t<_It1>, _Indirect_value_t<_It2>>
; 1053 :     && equivalence_relation<_Fn&, iter_reference_t<_It1>, iter_reference_t<_It2>>;
; 1054 : 
; 1055 : _EXPORT_STD template <class _Fn, class _It1, class _It2 = _It1>
; 1056 : concept indirect_strict_weak_order = indirectly_readable<_It1> && indirectly_readable<_It2> && copy_constructible<_Fn>
; 1057 :                                   && strict_weak_order<_Fn&, _Indirect_value_t<_It1>, _Indirect_value_t<_It2>>
; 1058 :                                   && strict_weak_order<_Fn&, _Indirect_value_t<_It1>, iter_reference_t<_It2>>
; 1059 :                                   && strict_weak_order<_Fn&, iter_reference_t<_It1>, _Indirect_value_t<_It2>>
; 1060 :                                   && strict_weak_order<_Fn&, iter_reference_t<_It1>, iter_reference_t<_It2>>;
; 1061 : 
; 1062 : _EXPORT_STD template <class _Fn, class... _Its>
; 1063 :     requires (indirectly_readable<_Its> && ...) && invocable<_Fn, iter_reference_t<_Its>...>
; 1064 : using indirect_result_t = invoke_result_t<_Fn, iter_reference_t<_Its>...>;
; 1065 : 
; 1066 : template <class _It>
; 1067 : struct _Projected_difference_type_impl {
; 1068 :     struct _Base {};
; 1069 : };
; 1070 : 
; 1071 : template <weakly_incrementable _It>
; 1072 : struct _Projected_difference_type_impl<_It> {
; 1073 :     struct _Base {
; 1074 :         using difference_type = iter_difference_t<_It>;
; 1075 :     };
; 1076 : };
; 1077 : 
; 1078 : template <class _It, class _Proj>
; 1079 : struct _Projected_impl {
; 1080 :     struct _Type : _Projected_difference_type_impl<_It>::_Base {
; 1081 :         using _Iterator   = _It;
; 1082 :         using _Projection = _Proj;
; 1083 : 
; 1084 :         using value_type = remove_cvref_t<indirect_result_t<_Proj&, _It>>;
; 1085 :         [[noreturn]] indirect_result_t<_Proj&, _It> operator*() const {
; 1086 :             _CSTD abort(); // shouldn't be called, see GH-3888
; 1087 :         }
; 1088 :     };
; 1089 : };
; 1090 : 
; 1091 : _EXPORT_STD template <indirectly_readable _It, indirectly_regular_unary_invocable<_It> _Proj>
; 1092 : using projected = _Projected_impl<_It, _Proj>::_Type;
; 1093 : 
; 1094 : template <class _Ty>
; 1095 : concept _Projected_specialization = same_as<_Ty, projected<typename _Ty::_Iterator, typename _Ty::_Projection>>;
; 1096 : 
; 1097 : template <_Projected_specialization _ProjTy>
; 1098 : struct _Indirect_value_impl<_ProjTy> {
; 1099 :     using type = invoke_result_t<typename _ProjTy::_Projection&, _Indirect_value_t<typename _ProjTy::_Iterator>>;
; 1100 : };
; 1101 : 
; 1102 : _EXPORT_STD template <class _In, class _Out>
; 1103 : concept indirectly_movable = indirectly_readable<_In> && indirectly_writable<_Out, iter_rvalue_reference_t<_In>>;
; 1104 : 
; 1105 : _EXPORT_STD template <class _In, class _Out>
; 1106 : concept indirectly_movable_storable =
; 1107 :     indirectly_movable<_In, _Out> && indirectly_writable<_Out, iter_value_t<_In>> && movable<iter_value_t<_In>>
; 1108 :     && constructible_from<iter_value_t<_In>, iter_rvalue_reference_t<_In>>
; 1109 :     && assignable_from<iter_value_t<_In>&, iter_rvalue_reference_t<_In>>;
; 1110 : 
; 1111 : _EXPORT_STD template <class _In, class _Out>
; 1112 : concept indirectly_copyable = indirectly_readable<_In> && indirectly_writable<_Out, iter_reference_t<_In>>;
; 1113 : 
; 1114 : _EXPORT_STD template <class _In, class _Out>
; 1115 : concept indirectly_copyable_storable =
; 1116 :     indirectly_copyable<_In, _Out> && indirectly_writable<_Out, iter_value_t<_In>&>
; 1117 :     && indirectly_writable<_Out, const iter_value_t<_In>&> && indirectly_writable<_Out, iter_value_t<_In>&&>
; 1118 :     && indirectly_writable<_Out, const iter_value_t<_In>&&> && copyable<iter_value_t<_In>>
; 1119 :     && constructible_from<iter_value_t<_In>, iter_reference_t<_In>>
; 1120 :     && assignable_from<iter_value_t<_In>&, iter_reference_t<_In>>;
; 1121 : 
; 1122 : namespace ranges {
; 1123 :     namespace _Iter_swap {
; 1124 :         template <class _Ty1, class _Ty2>
; 1125 :         void iter_swap(_Ty1, _Ty2) = delete;
; 1126 : 
; 1127 :         template <class _Ty1, class _Ty2>
; 1128 :         concept _Has_ADL =
; 1129 :             (_Has_class_or_enum_type<_Ty1> || _Has_class_or_enum_type<_Ty2>) && requires(_Ty1&& __t1, _Ty2&& __t2) {
; 1130 :                 iter_swap(static_cast<_Ty1&&>(__t1), static_cast<_Ty2&&>(__t2)); // intentional ADL
; 1131 :             };
; 1132 : 
; 1133 :         template <class _Ty1, class _Ty2>
; 1134 :         concept _Can_swap_references =
; 1135 :             indirectly_readable<remove_reference_t<_Ty1>> && indirectly_readable<remove_reference_t<_Ty2>>
; 1136 :             && swappable_with<iter_reference_t<_Ty1>, iter_reference_t<_Ty2>>;
; 1137 : 
; 1138 :         template <class _Ty1, class _Ty2>
; 1139 :         concept _Symmetric_indirectly_movable_storable =
; 1140 :             indirectly_movable_storable<remove_reference_t<_Ty1>, remove_reference_t<_Ty2>>
; 1141 :             && indirectly_movable_storable<remove_reference_t<_Ty2>, remove_reference_t<_Ty1>>;
; 1142 : 
; 1143 :         template <class _Xty, class _Yty>
; 1144 :         _NODISCARD constexpr iter_value_t<remove_reference_t<_Xty>> _Iter_exchange_move(_Xty&& _XVal, _Yty&& _YVal)
; 1145 :             noexcept(noexcept(iter_value_t<remove_reference_t<_Xty>>(_RANGES iter_move(_XVal)))) {
; 1146 :             iter_value_t<remove_reference_t<_Xty>> _Tmp(_RANGES iter_move(_XVal));
; 1147 :             *_XVal = _RANGES iter_move(_YVal);
; 1148 :             return _Tmp;
; 1149 :         }
; 1150 : 
; 1151 :         class _Cpo {
; 1152 :         private:
; 1153 :             enum class _St { _None, _Custom, _Swap, _Exchange };
; 1154 : 
; 1155 :             template <class _Ty1, class _Ty2>
; 1156 :             _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
; 1157 :                 if constexpr (_Has_ADL<_Ty1, _Ty2>) {
; 1158 :                     return {_St::_Custom,
; 1159 :                         noexcept(iter_swap(_STD declval<_Ty1>(), _STD declval<_Ty2>()))}; // intentional ADL
; 1160 :                 } else if constexpr (_Can_swap_references<_Ty1, _Ty2>) {
; 1161 :                     return {_St::_Swap, noexcept(_RANGES swap(*_STD declval<_Ty1>(), *_STD declval<_Ty2>()))};
; 1162 :                 } else if constexpr (_Symmetric_indirectly_movable_storable<_Ty1, _Ty2>) {
; 1163 :                     constexpr auto _Nothrow = noexcept(*_STD declval<_Ty1>() = _Iter_swap::_Iter_exchange_move(
; 1164 :                                                            _STD declval<_Ty2>(), _STD declval<_Ty1>()));
; 1165 :                     return {_St::_Exchange, _Nothrow};
; 1166 :                 } else {
; 1167 :                     return {_St::_None};
; 1168 :                 }
; 1169 :             }
; 1170 : 
; 1171 :             template <class _Ty1, class _Ty2>
; 1172 :             static constexpr _Choice_t<_St> _Choice = _Choose<_Ty1, _Ty2>();
; 1173 : 
; 1174 :         public:
; 1175 :             template <class _Ty1, class _Ty2>
; 1176 :                 requires (_Choice<_Ty1, _Ty2>._Strategy != _St::_None)
; 1177 :             _STATIC_CALL_OPERATOR constexpr void operator()(_Ty1&& _Val1, _Ty2&& _Val2) _CONST_CALL_OPERATOR
; 1178 :                 noexcept(_Choice<_Ty1, _Ty2>._No_throw) {
; 1179 :                 constexpr _St _Strat = _Choice<_Ty1, _Ty2>._Strategy;
; 1180 : 
; 1181 :                 if constexpr (_Strat == _St::_Custom) {
; 1182 :                     (void) iter_swap(static_cast<_Ty1&&>(_Val1), static_cast<_Ty2&&>(_Val2)); // intentional ADL
; 1183 :                 } else if constexpr (_Strat == _St::_Swap) {
; 1184 :                     _RANGES swap(*static_cast<_Ty1&&>(_Val1), *static_cast<_Ty2&&>(_Val2));
; 1185 :                 } else if constexpr (_Strat == _St::_Exchange) {
; 1186 :                     *static_cast<_Ty1&&>(_Val1) =
; 1187 :                         _Iter_swap::_Iter_exchange_move(static_cast<_Ty2&&>(_Val2), static_cast<_Ty1&&>(_Val1));
; 1188 :                 } else {
; 1189 :                     _STL_INTERNAL_STATIC_ASSERT(false); // unexpected strategy
; 1190 :                 }
; 1191 :             }
; 1192 :         };
; 1193 :     } // namespace _Iter_swap
; 1194 : 
; 1195 :     inline namespace _Cpos {
; 1196 :         _EXPORT_STD inline constexpr _Iter_swap::_Cpo iter_swap;
; 1197 :     }
; 1198 : } // namespace ranges
; 1199 : 
; 1200 : _EXPORT_STD template <class _It1, class _It2 = _It1>
; 1201 : concept indirectly_swappable =
; 1202 :     indirectly_readable<_It1> && indirectly_readable<_It2> && requires(const _It1 __i1, const _It2 __i2) {
; 1203 :         _RANGES iter_swap(__i1, __i1);
; 1204 :         _RANGES iter_swap(__i2, __i2);
; 1205 :         _RANGES iter_swap(__i1, __i2);
; 1206 :         _RANGES iter_swap(__i2, __i1);
; 1207 :     };
; 1208 : 
; 1209 : _EXPORT_STD template <class _It1, class _It2, class _Rel, class _Proj1 = identity, class _Proj2 = identity>
; 1210 : concept indirectly_comparable = indirect_binary_predicate<_Rel, projected<_It1, _Proj1>, projected<_It2, _Proj2>>;
; 1211 : 
; 1212 : _EXPORT_STD template <class _It>
; 1213 : concept permutable = forward_iterator<_It> && indirectly_movable_storable<_It, _It> && indirectly_swappable<_It, _It>;
; 1214 : 
; 1215 : namespace ranges {
; 1216 :     _EXPORT_STD struct less;
; 1217 : } // namespace ranges
; 1218 : 
; 1219 : _EXPORT_STD template <class _It1, class _It2, class _Out, class _Pr = ranges::less, class _Pj1 = identity,
; 1220 :     class _Pj2 = identity>
; 1221 : concept mergeable =
; 1222 :     input_iterator<_It1> && input_iterator<_It2> && weakly_incrementable<_Out> && indirectly_copyable<_It1, _Out>
; 1223 :     && indirectly_copyable<_It2, _Out> && indirect_strict_weak_order<_Pr, projected<_It1, _Pj1>, projected<_It2, _Pj2>>;
; 1224 : 
; 1225 : _EXPORT_STD template <class _It, class _Pr = ranges::less, class _Proj = identity>
; 1226 : concept sortable = permutable<_It> && indirect_strict_weak_order<_Pr, projected<_It, _Proj>>;
; 1227 : 
; 1228 : template <class _Iter>
; 1229 : using _Iter_ref_t = iter_reference_t<_Iter>;
; 1230 : 
; 1231 : template <class _Iter>
; 1232 : using _Iter_value_t = iter_value_t<_Iter>;
; 1233 : 
; 1234 : template <class _Iter>
; 1235 : using _Iter_diff_t = iter_difference_t<_Iter>;
; 1236 : 
; 1237 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 1238 : template <class _Iter>
; 1239 : using _Iter_ref_t = typename iterator_traits<_Iter>::reference;
; 1240 : 
; 1241 : template <class _Iter>
; 1242 : using _Iter_value_t = typename iterator_traits<_Iter>::value_type;
; 1243 : 
; 1244 : template <class _Iter>
; 1245 : using _Iter_diff_t = typename iterator_traits<_Iter>::difference_type;
; 1246 : 
; 1247 : template <class _Ty>
; 1248 : using _Make_unsigned_like_t = make_unsigned_t<_Ty>;
; 1249 : #endif // ^^^ !_HAS_CXX20 ^^^
; 1250 : 
; 1251 : template <class... _Iters>
; 1252 : using _Common_diff_t = common_type_t<_Iter_diff_t<_Iters>...>;
; 1253 : 
; 1254 : template <class _Iter>
; 1255 : using _Iter_cat_t = typename iterator_traits<_Iter>::iterator_category;
; 1256 : 
; 1257 : #if _HAS_CXX20
; 1258 : template <class _Ty>
; 1259 : concept _Iterator_for_container = requires { typename _Iter_cat_t<_Ty>; };
; 1260 : 
; 1261 : template <class _Ty>
; 1262 : constexpr bool _Is_iterator_v = _Iterator_for_container<_Ty>;
; 1263 : 
; 1264 : template <class _Ty>
; 1265 : struct _Is_iterator : bool_constant<_Iterator_for_container<_Ty>> {};
; 1266 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 1267 : template <class _Ty, class = void>
; 1268 : constexpr bool _Is_iterator_v = false;
; 1269 : 
; 1270 : template <class _Ty>
; 1271 : constexpr bool _Is_iterator_v<_Ty, void_t<_Iter_cat_t<_Ty>>> = true;
; 1272 : 
; 1273 : template <class _Ty>
; 1274 : struct _Is_iterator : bool_constant<_Is_iterator_v<_Ty>> {};
; 1275 : #endif // ^^^ !_HAS_CXX20 ^^^
; 1276 : 
; 1277 : template <class _Iter>
; 1278 : constexpr bool _Is_cpp17_input_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, input_iterator_tag>;
; 1279 : 
; 1280 : template <class _Iter>
; 1281 : constexpr bool _Is_ranges_input_iter_v =
; 1282 : #if _HAS_CXX20
; 1283 :     (input_iterator<_Iter> && sentinel_for<_Iter, _Iter>) ||
; 1284 : #endif
; 1285 :     _Is_cpp17_input_iter_v<_Iter>;
; 1286 : 
; 1287 : template <class _Iter>
; 1288 : constexpr bool _Is_cpp17_fwd_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, forward_iterator_tag>;
; 1289 : 
; 1290 : template <class _Iter>
; 1291 : constexpr bool _Is_ranges_fwd_iter_v =
; 1292 : #if _HAS_CXX20
; 1293 :     forward_iterator<_Iter> ||
; 1294 : #endif
; 1295 :     _Is_cpp17_fwd_iter_v<_Iter>;
; 1296 : 
; 1297 : template <class _Iter>
; 1298 : constexpr bool _Is_cpp17_bidi_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, bidirectional_iterator_tag>;
; 1299 : 
; 1300 : template <class _Iter>
; 1301 : constexpr bool _Is_ranges_bidi_iter_v =
; 1302 : #if _HAS_CXX20
; 1303 :     bidirectional_iterator<_Iter> ||
; 1304 : #endif
; 1305 :     _Is_cpp17_bidi_iter_v<_Iter>;
; 1306 : 
; 1307 : template <class _Iter>
; 1308 : constexpr bool _Is_cpp17_random_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, random_access_iterator_tag>;
; 1309 : 
; 1310 : template <class _Iter>
; 1311 : constexpr bool _Is_ranges_random_iter_v =
; 1312 : #if _HAS_CXX20
; 1313 :     random_access_iterator<_Iter> ||
; 1314 : #endif
; 1315 :     _Is_cpp17_random_iter_v<_Iter>;
; 1316 : 
; 1317 : #define _REQUIRE_CPP17_MUTABLE_ITERATOR(_Iter) \
; 1318 :     static_assert(_Is_cpp17_fwd_iter_v<_Iter>, \
; 1319 :         "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.")
; 1320 : 
; 1321 : #define _REQUIRE_CPP17_MUTABLE_BIDIRECTIONAL_ITERATOR(_Iter) \
; 1322 :     static_assert(_Is_cpp17_bidi_iter_v<_Iter>,              \
; 1323 :         "This algorithm requires that mutable iterators be Cpp17BidirectionalIterators or stronger.")
; 1324 : 
; 1325 : template <class, class = void>
; 1326 : struct _Is_checked_helper {}; // default definition, no longer used, retained due to pseudo-documentation
; 1327 : 
; 1328 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1329 : template <class _Ty>
; 1330 : constexpr void _Verify_range(const _Ty* const _First, const _Ty* const _Last) noexcept {
; 1331 :     // special case range verification for pointers
; 1332 :     _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1333 : }
; 1334 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1335 : 
; 1336 : template <class _Iter, class = void>
; 1337 : constexpr bool _Allow_inheriting_unwrap_v = true;
; 1338 : 
; 1339 : template <class _Iter>
; 1340 : constexpr bool _Allow_inheriting_unwrap_v<_Iter, void_t<typename _Iter::_Prevent_inheriting_unwrap>> =
; 1341 :     is_same_v<_Iter, typename _Iter::_Prevent_inheriting_unwrap>;
; 1342 : 
; 1343 : template <class _Iter, class _Sentinel = _Iter, class = void>
; 1344 : constexpr bool _Range_verifiable_v = false;
; 1345 : 
; 1346 : template <class _Iter, class _Sentinel>
; 1347 : constexpr bool _Range_verifiable_v<_Iter, _Sentinel,
; 1348 :     void_t<decltype(_Verify_range(_STD declval<const _Iter&>(), _STD declval<const _Sentinel&>()))>> =
; 1349 :     _Allow_inheriting_unwrap_v<_Iter>;
; 1350 : 
; 1351 : template <class _Iter, class _Sentinel>
; 1352 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {
; 1353 :     // check that [_First, _Last) forms an iterator range
; 1354 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1355 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1356 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1357 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1358 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1359 :         _Verify_range(_First, _Last);
; 1360 :     }
; 1361 : }
; 1362 : 
; 1363 : template <class _Iter, class = void>
; 1364 : constexpr bool _Unwrappable_v = false;
; 1365 : 
; 1366 : template <class _Iter>
; 1367 : constexpr bool _Unwrappable_v<_Iter,
; 1368 :     void_t<decltype(_STD declval<_Remove_cvref_t<_Iter>&>()._Seek_to(_STD declval<_Iter>()._Unwrapped()))>> =
; 1369 :     _Allow_inheriting_unwrap_v<_Remove_cvref_t<_Iter>>;
; 1370 : 
; 1371 : template <class _Iter, class = void>
; 1372 : constexpr bool _Has_nothrow_unwrapped = false;
; 1373 : template <class _Iter>
; 1374 : constexpr bool _Has_nothrow_unwrapped<_Iter, void_t<decltype(_STD declval<_Iter>()._Unwrapped())>> =
; 1375 :     noexcept(_STD declval<_Iter>()._Unwrapped());
; 1376 : 
; 1377 : template <class _Iter>
; 1378 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It)
; 1379 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {
; 1380 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1381 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1382 :         return _It + 0;
; 1383 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1384 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1385 :     } else {
; 1386 :         return static_cast<_Iter&&>(_It);
; 1387 :     }
; 1388 : }
; 1389 : 
; 1390 : template <class _Iter>
; 1391 : using _Unwrapped_t = _Remove_cvref_t<decltype(_STD _Get_unwrapped(_STD declval<_Iter>()))>;
; 1392 : 
; 1393 : template <class _Iter, class = bool>
; 1394 : constexpr bool _Do_unwrap_when_unverified_v = false;
; 1395 : 
; 1396 : template <class _Iter>
; 1397 : constexpr bool _Do_unwrap_when_unverified_v<_Iter, decltype(static_cast<bool>(_Iter::_Unwrap_when_unverified))> =
; 1398 :     static_cast<bool>(_Iter::_Unwrap_when_unverified);
; 1399 : 
; 1400 : template <class _Iter>
; 1401 : constexpr bool _Unwrappable_for_unverified_v =
; 1402 :     _Unwrappable_v<_Iter> && _Do_unwrap_when_unverified_v<_Remove_cvref_t<_Iter>>;
; 1403 : 
; 1404 : template <class _Iter>
; 1405 : _NODISCARD constexpr decltype(auto) _Get_unwrapped_unverified(_Iter&& _It) {
; 1406 :     // unwrap an iterator not previously subjected to _Adl_verify_range
; 1407 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1408 :         return _It + 0;
; 1409 :     } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
; 1410 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1411 :     } else {
; 1412 :         return static_cast<_Iter&&>(_It);
; 1413 :     }
; 1414 : }
; 1415 : 
; 1416 : template <class _Iter>
; 1417 : using _Unwrapped_unverified_t = _Remove_cvref_t<decltype(_Get_unwrapped_unverified(_STD declval<_Iter>()))>;
; 1418 : 
; 1419 : struct _Distance_unknown {
; 1420 :     constexpr _Distance_unknown operator-() const noexcept {
; 1421 :         return {};
; 1422 :     }
; 1423 : };
; 1424 : 
; 1425 : template <class _Diff>
; 1426 : constexpr _Diff _Max_possible_v{static_cast<_Make_unsigned_like_t<_Diff>>(-1) >> 1};
; 1427 : 
; 1428 : template <class _Diff>
; 1429 : constexpr _Diff _Min_possible_v{-_Max_possible_v<_Diff> - 1};
; 1430 : 
; 1431 : template <class _Iter, class = void>
; 1432 : constexpr bool _Offset_verifiable_v = false;
; 1433 : 
; 1434 : template <class _Iter>
; 1435 : constexpr bool
; 1436 :     _Offset_verifiable_v<_Iter, void_t<decltype(_STD declval<const _Iter&>()._Verify_offset(_Iter_diff_t<_Iter>{}))>> =
; 1437 :         true;
; 1438 : 
; 1439 : template <class _Iter>
; 1440 : constexpr bool _Unwrappable_for_offset_v = _Unwrappable_v<_Iter> && _Offset_verifiable_v<_Remove_cvref_t<_Iter>>;
; 1441 : 
; 1442 : template <class _Iter, class _Diff>
; 1443 : _NODISCARD constexpr decltype(auto) _Get_unwrapped_n(_Iter&& _It, const _Diff _Off) {
; 1444 :     if constexpr (is_pointer_v<decay_t<_Iter>>) {
; 1445 :         return _It + 0;
; 1446 :     } else if constexpr (_Unwrappable_for_offset_v<_Iter> && _Integer_like<_Diff>) {
; 1447 :         // ask an iterator to assert that the iterator moved _Off positions is valid, and unwrap
; 1448 :         using _IDiff     = _Iter_diff_t<_Remove_cvref_t<_Iter>>;
; 1449 :         using _CDiff     = common_type_t<_Diff, _IDiff>;
; 1450 :         const auto _COff = static_cast<_CDiff>(_Off);
; 1451 : 
; 1452 :         _STL_ASSERT(_COff <= static_cast<_CDiff>(_Max_possible_v<_IDiff>)
; 1453 :                         && (is_unsigned_v<_Diff> || static_cast<_CDiff>(_Min_possible_v<_IDiff>) <= _COff),
; 1454 :             "integer overflow");
; 1455 :         (void) _COff;
; 1456 : 
; 1457 :         _It._Verify_offset(static_cast<_IDiff>(_Off));
; 1458 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1459 :     } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
; 1460 :         // iterator doesn't support offset-based asserts, or offset unknown; defer to unverified unwrap
; 1461 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1462 :     } else {
; 1463 :         // pass through iterator that doesn't participate in checking
; 1464 :         return static_cast<_Iter&&>(_It);
; 1465 :     }
; 1466 : }
; 1467 : 
; 1468 : template <class _Iter, class _UIter, class = void>
; 1469 : constexpr bool _Wrapped_seekable_v = false;
; 1470 : 
; 1471 : template <class _Iter, class _UIter>
; 1472 : constexpr bool
; 1473 :     _Wrapped_seekable_v<_Iter, _UIter, void_t<decltype(_STD declval<_Iter&>()._Seek_to(_STD declval<_UIter>()))>> =
; 1474 :         true;
; 1475 : 
; 1476 : template <class _Iter, class _UIter>
; 1477 : constexpr void _Seek_wrapped(_Iter& _It, _UIter&& _UIt) {
; 1478 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1479 :         _It._Seek_to(_STD forward<_UIter>(_UIt));
; 1480 :     } else {
; 1481 :         _It = _STD forward<_UIter>(_UIt);
; 1482 :     }
; 1483 : }
; 1484 : 
; 1485 : #if _HAS_CXX17
; 1486 : #if _HAS_CXX20
; 1487 : // detects whether _Ty resembles an allocator, N4981 [container.reqmts]/69
; 1488 : template <class _Ty>
; 1489 : concept _Allocator_for_container = requires(_Ty& _Alloc) {
; 1490 :     typename _Ty::value_type;
; 1491 :     _Alloc.deallocate(_Alloc.allocate(size_t{1}), size_t{1});
; 1492 : };
; 1493 : 
; 1494 : template <class _Ty>
; 1495 : struct _Is_allocator : bool_constant<_Allocator_for_container<_Ty>> {};
; 1496 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 1497 : template <class _Ty, class = void>
; 1498 : struct _Is_allocator : false_type {}; // selected when _Ty can't possibly be an allocator
; 1499 : 
; 1500 : template <class _Ty>
; 1501 : struct _Is_allocator<_Ty, void_t<typename _Ty::value_type, decltype(_STD declval<_Ty&>().deallocate(
; 1502 :                                                                _STD declval<_Ty&>().allocate(size_t{1}), size_t{1}))>>
; 1503 :     : true_type {}; // selected when _Ty resembles an allocator, N4950 [container.reqmts]/69
; 1504 : #endif // ^^^ !_HAS_CXX20 ^^^
; 1505 : 
; 1506 : // deduction guide utilities (N4950 [associative.general]/2)
; 1507 : template <class _Iter>
; 1508 : using _Guide_key_t =
; 1509 : #if _HAS_CXX23
; 1510 :     remove_const_t<tuple_element_t<0, typename iterator_traits<_Iter>::value_type>>;
; 1511 : #else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
; 1512 :     remove_const_t<typename iterator_traits<_Iter>::value_type::first_type>;
; 1513 : #endif // ^^^ !_HAS_CXX23 ^^^
; 1514 : 
; 1515 : template <class _Iter>
; 1516 : using _Guide_val_t =
; 1517 : #if _HAS_CXX23
; 1518 :     tuple_element_t<1, typename iterator_traits<_Iter>::value_type>;
; 1519 : #else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
; 1520 :     typename iterator_traits<_Iter>::value_type::second_type;
; 1521 : #endif // ^^^ !_HAS_CXX23 ^^^
; 1522 : 
; 1523 : template <class _Iter>
; 1524 : using _Guide_pair_t =
; 1525 : #if _HAS_CXX23
; 1526 :     pair<add_const_t<tuple_element_t<0, typename iterator_traits<_Iter>::value_type>>,
; 1527 :         tuple_element_t<1, typename iterator_traits<_Iter>::value_type>>;
; 1528 : #else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
; 1529 :     pair<add_const_t<typename iterator_traits<_Iter>::value_type::first_type>,
; 1530 :         typename iterator_traits<_Iter>::value_type::second_type>;
; 1531 : #endif // ^^^ !_HAS_CXX23 ^^^
; 1532 : 
; 1533 : _EXPORT_STD template <class _Ty>
; 1534 : struct is_execution_policy : false_type {};
; 1535 : 
; 1536 : _EXPORT_STD template <class _Ty>
; 1537 : constexpr bool is_execution_policy_v = is_execution_policy<_Ty>::value;
; 1538 : 
; 1539 : // Note: The noexcept specifiers on all parallel algorithm overloads enforce termination as per
; 1540 : // N4950 [execpol.seq]/2, [execpol.par]/2, [execpol.parunseq]/2, and [execpol.unseq]/2
; 1541 : template <class _ExPo>
; 1542 : using _Enable_if_execution_policy_t = typename remove_reference_t<_ExPo>::_Standard_execution_policy;
; 1543 : 
; 1544 : #define _REQUIRE_PARALLEL_ITERATOR(_Iter) \
; 1545 :     static_assert(_Is_ranges_fwd_iter_v<_Iter>, "Parallel algorithms require forward iterators or stronger.")
; 1546 : 
; 1547 : #endif // _HAS_CXX17
; 1548 : 
; 1549 : template <class _Checked, class _Iter>
; 1550 : _NODISCARD constexpr auto _Idl_distance(const _Iter& _First, const _Iter& _Last) {
; 1551 :     // Returns the distance between _First and _Last or
; 1552 :     // an indicator that the distance cannot be determined in O(1).
; 1553 :     _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Unwrapped_t<_Checked>, _Iter>);
; 1554 :     if constexpr (_Is_ranges_random_iter_v<_Iter>) {
; 1555 :         return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);
; 1556 :     } else {
; 1557 :         return _Distance_unknown{};
; 1558 :     }
; 1559 : }
; 1560 : 
; 1561 : template <class _Elem, bool _Is_enum = is_enum_v<_Elem>>
; 1562 : struct _Unwrap_enum { // if _Elem is an enum, gets its underlying type; otherwise leaves _Elem unchanged
; 1563 :     using type = underlying_type_t<_Elem>;
; 1564 : };
; 1565 : 
; 1566 : template <class _Elem>
; 1567 : struct _Unwrap_enum<_Elem, false> { // passthrough non-enum type
; 1568 :     using type = _Elem;
; 1569 : };
; 1570 : 
; 1571 : template <class _Elem>
; 1572 : using _Unwrap_enum_t = typename _Unwrap_enum<_Elem>::type;
; 1573 : 
; 1574 : #if _ITERATOR_DEBUG_LEVEL < 2
; 1575 : #define _DEBUG_LT_PRED(pred, x, y) static_cast<bool>(pred(x, y))
; 1576 : #define _DEBUG_ORDER_UNWRAPPED(first, last, pred)
; 1577 : #define _DEBUG_ORDER_SET_UNWRAPPED(otherIter, first, last, pred)
; 1578 : 
; 1579 : #else // ^^^ _ITERATOR_DEBUG_LEVEL < 2 / _ITERATOR_DEBUG_LEVEL == 2 vvv
; 1580 : #define _DEBUG_LT_PRED(pred, x, y)                _STD _Debug_lt_pred(pred, x, y)
; 1581 : #define _DEBUG_ORDER_UNWRAPPED(first, last, pred) _STD _Debug_order_unchecked(first, last, pred)
; 1582 : #define _DEBUG_ORDER_SET_UNWRAPPED(otherIter, first, last, pred) \
; 1583 :     _STD _Debug_order_set_unchecked<otherIter>(first, last, pred)
; 1584 : 
; 1585 : template <class _Pr, class _Ty1, class _Ty2>
; 1586 : constexpr bool _Enable_debug_lt_pred_order_check = is_same_v<_Remove_cvref_t<_Ty1>, _Remove_cvref_t<_Ty2>>;
; 1587 : 
; 1588 : template <class _Pr, class _Ty1, class _Ty2, bool _Order_check = _Enable_debug_lt_pred_order_check<_Pr, _Ty1, _Ty2>>
; 1589 : constexpr bool _Debug_lt_pred_order_check_noexcept =
; 1590 :     noexcept(_STD declval<_Pr&>()(_STD declval<_Ty2&>(), _STD declval<_Ty1&>()));
; 1591 : 
; 1592 : template <class _Pr, class _Ty1, class _Ty2>
; 1593 : constexpr bool _Debug_lt_pred_order_check_noexcept<_Pr, _Ty1, _Ty2, false> = true;
; 1594 : 
; 1595 : template <class _Pr, class _Ty1, class _Ty2>
; 1596 : _NODISCARD constexpr bool _Debug_lt_pred(_Pr&& _Pred, _Ty1&& _Left, _Ty2&& _Right)
; 1597 :     noexcept(noexcept(_Pred(_Left, _Right)) && _Debug_lt_pred_order_check_noexcept<_Pr, _Ty1, _Ty2>) {
; 1598 :     const auto _Result = static_cast<bool>(_Pred(_Left, _Right));
; 1599 : 
; 1600 :     if constexpr (_Enable_debug_lt_pred_order_check<_Pr, _Ty1, _Ty2>) {
; 1601 :         if (_Result) {
; 1602 :             _STL_VERIFY(!_Pred(_Right, _Left), "invalid comparator");
; 1603 :         }
; 1604 :     }
; 1605 : 
; 1606 :     return _Result;
; 1607 : }
; 1608 : 
; 1609 : template <class _InIt, class _Sentinel, class _Pr>
; 1610 : constexpr void _Debug_order_unchecked(_InIt _First, _Sentinel _Last, _Pr&& _Pred) {
; 1611 :     // test if range is ordered by predicate
; 1612 :     if constexpr (_Is_ranges_fwd_iter_v<_InIt>) {
; 1613 :         if (_First != _Last) {
; 1614 :             for (auto _Next = _First; ++_Next != _Last; _First = _Next) {
; 1615 :                 _STL_VERIFY(!static_cast<bool>(_Pred(*_Next, *_First)), "sequence not ordered");
; 1616 :             }
; 1617 :         }
; 1618 :     }
; 1619 : }
; 1620 : 
; 1621 : template <class _OtherIt, class _InIt, class _Pr>
; 1622 : constexpr void _Debug_order_set_unchecked(_InIt _First, _InIt _Last, _Pr&& _Pred) {
; 1623 :     // test if range is ordered by predicate
; 1624 :     if constexpr (is_same_v<_Iter_value_t<_OtherIt>, _Iter_value_t<_InIt>>) {
; 1625 :         _STD _Debug_order_unchecked(_First, _Last, _Pred);
; 1626 :     }
; 1627 : }
; 1628 : #endif // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^
; 1629 : 
; 1630 : // from <iterator>
; 1631 : _EXPORT_STD template <class _InIt, class _Diff>
; 1632 : _CONSTEXPR17 void advance(_InIt& _Where, _Diff _Off) { // increment iterator by offset
; 1633 :     if constexpr (_Is_ranges_random_iter_v<_InIt>) {
; 1634 :         _Where += _Off;
; 1635 :     } else {
; 1636 :         if constexpr (is_signed_v<_Diff> && !_Is_ranges_bidi_iter_v<_InIt>) {
; 1637 :             _STL_ASSERT(_Off >= 0, "negative advance of non-bidirectional iterator");
; 1638 :         }
; 1639 : 
; 1640 :         decltype(auto) _UWhere      = _STD _Get_unwrapped_n(_STD move(_Where), _Off);
; 1641 :         constexpr bool _Need_rewrap = !is_reference_v<decltype(_STD _Get_unwrapped_n(_STD move(_Where), _Off))>;
; 1642 : 
; 1643 :         if constexpr (is_signed_v<_Diff> && _Is_ranges_bidi_iter_v<_InIt>) {
; 1644 :             for (; _Off < 0; ++_Off) {
; 1645 :                 --_UWhere;
; 1646 :             }
; 1647 :         }
; 1648 : 
; 1649 :         for (; 0 < _Off; --_Off) {
; 1650 :             ++_UWhere;
; 1651 :         }
; 1652 : 
; 1653 :         if constexpr (_Need_rewrap) {
; 1654 :             _STD _Seek_wrapped(_Where, _STD move(_UWhere));
; 1655 :         }
; 1656 :     }
; 1657 : }
; 1658 : 
; 1659 : _EXPORT_STD template <class _InIt>
; 1660 : _NODISCARD _CONSTEXPR17 _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) {
; 1661 :     if constexpr (_Is_ranges_random_iter_v<_InIt>) {
; 1662 :         return _Last - _First; // assume the iterator will do debug checking
; 1663 :     } else {
; 1664 :         _STD _Adl_verify_range(_First, _Last);
; 1665 :         auto _UFirst             = _STD _Get_unwrapped(_First);
; 1666 :         const auto _ULast        = _STD _Get_unwrapped(_Last);
; 1667 :         _Iter_diff_t<_InIt> _Off = 0;
; 1668 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1669 :             ++_Off;
; 1670 :         }
; 1671 : 
; 1672 :         return _Off;
; 1673 :     }
; 1674 : }
; 1675 : 
; 1676 : template <class _InIt>
; 1677 : constexpr _InIt _Next_iter(_InIt _First) { // increment iterator
; 1678 :     return ++_First;
; 1679 : }
; 1680 : 
; 1681 : _EXPORT_STD template <class _InIt>
; 1682 : _NODISCARD _CONSTEXPR17 _InIt next(
; 1683 :     _InIt _First, typename iterator_traits<_InIt>::difference_type _Off = 1) { // increment iterator
; 1684 :     static_assert(_Is_ranges_input_iter_v<_InIt>, "next requires input iterator");
; 1685 : 
; 1686 :     _STD advance(_First, _Off);
; 1687 :     return _First;
; 1688 : }
; 1689 : 
; 1690 : template <class _BidIt>
; 1691 : constexpr _BidIt _Prev_iter(_BidIt _First) { // decrement iterator
; 1692 :     return --_First;
; 1693 : }
; 1694 : 
; 1695 : _EXPORT_STD template <class _BidIt>
; 1696 : _NODISCARD _CONSTEXPR17 _BidIt prev(
; 1697 :     _BidIt _First, typename iterator_traits<_BidIt>::difference_type _Off = 1) { // decrement iterator
; 1698 :     static_assert(_Is_ranges_bidi_iter_v<_BidIt>, "prev requires bidirectional iterator");
; 1699 : 
; 1700 :     _STD advance(_First, -_Off);
; 1701 :     return _First;
; 1702 : }
; 1703 : 
; 1704 : template <class _Iter, class _Pointer, bool = is_pointer_v<_Remove_cvref_t<_Iter>>>
; 1705 : constexpr bool _Has_nothrow_operator_arrow = _Is_nothrow_convertible_v<_Iter, _Pointer>;
; 1706 : 
; 1707 : template <class _Iter, class _Pointer>
; 1708 : constexpr bool _Has_nothrow_operator_arrow<_Iter, _Pointer, false> =
; 1709 :     noexcept(_STD _Fake_copy_init<_Pointer>(_STD declval<_Iter>().operator->()));
; 1710 : 
; 1711 : _EXPORT_STD template <class _BidIt>
; 1712 : class reverse_iterator {
; 1713 : public:
; 1714 :     using iterator_type = _BidIt;
; 1715 : 
; 1716 : #if _HAS_CXX20
; 1717 :     using iterator_concept =
; 1718 :         conditional_t<random_access_iterator<_BidIt>, random_access_iterator_tag, bidirectional_iterator_tag>;
; 1719 :     using iterator_category = conditional_t<derived_from<_Iter_cat_t<_BidIt>, random_access_iterator_tag>,
; 1720 :         random_access_iterator_tag, _Iter_cat_t<_BidIt>>;
; 1721 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 1722 :     using iterator_category = _Iter_cat_t<_BidIt>;
; 1723 : #endif // ^^^ !_HAS_CXX20 ^^^
; 1724 :     using value_type      = _Iter_value_t<_BidIt>;
; 1725 :     using difference_type = _Iter_diff_t<_BidIt>;
; 1726 :     using pointer         = typename iterator_traits<_BidIt>::pointer;
; 1727 :     using reference       = _Iter_ref_t<_BidIt>;
; 1728 : 
; 1729 :     template <class>
; 1730 :     friend class reverse_iterator;
; 1731 : 
; 1732 :     _CONSTEXPR17 reverse_iterator() = default;
; 1733 : 
; 1734 :     _CONSTEXPR17 explicit reverse_iterator(_BidIt _Right)
; 1735 :         noexcept(is_nothrow_move_constructible_v<_BidIt>) // strengthened
; 1736 :         : current(_STD move(_Right)) {}
; 1737 : 
; 1738 :     template <class _Other>
; 1739 : #if _HAS_CXX20
; 1740 :         requires (!is_same_v<_Other, _BidIt>) && convertible_to<const _Other&, _BidIt>
; 1741 : #endif // _HAS_CXX20
; 1742 :     _CONSTEXPR17 reverse_iterator(const reverse_iterator<_Other>& _Right)
; 1743 :         noexcept(is_nothrow_constructible_v<_BidIt, const _Other&>) // strengthened
; 1744 :         : current(_Right.current) {
; 1745 :     }
; 1746 : 
; 1747 :     template <class _Other>
; 1748 : #if _HAS_CXX20
; 1749 :         requires (!is_same_v<_Other, _BidIt>)
; 1750 :               && convertible_to<const _Other&, _BidIt> && assignable_from<_BidIt&, const _Other&>
; 1751 : #endif // _HAS_CXX20
; 1752 :     _CONSTEXPR17 reverse_iterator& operator=(const reverse_iterator<_Other>& _Right)
; 1753 :         noexcept(is_nothrow_assignable_v<_BidIt&, const _Other&>) /* strengthened */ {
; 1754 :         current = _Right.current;
; 1755 :         return *this;
; 1756 :     }
; 1757 : 
; 1758 :     _NODISCARD _CONSTEXPR17 _BidIt base() const noexcept(is_nothrow_copy_constructible_v<_BidIt>) /* strengthened */ {
; 1759 :         return current;
; 1760 :     }
; 1761 : 
; 1762 :     _NODISCARD _CONSTEXPR17 reference operator*() const
; 1763 :         noexcept(is_nothrow_copy_constructible_v<_BidIt> && noexcept(*--(_STD declval<_BidIt&>()))) /* strengthened */ {
; 1764 :         _BidIt _Tmp = current;
; 1765 :         return *--_Tmp;
; 1766 :     }
; 1767 : 
; 1768 :     _NODISCARD _CONSTEXPR17 pointer operator->() const
; 1769 :         noexcept(is_nothrow_copy_constructible_v<_BidIt> && noexcept(--(_STD declval<_BidIt&>()))
; 1770 :                  && _Has_nothrow_operator_arrow<_BidIt&, pointer>) /* strengthened */
; 1771 : #if _HAS_CXX20
; 1772 :         requires (is_pointer_v<_BidIt> || requires(const _BidIt __i) { __i.operator->(); })
; 1773 : #endif
; 1774 :     {
; 1775 :         _BidIt _Tmp = current;
; 1776 :         --_Tmp;
; 1777 :         if constexpr (is_pointer_v<_BidIt>) {
; 1778 :             return _Tmp;
; 1779 :         } else {
; 1780 :             return _Tmp.operator->();
; 1781 :         }
; 1782 :     }
; 1783 : 
; 1784 :     _CONSTEXPR17 reverse_iterator& operator++() noexcept(noexcept(--current)) /* strengthened */ {
; 1785 :         --current;
; 1786 :         return *this;
; 1787 :     }
; 1788 : 
; 1789 :     _CONSTEXPR17 reverse_iterator operator++(int) noexcept(is_nothrow_copy_constructible_v<_BidIt> //
; 1790 :                                                            && noexcept(--current)) /* strengthened */ {
; 1791 :         reverse_iterator _Tmp = *this;
; 1792 :         --current;
; 1793 :         return _Tmp;
; 1794 :     }
; 1795 : 
; 1796 :     _CONSTEXPR17 reverse_iterator& operator--() noexcept(noexcept(++current)) /* strengthened */ {
; 1797 :         ++current;
; 1798 :         return *this;
; 1799 :     }
; 1800 : 
; 1801 :     _CONSTEXPR17 reverse_iterator operator--(int) noexcept(is_nothrow_copy_constructible_v<_BidIt> //
; 1802 :                                                            && noexcept(++current)) /* strengthened */ {
; 1803 :         reverse_iterator _Tmp = *this;
; 1804 :         ++current;
; 1805 :         return _Tmp;
; 1806 :     }
; 1807 : 
; 1808 :     _NODISCARD _CONSTEXPR17 reverse_iterator operator+(const difference_type _Off) const
; 1809 :         noexcept(noexcept(reverse_iterator(current - _Off))) /* strengthened */ {
; 1810 :         return reverse_iterator(current - _Off);
; 1811 :     }
; 1812 : 
; 1813 :     _CONSTEXPR17 reverse_iterator& operator+=(const difference_type _Off)
; 1814 :         noexcept(noexcept(current -= _Off)) /* strengthened */ {
; 1815 :         current -= _Off;
; 1816 :         return *this;
; 1817 :     }
; 1818 : 
; 1819 :     _NODISCARD _CONSTEXPR17 reverse_iterator operator-(const difference_type _Off) const
; 1820 :         noexcept(noexcept(reverse_iterator(current + _Off))) /* strengthened */ {
; 1821 :         return reverse_iterator(current + _Off);
; 1822 :     }
; 1823 : 
; 1824 :     _CONSTEXPR17 reverse_iterator& operator-=(const difference_type _Off)
; 1825 :         noexcept(noexcept(current += _Off)) /* strengthened */ {
; 1826 :         current += _Off;
; 1827 :         return *this;
; 1828 :     }
; 1829 : 
; 1830 :     _NODISCARD _CONSTEXPR17 reference operator[](const difference_type _Off) const
; 1831 :         noexcept(noexcept(_STD _Fake_copy_init<reference>(current[_Off]))) /* strengthened */ {
; 1832 :         return current[static_cast<difference_type>(-_Off - 1)];
; 1833 :     }
; 1834 : 
; 1835 : #if _HAS_CXX20
; 1836 :     _NODISCARD friend constexpr iter_rvalue_reference_t<_BidIt> iter_move(const reverse_iterator& _It)
; 1837 :         noexcept(is_nothrow_copy_constructible_v<_BidIt> && noexcept(_RANGES iter_move(--_STD declval<_BidIt&>()))) {
; 1838 :         auto _Tmp = _It.current;
; 1839 :         --_Tmp;
; 1840 :         return _RANGES iter_move(_Tmp);
; 1841 :     }
; 1842 : 
; 1843 :     template <indirectly_swappable<_BidIt> _BidIt2>
; 1844 :     friend constexpr void iter_swap(const reverse_iterator& _Left, const reverse_iterator<_BidIt2>& _Right)
; 1845 :         noexcept(is_nothrow_copy_constructible_v<_BidIt> && is_nothrow_copy_constructible_v<_BidIt2>
; 1846 :                  && noexcept(_RANGES iter_swap(--_STD declval<_BidIt&>(), --_STD declval<_BidIt2&>()))) {
; 1847 :         auto _LTmp = _Left.current;
; 1848 :         auto _RTmp = _Right.base();
; 1849 :         --_LTmp;
; 1850 :         --_RTmp;
; 1851 :         _RANGES iter_swap(_LTmp, _RTmp);
; 1852 :     }
; 1853 : #endif // _HAS_CXX20
; 1854 : 
; 1855 :     using _Prevent_inheriting_unwrap = reverse_iterator;
; 1856 : 
; 1857 :     template <class _BidIt2, enable_if_t<_Range_verifiable_v<_BidIt, _BidIt2>, int> = 0>
; 1858 :     friend constexpr void _Verify_range(
; 1859 :         const reverse_iterator& _First, const reverse_iterator<_BidIt2>& _Last) noexcept {
; 1860 :         _Verify_range(_Last._Get_current(), _First.current); // note reversed parameters
; 1861 :     }
; 1862 : 
; 1863 :     template <class _BidIt2 = _BidIt, enable_if_t<_Offset_verifiable_v<_BidIt2>, int> = 0>
; 1864 :     constexpr void _Verify_offset(const difference_type _Off) const noexcept {
; 1865 :         _STL_VERIFY(_Off != _Min_possible_v<difference_type>, "integer overflow");
; 1866 :         current._Verify_offset(-_Off);
; 1867 :     }
; 1868 : 
; 1869 :     template <class _BidIt2 = _BidIt, enable_if_t<_Unwrappable_v<const _BidIt2&>, int> = 0>
; 1870 :     _NODISCARD constexpr reverse_iterator<_Unwrapped_t<const _BidIt2&>> _Unwrapped() const& noexcept(
; 1871 :         noexcept(static_cast<reverse_iterator<_Unwrapped_t<const _BidIt2&>>>(current._Unwrapped()))) {
; 1872 :         return static_cast<reverse_iterator<_Unwrapped_t<const _BidIt2&>>>(current._Unwrapped());
; 1873 :     }
; 1874 :     template <class _BidIt2 = _BidIt, enable_if_t<_Unwrappable_v<_BidIt2>, int> = 0>
; 1875 :     _NODISCARD constexpr reverse_iterator<_Unwrapped_t<_BidIt2>> _Unwrapped() && noexcept(
; 1876 :         noexcept(static_cast<reverse_iterator<_Unwrapped_t<_BidIt2>>>(_STD move(current)._Unwrapped()))) {
; 1877 :         return static_cast<reverse_iterator<_Unwrapped_t<_BidIt2>>>(_STD move(current)._Unwrapped());
; 1878 :     }
; 1879 : 
; 1880 :     static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<_BidIt>;
; 1881 : 
; 1882 :     template <class _Src, enable_if_t<_Wrapped_seekable_v<_BidIt, const _Src&>, int> = 0>
; 1883 :     constexpr void _Seek_to(const reverse_iterator<_Src>& _It) noexcept(noexcept(current._Seek_to(_It.current))) {
; 1884 :         current._Seek_to(_It.current);
; 1885 :     }
; 1886 : 
; 1887 :     _NODISCARD constexpr const _BidIt& _Get_current() const noexcept {
; 1888 :         return current;
; 1889 :     }
; 1890 : 
; 1891 : protected:
; 1892 :     _BidIt current{};
; 1893 : };
; 1894 : 
; 1895 : _EXPORT_STD template <class _BidIt1, class _BidIt2>
; 1896 : _NODISCARD _CONSTEXPR17 bool operator==(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)
; 1897 :     noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left._Get_current() == _Right._Get_current()))) /* strengthened */
; 1898 : #if _HAS_CXX20
; 1899 :     requires requires {
; 1900 :         { _Left._Get_current() == _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
; 1901 :     }
; 1902 : #endif // _HAS_CXX20
; 1903 : {
; 1904 :     return _Left._Get_current() == _Right._Get_current();
; 1905 : }
; 1906 : 
; 1907 : _EXPORT_STD template <class _BidIt1, class _BidIt2>
; 1908 : _NODISCARD _CONSTEXPR17 bool operator!=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)
; 1909 :     noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left._Get_current() != _Right._Get_current()))) /* strengthened */
; 1910 : #if _HAS_CXX20
; 1911 :     requires requires {
; 1912 :         { _Left._Get_current() != _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
; 1913 :     }
; 1914 : #endif // _HAS_CXX20
; 1915 : {
; 1916 :     return _Left._Get_current() != _Right._Get_current();
; 1917 : }
; 1918 : 
; 1919 : _EXPORT_STD template <class _BidIt1, class _BidIt2>
; 1920 : _NODISCARD _CONSTEXPR17 bool operator<(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)
; 1921 :     noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left._Get_current() > _Right._Get_current()))) /* strengthened */
; 1922 : #if _HAS_CXX20
; 1923 :     requires requires {
; 1924 :         { _Left._Get_current() > _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
; 1925 :     }
; 1926 : #endif // _HAS_CXX20
; 1927 : {
; 1928 :     return _Left._Get_current() > _Right._Get_current();
; 1929 : }
; 1930 : 
; 1931 : _EXPORT_STD template <class _BidIt1, class _BidIt2>
; 1932 : _NODISCARD _CONSTEXPR17 bool operator>(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)
; 1933 :     noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left._Get_current() < _Right._Get_current()))) /* strengthened */
; 1934 : #if _HAS_CXX20
; 1935 :     requires requires {
; 1936 :         { _Left._Get_current() < _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
; 1937 :     }
; 1938 : #endif // _HAS_CXX20
; 1939 : {
; 1940 :     return _Left._Get_current() < _Right._Get_current();
; 1941 : }
; 1942 : 
; 1943 : _EXPORT_STD template <class _BidIt1, class _BidIt2>
; 1944 : _NODISCARD _CONSTEXPR17 bool operator<=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)
; 1945 :     noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left._Get_current() >= _Right._Get_current()))) /* strengthened */
; 1946 : #if _HAS_CXX20
; 1947 :     requires requires {
; 1948 :         { _Left._Get_current() >= _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
; 1949 :     }
; 1950 : #endif // _HAS_CXX20
; 1951 : {
; 1952 :     return _Left._Get_current() >= _Right._Get_current();
; 1953 : }
; 1954 : 
; 1955 : _EXPORT_STD template <class _BidIt1, class _BidIt2>
; 1956 : _NODISCARD _CONSTEXPR17 bool operator>=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)
; 1957 :     noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left._Get_current() <= _Right._Get_current()))) /* strengthened */
; 1958 : #if _HAS_CXX20
; 1959 :     requires requires {
; 1960 :         { _Left._Get_current() <= _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
; 1961 :     }
; 1962 : #endif // _HAS_CXX20
; 1963 : {
; 1964 :     return _Left._Get_current() <= _Right._Get_current();
; 1965 : }
; 1966 : 
; 1967 : #if _HAS_CXX20
; 1968 : _EXPORT_STD template <class _BidIt1, three_way_comparable_with<_BidIt1> _BidIt2>
; 1969 : _NODISCARD constexpr compare_three_way_result_t<_BidIt1, _BidIt2> operator<=>(
; 1970 :     const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)
; 1971 :     noexcept(noexcept(_Right._Get_current() <=> _Left._Get_current())) /* strengthened */ {
; 1972 :     return _Right._Get_current() <=> _Left._Get_current();
; 1973 : }
; 1974 : #endif // _HAS_CXX20
; 1975 : 
; 1976 : _EXPORT_STD template <class _BidIt1, class _BidIt2>
; 1977 : _NODISCARD _CONSTEXPR17 auto operator-(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)
; 1978 :     noexcept(noexcept(_Right._Get_current() - _Left._Get_current())) /* strengthened */
; 1979 :     -> decltype(_Right._Get_current() - _Left._Get_current()) {
; 1980 :     return _Right._Get_current() - _Left._Get_current();
; 1981 : }
; 1982 : 
; 1983 : _EXPORT_STD template <class _BidIt>
; 1984 : _NODISCARD _CONSTEXPR17 reverse_iterator<_BidIt> operator+(typename reverse_iterator<_BidIt>::difference_type _Off,
; 1985 :     const reverse_iterator<_BidIt>& _Right) noexcept(noexcept(_Right + _Off)) /* strengthened */ {
; 1986 :     return _Right + _Off;
; 1987 : }
; 1988 : 
; 1989 : _EXPORT_STD template <class _BidIt>
; 1990 : _NODISCARD _CONSTEXPR17 reverse_iterator<_BidIt> make_reverse_iterator(_BidIt _Iter)
; 1991 :     noexcept(is_nothrow_move_constructible_v<_BidIt>) /* strengthened */ {
; 1992 :     return reverse_iterator<_BidIt>(_STD move(_Iter));
; 1993 : }
; 1994 : 
; 1995 : #if _HAS_CXX20
; 1996 : template <class _BidIt1, class _BidIt2>
; 1997 :     requires (!sized_sentinel_for<_BidIt1, _BidIt2>)
; 1998 : constexpr bool disable_sized_sentinel_for<reverse_iterator<_BidIt1>, reverse_iterator<_BidIt2>> = true;
; 1999 : #endif // _HAS_CXX20
; 2000 : 
; 2001 : _EXPORT_STD template <class _Container>
; 2002 : _NODISCARD _CONSTEXPR17 auto begin(_Container& _Cont) noexcept(noexcept(_Cont.begin())) /* strengthened */
; 2003 :     -> decltype(_Cont.begin()) {
; 2004 :     return _Cont.begin();
; 2005 : }
; 2006 : 
; 2007 : _EXPORT_STD template <class _Container>
; 2008 : _NODISCARD _CONSTEXPR17 auto begin(const _Container& _Cont) noexcept(noexcept(_Cont.begin())) /* strengthened */
; 2009 :     -> decltype(_Cont.begin()) {
; 2010 :     return _Cont.begin();
; 2011 : }
; 2012 : 
; 2013 : _EXPORT_STD template <class _Container>
; 2014 : _NODISCARD _CONSTEXPR17 auto end(_Container& _Cont) noexcept(noexcept(_Cont.end())) /* strengthened */
; 2015 :     -> decltype(_Cont.end()) {
; 2016 :     return _Cont.end();
; 2017 : }
; 2018 : 
; 2019 : _EXPORT_STD template <class _Container>
; 2020 : _NODISCARD _CONSTEXPR17 auto end(const _Container& _Cont) noexcept(noexcept(_Cont.end())) /* strengthened */
; 2021 :     -> decltype(_Cont.end()) {
; 2022 :     return _Cont.end();
; 2023 : }
; 2024 : 
; 2025 : _EXPORT_STD template <class _Ty, size_t _Size>
; 2026 : _NODISCARD constexpr _Ty* begin(_Ty (&_Array)[_Size]) noexcept {
; 2027 :     return _Array;
; 2028 : }
; 2029 : 
; 2030 : _EXPORT_STD template <class _Ty, size_t _Size>
; 2031 : _NODISCARD constexpr _Ty* end(_Ty (&_Array)[_Size]) noexcept {
; 2032 :     return _Array + _Size;
; 2033 : }
; 2034 : 
; 2035 : _EXPORT_STD template <class _Container>
; 2036 : _NODISCARD constexpr auto cbegin(const _Container& _Cont) noexcept(noexcept(_STD begin(_Cont)))
; 2037 :     -> decltype(_STD begin(_Cont)) {
; 2038 :     return _STD begin(_Cont);
; 2039 : }
; 2040 : 
; 2041 : _EXPORT_STD template <class _Container>
; 2042 : _NODISCARD constexpr auto cend(const _Container& _Cont) noexcept(noexcept(_STD end(_Cont)))
; 2043 :     -> decltype(_STD end(_Cont)) {
; 2044 :     return _STD end(_Cont);
; 2045 : }
; 2046 : 
; 2047 : _EXPORT_STD template <class _Container>
; 2048 : _NODISCARD _CONSTEXPR17 auto rbegin(_Container& _Cont) noexcept(noexcept(_Cont.rbegin())) /* strengthened */
; 2049 :     -> decltype(_Cont.rbegin()) {
; 2050 :     return _Cont.rbegin();
; 2051 : }
; 2052 : 
; 2053 : _EXPORT_STD template <class _Container>
; 2054 : _NODISCARD _CONSTEXPR17 auto rbegin(const _Container& _Cont) noexcept(noexcept(_Cont.rbegin())) /* strengthened */
; 2055 :     -> decltype(_Cont.rbegin()) {
; 2056 :     return _Cont.rbegin();
; 2057 : }
; 2058 : 
; 2059 : _EXPORT_STD template <class _Container>
; 2060 : _NODISCARD _CONSTEXPR17 auto rend(_Container& _Cont) noexcept(noexcept(_Cont.rend())) /* strengthened */
; 2061 :     -> decltype(_Cont.rend()) {
; 2062 :     return _Cont.rend();
; 2063 : }
; 2064 : 
; 2065 : _EXPORT_STD template <class _Container>
; 2066 : _NODISCARD _CONSTEXPR17 auto rend(const _Container& _Cont) noexcept(noexcept(_Cont.rend())) /* strengthened */
; 2067 :     -> decltype(_Cont.rend()) {
; 2068 :     return _Cont.rend();
; 2069 : }
; 2070 : 
; 2071 : _EXPORT_STD template <class _Ty, size_t _Size>
; 2072 : _NODISCARD _CONSTEXPR17 reverse_iterator<_Ty*> rbegin(_Ty (&_Array)[_Size]) noexcept /* strengthened */ {
; 2073 :     return reverse_iterator<_Ty*>(_Array + _Size);
; 2074 : }
; 2075 : 
; 2076 : _EXPORT_STD template <class _Ty, size_t _Size>
; 2077 : _NODISCARD _CONSTEXPR17 reverse_iterator<_Ty*> rend(_Ty (&_Array)[_Size]) noexcept /* strengthened */ {
; 2078 :     return reverse_iterator<_Ty*>(_Array);
; 2079 : }
; 2080 : 
; 2081 : _EXPORT_STD template <class _Elem>
; 2082 : _NODISCARD _CONSTEXPR17 reverse_iterator<const _Elem*> rbegin(initializer_list<_Elem> _Ilist) noexcept
; 2083 : /* strengthened */ {
; 2084 :     return reverse_iterator<const _Elem*>(_Ilist.end());
; 2085 : }
; 2086 : 
; 2087 : _EXPORT_STD template <class _Elem>
; 2088 : _NODISCARD _CONSTEXPR17 reverse_iterator<const _Elem*> rend(initializer_list<_Elem> _Ilist) noexcept
; 2089 : /* strengthened */ {
; 2090 :     return reverse_iterator<const _Elem*>(_Ilist.begin());
; 2091 : }
; 2092 : 
; 2093 : _EXPORT_STD template <class _Container>
; 2094 : _NODISCARD _CONSTEXPR17 auto crbegin(const _Container& _Cont) noexcept(noexcept(_STD rbegin(_Cont))) /* strengthened */
; 2095 :     -> decltype(_STD rbegin(_Cont)) {
; 2096 :     return _STD rbegin(_Cont);
; 2097 : }
; 2098 : 
; 2099 : _EXPORT_STD template <class _Container>
; 2100 : _NODISCARD _CONSTEXPR17 auto crend(const _Container& _Cont) noexcept(noexcept(_STD rend(_Cont))) /* strengthened */
; 2101 :     -> decltype(_STD rend(_Cont)) {
; 2102 :     return _STD rend(_Cont);
; 2103 : }
; 2104 : 
; 2105 : _EXPORT_STD template <class _Container>
; 2106 : _NODISCARD constexpr auto size(const _Container& _Cont) noexcept(noexcept(_Cont.size())) /* strengthened */
; 2107 :     -> decltype(_Cont.size()) {
; 2108 :     return _Cont.size();
; 2109 : }
; 2110 : 
; 2111 : _EXPORT_STD template <class _Ty, size_t _Size>
; 2112 : _NODISCARD constexpr size_t size(const _Ty (&)[_Size]) noexcept {
; 2113 :     return _Size;
; 2114 : }
; 2115 : 
; 2116 : #if _HAS_CXX20
; 2117 : _EXPORT_STD template <class _Container>
; 2118 : _NODISCARD constexpr auto ssize(const _Container& _Cont) noexcept(noexcept(
; 2119 :     static_cast<common_type_t<ptrdiff_t, make_signed_t<decltype(_Cont.size())>>>(_Cont.size()))) /* strengthened */
; 2120 :     -> common_type_t<ptrdiff_t, make_signed_t<decltype(_Cont.size())>> {
; 2121 :     using _Common = common_type_t<ptrdiff_t, make_signed_t<decltype(_Cont.size())>>;
; 2122 :     return static_cast<_Common>(_Cont.size());
; 2123 : }
; 2124 : 
; 2125 : _EXPORT_STD template <class _Ty, ptrdiff_t _Size>
; 2126 : _NODISCARD constexpr ptrdiff_t ssize(const _Ty (&)[_Size]) noexcept {
; 2127 :     return _Size;
; 2128 : }
; 2129 : #endif // _HAS_CXX20
; 2130 : 
; 2131 : _EXPORT_STD template <class _Container>
; 2132 : _NODISCARD_EMPTY_NON_MEMBER constexpr auto empty(const _Container& _Cont)
; 2133 :     noexcept(noexcept(_Cont.empty())) /* strengthened */
; 2134 :     -> decltype(_Cont.empty()) {
; 2135 :     return _Cont.empty();
; 2136 : }
; 2137 : 
; 2138 : _EXPORT_STD template <class _Ty, size_t _Size>
; 2139 : _NODISCARD_EMPTY_NON_MEMBER constexpr bool empty(const _Ty (&)[_Size]) noexcept {
; 2140 :     return false;
; 2141 : }
; 2142 : 
; 2143 : _EXPORT_STD template <class _Elem>
; 2144 : _NODISCARD_EMPTY_NON_MEMBER constexpr bool empty(initializer_list<_Elem> _Ilist) noexcept {
; 2145 :     return _Ilist.size() == 0;
; 2146 : }
; 2147 : 
; 2148 : _EXPORT_STD template <class _Container>
; 2149 : _NODISCARD constexpr auto data(_Container& _Cont) noexcept(noexcept(_Cont.data())) /* strengthened */
; 2150 :     -> decltype(_Cont.data()) {
; 2151 :     return _Cont.data();
; 2152 : }
; 2153 : 
; 2154 : _EXPORT_STD template <class _Container>
; 2155 : _NODISCARD constexpr auto data(const _Container& _Cont) noexcept(noexcept(_Cont.data())) /* strengthened */
; 2156 :     -> decltype(_Cont.data()) {
; 2157 :     return _Cont.data();
; 2158 : }
; 2159 : 
; 2160 : _EXPORT_STD template <class _Ty, size_t _Size>
; 2161 : _NODISCARD constexpr _Ty* data(_Ty (&_Array)[_Size]) noexcept {
; 2162 :     return _Array;
; 2163 : }
; 2164 : 
; 2165 : _EXPORT_STD template <class _Elem>
; 2166 : _NODISCARD constexpr const _Elem* data(initializer_list<_Elem> _Ilist) noexcept {
; 2167 :     return _Ilist.begin();
; 2168 : }
; 2169 : 
; 2170 : #if _HAS_CXX20
; 2171 : #if _HAS_CXX23
; 2172 : _EXPORT_STD template <indirectly_readable _Ty>
; 2173 : using iter_const_reference_t = common_reference_t<const iter_value_t<_Ty>&&, iter_reference_t<_Ty>>;
; 2174 : 
; 2175 : template <indirectly_readable _Iter>
; 2176 : using _Iter_const_rvalue_reference_t = common_reference_t<const iter_value_t<_Iter>&&, iter_rvalue_reference_t<_Iter>>;
; 2177 : 
; 2178 : template <class _Ty>
; 2179 : concept _Constant_iterator = input_iterator<_Ty> && same_as<iter_const_reference_t<_Ty>, iter_reference_t<_Ty>>;
; 2180 : 
; 2181 : _EXPORT_STD template <input_iterator _Iter>
; 2182 : class basic_const_iterator;
; 2183 : 
; 2184 : _EXPORT_STD template <input_iterator _Iter>
; 2185 : using const_iterator = conditional_t<_Constant_iterator<_Iter>, _Iter, basic_const_iterator<_Iter>>;
; 2186 : 
; 2187 : template <class _Sent>
; 2188 : struct _Const_sentinel {
; 2189 :     using type = _Sent;
; 2190 : };
; 2191 : 
; 2192 : template <input_iterator _Sent>
; 2193 : struct _Const_sentinel<_Sent> {
; 2194 :     using type = const_iterator<_Sent>;
; 2195 : };
; 2196 : 
; 2197 : _EXPORT_STD template <semiregular _Sent>
; 2198 : using const_sentinel = _Const_sentinel<_Sent>::type;
; 2199 : 
; 2200 : template <class _Ty>
; 2201 : concept _Not_a_const_iterator = !_Is_specialization_v<_Ty, basic_const_iterator>;
; 2202 : 
; 2203 : template <class>
; 2204 : struct _Basic_const_iterator_category {};
; 2205 : 
; 2206 : template <forward_iterator _Iter>
; 2207 : struct _Basic_const_iterator_category<_Iter> {
; 2208 :     using iterator_category = iterator_traits<_Iter>::iterator_category;
; 2209 : };
; 2210 : 
; 2211 : _EXPORT_STD template <input_iterator _Iter>
; 2212 : class basic_const_iterator : public _Basic_const_iterator_category<_Iter> {
; 2213 : private:
; 2214 :     template <input_iterator>
; 2215 :     friend class basic_const_iterator;
; 2216 : 
; 2217 :     /* [[no_unique_address]] */ _Iter _Current{};
; 2218 : 
; 2219 :     using _Reference        = iter_const_reference_t<_Iter>;
; 2220 :     using _Rvalue_reference = _Iter_const_rvalue_reference_t<_Iter>;
; 2221 : 
; 2222 :     _NODISCARD static consteval auto _Get_iter_concept() noexcept {
; 2223 :         if constexpr (contiguous_iterator<_Iter>) {
; 2224 :             return contiguous_iterator_tag{};
; 2225 :         } else if constexpr (random_access_iterator<_Iter>) {
; 2226 :             return random_access_iterator_tag{};
; 2227 :         } else if constexpr (bidirectional_iterator<_Iter>) {
; 2228 :             return bidirectional_iterator_tag{};
; 2229 :         } else if constexpr (forward_iterator<_Iter>) {
; 2230 :             return forward_iterator_tag{};
; 2231 :         } else {
; 2232 :             return input_iterator_tag{};
; 2233 :         }
; 2234 :     }
; 2235 : 
; 2236 : public:
; 2237 :     using iterator_concept = decltype(_Get_iter_concept());
; 2238 :     using value_type       = iter_value_t<_Iter>;
; 2239 :     using difference_type  = iter_difference_t<_Iter>;
; 2240 : 
; 2241 :     basic_const_iterator()
; 2242 :         requires default_initializable<_Iter>
; 2243 :     = default;
; 2244 : 
; 2245 :     constexpr basic_const_iterator(_Iter _Current_) noexcept(is_nothrow_move_constructible_v<_Iter>) // strengthened
; 2246 :         : _Current(_STD move(_Current_)) {}
; 2247 : 
; 2248 :     template <convertible_to<_Iter> _Other>
; 2249 :     constexpr basic_const_iterator(basic_const_iterator<_Other> _Current_)
; 2250 :         noexcept(is_nothrow_constructible_v<_Iter, _Other>) // strengthened
; 2251 :         : _Current(_STD move(_Current_._Current)) {}
; 2252 : 
; 2253 :     template <_Different_from<basic_const_iterator> _Other>
; 2254 :         requires convertible_to<_Other, _Iter>
; 2255 :     constexpr basic_const_iterator(_Other&& _Current_)
; 2256 :         noexcept(is_nothrow_constructible_v<_Iter, _Other>) // strengthened
; 2257 :         : _Current(_STD forward<_Other>(_Current_)) {}
; 2258 : 
; 2259 :     _NODISCARD constexpr const _Iter& base() const& noexcept {
; 2260 :         return _Current;
; 2261 :     }
; 2262 : 
; 2263 :     _NODISCARD constexpr _Iter base() && noexcept(is_nothrow_move_constructible_v<_Iter>) /* strengthened */ {
; 2264 :         return _STD move(_Current);
; 2265 :     }
; 2266 : 
; 2267 :     _NODISCARD constexpr _Reference operator*() const
; 2268 :         noexcept(noexcept(static_cast<_Reference>(*_Current))) /* strengthened */ {
; 2269 :         return static_cast<_Reference>(*_Current);
; 2270 :     }
; 2271 : 
; 2272 :     _NODISCARD constexpr const auto* operator->() const
; 2273 :         noexcept(contiguous_iterator<_Iter> || noexcept(*_Current)) /* strengthened */
; 2274 :         requires is_lvalue_reference_v<iter_reference_t<_Iter>>
; 2275 :               && same_as<remove_cvref_t<iter_reference_t<_Iter>>, value_type>
; 2276 :     {
; 2277 :         if constexpr (contiguous_iterator<_Iter>) {
; 2278 :             return _STD to_address(_Current);
; 2279 :         } else {
; 2280 :             return _STD addressof(*_Current);
; 2281 :         }
; 2282 :     }
; 2283 : 
; 2284 :     constexpr basic_const_iterator& operator++() noexcept(noexcept(++_Current)) /* strengthened */ {
; 2285 :         ++_Current;
; 2286 :         return *this;
; 2287 :     }
; 2288 : 
; 2289 :     constexpr void operator++(int) noexcept(noexcept(++_Current)) /* strengthened */ {
; 2290 :         ++_Current;
; 2291 :     }
; 2292 : 
; 2293 :     constexpr basic_const_iterator operator++(int)
; 2294 :         noexcept(noexcept(++*this) && is_nothrow_copy_constructible_v<basic_const_iterator>) // strengthened
; 2295 :         requires forward_iterator<_Iter>
; 2296 :     {
; 2297 :         auto _Tmp = *this;
; 2298 :         ++*this;
; 2299 :         return _Tmp;
; 2300 :     }
; 2301 : 
; 2302 :     constexpr basic_const_iterator& operator--() noexcept(noexcept(--_Current)) // strengthened
; 2303 :         requires bidirectional_iterator<_Iter>
; 2304 :     {
; 2305 :         --_Current;
; 2306 :         return *this;
; 2307 :     }
; 2308 : 
; 2309 :     constexpr basic_const_iterator operator--(int)
; 2310 :         noexcept(noexcept(--*this) && is_nothrow_copy_constructible_v<basic_const_iterator>) // strengthened
; 2311 :         requires bidirectional_iterator<_Iter>
; 2312 :     {
; 2313 :         auto _Tmp = *this;
; 2314 :         --*this;
; 2315 :         return _Tmp;
; 2316 :     }
; 2317 : 
; 2318 :     constexpr basic_const_iterator& operator+=(const difference_type _Off)
; 2319 :         noexcept(noexcept(_Current += _Off)) // strengthened
; 2320 :         requires random_access_iterator<_Iter>
; 2321 :     {
; 2322 :         _Current += _Off;
; 2323 :         return *this;
; 2324 :     }
; 2325 : 
; 2326 :     constexpr basic_const_iterator& operator-=(const difference_type _Off)
; 2327 :         noexcept(noexcept(_Current -= _Off)) // strengthened
; 2328 :         requires random_access_iterator<_Iter>
; 2329 :     {
; 2330 :         _Current -= _Off;
; 2331 :         return *this;
; 2332 :     }
; 2333 : 
; 2334 :     _NODISCARD constexpr _Reference operator[](const difference_type _Idx) const
; 2335 :         noexcept(noexcept(static_cast<_Reference>(_Current[_Idx]))) // strengthened
; 2336 :         requires random_access_iterator<_Iter>
; 2337 :     {
; 2338 :         return static_cast<_Reference>(_Current[_Idx]);
; 2339 :     }
; 2340 : 
; 2341 :     template <sentinel_for<_Iter> _Sent>
; 2342 :     _NODISCARD constexpr bool operator==(const _Sent& _Se) const
; 2343 :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Current == _Se))) /* strengthened */ {
; 2344 :         return _Current == _Se;
; 2345 :     }
; 2346 : 
; 2347 :     template <_Not_a_const_iterator _Other>
; 2348 :         requires _Constant_iterator<_Other> && convertible_to<const _Iter&, _Other>
; 2349 :     _NODISCARD constexpr operator _Other() const& noexcept(
; 2350 :         is_nothrow_convertible_v<const _Iter&, _Other>) /* strengthened */ {
; 2351 :         return _Current;
; 2352 :     }
; 2353 : 
; 2354 :     template <_Not_a_const_iterator _Other>
; 2355 :         requires _Constant_iterator<_Other> && convertible_to<_Iter, _Other>
; 2356 :     _NODISCARD constexpr operator _Other() && noexcept(is_nothrow_convertible_v<_Iter, _Other>) /* strengthened */ {
; 2357 :         return _STD move(_Current);
; 2358 :     }
; 2359 : 
; 2360 :     _NODISCARD constexpr bool operator<(const basic_const_iterator& _Right) const
; 2361 :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Current < _Right._Current))) // strengthened
; 2362 :         requires random_access_iterator<_Iter>
; 2363 :     {
; 2364 :         return _Current < _Right._Current;
; 2365 :     }
; 2366 : 
; 2367 :     _NODISCARD constexpr bool operator>(const basic_const_iterator& _Right) const
; 2368 :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Current > _Right._Current))) // strengthened
; 2369 :         requires random_access_iterator<_Iter>
; 2370 :     {
; 2371 :         return _Current > _Right._Current;
; 2372 :     }
; 2373 : 
; 2374 :     _NODISCARD constexpr bool operator<=(const basic_const_iterator& _Right) const
; 2375 :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Current <= _Right._Current))) // strengthened
; 2376 :         requires random_access_iterator<_Iter>
; 2377 :     {
; 2378 :         return _Current <= _Right._Current;
; 2379 :     }
; 2380 : 
; 2381 :     _NODISCARD constexpr bool operator>=(const basic_const_iterator& _Right) const
; 2382 :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Current >= _Right._Current))) // strengthened
; 2383 :         requires random_access_iterator<_Iter>
; 2384 :     {
; 2385 :         return _Current >= _Right._Current;
; 2386 :     }
; 2387 : 
; 2388 :     _NODISCARD constexpr auto operator<=>(const basic_const_iterator& _Right) const
; 2389 :         noexcept(noexcept(_Current <=> _Right._Current)) // strengthened
; 2390 :         requires random_access_iterator<_Iter> && three_way_comparable<_Iter>
; 2391 :     {
; 2392 :         return _Current <=> _Right._Current;
; 2393 :     }
; 2394 : 
; 2395 :     template <_Different_from<basic_const_iterator> _Other>
; 2396 :         requires random_access_iterator<_Iter> && totally_ordered_with<_Iter, _Other>
; 2397 :     _NODISCARD constexpr bool operator<(const _Other& _Right) const
; 2398 :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Current < _Right))) /* strengthened */ {
; 2399 :         return _Current < _Right;
; 2400 :     }
; 2401 : 
; 2402 :     template <_Different_from<basic_const_iterator> _Other>
; 2403 :         requires random_access_iterator<_Iter> && totally_ordered_with<_Iter, _Other>
; 2404 :     _NODISCARD constexpr bool operator>(const _Other& _Right) const
; 2405 :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Current > _Right))) /* strengthened */ {
; 2406 :         return _Current > _Right;
; 2407 :     }
; 2408 : 
; 2409 :     template <_Different_from<basic_const_iterator> _Other>
; 2410 :         requires random_access_iterator<_Iter> && totally_ordered_with<_Iter, _Other>
; 2411 :     _NODISCARD constexpr bool operator<=(const _Other& _Right) const
; 2412 :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Current <= _Right))) /* strengthened */ {
; 2413 :         return _Current <= _Right;
; 2414 :     }
; 2415 : 
; 2416 :     template <_Different_from<basic_const_iterator> _Other>
; 2417 :         requires random_access_iterator<_Iter> && totally_ordered_with<_Iter, _Other>
; 2418 :     _NODISCARD constexpr bool operator>=(const _Other& _Right) const
; 2419 :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Current >= _Right))) /* strengthened */ {
; 2420 :         return _Current >= _Right;
; 2421 :     }
; 2422 : 
; 2423 :     template <_Different_from<basic_const_iterator> _Other>
; 2424 :         requires random_access_iterator<_Iter> && totally_ordered_with<_Iter, _Other>
; 2425 :               && three_way_comparable_with<_Iter, _Other>
; 2426 :     _NODISCARD constexpr auto operator<=>(const _Other& _Right) const
; 2427 :         noexcept(noexcept(_Current <=> _Right)) /* strengthened */ {
; 2428 :         return _Current <=> _Right;
; 2429 :     }
; 2430 : 
; 2431 :     template <_Not_a_const_iterator _Other>
; 2432 :         requires random_access_iterator<_Iter> && totally_ordered_with<_Iter, _Other>
; 2433 :     _NODISCARD friend constexpr bool operator<(const _Other& _Left, const basic_const_iterator& _Right)
; 2434 :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left < _Right._Current))) /* strengthened */ {
; 2435 :         return _Left < _Right._Current;
; 2436 :     }
; 2437 : 
; 2438 :     template <_Not_a_const_iterator _Other>
; 2439 :         requires random_access_iterator<_Iter> && totally_ordered_with<_Iter, _Other>
; 2440 :     _NODISCARD friend constexpr bool operator>(const _Other& _Left, const basic_const_iterator& _Right)
; 2441 :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left > _Right._Current))) /* strengthened */ {
; 2442 :         return _Left > _Right._Current;
; 2443 :     }
; 2444 : 
; 2445 :     template <_Not_a_const_iterator _Other>
; 2446 :         requires random_access_iterator<_Iter> && totally_ordered_with<_Iter, _Other>
; 2447 :     _NODISCARD friend constexpr bool operator<=(const _Other& _Left, const basic_const_iterator& _Right)
; 2448 :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left <= _Right._Current))) /* strengthened */ {
; 2449 :         return _Left <= _Right._Current;
; 2450 :     }
; 2451 : 
; 2452 :     template <_Not_a_const_iterator _Other>
; 2453 :         requires random_access_iterator<_Iter> && totally_ordered_with<_Iter, _Other>
; 2454 :     _NODISCARD friend constexpr bool operator>=(const _Other& _Left, const basic_const_iterator& _Right)
; 2455 :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left >= _Right._Current))) /* strengthened */ {
; 2456 :         return _Left >= _Right._Current;
; 2457 :     }
; 2458 : 
; 2459 :     _NODISCARD friend constexpr basic_const_iterator operator+(const basic_const_iterator& _It,
; 2460 :         const difference_type _Off) noexcept(noexcept(basic_const_iterator{_It._Current + _Off})) // strengthened
; 2461 :         requires random_access_iterator<_Iter>
; 2462 :     {
; 2463 :         return basic_const_iterator{_It._Current + _Off};
; 2464 :     }
; 2465 : 
; 2466 :     _NODISCARD friend constexpr basic_const_iterator operator+(const difference_type _Off,
; 2467 :         const basic_const_iterator& _It) noexcept(noexcept(basic_const_iterator{_It._Current + _Off})) // strengthened
; 2468 :         requires random_access_iterator<_Iter>
; 2469 :     {
; 2470 :         return basic_const_iterator{_It._Current + _Off};
; 2471 :     }
; 2472 : 
; 2473 :     _NODISCARD friend constexpr basic_const_iterator operator-(const basic_const_iterator& _It,
; 2474 :         const difference_type _Off) noexcept(noexcept(basic_const_iterator{_It._Current - _Off})) // strengthened
; 2475 :         requires random_access_iterator<_Iter>
; 2476 :     {
; 2477 :         return basic_const_iterator{_It._Current - _Off};
; 2478 :     }
; 2479 : 
; 2480 :     template <sized_sentinel_for<_Iter> _Sent>
; 2481 :     _NODISCARD constexpr difference_type operator-(const _Sent& _Se) const
; 2482 :         noexcept(noexcept(_Current - _Se)) /* strengthened */ {
; 2483 :         return _Current - _Se;
; 2484 :     }
; 2485 : 
; 2486 :     template <_Not_a_const_iterator _Sent>
; 2487 :         requires sized_sentinel_for<_Sent, _Iter>
; 2488 :     _NODISCARD friend constexpr difference_type operator-(const _Sent& _Se, const basic_const_iterator& _It)
; 2489 :         noexcept(noexcept(_Se - _It._Current)) /* strengthened */ {
; 2490 :         return _Se - _It._Current;
; 2491 :     }
; 2492 : 
; 2493 :     _NODISCARD friend constexpr _Rvalue_reference iter_move(const basic_const_iterator& _It)
; 2494 :         noexcept(noexcept(static_cast<_Rvalue_reference>(_RANGES iter_move(_It._Current)))) {
; 2495 :         return static_cast<_Rvalue_reference>(_RANGES iter_move(_It._Current));
; 2496 :     }
; 2497 : };
; 2498 : 
; 2499 : template <class _Ty1, common_with<_Ty1> _Ty2>
; 2500 :     requires input_iterator<common_type_t<_Ty1, _Ty2>>
; 2501 : struct common_type<basic_const_iterator<_Ty1>, _Ty2> {
; 2502 :     using type = basic_const_iterator<common_type_t<_Ty1, _Ty2>>;
; 2503 : };
; 2504 : 
; 2505 : template <class _Ty1, common_with<_Ty1> _Ty2>
; 2506 :     requires input_iterator<common_type_t<_Ty1, _Ty2>>
; 2507 : struct common_type<_Ty2, basic_const_iterator<_Ty1>> {
; 2508 :     using type = basic_const_iterator<common_type_t<_Ty1, _Ty2>>;
; 2509 : };
; 2510 : 
; 2511 : template <class _Ty1, common_with<_Ty1> _Ty2>
; 2512 :     requires input_iterator<common_type_t<_Ty1, _Ty2>>
; 2513 : struct common_type<basic_const_iterator<_Ty1>, basic_const_iterator<_Ty2>> {
; 2514 :     using type = basic_const_iterator<common_type_t<_Ty1, _Ty2>>;
; 2515 : };
; 2516 : 
; 2517 : _EXPORT_STD template <input_iterator _Iter>
; 2518 : _NODISCARD constexpr const_iterator<_Iter> make_const_iterator(_Iter _It)
; 2519 :     noexcept(is_nothrow_constructible_v<const_iterator<_Iter>, _Iter&>) /* strengthened */ {
; 2520 :     return _It;
; 2521 : }
; 2522 : 
; 2523 : _EXPORT_STD template <semiregular _Sent>
; 2524 : _NODISCARD constexpr const_sentinel<_Sent> make_const_sentinel(_Sent _Se)
; 2525 :     noexcept(is_nothrow_constructible_v<const_sentinel<_Sent>, _Sent&>) /* strengthened */ {
; 2526 :     return _Se;
; 2527 : }
; 2528 : #endif // _HAS_CXX23
; 2529 : 
; 2530 : namespace ranges {
; 2531 :     template <class>
; 2532 :     constexpr bool _Has_complete_elements = false;
; 2533 : 
; 2534 :     template <class _Ty>
; 2535 :         requires requires(_Ty& __t) { sizeof(__t[0]); }
; 2536 :     constexpr bool _Has_complete_elements<_Ty> = true;
; 2537 : 
; 2538 :     _EXPORT_STD template <class>
; 2539 :     constexpr bool enable_borrowed_range = false;
; 2540 : 
; 2541 :     template <class _Rng>
; 2542 :     concept _Should_range_access = is_lvalue_reference_v<_Rng> || enable_borrowed_range<remove_cvref_t<_Rng>>;
; 2543 : 
; 2544 :     namespace _Begin {
; 2545 : #if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1681199
; 2546 :         void begin() = delete; // Block unqualified name lookup
; 2547 : #else // ^^^ no workaround / workaround vvv
; 2548 :         void begin();
; 2549 : #endif // ^^^ workaround ^^^
; 2550 : 
; 2551 :         template <class _Ty>
; 2552 :         concept _Has_member = requires(_Ty __t) {
; 2553 :             { _STD _Fake_copy_init(__t.begin()) } -> input_or_output_iterator;
; 2554 :         };
; 2555 : 
; 2556 :         template <class _Ty>
; 2557 :         concept _Has_ADL = _Has_class_or_enum_type<_Ty> && requires(_Ty __t) {
; 2558 :             { _STD _Fake_copy_init(begin(__t)) } -> input_or_output_iterator; // intentional ADL
; 2559 :         };
; 2560 : 
; 2561 :         class _Cpo {
; 2562 :         private:
; 2563 :             enum class _St { _None, _Array, _Member, _Non_member };
; 2564 : 
; 2565 :             template <class _Ty>
; 2566 :             _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
; 2567 :                 _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
; 2568 :                 if constexpr (is_array_v<remove_reference_t<_Ty>>) {
; 2569 :                     static_assert(_Has_complete_elements<_Ty>,
; 2570 :                         "The range access customization point objects "
; 2571 :                         "std::ranges::begin, std::ranges::end, std::ranges::rbegin, std::ranges::rend, "
; 2572 :                         "and std::ranges::data do not accept arrays with incomplete element types.");
; 2573 :                     return {_St::_Array, true};
; 2574 :                 } else if constexpr (_Has_member<_Ty>) {
; 2575 :                     return {_St::_Member, noexcept(_STD _Fake_copy_init(_STD declval<_Ty>().begin()))};
; 2576 :                 } else if constexpr (_Has_ADL<_Ty>) {
; 2577 :                     return {_St::_Non_member,
; 2578 :                         noexcept(_STD _Fake_copy_init(begin(_STD declval<_Ty>())))}; // intentional ADL
; 2579 :                 } else {
; 2580 :                     return {_St::_None};
; 2581 :                 }
; 2582 :             }
; 2583 : 
; 2584 :             template <class _Ty>
; 2585 :             static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();
; 2586 : 
; 2587 :         public:
; 2588 :             template <_Should_range_access _Ty>
; 2589 :                 requires (_Choice<_Ty&>._Strategy != _St::_None)
; 2590 :             _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
; 2591 :                 noexcept(_Choice<_Ty&>._No_throw) {
; 2592 :                 constexpr _St _Strat = _Choice<_Ty&>._Strategy;
; 2593 : 
; 2594 :                 if constexpr (_Strat == _St::_Array) {
; 2595 :                     return _Val;
; 2596 :                 } else if constexpr (_Strat == _St::_Member) {
; 2597 :                     return _Val.begin();
; 2598 :                 } else if constexpr (_Strat == _St::_Non_member) {
; 2599 :                     return begin(_Val); // intentional ADL
; 2600 :                 } else {
; 2601 :                     _STL_INTERNAL_STATIC_ASSERT(false); // unexpected strategy
; 2602 :                 }
; 2603 :             }
; 2604 :         };
; 2605 :     } // namespace _Begin
; 2606 : 
; 2607 :     inline namespace _Cpos {
; 2608 :         _EXPORT_STD inline constexpr _Begin::_Cpo begin;
; 2609 :     }
; 2610 : 
; 2611 :     _EXPORT_STD template <class _Ty>
; 2612 :     using iterator_t = decltype(_RANGES begin(_STD declval<_Ty&>()));
; 2613 : 
; 2614 :     namespace _End {
; 2615 : #if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1681199
; 2616 :         void end() = delete; // Block unqualified name lookup
; 2617 : #else // ^^^ no workaround / workaround vvv
; 2618 :         void end();
; 2619 : #endif // ^^^ workaround ^^^
; 2620 : 
; 2621 :         template <class _Ty>
; 2622 :         concept _Has_member = requires(_Ty __t) {
; 2623 :             { _STD _Fake_copy_init(__t.end()) } -> sentinel_for<iterator_t<_Ty>>;
; 2624 :         };
; 2625 : 
; 2626 :         template <class _Ty>
; 2627 :         concept _Has_ADL = _Has_class_or_enum_type<_Ty> && requires(_Ty __t) {
; 2628 :             { _STD _Fake_copy_init(end(__t)) } -> sentinel_for<iterator_t<_Ty>>; // intentional ADL
; 2629 :         };
; 2630 : 
; 2631 :         class _Cpo {
; 2632 :         private:
; 2633 :             enum class _St { _None, _Array, _Member, _Non_member };
; 2634 : 
; 2635 :             template <class _Ty>
; 2636 :             _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
; 2637 :                 _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
; 2638 :                 using _UnRef = remove_reference_t<_Ty>;
; 2639 : 
; 2640 :                 if constexpr (is_array_v<_UnRef>) {
; 2641 :                     static_assert(_Has_complete_elements<_UnRef>,
; 2642 :                         "The range access customization point objects "
; 2643 :                         "std::ranges::begin, std::ranges::end, std::ranges::rbegin, std::ranges::rend, "
; 2644 :                         "and std::ranges::data do not accept arrays with incomplete element types.");
; 2645 :                     if constexpr (extent_v<_UnRef> != 0) {
; 2646 :                         return {_St::_Array, true};
; 2647 :                     } else {
; 2648 :                         return {_St::_None};
; 2649 :                     }
; 2650 :                 } else if constexpr (_Has_member<_Ty>) {
; 2651 :                     return {_St::_Member, noexcept(_STD _Fake_copy_init(_STD declval<_Ty>().end()))};
; 2652 :                 } else if constexpr (_Has_ADL<_Ty>) {
; 2653 :                     return {
; 2654 :                         _St::_Non_member, noexcept(_STD _Fake_copy_init(end(_STD declval<_Ty>())))}; // intentional ADL
; 2655 :                 } else {
; 2656 :                     return {_St::_None};
; 2657 :                 }
; 2658 :             }
; 2659 : 
; 2660 :             template <class _Ty>
; 2661 :             static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();
; 2662 : 
; 2663 :         public:
; 2664 :             template <_Should_range_access _Ty>
; 2665 :                 requires (_Choice<_Ty&>._Strategy != _St::_None)
; 2666 :             _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
; 2667 :                 noexcept(_Choice<_Ty&>._No_throw) {
; 2668 :                 constexpr _St _Strat = _Choice<_Ty&>._Strategy;
; 2669 : 
; 2670 :                 if constexpr (_Strat == _St::_Array) {
; 2671 :                     // extent_v<remove_reference_t<_Ty&>> reuses specializations from _Choose
; 2672 :                     return _Val + extent_v<remove_reference_t<_Ty&>>;
; 2673 :                 } else if constexpr (_Strat == _St::_Member) {
; 2674 :                     return _Val.end();
; 2675 :                 } else if constexpr (_Strat == _St::_Non_member) {
; 2676 :                     return end(_Val); // intentional ADL
; 2677 :                 } else {
; 2678 :                     _STL_INTERNAL_STATIC_ASSERT(false); // unexpected strategy
; 2679 :                 }
; 2680 :             }
; 2681 :         };
; 2682 :     } // namespace _End
; 2683 : 
; 2684 :     inline namespace _Cpos {
; 2685 :         _EXPORT_STD inline constexpr _End::_Cpo end;
; 2686 :     }
; 2687 : 
; 2688 :     _EXPORT_STD template <class _Rng>
; 2689 :     concept range = requires(_Rng& __r) {
; 2690 :         _RANGES begin(__r);
; 2691 :         _RANGES end(__r);
; 2692 :     };
; 2693 : 
; 2694 :     _EXPORT_STD template <class _Rng>
; 2695 :     concept input_range = range<_Rng> && input_iterator<iterator_t<_Rng>>;
; 2696 : 
; 2697 :     _EXPORT_STD template <range _Rng>
; 2698 :     using sentinel_t = decltype(_RANGES end(_STD declval<_Rng&>()));
; 2699 : 
; 2700 :     template <class _Wrapped>
; 2701 :     concept _Weakly_unwrappable = _Allow_inheriting_unwrap_v<remove_cvref_t<_Wrapped>>
; 2702 :                                && requires(_Wrapped&& _Wr) { _STD forward<_Wrapped>(_Wr)._Unwrapped(); };
; 2703 : 
; 2704 :     template <class _Sent>
; 2705 :     concept _Weakly_unwrappable_sentinel = _Weakly_unwrappable<const remove_reference_t<_Sent>&>;
; 2706 : 
; 2707 :     template <class _Iter>
; 2708 :     concept _Weakly_unwrappable_iterator =
; 2709 :         _Weakly_unwrappable<_Iter> && requires(_Iter&& _It, remove_cvref_t<_Iter>& _MutIt) {
; 2710 :             _MutIt._Seek_to(_STD forward<_Iter>(_It)._Unwrapped());
; 2711 :         };
; 2712 : 
; 2713 :     template <class _Sent, class _Iter>
; 2714 :     concept _Unwrappable_sentinel_for = _Weakly_unwrappable_sentinel<_Sent> && _Weakly_unwrappable_iterator<_Iter>
; 2715 :                                      && requires(_Iter&& _It, const remove_reference_t<_Sent>& _Se) {
; 2716 :                                             {
; 2717 :                                                 _Se._Unwrapped()
; 2718 :                                             } -> sentinel_for<decltype(_STD forward<_Iter>(_It)._Unwrapped())>;
; 2719 :                                         };
; 2720 : 
; 2721 :     template <class _Sent, class _Iter>
; 2722 :     _NODISCARD constexpr decltype(auto) _Unwrap_iter(_Iter&& _It)
; 2723 :         noexcept(!_Unwrappable_sentinel_for<_Sent, _Iter> || _Has_nothrow_unwrapped<_Iter>) {
; 2724 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2725 :         if constexpr (is_pointer_v<remove_cvref_t<_Iter>>) {
; 2726 :             return _It + 0;
; 2727 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2728 :             return static_cast<_Iter&&>(_It)._Unwrapped();
; 2729 :         } else {
; 2730 :             return static_cast<_Iter&&>(_It);
; 2731 :         }
; 2732 :     }
; 2733 : 
; 2734 :     template <class _Iter, class _Sent>
; 2735 :     _NODISCARD constexpr decltype(auto) _Unwrap_sent(_Sent&& _Se)
; 2736 :         noexcept(!_Unwrappable_sentinel_for<_Sent, _Iter> || _Has_nothrow_unwrapped<_Sent>) {
; 2737 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2738 :         if constexpr (is_pointer_v<remove_cvref_t<_Sent>>) {
; 2739 :             return _Se + 0;
; 2740 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2741 :             return static_cast<_Sent&&>(_Se)._Unwrapped();
; 2742 :         } else {
; 2743 :             return static_cast<_Sent&&>(_Se);
; 2744 :         }
; 2745 :     }
; 2746 : 
; 2747 :     template <range _Rng, class _Iter>
; 2748 :     _NODISCARD constexpr decltype(auto) _Unwrap_range_iter(_Iter&& _It)
; 2749 :         noexcept(noexcept(_RANGES _Unwrap_iter<sentinel_t<_Rng>>(static_cast<_Iter&&>(_It)))) {
; 2750 :         _STL_INTERNAL_STATIC_ASSERT(same_as<remove_cvref_t<_Iter>, iterator_t<_Rng>>);
; 2751 :         return _RANGES _Unwrap_iter<sentinel_t<_Rng>>(static_cast<_Iter&&>(_It));
; 2752 :     }
; 2753 : 
; 2754 :     template <range _Rng, class _Sent>
; 2755 :     _NODISCARD constexpr decltype(auto) _Unwrap_range_sent(_Sent&& _Se)
; 2756 :         noexcept(noexcept(_RANGES _Unwrap_sent<iterator_t<_Rng>>(static_cast<_Sent&&>(_Se)))) {
; 2757 :         _STL_INTERNAL_STATIC_ASSERT(same_as<remove_cvref_t<_Sent>, sentinel_t<_Rng>>);
; 2758 :         return _RANGES _Unwrap_sent<iterator_t<_Rng>>(static_cast<_Sent&&>(_Se));
; 2759 :     }
; 2760 : 
; 2761 :     template <class _Iter, class _Sent>
; 2762 :     using _Unwrap_iter_t = remove_cvref_t<decltype(_RANGES _Unwrap_iter<_Sent>(_STD declval<_Iter>()))>;
; 2763 :     template <class _Sent, class _Iter>
; 2764 :     using _Unwrap_sent_t = remove_cvref_t<decltype(_RANGES _Unwrap_sent<_Iter>(_STD declval<_Sent>()))>;
; 2765 : 
; 2766 :     template <range _Rng>
; 2767 :     using _Unwrapped_iterator_t = _Unwrap_iter_t<iterator_t<_Rng>, sentinel_t<_Rng>>;
; 2768 :     template <range _Rng>
; 2769 :     using _Unwrapped_sentinel_t = _Unwrap_sent_t<sentinel_t<_Rng>, iterator_t<_Rng>>;
; 2770 : 
; 2771 :     namespace _Unchecked_begin {
; 2772 :         template <class _Ty>
; 2773 :         concept _Has_member = requires(_Ty& __t) {
; 2774 :             { __t._Unchecked_begin() } -> input_or_output_iterator;
; 2775 :         };
; 2776 : 
; 2777 :         template <class _Ty>
; 2778 :         concept _Can_begin = requires(_Ty& __t) { _RANGES _Unwrap_range_iter<_Ty>(_RANGES begin(__t)); };
; 2779 : 
; 2780 :         class _Cpo {
; 2781 :         private:
; 2782 :             enum class _St { _None, _Member, _Unwrap };
; 2783 : 
; 2784 :             template <class _Ty>
; 2785 :             _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
; 2786 :                 _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
; 2787 :                 if constexpr (_Has_member<_Ty>) {
; 2788 :                     _STL_INTERNAL_STATIC_ASSERT(
; 2789 :                         same_as<decltype(_STD declval<_Ty>()._Unchecked_begin()), _Unwrapped_iterator_t<_Ty>>);
; 2790 :                     return {_St::_Member, noexcept(_STD _Fake_copy_init(_STD declval<_Ty>()._Unchecked_begin()))};
; 2791 :                 } else if constexpr (_Can_begin<_Ty>) {
; 2792 :                     return {_St::_Unwrap, noexcept(_STD _Fake_copy_init(
; 2793 :                                               _RANGES _Unwrap_range_iter<_Ty>(_RANGES begin(_STD declval<_Ty>()))))};
; 2794 :                 } else {
; 2795 :                     return {_St::_None};
; 2796 :                 }
; 2797 :             }
; 2798 : 
; 2799 :             template <class _Ty>
; 2800 :             static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();
; 2801 : 
; 2802 :         public:
; 2803 :             template <_Should_range_access _Ty>
; 2804 :                 requires (_Choice<_Ty&>._Strategy != _St::_None)
; 2805 :             _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
; 2806 :                 noexcept(_Choice<_Ty&>._No_throw) {
; 2807 :                 constexpr _St _Strat = _Choice<_Ty&>._Strategy;
; 2808 : 
; 2809 :                 if constexpr (_Strat == _St::_Member) {
; 2810 :                     return _Val._Unchecked_begin();
; 2811 :                 } else if constexpr (_Strat == _St::_Unwrap) {
; 2812 :                     return _RANGES _Unwrap_range_iter<_Ty>(_RANGES begin(_Val));
; 2813 :                 } else {
; 2814 :                     _STL_INTERNAL_STATIC_ASSERT(false); // unexpected strategy
; 2815 :                 }
; 2816 :             }
; 2817 :         };
; 2818 :     } // namespace _Unchecked_begin
; 2819 : 
; 2820 :     inline namespace _Cpos {
; 2821 :         inline constexpr _Unchecked_begin::_Cpo _Ubegin;
; 2822 :     }
; 2823 : 
; 2824 :     namespace _Unchecked_end {
; 2825 :         template <class _Ty>
; 2826 :         concept _Has_member = _Unchecked_begin::_Has_member<_Ty> && requires(_Ty& __t) {
; 2827 :             __t._Unchecked_begin(); // required explicitly for better diagnostics
; 2828 :             { __t._Unchecked_end() } -> sentinel_for<decltype(__t._Unchecked_begin())>;
; 2829 :         };
; 2830 : 
; 2831 :         template <class _Ty>
; 2832 :         concept _Can_end = requires(_Ty& __t) { _RANGES _Unwrap_range_sent<_Ty>(_RANGES end(__t)); };
; 2833 : 
; 2834 :         class _Cpo {
; 2835 :         private:
; 2836 :             enum class _St { _None, _Member, _Unwrap };
; 2837 : 
; 2838 :             template <class _Ty>
; 2839 :             _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
; 2840 :                 _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
; 2841 :                 if constexpr (_Has_member<_Ty>) {
; 2842 :                     return {_St::_Member, noexcept(_STD declval<_Ty>()._Unchecked_end())};
; 2843 :                 } else if constexpr (_Can_end<_Ty>) {
; 2844 :                     return {_St::_Unwrap, noexcept(_RANGES _Unwrap_range_sent<_Ty>(_RANGES end(_STD declval<_Ty>())))};
; 2845 :                 } else {
; 2846 :                     return {_St::_None};
; 2847 :                 }
; 2848 :             }
; 2849 : 
; 2850 :             template <class _Ty>
; 2851 :             static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();
; 2852 : 
; 2853 :         public:
; 2854 :             template <_Should_range_access _Ty>
; 2855 :                 requires (_Choice<_Ty&>._Strategy != _St::_None)
; 2856 :             _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
; 2857 :                 noexcept(_Choice<_Ty&>._No_throw) {
; 2858 :                 constexpr _St _Strat = _Choice<_Ty&>._Strategy;
; 2859 : 
; 2860 :                 if constexpr (_Strat == _St::_Member) {
; 2861 :                     return _Val._Unchecked_end();
; 2862 :                 } else if constexpr (_Strat == _St::_Unwrap) {
; 2863 :                     return _RANGES _Unwrap_range_sent<_Ty>(_RANGES end(_Val));
; 2864 :                 } else {
; 2865 :                     _STL_INTERNAL_STATIC_ASSERT(false); // unexpected strategy
; 2866 :                 }
; 2867 :             }
; 2868 :         };
; 2869 :     } // namespace _Unchecked_end
; 2870 : 
; 2871 :     inline namespace _Cpos {
; 2872 :         inline constexpr _Unchecked_end::_Cpo _Uend;
; 2873 :     }
; 2874 : 
; 2875 :     _EXPORT_STD template <class _Rng>
; 2876 :     concept borrowed_range = range<_Rng> && _Should_range_access<_Rng>;
; 2877 : 
; 2878 :     _EXPORT_STD template <range _Rng>
; 2879 :     using range_difference_t = iter_difference_t<iterator_t<_Rng>>;
; 2880 : 
; 2881 :     _EXPORT_STD template <range _Rng>
; 2882 :     using range_value_t = iter_value_t<iterator_t<_Rng>>;
; 2883 : 
; 2884 :     _EXPORT_STD template <range _Rng>
; 2885 :     using range_reference_t = iter_reference_t<iterator_t<_Rng>>;
; 2886 : 
; 2887 :     _EXPORT_STD template <range _Rng>
; 2888 :     using range_rvalue_reference_t = iter_rvalue_reference_t<iterator_t<_Rng>>;
; 2889 : 
; 2890 :     _EXPORT_STD template <range _Rng>
; 2891 :     using range_common_reference_t = iter_common_reference_t<iterator_t<_Rng>>;
; 2892 : 
; 2893 : #if _HAS_CXX23
; 2894 :     _EXPORT_STD template <class _Rng>
; 2895 :     concept constant_range = input_range<_Rng> && _Constant_iterator<iterator_t<_Rng>>;
; 2896 : 
; 2897 :     template <input_range _Rng>
; 2898 :     _NODISCARD _MSVC_INTRINSIC constexpr auto& _Possibly_const_range(_Rng& _Range) noexcept {
; 2899 :         if constexpr (input_range<const _Rng>) {
; 2900 :             return _STD as_const(_Range);
; 2901 :         } else {
; 2902 :             return _Range;
; 2903 :         }
; 2904 :     }
; 2905 : 
; 2906 :     template <class _Ty>
; 2907 :     _NODISCARD _MSVC_INTRINSIC constexpr auto _As_const_pointer(const _Ty* _Ptr) noexcept {
; 2908 :         return _Ptr;
; 2909 :     }
; 2910 : #endif // _HAS_CXX23
; 2911 : 
; 2912 :     struct _Cbegin_fn {
; 2913 : #if _HAS_CXX23
; 2914 :         template <class _Ty>
; 2915 :         using _Begin_on_const = decltype(_RANGES begin(_RANGES _Possibly_const_range(_STD declval<_Ty&>())));
; 2916 : 
; 2917 :         template <_Should_range_access _Ty>
; 2918 :             requires requires(_Ty& _Val) {
; 2919 :                 typename _Begin_on_const<_Ty>;
; 2920 :                 typename const_iterator<_Begin_on_const<_Ty>>;
; 2921 :                 const_iterator<_Begin_on_const<_Ty>>{_RANGES begin(_RANGES _Possibly_const_range(_Val))};
; 2922 :             }
; 2923 :         _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR noexcept(
; 2924 :             noexcept(const_iterator<_Begin_on_const<_Ty>>{_RANGES begin(_RANGES _Possibly_const_range(_Val))})) {
; 2925 :             return const_iterator<_Begin_on_const<_Ty>>{_RANGES begin(_RANGES _Possibly_const_range(_Val))};
; 2926 :         }
; 2927 : #else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
; 2928 :         template <class _Ty, class _CTy = _Const_thru_ref<_Ty>>
; 2929 :         _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
; 2930 :             noexcept(noexcept(_RANGES begin(static_cast<_CTy&&>(_Val))))
; 2931 :             requires requires { _RANGES begin(static_cast<_CTy&&>(_Val)); }
; 2932 :         {
; 2933 :             return _RANGES begin(static_cast<_CTy&&>(_Val));
; 2934 :         }
; 2935 : #endif // ^^^ !_HAS_CXX23 ^^^
; 2936 :     };
; 2937 : 
; 2938 :     inline namespace _Cpos {
; 2939 :         _EXPORT_STD inline constexpr _Cbegin_fn cbegin;
; 2940 :     }
; 2941 : 
; 2942 :     struct _Cend_fn {
; 2943 : #if _HAS_CXX23
; 2944 :         template <class _Ty>
; 2945 :         using _End_on_const = decltype(_RANGES end(_RANGES _Possibly_const_range(_STD declval<_Ty&>())));
; 2946 : 
; 2947 :         template <_Should_range_access _Ty>
; 2948 :             requires requires(_Ty& _Val) {
; 2949 :                 typename _End_on_const<_Ty>;
; 2950 :                 typename const_sentinel<_End_on_const<_Ty>>;
; 2951 :                 const_sentinel<_End_on_const<_Ty>>{_RANGES end(_RANGES _Possibly_const_range(_Val))};
; 2952 :             }
; 2953 :         _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
; 2954 :             noexcept(noexcept(const_sentinel<_End_on_const<_Ty>>{_RANGES end(_RANGES _Possibly_const_range(_Val))})) {
; 2955 :             return const_sentinel<_End_on_const<_Ty>>{_RANGES end(_RANGES _Possibly_const_range(_Val))};
; 2956 :         }
; 2957 : #else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
; 2958 :         template <class _Ty, class _CTy = _Const_thru_ref<_Ty>>
; 2959 :         _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
; 2960 :             noexcept(noexcept(_RANGES end(static_cast<_CTy&&>(_Val))))
; 2961 :             requires requires { _RANGES end(static_cast<_CTy&&>(_Val)); }
; 2962 :         {
; 2963 :             return _RANGES end(static_cast<_CTy&&>(_Val));
; 2964 :         }
; 2965 : #endif // ^^^ !_HAS_CXX23 ^^^
; 2966 :     };
; 2967 : 
; 2968 :     inline namespace _Cpos {
; 2969 :         _EXPORT_STD inline constexpr _Cend_fn cend;
; 2970 :     }
; 2971 : 
; 2972 :     namespace _Rbegin {
; 2973 : #if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1681199
; 2974 :         void rbegin() = delete; // Block unqualified name lookup
; 2975 : #else // ^^^ no workaround / workaround vvv
; 2976 :         void rbegin();
; 2977 : #endif // ^^^ workaround ^^^
; 2978 : 
; 2979 :         template <class _Ty>
; 2980 :         concept _Has_member = requires(_Ty __t) {
; 2981 :             { _STD _Fake_copy_init(__t.rbegin()) } -> input_or_output_iterator;
; 2982 :         };
; 2983 : 
; 2984 :         template <class _Ty>
; 2985 :         concept _Has_ADL = _Has_class_or_enum_type<_Ty> && requires(_Ty __t) {
; 2986 :             { _STD _Fake_copy_init(rbegin(__t)) } -> input_or_output_iterator; // intentional ADL
; 2987 :         };
; 2988 : 
; 2989 :         template <class _Ty>
; 2990 :         concept _Can_make_reverse = requires(_Ty __t) {
; 2991 :             { _RANGES begin(__t) } -> bidirectional_iterator;
; 2992 :             { _RANGES end(__t) } -> same_as<decltype(_RANGES begin(__t))>;
; 2993 :         };
; 2994 : 
; 2995 :         class _Cpo {
; 2996 :         private:
; 2997 :             enum class _St { _None, _Member, _Non_member, _Make_reverse };
; 2998 : 
; 2999 :             template <class _Ty>
; 3000 :             _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
; 3001 :                 _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
; 3002 :                 if constexpr (_Has_member<_Ty>) {
; 3003 :                     return {_St::_Member, noexcept(_STD _Fake_copy_init(_STD declval<_Ty>().rbegin()))};
; 3004 :                 } else if constexpr (_Has_ADL<_Ty>) {
; 3005 :                     return {_St::_Non_member,
; 3006 :                         noexcept(_STD _Fake_copy_init(rbegin(_STD declval<_Ty>())))}; // intentional ADL
; 3007 :                 } else if constexpr (_Can_make_reverse<_Ty>) {
; 3008 :                     return {_St::_Make_reverse, noexcept(_STD make_reverse_iterator(_RANGES end(_STD declval<_Ty>())))};
; 3009 :                 } else {
; 3010 :                     return {_St::_None};
; 3011 :                 }
; 3012 :             }
; 3013 : 
; 3014 :             template <class _Ty>
; 3015 :             static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();
; 3016 : 
; 3017 :         public:
; 3018 :             template <_Should_range_access _Ty>
; 3019 :                 requires (_Choice<_Ty&>._Strategy != _St::_None)
; 3020 :             _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
; 3021 :                 noexcept(_Choice<_Ty&>._No_throw) {
; 3022 :                 constexpr _St _Strat = _Choice<_Ty&>._Strategy;
; 3023 : 
; 3024 :                 if constexpr (_Strat == _St::_Member) {
; 3025 :                     return _Val.rbegin();
; 3026 :                 } else if constexpr (_Strat == _St::_Non_member) {
; 3027 :                     return rbegin(_Val); // intentional ADL
; 3028 :                 } else if constexpr (_Strat == _St::_Make_reverse) {
; 3029 :                     return _STD make_reverse_iterator(_RANGES end(_Val));
; 3030 :                 } else {
; 3031 :                     _STL_INTERNAL_STATIC_ASSERT(false); // unexpected strategy
; 3032 :                 }
; 3033 :             }
; 3034 :         };
; 3035 :     } // namespace _Rbegin
; 3036 : 
; 3037 :     inline namespace _Cpos {
; 3038 :         _EXPORT_STD inline constexpr _Rbegin::_Cpo rbegin;
; 3039 :     }
; 3040 : 
; 3041 :     namespace _Rend {
; 3042 : #if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1681199
; 3043 :         void rend() = delete; // Block unqualified name lookup
; 3044 : #else // ^^^ no workaround / workaround vvv
; 3045 :         void rend();
; 3046 : #endif // ^^^ workaround ^^^
; 3047 : 
; 3048 :         template <class _Ty>
; 3049 :         concept _Has_member = requires(_Ty __t) {
; 3050 :             { _STD _Fake_copy_init(__t.rend()) } -> sentinel_for<decltype(_RANGES rbegin(__t))>;
; 3051 :         };
; 3052 : 
; 3053 :         template <class _Ty>
; 3054 :         concept _Has_ADL = _Has_class_or_enum_type<_Ty> && requires(_Ty __t) {
; 3055 :             // intentional ADL
; 3056 :             { _STD _Fake_copy_init(rend(__t)) } -> sentinel_for<decltype(_RANGES rbegin(__t))>;
; 3057 :         };
; 3058 : 
; 3059 :         template <class _Ty>
; 3060 :         concept _Can_make_reverse = requires(_Ty __t) {
; 3061 :             { _RANGES begin(__t) } -> bidirectional_iterator;
; 3062 :             { _RANGES end(__t) } -> same_as<decltype(_RANGES begin(__t))>;
; 3063 :         };
; 3064 : 
; 3065 :         class _Cpo {
; 3066 :         private:
; 3067 :             enum class _St { _None, _Member, _Non_member, _Make_reverse };
; 3068 : 
; 3069 :             template <class _Ty>
; 3070 :             _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
; 3071 :                 _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
; 3072 :                 if constexpr (_Has_member<_Ty>) {
; 3073 :                     return {_St::_Member, noexcept(_STD _Fake_copy_init(_STD declval<_Ty>().rend()))};
; 3074 :                 } else if constexpr (_Has_ADL<_Ty>) {
; 3075 :                     return {
; 3076 :                         _St::_Non_member, noexcept(_STD _Fake_copy_init(rend(_STD declval<_Ty>())))}; // intentional ADL
; 3077 :                 } else if constexpr (_Can_make_reverse<_Ty>) {
; 3078 :                     return {
; 3079 :                         _St::_Make_reverse, noexcept(_STD make_reverse_iterator(_RANGES begin(_STD declval<_Ty>())))};
; 3080 :                 } else {
; 3081 :                     return {_St::_None};
; 3082 :                 }
; 3083 :             }
; 3084 : 
; 3085 :             template <class _Ty>
; 3086 :             static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();
; 3087 : 
; 3088 :         public:
; 3089 :             template <_Should_range_access _Ty>
; 3090 :                 requires (_Choice<_Ty&>._Strategy != _St::_None)
; 3091 :             _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
; 3092 :                 noexcept(_Choice<_Ty&>._No_throw) {
; 3093 :                 constexpr _St _Strat = _Choice<_Ty&>._Strategy;
; 3094 : 
; 3095 :                 if constexpr (_Strat == _St::_Member) {
; 3096 :                     return _Val.rend();
; 3097 :                 } else if constexpr (_Strat == _St::_Non_member) {
; 3098 :                     return rend(_Val); // intentional ADL
; 3099 :                 } else if constexpr (_Strat == _St::_Make_reverse) {
; 3100 :                     return _STD make_reverse_iterator(_RANGES begin(_Val));
; 3101 :                 } else {
; 3102 :                     _STL_INTERNAL_STATIC_ASSERT(false); // unexpected strategy
; 3103 :                 }
; 3104 :             }
; 3105 :         };
; 3106 :     } // namespace _Rend
; 3107 : 
; 3108 :     inline namespace _Cpos {
; 3109 :         _EXPORT_STD inline constexpr _Rend::_Cpo rend;
; 3110 :     }
; 3111 : 
; 3112 :     struct _Crbegin_fn {
; 3113 : #if _HAS_CXX23
; 3114 :         template <class _Ty>
; 3115 :         using _Rbegin_on_const = decltype(_RANGES rbegin(_RANGES _Possibly_const_range(_STD declval<_Ty&>())));
; 3116 : 
; 3117 :         template <_Should_range_access _Ty>
; 3118 :             requires requires(_Ty& _Val) {
; 3119 :                 typename _Rbegin_on_const<_Ty>;
; 3120 :                 typename const_iterator<_Rbegin_on_const<_Ty>>;
; 3121 :                 const_iterator<_Rbegin_on_const<_Ty>>{_RANGES rbegin(_RANGES _Possibly_const_range(_Val))};
; 3122 :             }
; 3123 :         _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR noexcept(
; 3124 :             noexcept(const_iterator<_Rbegin_on_const<_Ty>>{_RANGES rbegin(_RANGES _Possibly_const_range(_Val))})) {
; 3125 :             return const_iterator<_Rbegin_on_const<_Ty>>{_RANGES rbegin(_RANGES _Possibly_const_range(_Val))};
; 3126 :         }
; 3127 : #else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
; 3128 :         template <class _Ty, class _CTy = _Const_thru_ref<_Ty>>
; 3129 :         _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
; 3130 :             noexcept(noexcept(_RANGES rbegin(static_cast<_CTy&&>(_Val))))
; 3131 :             requires requires { _RANGES rbegin(static_cast<_CTy&&>(_Val)); }
; 3132 :         {
; 3133 :             return _RANGES rbegin(static_cast<_CTy&&>(_Val));
; 3134 :         }
; 3135 : #endif // ^^^ !_HAS_CXX23 ^^^
; 3136 :     };
; 3137 : 
; 3138 :     inline namespace _Cpos {
; 3139 :         _EXPORT_STD inline constexpr _Crbegin_fn crbegin;
; 3140 :     }
; 3141 : 
; 3142 :     struct _Crend_fn {
; 3143 : #if _HAS_CXX23
; 3144 :         template <class _Ty>
; 3145 :         using _Rend_on_const = decltype(_RANGES rend(_RANGES _Possibly_const_range(_STD declval<_Ty&>())));
; 3146 : 
; 3147 :         template <_Should_range_access _Ty>
; 3148 :             requires requires(_Ty& _Val) {
; 3149 :                 typename _Rend_on_const<_Ty>;
; 3150 :                 typename const_sentinel<_Rend_on_const<_Ty>>;
; 3151 :                 const_sentinel<_Rend_on_const<_Ty>>{_RANGES rend(_RANGES _Possibly_const_range(_Val))};
; 3152 :             }
; 3153 :         _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
; 3154 :             noexcept(noexcept(const_sentinel<_Rend_on_const<_Ty>>{_RANGES rend(_RANGES _Possibly_const_range(_Val))})) {
; 3155 :             return const_sentinel<_Rend_on_const<_Ty>>{_RANGES rend(_RANGES _Possibly_const_range(_Val))};
; 3156 :         }
; 3157 : #else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
; 3158 :         template <class _Ty, class _CTy = _Const_thru_ref<_Ty>>
; 3159 :         _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
; 3160 :             noexcept(noexcept(_RANGES rend(static_cast<_CTy&&>(_Val))))
; 3161 :             requires requires { _RANGES rend(static_cast<_CTy&&>(_Val)); }
; 3162 :         {
; 3163 :             return _RANGES rend(static_cast<_CTy&&>(_Val));
; 3164 :         }
; 3165 : #endif // ^^^ !_HAS_CXX23 ^^^
; 3166 :     };
; 3167 : 
; 3168 :     inline namespace _Cpos {
; 3169 :         _EXPORT_STD inline constexpr _Crend_fn crend;
; 3170 :     }
; 3171 : 
; 3172 :     _EXPORT_STD template <class>
; 3173 :     constexpr bool disable_sized_range = false;
; 3174 : 
; 3175 :     namespace _Size {
; 3176 : #if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1681199
; 3177 :         void size() = delete; // Block unqualified name lookup
; 3178 : #else // ^^^ no workaround / workaround vvv
; 3179 :         void size();
; 3180 : #endif // ^^^ workaround ^^^
; 3181 : 
; 3182 :         template <class _Ty, class _UnCV>
; 3183 :         concept _Has_member = !disable_sized_range<_UnCV> && requires(_Ty __t) {
; 3184 :             { _STD _Fake_copy_init(__t.size()) } -> _Integer_like;
; 3185 :         };
; 3186 : 
; 3187 :         template <class _Ty, class _UnCV>
; 3188 :         concept _Has_ADL = _Has_class_or_enum_type<_Ty> && !disable_sized_range<_UnCV> && requires(_Ty __t) {
; 3189 :             { _STD _Fake_copy_init(size(__t)) } -> _Integer_like; // intentional ADL
; 3190 :         };
; 3191 : 
; 3192 :         template <class _Ty>
; 3193 :         concept _Can_difference = requires(_Ty __t) {
; 3194 :             { _RANGES begin(__t) } -> forward_iterator;
; 3195 :             { _RANGES end(__t) } -> sized_sentinel_for<decltype(_RANGES begin(__t))>;
; 3196 :         };
; 3197 : 
; 3198 :         class _Cpo {
; 3199 :         private:
; 3200 :             enum class _St { _None, _Array, _Member, _Non_member, _Subtract };
; 3201 : 
; 3202 :             template <class _Ty>
; 3203 :             _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
; 3204 :                 _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
; 3205 :                 using _UnCV = remove_cvref_t<_Ty>;
; 3206 : 
; 3207 :                 if constexpr (is_array_v<_UnCV>) {
; 3208 :                     if constexpr (extent_v<_UnCV> != 0) {
; 3209 :                         return {_St::_Array, true};
; 3210 :                     } else {
; 3211 :                         return {_St::_None};
; 3212 :                     }
; 3213 :                 } else if constexpr (_Has_member<_Ty, _UnCV>) {
; 3214 :                     return {_St::_Member, noexcept(_STD _Fake_copy_init(_STD declval<_Ty>().size()))};
; 3215 :                 } else if constexpr (_Has_ADL<_Ty, _UnCV>) {
; 3216 :                     return {
; 3217 :                         _St::_Non_member, noexcept(_STD _Fake_copy_init(size(_STD declval<_Ty>())))}; // intentional ADL
; 3218 :                 } else if constexpr (_Can_difference<_Ty>) {
; 3219 :                     return {_St::_Subtract,
; 3220 :                         noexcept(_RANGES end(_STD declval<_Ty>()) - _RANGES begin(_STD declval<_Ty>()))};
; 3221 :                 } else {
; 3222 :                     return {_St::_None};
; 3223 :                 }
; 3224 :             }
; 3225 : 
; 3226 :             template <class _Ty>
; 3227 :             static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();
; 3228 : 
; 3229 :         public:
; 3230 :             template <class _Ty>
; 3231 :                 requires (_Choice<_Ty&>._Strategy != _St::_None)
; 3232 :             _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
; 3233 :                 noexcept(_Choice<_Ty&>._No_throw) {
; 3234 :                 constexpr _St _Strat = _Choice<_Ty&>._Strategy;
; 3235 : 
; 3236 :                 if constexpr (_Strat == _St::_Array) {
; 3237 :                     // extent_v<remove_cvref_t<_Ty&>> reuses specializations from _Choose
; 3238 :                     return extent_v<remove_cvref_t<_Ty&>>;
; 3239 :                 } else if constexpr (_Strat == _St::_Member) {
; 3240 :                     return _Val.size();
; 3241 :                 } else if constexpr (_Strat == _St::_Non_member) {
; 3242 :                     return size(_Val); // intentional ADL
; 3243 :                 } else if constexpr (_Strat == _St::_Subtract) {
; 3244 :                     const auto _Delta = _RANGES end(_Val) - _RANGES begin(_Val);
; 3245 :                     return static_cast<_Make_unsigned_like_t<remove_cv_t<decltype(_Delta)>>>(_Delta);
; 3246 :                 } else {
; 3247 :                     _STL_INTERNAL_STATIC_ASSERT(false); // unexpected strategy
; 3248 :                 }
; 3249 :             }
; 3250 :         };
; 3251 :     } // namespace _Size
; 3252 : 
; 3253 :     inline namespace _Cpos {
; 3254 :         _EXPORT_STD inline constexpr _Size::_Cpo size;
; 3255 :     }
; 3256 : 
; 3257 :     namespace _Empty {
; 3258 :         template <class _Ty>
; 3259 :         concept _Has_member = requires(_Ty __t) { static_cast<bool>(__t.empty()); };
; 3260 : 
; 3261 :         template <class _Ty>
; 3262 :         concept _Has_size = requires(_Ty __t) { _RANGES size(__t); };
; 3263 : 
; 3264 :         template <class _Ty>
; 3265 :         concept _Can_begin_end = requires(_Ty __t) {
; 3266 :             { _RANGES begin(__t) } -> forward_iterator;
; 3267 :             _RANGES end(__t);
; 3268 :         };
; 3269 : 
; 3270 :         class _Cpo {
; 3271 :         private:
; 3272 :             enum class _St { _None, _Member, _Size, _Compare };
; 3273 : 
; 3274 :             template <class _Ty>
; 3275 :             _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
; 3276 :                 _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
; 3277 :                 if constexpr (is_unbounded_array_v<remove_reference_t<_Ty>>) {
; 3278 :                     return {_St::_None};
; 3279 :                 } else if constexpr (_Has_member<_Ty>) {
; 3280 :                     return {_St::_Member, noexcept(static_cast<bool>(_STD declval<_Ty>().empty()))};
; 3281 :                 } else if constexpr (_Has_size<_Ty>) {
; 3282 :                     return {_St::_Size, noexcept(_RANGES size(_STD declval<_Ty>()))};
; 3283 :                 } else if constexpr (_Can_begin_end<_Ty>) {
; 3284 :                     constexpr auto _Nothrow = noexcept(
; 3285 :                         static_cast<bool>(_RANGES begin(_STD declval<_Ty>()) == _RANGES end(_STD declval<_Ty>())));
; 3286 :                     return {_St::_Compare, _Nothrow};
; 3287 :                 } else {
; 3288 :                     return {_St::_None};
; 3289 :                 }
; 3290 :             }
; 3291 : 
; 3292 :             template <class _Ty>
; 3293 :             static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();
; 3294 : 
; 3295 :         public:
; 3296 :             template <class _Ty>
; 3297 :                 requires (_Choice<_Ty&>._Strategy != _St::_None)
; 3298 :             _NODISCARD _STATIC_CALL_OPERATOR constexpr bool operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
; 3299 :                 noexcept(_Choice<_Ty&>._No_throw) {
; 3300 :                 constexpr _St _Strat = _Choice<_Ty&>._Strategy;
; 3301 : 
; 3302 :                 if constexpr (_Strat == _St::_Member) {
; 3303 :                     return static_cast<bool>(_Val.empty());
; 3304 :                 } else if constexpr (_Strat == _St::_Size) {
; 3305 :                     return _RANGES size(_Val) == 0;
; 3306 :                 } else if constexpr (_Strat == _St::_Compare) {
; 3307 :                     return static_cast<bool>(_RANGES begin(_Val) == _RANGES end(_Val));
; 3308 :                 } else {
; 3309 :                     _STL_INTERNAL_STATIC_ASSERT(false); // unexpected strategy
; 3310 :                 }
; 3311 :             }
; 3312 :         };
; 3313 :     } // namespace _Empty
; 3314 : 
; 3315 :     inline namespace _Cpos {
; 3316 :         _EXPORT_STD inline constexpr _Empty::_Cpo empty;
; 3317 :     }
; 3318 : 
; 3319 :     namespace _Data {
; 3320 :         template <class _Ty>
; 3321 :         concept _Points_to_object = is_pointer_v<_Ty> && is_object_v<remove_pointer_t<_Ty>>;
; 3322 : 
; 3323 :         template <class _Ty>
; 3324 :         concept _Has_member = requires(_Ty __t) {
; 3325 :             { _STD _Fake_copy_init(__t.data()) } -> _Points_to_object;
; 3326 :         };
; 3327 : 
; 3328 :         template <class _Ty>
; 3329 :         concept _Has_contiguous_iterator = requires(_Ty __t) {
; 3330 :             { _RANGES begin(__t) } -> contiguous_iterator;
; 3331 :         };
; 3332 : 
; 3333 :         class _Cpo {
; 3334 :         private:
; 3335 :             enum class _St { _None, _Member, _Address };
; 3336 : 
; 3337 :             template <class _Ty>
; 3338 :             _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
; 3339 :                 _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
; 3340 :                 if constexpr (_Has_member<_Ty>) {
; 3341 :                     return {_St::_Member, noexcept(_STD declval<_Ty>().data())};
; 3342 :                 } else if constexpr (_Has_contiguous_iterator<_Ty>) {
; 3343 :                     return {_St::_Address, noexcept(_STD to_address(_RANGES begin(_STD declval<_Ty>())))};
; 3344 :                 } else {
; 3345 :                     return {_St::_None};
; 3346 :                 }
; 3347 :             }
; 3348 : 
; 3349 :             template <class _Ty>
; 3350 :             static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();
; 3351 : 
; 3352 :         public:
; 3353 :             template <_Should_range_access _Ty>
; 3354 :                 requires (_Choice<_Ty&>._Strategy != _St::_None)
; 3355 :             _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
; 3356 :                 noexcept(_Choice<_Ty&>._No_throw) {
; 3357 :                 constexpr _St _Strat = _Choice<_Ty&>._Strategy;
; 3358 : 
; 3359 :                 if constexpr (_Strat == _St::_Member) {
; 3360 :                     return _Val.data();
; 3361 :                 } else if constexpr (_Strat == _St::_Address) {
; 3362 :                     return _STD to_address(_RANGES begin(_Val));
; 3363 :                 } else {
; 3364 :                     _STL_INTERNAL_STATIC_ASSERT(false); // unexpected strategy
; 3365 :                 }
; 3366 :             }
; 3367 :         };
; 3368 :     } // namespace _Data
; 3369 : 
; 3370 :     inline namespace _Cpos {
; 3371 :         _EXPORT_STD inline constexpr _Data::_Cpo data;
; 3372 :     }
; 3373 : 
; 3374 :     struct _Cdata_fn {
; 3375 : #if _HAS_CXX23
; 3376 :         template <_Should_range_access _Ty>
; 3377 :             requires requires(_Ty& _Val) { //
; 3378 :                 _RANGES _As_const_pointer(_RANGES data(_RANGES _Possibly_const_range(_Val)));
; 3379 :             }
; 3380 :         _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
; 3381 :             noexcept(noexcept(_RANGES data(_RANGES _Possibly_const_range(_Val)))) {
; 3382 :             return _RANGES _As_const_pointer(_RANGES data(_RANGES _Possibly_const_range(_Val)));
; 3383 :         }
; 3384 : #else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
; 3385 :         template <class _Ty, class _CTy = _Const_thru_ref<_Ty>>
; 3386 :         _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
; 3387 :             noexcept(noexcept(_RANGES data(static_cast<_CTy&&>(_Val))))
; 3388 :             requires requires { _RANGES data(static_cast<_CTy&&>(_Val)); }
; 3389 :         {
; 3390 :             return _RANGES data(static_cast<_CTy&&>(_Val));
; 3391 :         }
; 3392 : #endif // ^^^ !_HAS_CXX23 ^^^
; 3393 :     };
; 3394 : 
; 3395 :     inline namespace _Cpos {
; 3396 :         _EXPORT_STD inline constexpr _Cdata_fn cdata;
; 3397 :     }
; 3398 : 
; 3399 :     _EXPORT_STD template <class _Rng>
; 3400 :     concept sized_range = range<_Rng> && requires(_Rng& __r) { _RANGES size(__r); };
; 3401 : 
; 3402 :     _EXPORT_STD template <sized_range _Rng>
; 3403 :     using range_size_t = decltype(_RANGES size(_STD declval<_Rng&>()));
; 3404 : 
; 3405 :     _EXPORT_STD struct view_base {};
; 3406 : 
; 3407 :     template <class _Ty, template <class...> class _Template>
; 3408 :     concept _Strictly_derived_from_specialization_of =
; 3409 :         is_object_v<_Ty> && _Derived_from_specialization_of<_Ty, _Template>;
; 3410 : 
; 3411 :     _EXPORT_STD template <class _Derived>
; 3412 :         requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
; 3413 :     class view_interface;
; 3414 : 
; 3415 :     _EXPORT_STD template <class _Ty>
; 3416 :     constexpr bool enable_view =
; 3417 :         derived_from<_Ty, view_base> || _Strictly_derived_from_specialization_of<_Ty, view_interface>;
; 3418 : 
; 3419 :     _EXPORT_STD template <class _Ty>
; 3420 :     concept view = range<_Ty> && movable<_Ty> && enable_view<_Ty>;
; 3421 : 
; 3422 :     _EXPORT_STD template <class _Rng, class _Ty>
; 3423 :     concept output_range = range<_Rng> && output_iterator<iterator_t<_Rng>, _Ty>;
; 3424 : 
; 3425 :     _EXPORT_STD template <class _Rng>
; 3426 :     concept forward_range = range<_Rng> && forward_iterator<iterator_t<_Rng>>;
; 3427 : 
; 3428 :     _EXPORT_STD template <class _Rng>
; 3429 :     concept bidirectional_range = range<_Rng> && bidirectional_iterator<iterator_t<_Rng>>;
; 3430 : 
; 3431 :     _EXPORT_STD template <class _Rng>
; 3432 :     concept random_access_range = range<_Rng> && random_access_iterator<iterator_t<_Rng>>;
; 3433 : 
; 3434 :     _EXPORT_STD template <class _Rng>
; 3435 :     concept contiguous_range = range<_Rng> && contiguous_iterator<iterator_t<_Rng>> && requires(_Rng& __r) {
; 3436 :         { _RANGES data(__r) } -> same_as<add_pointer_t<range_reference_t<_Rng>>>;
; 3437 :     };
; 3438 : 
; 3439 :     class _Advance_fn {
; 3440 :     public:
; 3441 :         template <input_or_output_iterator _It>
; 3442 :         _STATIC_CALL_OPERATOR constexpr void operator()(_It& _Where, iter_difference_t<_It> _Off) _CONST_CALL_OPERATOR {
; 3443 :             if constexpr (random_access_iterator<_It>) {
; 3444 :                 _Where += _Off;
; 3445 :             } else {
; 3446 :                 if constexpr (!bidirectional_iterator<_It>) {
; 3447 :                     _STL_ASSERT(_Off >= 0, "negative advance of non-bidirectional iterator");
; 3448 :                 }
; 3449 : 
; 3450 :                 decltype(auto) _UWhere      = _STD _Get_unwrapped_n(_STD move(_Where), _Off);
; 3451 :                 constexpr bool _Need_rewrap = !is_reference_v<decltype(_STD _Get_unwrapped_n(_STD move(_Where), _Off))>;
; 3452 : 
; 3453 :                 if constexpr (bidirectional_iterator<_It>) {
; 3454 :                     for (; _Off < 0; ++_Off) {
; 3455 :                         --_UWhere;
; 3456 :                     }
; 3457 :                 }
; 3458 : 
; 3459 :                 for (; _Off > 0; --_Off) {
; 3460 :                     ++_UWhere;
; 3461 :                 }
; 3462 : 
; 3463 :                 if constexpr (_Need_rewrap) {
; 3464 :                     _STD _Seek_wrapped(_Where, _STD move(_UWhere));
; 3465 :                 }
; 3466 :             }
; 3467 :         }
; 3468 : 
; 3469 :         template <input_or_output_iterator _It, sentinel_for<_It> _Se>
; 3470 :         _STATIC_CALL_OPERATOR constexpr void operator()(_It& _Where, _Se _Last) _CONST_CALL_OPERATOR {
; 3471 :             if constexpr (assignable_from<_It&, _Se>) {
; 3472 :                 _Where = static_cast<_Se&&>(_Last);
; 3473 :             } else if constexpr (sized_sentinel_for<_Se, _It>) {
; 3474 :                 operator()(_Where, _Last - _Where);
; 3475 :             } else {
; 3476 :                 _STD _Adl_verify_range(_Where, _Last);
; 3477 : 
; 3478 :                 decltype(auto) _UWhere = _RANGES _Unwrap_iter<_Se>(static_cast<_It&&>(_Where));
; 3479 :                 constexpr bool _Need_rewrap =
; 3480 :                     !is_reference_v<decltype(_RANGES _Unwrap_iter<_Se>(static_cast<_It&&>(_Where)))>;
; 3481 :                 decltype(auto) _ULast = _RANGES _Unwrap_sent<_It>(static_cast<_Se&&>(_Last));
; 3482 : 
; 3483 :                 while (_UWhere != _ULast) {
; 3484 :                     ++_UWhere;
; 3485 :                 }
; 3486 : 
; 3487 :                 if constexpr (_Need_rewrap) {
; 3488 :                     _STD _Seek_wrapped(_Where, _STD move(_UWhere));
; 3489 :                 }
; 3490 :             }
; 3491 :         }
; 3492 : 
; 3493 :         template <input_or_output_iterator _It, sentinel_for<_It> _Se>
; 3494 :         _STATIC_CALL_OPERATOR constexpr iter_difference_t<_It> operator()(
; 3495 :             _It& _Where, iter_difference_t<_It> _Off, _Se _Last) _CONST_CALL_OPERATOR {
; 3496 :             if constexpr (sized_sentinel_for<_Se, _It>) {
; 3497 :                 const iter_difference_t<_It> _Delta = _Last - _Where;
; 3498 :                 if ((_Off < 0 && _Off <= _Delta) || (_Off > 0 && _Off >= _Delta)) {
; 3499 :                     if constexpr (assignable_from<_It&, _Se>) {
; 3500 :                         _Where = static_cast<_Se&&>(_Last);
; 3501 :                     } else {
; 3502 :                         operator()(_Where, _Delta);
; 3503 :                     }
; 3504 :                     return _Off - _Delta;
; 3505 :                 }
; 3506 : 
; 3507 :                 operator()(_Where, _Off);
; 3508 :                 return 0;
; 3509 :             } else {
; 3510 :                 // performance note: develop unwrapping technology for (i, n, s)?
; 3511 :                 if constexpr (bidirectional_iterator<_It>) {
; 3512 :                     for (; _Off < 0 && _Where != _Last; ++_Off) {
; 3513 :                         --_Where;
; 3514 :                     }
; 3515 :                 } else {
; 3516 :                     _STL_ASSERT(_Off >= 0, "negative advance of non-bidirectional iterator");
; 3517 :                 }
; 3518 : 
; 3519 :                 for (; _Off > 0 && _Where != _Last; --_Off) {
; 3520 :                     ++_Where;
; 3521 :                 }
; 3522 : 
; 3523 :                 return _Off;
; 3524 :             }
; 3525 :         }
; 3526 :     };
; 3527 : 
; 3528 :     _EXPORT_STD inline constexpr _Advance_fn advance;
; 3529 : 
; 3530 :     class _Distance_fn {
; 3531 :     public:
; 3532 :         template <class _It, sentinel_for<_It> _Se>
; 3533 :             requires (!sized_sentinel_for<_Se, _It>)
; 3534 :         _NODISCARD _STATIC_CALL_OPERATOR constexpr iter_difference_t<_It> operator()(
; 3535 :             _It _First, _Se _Last) _CONST_CALL_OPERATOR
; 3536 :             noexcept(noexcept(_Distance_unchecked(
; 3537 :                 _STD _Get_unwrapped(_STD move(_First)), _STD _Get_unwrapped(_STD move(_Last))))) /* strengthened */ {
; 3538 :             _STD _Adl_verify_range(_First, _Last);
; 3539 :             return _Distance_unchecked(
; 3540 :                 _RANGES _Unwrap_iter<_Se>(_STD move(_First)), _RANGES _Unwrap_sent<_It>(_STD move(_Last)));
; 3541 :         }
; 3542 : 
; 3543 :         template <class _It, sized_sentinel_for<decay_t<_It>> _Se>
; 3544 :         _NODISCARD _STATIC_CALL_OPERATOR constexpr iter_difference_t<decay_t<_It>> operator()(
; 3545 :             _It&& _First, const _Se _Last) _CONST_CALL_OPERATOR
; 3546 :             noexcept(noexcept(_Last - static_cast<const decay_t<_It>&>(_First))) /* strengthened */ {
; 3547 :             return _Last - static_cast<const decay_t<_It>&>(_First);
; 3548 :         }
; 3549 : 
; 3550 :         template <range _Rng>
; 3551 :         _NODISCARD _STATIC_CALL_OPERATOR constexpr range_difference_t<_Rng> operator()(
; 3552 :             _Rng&& _Range) _CONST_CALL_OPERATOR noexcept(_Nothrow_size<_Rng>) /* strengthened */ {
; 3553 :             if constexpr (sized_range<_Rng>) {
; 3554 :                 return static_cast<range_difference_t<_Rng>>(_RANGES size(_Range));
; 3555 :             } else {
; 3556 :                 return _Distance_unchecked(_Ubegin(_Range), _Uend(_Range));
; 3557 :             }
; 3558 :         }
; 3559 : 
; 3560 :     private:
; 3561 :         template <class _It, class _Se>
; 3562 :         _NODISCARD static constexpr iter_difference_t<_It> _Distance_unchecked(_It _First, const _Se _Last)
; 3563 :             noexcept(noexcept(++_First != _Last)) {
; 3564 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 3565 : 
; 3566 :             iter_difference_t<_It> _Count = 0;
; 3567 :             for (; _First != _Last; ++_First) {
; 3568 :                 ++_Count;
; 3569 :             }
; 3570 : 
; 3571 :             return _Count;
; 3572 :         }
; 3573 : 
; 3574 :         template <class _Rng>
; 3575 :         static constexpr bool _Nothrow_size =
; 3576 :             noexcept(_Distance_unchecked(_Ubegin(_STD declval<_Rng&>()), _Uend(_STD declval<_Rng&>())));
; 3577 : 
; 3578 :         template <sized_range _Rng>
; 3579 :         static constexpr bool _Nothrow_size<_Rng> = noexcept(_RANGES size(_STD declval<_Rng&>()));
; 3580 :     };
; 3581 : 
; 3582 :     _EXPORT_STD inline constexpr _Distance_fn distance;
; 3583 : 
; 3584 :     class _Ssize_fn {
; 3585 :     public:
; 3586 :         template <class _Rng>
; 3587 :         _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Rng&& _Range) _CONST_CALL_OPERATOR
; 3588 :             noexcept(noexcept(_RANGES size(_Range)))
; 3589 :             requires requires { _RANGES size(_Range); }
; 3590 :         {
; 3591 :             using _Sty = _Make_signed_like_t<decltype(_RANGES size(_Range))>;
; 3592 :             using _Ty  = common_type_t<conditional_t<is_integral_v<_Sty>, ptrdiff_t, _Sty>, _Sty>;
; 3593 :             return static_cast<_Ty>(_RANGES size(_Range));
; 3594 :         }
; 3595 :     };
; 3596 : 
; 3597 :     inline namespace _Cpos {
; 3598 :         _EXPORT_STD inline constexpr _Ssize_fn ssize;
; 3599 :     }
; 3600 : 
; 3601 :     class _Next_fn {
; 3602 :     public:
; 3603 :         template <input_or_output_iterator _It>
; 3604 :         _NODISCARD _STATIC_CALL_OPERATOR constexpr _It operator()(_It _Where) _CONST_CALL_OPERATOR {
; 3605 :             ++_Where;
; 3606 :             return _Where;
; 3607 :         }
; 3608 : 
; 3609 :         template <input_or_output_iterator _It>
; 3610 :         _NODISCARD _STATIC_CALL_OPERATOR constexpr _It operator()(
; 3611 :             _It _Where, const iter_difference_t<_It> _Off) _CONST_CALL_OPERATOR {
; 3612 :             _RANGES advance(_Where, _Off);
; 3613 :             return _Where;
; 3614 :         }
; 3615 : 
; 3616 :         template <input_or_output_iterator _It, sentinel_for<_It> _Se>
; 3617 :         _NODISCARD _STATIC_CALL_OPERATOR constexpr _It operator()(_It _Where, _Se _Last) _CONST_CALL_OPERATOR {
; 3618 :             _RANGES advance(_Where, static_cast<_Se&&>(_Last));
; 3619 :             return _Where;
; 3620 :         }
; 3621 : 
; 3622 :         template <input_or_output_iterator _It, sentinel_for<_It> _Se>
; 3623 :         _NODISCARD _STATIC_CALL_OPERATOR constexpr _It operator()(
; 3624 :             _It _Where, const iter_difference_t<_It> _Off, _Se _Last) _CONST_CALL_OPERATOR {
; 3625 :             _RANGES advance(_Where, _Off, static_cast<_Se&&>(_Last));
; 3626 :             return _Where;
; 3627 :         }
; 3628 :     };
; 3629 : 
; 3630 :     _EXPORT_STD inline constexpr _Next_fn next;
; 3631 : 
; 3632 :     class _Prev_fn {
; 3633 :     public:
; 3634 :         template <bidirectional_iterator _It>
; 3635 :         _NODISCARD _STATIC_CALL_OPERATOR constexpr _It operator()(_It _Where) _CONST_CALL_OPERATOR {
; 3636 :             --_Where;
; 3637 :             return _Where;
; 3638 :         }
; 3639 : 
; 3640 :         template <bidirectional_iterator _It>
; 3641 :         _NODISCARD _STATIC_CALL_OPERATOR constexpr _It operator()(
; 3642 :             _It _Where, const iter_difference_t<_It> _Off) _CONST_CALL_OPERATOR {
; 3643 :             _STL_ASSERT(_Off != _Min_possible_v<iter_difference_t<_It>>, "integer overflow");
; 3644 :             _RANGES advance(_Where, -_Off);
; 3645 :             return _Where;
; 3646 :         }
; 3647 : 
; 3648 :         template <bidirectional_iterator _It>
; 3649 :         _NODISCARD _STATIC_CALL_OPERATOR constexpr _It operator()(
; 3650 :             _It _Where, const iter_difference_t<_It> _Off, _It _Last) _CONST_CALL_OPERATOR {
; 3651 :             _STL_ASSERT(_Off != _Min_possible_v<iter_difference_t<_It>>, "integer overflow");
; 3652 :             _RANGES advance(_Where, -_Off, static_cast<_It&&>(_Last));
; 3653 :             return _Where;
; 3654 :         }
; 3655 :     };
; 3656 : 
; 3657 :     _EXPORT_STD inline constexpr _Prev_fn prev;
; 3658 : 
; 3659 :     template <forward_iterator _It, sentinel_for<_It> _Se>
; 3660 :     _NODISCARD constexpr _It _Find_last_iterator(
; 3661 :         const _It& _First, const _Se& _Last, const iter_difference_t<_It> _Count) {
; 3662 :         // Find the iterator in [_First, _Last) (of length _Count) which equals _Last
; 3663 :         _STL_INTERNAL_CHECK(_RANGES distance(_First, _Last) == _Count);
; 3664 :         if constexpr (is_same_v<_It, _Se>) {
; 3665 :             return _Last;
; 3666 :         } else {
; 3667 :             return _RANGES next(_First, _Count);
; 3668 :         }
; 3669 :     }
; 3670 : 
; 3671 :     _EXPORT_STD struct equal_to {
; 3672 :         template <class _Ty1, class _Ty2>
; 3673 :             requires equality_comparable_with<_Ty1, _Ty2>
; 3674 :         _NODISCARD constexpr bool operator()(_Ty1&& _Left, _Ty2&& _Right) const noexcept(
; 3675 :             noexcept(static_cast<bool>(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right)))) /* strengthened */ {
; 3676 :             return static_cast<bool>(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right));
; 3677 :         }
; 3678 : 
; 3679 :         using is_transparent = int;
; 3680 :     };
; 3681 : 
; 3682 :     _EXPORT_STD struct less {
; 3683 :         template <class _Ty1, class _Ty2>
; 3684 :             requires totally_ordered_with<_Ty1, _Ty2>
; 3685 :         _NODISCARD constexpr bool operator()(_Ty1&& _Left, _Ty2&& _Right) const noexcept(
; 3686 :             noexcept(static_cast<bool>(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right)))) /* strengthened */ {
; 3687 :             return static_cast<bool>(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right));
; 3688 :         }
; 3689 : 
; 3690 :         using is_transparent = int;
; 3691 :     };
; 3692 : 
; 3693 :     _EXPORT_STD struct greater {
; 3694 :         template <class _Ty1, class _Ty2>
; 3695 :             requires totally_ordered_with<_Ty1, _Ty2>
; 3696 :         _NODISCARD constexpr bool operator()(_Ty1&& _Left, _Ty2&& _Right) const noexcept(
; 3697 :             noexcept(static_cast<bool>(static_cast<_Ty2&&>(_Right) < static_cast<_Ty1&&>(_Left)))) /* strengthened */ {
; 3698 :             return static_cast<bool>(static_cast<_Ty2&&>(_Right) < static_cast<_Ty1&&>(_Left));
; 3699 :         }
; 3700 : 
; 3701 :         using is_transparent = int;
; 3702 :     };
; 3703 : 
; 3704 :     _EXPORT_STD template <class _Rng>
; 3705 :     concept common_range = range<_Rng> && same_as<iterator_t<_Rng>, sentinel_t<_Rng>>;
; 3706 : 
; 3707 :     template <class _It, class _Se>
; 3708 :     concept _Bidi_common = is_same_v<_It, _Se> && bidirectional_iterator<_It>;
; 3709 :     template <class _Rng>
; 3710 :     concept _Bidi_common_range = common_range<_Rng> && bidirectional_iterator<iterator_t<_Rng>>;
; 3711 : 
; 3712 :     template <class _Ty>
; 3713 :     concept _Can_empty = requires(_Ty __t) { _RANGES empty(__t); };
; 3714 : 
; 3715 :     _EXPORT_STD template <class _Derived>
; 3716 :         requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
; 3717 :     class view_interface {
; 3718 :     private:
; 3719 :         _NODISCARD constexpr _Derived& _Cast() noexcept {
; 3720 :             static_assert(derived_from<_Derived, view_interface>,
; 3721 :                 "view_interface's template argument D must derive from view_interface<D> "
; 3722 :                 "(N4950 [view.interface.general]/2).");
; 3723 :             static_assert(view<_Derived>,
; 3724 :                 "view_interface's template argument must model the view concept (N4950 [view.interface.general]/2).");
; 3725 :             return static_cast<_Derived&>(*this);
; 3726 :         }
; 3727 : 
; 3728 :         _NODISCARD constexpr const _Derived& _Cast() const noexcept {
; 3729 :             static_assert(derived_from<_Derived, view_interface>,
; 3730 :                 "view_interface's template argument D must derive from view_interface<D> "
; 3731 :                 "(N4950 [view.interface.general]/2).");
; 3732 :             static_assert(view<_Derived>,
; 3733 :                 "view_interface's template argument must model the view concept (N4950 [view.interface.general]/2).");
; 3734 :             return static_cast<const _Derived&>(*this);
; 3735 :         }
; 3736 : 
; 3737 :     public:
; 3738 :         _NODISCARD constexpr bool empty()
; 3739 :             requires sized_range<_Derived> || forward_range<_Derived>
; 3740 :         {
; 3741 :             auto& _Self = _Cast();
; 3742 :             if constexpr (sized_range<_Derived>) {
; 3743 :                 return _RANGES size(_Self) == 0;
; 3744 :             } else {
; 3745 :                 return _RANGES begin(_Self) == _RANGES end(_Self);
; 3746 :             }
; 3747 :         }
; 3748 : 
; 3749 :         _NODISCARD constexpr bool empty() const
; 3750 :             requires sized_range<const _Derived> || forward_range<const _Derived>
; 3751 :         {
; 3752 :             auto& _Self = _Cast();
; 3753 :             if constexpr (sized_range<const _Derived>) {
; 3754 :                 return _RANGES size(_Self) == 0;
; 3755 :             } else {
; 3756 :                 return _RANGES begin(_Self) == _RANGES end(_Self);
; 3757 :             }
; 3758 :         }
; 3759 : 
; 3760 : #if _HAS_CXX23
; 3761 :         _NODISCARD constexpr auto cbegin()
; 3762 :             requires input_range<_Derived>
; 3763 :         {
; 3764 :             return _RANGES cbegin(_Cast());
; 3765 :         }
; 3766 : 
; 3767 :         _NODISCARD constexpr auto cbegin() const
; 3768 :             requires input_range<const _Derived>
; 3769 :         {
; 3770 :             return _RANGES cbegin(_Cast());
; 3771 :         }
; 3772 : 
; 3773 :         _NODISCARD constexpr auto cend()
; 3774 :             requires input_range<_Derived>
; 3775 :         {
; 3776 :             return _RANGES cend(_Cast());
; 3777 :         }
; 3778 : 
; 3779 :         _NODISCARD constexpr auto cend() const
; 3780 :             requires input_range<const _Derived>
; 3781 :         {
; 3782 :             return _RANGES cend(_Cast());
; 3783 :         }
; 3784 : #endif // _HAS_CXX23
; 3785 : 
; 3786 :         constexpr explicit operator bool()
; 3787 :             requires _Can_empty<_Derived>
; 3788 :         {
; 3789 :             return !_RANGES empty(_Cast());
; 3790 :         }
; 3791 : 
; 3792 :         constexpr explicit operator bool() const
; 3793 :             requires _Can_empty<const _Derived>
; 3794 :         {
; 3795 :             return !_RANGES empty(_Cast());
; 3796 :         }
; 3797 : 
; 3798 :         _NODISCARD constexpr auto data()
; 3799 :             requires contiguous_iterator<iterator_t<_Derived>>
; 3800 :         {
; 3801 :             return _STD to_address(_RANGES begin(_Cast()));
; 3802 :         }
; 3803 : 
; 3804 :         _NODISCARD constexpr auto data() const
; 3805 :             requires range<const _Derived> && contiguous_iterator<iterator_t<const _Derived>>
; 3806 :         {
; 3807 :             return _STD to_address(_RANGES begin(_Cast()));
; 3808 :         }
; 3809 : 
; 3810 :         _NODISCARD constexpr auto size()
; 3811 :             requires forward_range<_Derived> && sized_sentinel_for<sentinel_t<_Derived>, iterator_t<_Derived>>
; 3812 :         {
; 3813 :             auto& _Self = _Cast();
; 3814 :             return _STD _To_unsigned_like(_RANGES end(_Self) - _RANGES begin(_Self));
; 3815 :         }
; 3816 : 
; 3817 :         _NODISCARD constexpr auto size() const
; 3818 :             requires forward_range<const _Derived>
; 3819 :                   && sized_sentinel_for<sentinel_t<const _Derived>, iterator_t<const _Derived>>
; 3820 :         {
; 3821 :             auto& _Self = _Cast();
; 3822 :             return _STD _To_unsigned_like(_RANGES end(_Self) - _RANGES begin(_Self));
; 3823 :         }
; 3824 : 
; 3825 :         _NODISCARD constexpr decltype(auto) front()
; 3826 :             requires forward_range<_Derived>
; 3827 :         {
; 3828 :             auto& _Self = _Cast();
; 3829 : 
; 3830 : #if _MSVC_STL_HARDENING_RANGES_VIEW_INTERFACE || _ITERATOR_DEBUG_LEVEL != 0
; 3831 :             _STL_VERIFY(!_RANGES empty(_Self), "front() called on empty ranges::view_interface");
; 3832 : #endif
; 3833 : 
; 3834 :             return *_RANGES begin(_Self);
; 3835 :         }
; 3836 : 
; 3837 :         _NODISCARD constexpr decltype(auto) front() const
; 3838 :             requires forward_range<const _Derived>
; 3839 :         {
; 3840 :             auto& _Self = _Cast();
; 3841 : 
; 3842 : #if _MSVC_STL_HARDENING_RANGES_VIEW_INTERFACE || _ITERATOR_DEBUG_LEVEL != 0
; 3843 :             _STL_VERIFY(!_RANGES empty(_Self), "front() called on empty ranges::view_interface");
; 3844 : #endif
; 3845 : 
; 3846 :             return *_RANGES begin(_Self);
; 3847 :         }
; 3848 : 
; 3849 :         _NODISCARD constexpr decltype(auto) back()
; 3850 :             requires bidirectional_range<_Derived> && common_range<_Derived>
; 3851 :         {
; 3852 :             auto& _Self = _Cast();
; 3853 : 
; 3854 : #if _MSVC_STL_HARDENING_RANGES_VIEW_INTERFACE || _ITERATOR_DEBUG_LEVEL != 0
; 3855 :             _STL_VERIFY(!_RANGES empty(_Self), "back() called on empty ranges::view_interface");
; 3856 : #endif
; 3857 : 
; 3858 :             auto _Last = _RANGES end(_Self);
; 3859 :             return *--_Last;
; 3860 :         }
; 3861 : 
; 3862 :         _NODISCARD constexpr decltype(auto) back() const
; 3863 :             requires bidirectional_range<const _Derived> && common_range<const _Derived>
; 3864 :         {
; 3865 :             auto& _Self = _Cast();
; 3866 : 
; 3867 : #if _MSVC_STL_HARDENING_RANGES_VIEW_INTERFACE || _ITERATOR_DEBUG_LEVEL != 0
; 3868 :             _STL_VERIFY(!_RANGES empty(_Self), "back() called on empty ranges::view_interface");
; 3869 : #endif
; 3870 : 
; 3871 :             auto _Last = _RANGES end(_Self);
; 3872 :             return *--_Last;
; 3873 :         }
; 3874 : 
; 3875 :         template <random_access_range _Rng = _Derived>
; 3876 :         _NODISCARD constexpr decltype(auto) operator[](const range_difference_t<_Rng> _Idx) {
; 3877 :             auto& _Self = _Cast();
; 3878 : 
; 3879 : #if _MSVC_STL_HARDENING_RANGES_VIEW_INTERFACE || _ITERATOR_DEBUG_LEVEL != 0
; 3880 :             if constexpr (sized_range<_Derived>) {
; 3881 :                 using _U_diff = _Make_unsigned_like_t<range_difference_t<_Rng>>;
; 3882 :                 _STL_VERIFY(static_cast<_U_diff>(_Idx) < static_cast<_U_diff>(_RANGES size(_Self)),
; 3883 :                     "ranges::view_interface subscript out of range");
; 3884 :             }
; 3885 : #endif // _MSVC_STL_HARDENING_RANGES_VIEW_INTERFACE || _ITERATOR_DEBUG_LEVEL != 0
; 3886 : 
; 3887 :             return _RANGES begin(_Self)[_Idx];
; 3888 :         }
; 3889 : 
; 3890 :         template <random_access_range _Rng = const _Derived>
; 3891 :         _NODISCARD constexpr decltype(auto) operator[](const range_difference_t<_Rng> _Idx) const {
; 3892 :             auto& _Self = _Cast();
; 3893 : 
; 3894 : #if _MSVC_STL_HARDENING_RANGES_VIEW_INTERFACE || _ITERATOR_DEBUG_LEVEL != 0
; 3895 :             if constexpr (sized_range<_Derived>) {
; 3896 :                 using _U_diff = _Make_unsigned_like_t<range_difference_t<_Rng>>;
; 3897 :                 _STL_VERIFY(static_cast<_U_diff>(_Idx) < static_cast<_U_diff>(_RANGES size(_Self)),
; 3898 :                     "ranges::view_interface subscript out of range");
; 3899 :             }
; 3900 : #endif // _MSVC_STL_HARDENING_RANGES_VIEW_INTERFACE || _ITERATOR_DEBUG_LEVEL != 0
; 3901 : 
; 3902 :             return _RANGES begin(_Self)[_Idx];
; 3903 :         }
; 3904 :     };
; 3905 : } // namespace ranges
; 3906 : 
; 3907 : #if _HAS_CXX23
; 3908 : template <class _Ty>
; 3909 : concept _Pair_like = _Tuple_like<_Ty> && tuple_size_v<remove_cvref_t<_Ty>> == 2;
; 3910 : #else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
; 3911 : template <class _Ty>
; 3912 : concept _Pair_like = !is_reference_v<_Ty> && requires(_Ty __t) {
; 3913 :     typename tuple_size<_Ty>::type;
; 3914 :     requires derived_from<tuple_size<_Ty>, integral_constant<size_t, 2>>;
; 3915 :     typename tuple_element_t<0, remove_const_t<_Ty>>;
; 3916 :     typename tuple_element_t<1, remove_const_t<_Ty>>;
; 3917 :     { _STD get<0>(__t) } -> convertible_to<const tuple_element_t<0, _Ty>&>;
; 3918 :     { _STD get<1>(__t) } -> convertible_to<const tuple_element_t<1, _Ty>&>;
; 3919 : };
; 3920 : #endif // ^^^ !_HAS_CXX23 ^^^
; 3921 : 
; 3922 : namespace ranges {
; 3923 :     template <class _From, class _To>
; 3924 :     concept _Uses_nonqualification_pointer_conversion =
; 3925 :         is_pointer_v<_From> && is_pointer_v<_To>
; 3926 :         && !convertible_to<remove_pointer_t<_From> (*)[], remove_pointer_t<_To> (*)[]>;
; 3927 : 
; 3928 :     template <class _From, class _To>
; 3929 :     concept _Convertible_to_non_slicing =
; 3930 :         convertible_to<_From, _To> && !_Uses_nonqualification_pointer_conversion<decay_t<_From>, decay_t<_To>>;
; 3931 : 
; 3932 :     template <class _Ty, class _First, class _Second>
; 3933 :     concept _Pair_like_convertible_from = !range<_Ty>
; 3934 : #if _HAS_CXX23
; 3935 :                                        && !is_reference_v<_Ty>
; 3936 : #endif // _HAS_CXX23
; 3937 :                                        && _Pair_like<_Ty> && constructible_from<_Ty, _First, _Second>
; 3938 :                                        && _Convertible_to_non_slicing<_First, tuple_element_t<0, _Ty>>
; 3939 :                                        && convertible_to<_Second, tuple_element_t<1, _Ty>>;
; 3940 : 
; 3941 :     template <class _It, class _Se, subrange_kind _Ki>
; 3942 :     concept _Store_size = (_Ki == subrange_kind::sized) && !sized_sentinel_for<_Se, _It>;
; 3943 : 
; 3944 :     template <class _It, class _Se, subrange_kind _Ki>
; 3945 :     class _Subrange_base : public view_interface<subrange<_It, _Se, _Ki>> {
; 3946 :     protected:
; 3947 :         using _Size_type = _Make_unsigned_like_t<iter_difference_t<_It>>;
; 3948 : 
; 3949 :     public:
; 3950 :         _Subrange_base() = default;
; 3951 :         constexpr explicit _Subrange_base(const _Size_type&) noexcept {}
; 3952 :     };
; 3953 : 
; 3954 :     template <class _It, class _Se, subrange_kind _Ki>
; 3955 :         requires _Store_size<_It, _Se, _Ki>
; 3956 :     class _Subrange_base<_It, _Se, _Ki> : public view_interface<subrange<_It, _Se, _Ki>> {
; 3957 :     protected:
; 3958 :         using _Size_type = _Make_unsigned_like_t<iter_difference_t<_It>>;
; 3959 : 
; 3960 :         _Size_type _Size = 0;
; 3961 : 
; 3962 :     public:
; 3963 :         _Subrange_base() = default;
; 3964 :         constexpr explicit _Subrange_base(const _Size_type& _Size_) noexcept : _Size(_Size_) {}
; 3965 :     };
; 3966 : 
; 3967 :     _EXPORT_STD template <input_or_output_iterator _It, sentinel_for<_It> _Se, subrange_kind _Ki>
; 3968 :         requires (_Ki == subrange_kind::sized || !sized_sentinel_for<_Se, _It>)
; 3969 :     class subrange : public _Subrange_base<_It, _Se, _Ki> {
; 3970 :     private:
; 3971 :         using _Size_type = _Make_unsigned_like_t<iter_difference_t<_It>>;
; 3972 : 
; 3973 :         // TRANSITION, [[no_unique_address]]:
; 3974 :         /* [[no_unique_address]] */ _It _First{};
; 3975 :         /* [[no_unique_address]] */ _Se _Last{};
; 3976 :         // [[no_unique_address]] conditional_t<_Store_size<_It, _Se, _Ki>, _Size_type, _Nil> _Size{};
; 3977 : 
; 3978 :         template <class _Rng>
; 3979 :         constexpr subrange(true_type, _Rng&& _Val)
; 3980 :             : subrange(_STD forward<_Rng>(_Val), static_cast<_Size_type>(_RANGES size(_Val))) {
; 3981 :             // delegation target for subrange(_Rng&&) when we must store the range size
; 3982 :             _STL_INTERNAL_STATIC_ASSERT(_Store_size<_It, _Se, _Ki>);
; 3983 :         }
; 3984 : 
; 3985 :         template <class _Rng>
; 3986 :         constexpr subrange(false_type, _Rng&& _Val) : subrange(_RANGES begin(_Val), _RANGES end(_Val)) {
; 3987 :             // delegation target for subrange(_Rng&&) when we need not store the range size
; 3988 :             _STL_INTERNAL_STATIC_ASSERT(!_Store_size<_It, _Se, _Ki>);
; 3989 :         }
; 3990 : 
; 3991 :     public:
; 3992 :         subrange()
; 3993 :             requires default_initializable<_It>
; 3994 :         = default;
; 3995 : 
; 3996 :         template <_Convertible_to_non_slicing<_It> _It2>
; 3997 :         constexpr subrange(_It2 _First_, _Se _Last_)
; 3998 :             requires (!_Store_size<_It, _Se, _Ki>)
; 3999 :             : _First(_STD move(_First_)), _Last(_STD move(_Last_)) {
; 4000 :             _STD _Adl_verify_range(_First, _Last);
; 4001 :         }
; 4002 : 
; 4003 :         template <_Convertible_to_non_slicing<_It> _It2>
; 4004 :         constexpr subrange(_It2 _First_, _Se _Last_, const _Size_type _Size_)
; 4005 :             requires (_Ki == subrange_kind::sized)
; 4006 :             : _Subrange_base<_It, _Se, _Ki>(_Size_), _First(_STD move(_First_)), _Last(_STD move(_Last_)) {
; 4007 :             _STD _Adl_verify_range(_First, _Last);
; 4008 :             if constexpr (sized_sentinel_for<_Se, _It>) {
; 4009 :                 _STL_ASSERT(_Size_ == static_cast<_Size_type>(_Last - _First),
; 4010 :                     "This constructor's third argument should be equal to the distance "
; 4011 :                     "between the first and second arguments (N4950 [range.subrange.ctor]/3).");
; 4012 :             }
; 4013 :         }
; 4014 : 
; 4015 :         template <_Different_from<subrange> _Rng>
; 4016 :             requires (borrowed_range<_Rng> && _Convertible_to_non_slicing<iterator_t<_Rng>, _It>
; 4017 :                       && convertible_to<sentinel_t<_Rng>, _Se>)
; 4018 :         constexpr subrange(_Rng&& _Val)
; 4019 :             requires (!_Store_size<_It, _Se, _Ki> || sized_range<_Rng>)
; 4020 :             : subrange{bool_constant<_Store_size<_It, _Se, _Ki>>{}, _STD forward<_Rng>(_Val)} {}
; 4021 : 
; 4022 :         template <borrowed_range _Rng>
; 4023 :             requires (_Convertible_to_non_slicing<iterator_t<_Rng>, _It> && convertible_to<sentinel_t<_Rng>, _Se>)
; 4024 :         constexpr subrange(_Rng&& _Val, const _Size_type _Count)
; 4025 :             requires (_Ki == subrange_kind::sized)
; 4026 :             : subrange{_RANGES begin(_Val), _RANGES end(_Val), _Count} {}
; 4027 : 
; 4028 :         template <_Different_from<subrange> _PairLike>
; 4029 :             requires _Pair_like_convertible_from<_PairLike, const _It&, const _Se&>
; 4030 :         constexpr operator _PairLike() const {
; 4031 :             return _PairLike(_First, _Last);
; 4032 :         }
; 4033 : 
; 4034 :         _NODISCARD constexpr _It begin() const
; 4035 :             requires copyable<_It>
; 4036 :         {
; 4037 :             return _First;
; 4038 :         }
; 4039 :         _NODISCARD constexpr _It begin()
; 4040 :             requires (!copyable<_It>)
; 4041 :         {
; 4042 :             return _STD move(_First);
; 4043 :         }
; 4044 : 
; 4045 :         _NODISCARD constexpr _Se end() const {
; 4046 :             return _Last;
; 4047 :         }
; 4048 : 
; 4049 :         _NODISCARD constexpr bool empty() const {
; 4050 :             return _First == _Last;
; 4051 :         }
; 4052 : 
; 4053 :         _NODISCARD constexpr _Size_type size() const
; 4054 :             requires (_Ki == subrange_kind::sized)
; 4055 :         {
; 4056 :             if constexpr (_Store_size<_It, _Se, _Ki>) {
; 4057 :                 return this->_Size;
; 4058 :             } else {
; 4059 :                 return static_cast<_Size_type>(_Last - _First);
; 4060 :             }
; 4061 :         }
; 4062 : 
; 4063 :         _NODISCARD constexpr subrange next() const&
; 4064 :             requires forward_iterator<_It>
; 4065 :         {
; 4066 :             auto _Tmp = *this;
; 4067 :             if (_Tmp._First != _Tmp._Last) {
; 4068 :                 ++_Tmp._First;
; 4069 :                 if constexpr (_Store_size<_It, _Se, _Ki>) {
; 4070 :                     --_Tmp._Size;
; 4071 :                 }
; 4072 :             }
; 4073 :             return _Tmp;
; 4074 :         }
; 4075 :         _NODISCARD constexpr subrange next(const iter_difference_t<_It> _Count) const&
; 4076 :             requires forward_iterator<_It>
; 4077 :         {
; 4078 :             auto _Tmp = *this;
; 4079 :             _Tmp.advance(_Count);
; 4080 :             return _Tmp;
; 4081 :         }
; 4082 : 
; 4083 :         _NODISCARD constexpr subrange next() && {
; 4084 :             if (_First != _Last) {
; 4085 :                 ++_First;
; 4086 :                 if constexpr (_Store_size<_It, _Se, _Ki>) {
; 4087 :                     --this->_Size;
; 4088 :                 }
; 4089 :             }
; 4090 :             return _STD move(*this);
; 4091 :         }
; 4092 :         _NODISCARD constexpr subrange next(const iter_difference_t<_It> _Count) && {
; 4093 :             advance(_Count);
; 4094 :             return _STD move(*this);
; 4095 :         }
; 4096 : 
; 4097 :         _NODISCARD constexpr subrange prev() const
; 4098 :             requires bidirectional_iterator<_It>
; 4099 :         {
; 4100 :             auto _Tmp = *this;
; 4101 :             --_Tmp._First;
; 4102 :             if constexpr (_Store_size<_It, _Se, _Ki>) {
; 4103 :                 ++_Tmp._Size;
; 4104 :             }
; 4105 :             return _Tmp;
; 4106 :         }
; 4107 :         _NODISCARD constexpr subrange prev(const iter_difference_t<_It> _Count) const
; 4108 :             requires bidirectional_iterator<_It>
; 4109 :         {
; 4110 :             auto _Tmp = *this;
; 4111 :             _Tmp.advance(-_Count);
; 4112 :             return _Tmp;
; 4113 :         }
; 4114 : 
; 4115 :         constexpr subrange& advance(const iter_difference_t<_It> _Count) {
; 4116 :             if constexpr (bidirectional_iterator<_It>) {
; 4117 :                 if (_Count < 0) {
; 4118 :                     _RANGES advance(_First, _Count);
; 4119 :                     if constexpr (_Store_size<_It, _Se, _Ki>) {
; 4120 :                         this->_Size += static_cast<_Size_type>(-_Count);
; 4121 :                     }
; 4122 :                     return *this;
; 4123 :                 }
; 4124 :             }
; 4125 : 
; 4126 :             const auto _Remainder = _RANGES advance(_First, _Count, _Last);
; 4127 :             if constexpr (_Store_size<_It, _Se, _Ki>) {
; 4128 :                 this->_Size -= static_cast<_Size_type>(_Count - _Remainder);
; 4129 :             }
; 4130 :             return *this;
; 4131 :         }
; 4132 :     };
; 4133 : 
; 4134 :     template <input_or_output_iterator _It, sentinel_for<_It> _Se>
; 4135 :     subrange(_It, _Se) -> subrange<_It, _Se>;
; 4136 : 
; 4137 :     template <input_or_output_iterator _It, sentinel_for<_It> _Se>
; 4138 :     subrange(_It, _Se, _Make_unsigned_like_t<iter_difference_t<_It>>) -> subrange<_It, _Se, subrange_kind::sized>;
; 4139 : 
; 4140 :     template <borrowed_range _Rng>
; 4141 :     subrange(_Rng&&) -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>,
; 4142 :         (sized_range<_Rng> || sized_sentinel_for<sentinel_t<_Rng>, iterator_t<_Rng>>) ? subrange_kind::sized
; 4143 :                                                                                       : subrange_kind::unsized>;
; 4144 : 
; 4145 :     template <borrowed_range _Rng>
; 4146 :     subrange(_Rng&&, _Make_unsigned_like_t<range_difference_t<_Rng>>)
; 4147 :         -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>, subrange_kind::sized>;
; 4148 : 
; 4149 :     template <class _It, class _Se, subrange_kind _Ki>
; 4150 :     constexpr bool enable_borrowed_range<subrange<_It, _Se, _Ki>> = true;
; 4151 : 
; 4152 :     _EXPORT_STD template <size_t _Idx, class _It, class _Se, subrange_kind _Ki>
; 4153 :         requires ((_Idx == 0 && copyable<_It>) || _Idx == 1)
; 4154 :     _NODISCARD constexpr auto get(const subrange<_It, _Se, _Ki>& _Val) {
; 4155 :         if constexpr (_Idx == 0) {
; 4156 :             return _Val.begin();
; 4157 :         } else {
; 4158 :             return _Val.end();
; 4159 :         }
; 4160 :     }
; 4161 : 
; 4162 :     _EXPORT_STD template <size_t _Idx, class _It, class _Se, subrange_kind _Ki>
; 4163 :         requires (_Idx < 2)
; 4164 :     _NODISCARD constexpr auto get(subrange<_It, _Se, _Ki>&& _Val) {
; 4165 :         if constexpr (_Idx == 0) {
; 4166 :             return _Val.begin();
; 4167 :         } else {
; 4168 :             return _Val.end();
; 4169 :         }
; 4170 :     }
; 4171 : 
; 4172 :     _EXPORT_STD struct dangling {
; 4173 :         constexpr dangling() noexcept = default;
; 4174 :         template <class... _Args>
; 4175 :         constexpr dangling(_Args&&...) noexcept {}
; 4176 :     };
; 4177 : 
; 4178 :     _EXPORT_STD template <range _Rng>
; 4179 :     using borrowed_iterator_t = conditional_t<borrowed_range<_Rng>, iterator_t<_Rng>, dangling>;
; 4180 : 
; 4181 :     _EXPORT_STD template <range _Rng>
; 4182 :     using borrowed_subrange_t = conditional_t<borrowed_range<_Rng>, subrange<iterator_t<_Rng>>, dangling>;
; 4183 : } // namespace ranges
; 4184 : #endif // _HAS_CXX20
; 4185 : 
; 4186 : struct _Container_proxy;
; 4187 : struct _Iterator_base12;
; 4188 : 
; 4189 : struct _Default_sentinel {}; // empty struct to serve as the end of a range
; 4190 : 
; 4191 : #if _HAS_CXX20
; 4192 : _EXPORT_STD template <semiregular>
; 4193 : class move_sentinel;
; 4194 : 
; 4195 : template <class>
; 4196 : struct _Move_iterator_category {};
; 4197 : 
; 4198 : template <class _Iter>
; 4199 :     requires requires { typename _Iter_cat_t<_Iter>; }
; 4200 : struct _Move_iterator_category<_Iter> {
; 4201 :     using iterator_category = conditional_t<derived_from<_Iter_cat_t<_Iter>, random_access_iterator_tag>,
; 4202 :         random_access_iterator_tag, _Iter_cat_t<_Iter>>;
; 4203 : };
; 4204 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 4205 : template <class _Iter>
; 4206 : struct _Move_iterator_category {
; 4207 :     using iterator_category = _Iter_cat_t<_Iter>;
; 4208 : };
; 4209 : #endif // ^^^ !_HAS_CXX20 ^^^
; 4210 : 
; 4211 : _EXPORT_STD template <class _Iter>
; 4212 : class move_iterator : public _Move_iterator_category<_Iter> {
; 4213 : private:
; 4214 :     _Iter _Current{};
; 4215 : 
; 4216 : public:
; 4217 :     using iterator_type   = _Iter;
; 4218 :     using value_type      = _Iter_value_t<_Iter>;
; 4219 :     using difference_type = _Iter_diff_t<_Iter>;
; 4220 :     using pointer         = _Iter;
; 4221 : 
; 4222 : #if _HAS_CXX20
; 4223 : private:
; 4224 :     static constexpr auto _Get_iter_concept() {
; 4225 :         if constexpr (random_access_iterator<_Iter>) {
; 4226 :             return random_access_iterator_tag{};
; 4227 :         } else if constexpr (bidirectional_iterator<_Iter>) {
; 4228 :             return bidirectional_iterator_tag{};
; 4229 :         } else if constexpr (forward_iterator<_Iter>) {
; 4230 :             return forward_iterator_tag{};
; 4231 :         } else {
; 4232 :             return input_iterator_tag{};
; 4233 :         }
; 4234 :     }
; 4235 : 
; 4236 : public:
; 4237 :     using iterator_concept = decltype(_Get_iter_concept());
; 4238 : 
; 4239 :     using reference = iter_rvalue_reference_t<_Iter>;
; 4240 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 4241 :     using reference =
; 4242 :         conditional_t<is_reference_v<_Iter_ref_t<_Iter>>, remove_reference_t<_Iter_ref_t<_Iter>>&&, _Iter_ref_t<_Iter>>;
; 4243 : #endif // ^^^ !_HAS_CXX20 ^^^
; 4244 : 
; 4245 :     _CONSTEXPR17 move_iterator() = default;
; 4246 : 
; 4247 :     _CONSTEXPR17 explicit move_iterator(_Iter _Right) noexcept(is_nothrow_move_constructible_v<_Iter>) // strengthened
; 4248 :         : _Current(_STD move(_Right)) {}
; 4249 : 
; 4250 :     template <class _Other>
; 4251 : #if _HAS_CXX20
; 4252 :         requires (!is_same_v<_Other, _Iter>) && convertible_to<const _Other&, _Iter>
; 4253 : #endif // _HAS_CXX20
; 4254 :     _CONSTEXPR17 move_iterator(const move_iterator<_Other>& _Right)
; 4255 :         noexcept(is_nothrow_constructible_v<_Iter, const _Other&>) // strengthened
; 4256 :         : _Current(_Right.base()) {
; 4257 :     }
; 4258 : 
; 4259 :     template <class _Other>
; 4260 : #if _HAS_CXX20
; 4261 :         requires (!is_same_v<_Other, _Iter>)
; 4262 :               && convertible_to<const _Other&, _Iter> && assignable_from<_Iter&, const _Other&>
; 4263 : #endif // _HAS_CXX20
; 4264 :     _CONSTEXPR17 move_iterator& operator=(const move_iterator<_Other>& _Right)
; 4265 :         noexcept(is_nothrow_assignable_v<_Iter&, const _Other&>) /* strengthened */ {
; 4266 :         _Current = _Right.base();
; 4267 :         return *this;
; 4268 :     }
; 4269 : 
; 4270 : #if _HAS_CXX20
; 4271 :     _NODISCARD constexpr const iterator_type& base() const& noexcept {
; 4272 :         return _Current;
; 4273 :     }
; 4274 :     _NODISCARD constexpr iterator_type base() && noexcept(is_nothrow_move_constructible_v<_Iter>) /* strengthened */ {
; 4275 :         return _STD move(_Current);
; 4276 :     }
; 4277 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 4278 :     _NODISCARD _CONSTEXPR17 iterator_type base() const
; 4279 :         noexcept(is_nothrow_copy_constructible_v<_Iter>) /* strengthened */ {
; 4280 :         return _Current;
; 4281 :     }
; 4282 : #endif // ^^^ !_HAS_CXX20 ^^^
; 4283 : 
; 4284 :     _NODISCARD _CONSTEXPR17 reference operator*() const
; 4285 : #if _HAS_CXX20
; 4286 :         noexcept(noexcept(_RANGES iter_move(_Current))) /* strengthened */ {
; 4287 :         return _RANGES iter_move(_Current);
; 4288 :     }
; 4289 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 4290 :         noexcept(noexcept(static_cast<reference>(*_Current))) /* strengthened */ {
; 4291 :         return static_cast<reference>(*_Current);
; 4292 :     }
; 4293 : #endif // ^^^ !_HAS_CXX20 ^^^
; 4294 : 
; 4295 :     _CXX20_DEPRECATE_MOVE_ITERATOR_ARROW _NODISCARD _CONSTEXPR17 pointer operator->() const
; 4296 :         noexcept(is_nothrow_copy_constructible_v<_Iter>) /* strengthened */ {
; 4297 :         return _Current;
; 4298 :     }
; 4299 : 
; 4300 :     _CONSTEXPR17 move_iterator& operator++() noexcept(noexcept(++_Current)) /* strengthened */ {
; 4301 :         ++_Current;
; 4302 :         return *this;
; 4303 :     }
; 4304 : 
; 4305 :     _CONSTEXPR17 auto operator++(int) noexcept(is_nothrow_copy_constructible_v<_Iter> //
; 4306 :                                                && noexcept(++_Current)) /* strengthened */ {
; 4307 : #if _HAS_CXX20
; 4308 :         if constexpr (forward_iterator<_Iter>) {
; 4309 : #endif // _HAS_CXX20
; 4310 :             move_iterator _Tmp = *this;
; 4311 :             ++_Current;
; 4312 :             return _Tmp;
; 4313 : #if _HAS_CXX20
; 4314 :         } else {
; 4315 :             ++_Current;
; 4316 :         }
; 4317 : #endif // _HAS_CXX20
; 4318 :     }
; 4319 : 
; 4320 :     _CONSTEXPR17 move_iterator& operator--() noexcept(noexcept(--_Current)) /* strengthened */ {
; 4321 :         --_Current;
; 4322 :         return *this;
; 4323 :     }
; 4324 : 
; 4325 :     _CONSTEXPR17 move_iterator operator--(int) noexcept(is_nothrow_copy_constructible_v<_Iter> //
; 4326 :                                                         && noexcept(--_Current)) /* strengthened */ {
; 4327 :         move_iterator _Tmp = *this;
; 4328 :         --_Current;
; 4329 :         return _Tmp;
; 4330 :     }
; 4331 : 
; 4332 :     template <class _Iter2 = _Iter>
; 4333 :     _NODISCARD auto operator==(_Default_sentinel _Sentinel) const noexcept //
; 4334 :         -> decltype(_STD declval<const _Iter2&>() == _Sentinel) {
; 4335 :         return _Current == _Sentinel;
; 4336 :     }
; 4337 : 
; 4338 :     template <class _Iter2 = _Iter>
; 4339 :     _NODISCARD auto operator!=(_Default_sentinel _Sentinel) const noexcept //
; 4340 :         -> decltype(_STD declval<const _Iter2&>() != _Sentinel) {
; 4341 :         return _Current != _Sentinel;
; 4342 :     }
; 4343 : 
; 4344 :     _NODISCARD _CONSTEXPR17 move_iterator operator+(const difference_type _Off) const
; 4345 :         noexcept(noexcept(move_iterator(_Current + _Off))) /* strengthened */ {
; 4346 :         return move_iterator(_Current + _Off);
; 4347 :     }
; 4348 : 
; 4349 :     _CONSTEXPR17 move_iterator& operator+=(const difference_type _Off)
; 4350 :         noexcept(noexcept(_Current += _Off)) /* strengthened */ {
; 4351 :         _Current += _Off;
; 4352 :         return *this;
; 4353 :     }
; 4354 : 
; 4355 :     _NODISCARD _CONSTEXPR17 move_iterator operator-(const difference_type _Off) const
; 4356 :         noexcept(noexcept(move_iterator(_Current - _Off))) /* strengthened */ {
; 4357 :         return move_iterator(_Current - _Off);
; 4358 :     }
; 4359 : 
; 4360 :     _CONSTEXPR17 move_iterator& operator-=(const difference_type _Off)
; 4361 :         noexcept(noexcept(_Current -= _Off)) /* strengthened */ {
; 4362 :         _Current -= _Off;
; 4363 :         return *this;
; 4364 :     }
; 4365 : 
; 4366 :     _NODISCARD _CONSTEXPR17 reference operator[](const difference_type _Off) const
; 4367 : #if _HAS_CXX20
; 4368 :         noexcept(noexcept(_RANGES iter_move(_Current + _Off))) /* strengthened */ {
; 4369 :         return _RANGES iter_move(_Current + _Off);
; 4370 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 4371 :         noexcept(noexcept(_STD move(_Current[_Off]))) /* strengthened */ {
; 4372 :         return _STD move(_Current[_Off]);
; 4373 : #endif // ^^^ !_HAS_CXX20 ^^^
; 4374 :     }
; 4375 : 
; 4376 : #if _HAS_CXX20
; 4377 :     template <sentinel_for<_Iter> _Sent>
; 4378 :     _NODISCARD friend constexpr bool operator==(const move_iterator& _Left, const move_sentinel<_Sent>& _Right)
; 4379 :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left._Current == _Right._Get_last()))) /* strengthened */ {
; 4380 :         return _Left._Current == _Right._Get_last();
; 4381 :     }
; 4382 : 
; 4383 :     template <sized_sentinel_for<_Iter> _Sent>
; 4384 :     _NODISCARD friend constexpr difference_type operator-(const move_sentinel<_Sent>& _Left,
; 4385 :         const move_iterator& _Right) noexcept(noexcept(_Left._Get_last() - _Right._Current)) /* strengthened */ {
; 4386 :         return _Left._Get_last() - _Right._Current;
; 4387 :     }
; 4388 : 
; 4389 :     template <sized_sentinel_for<_Iter> _Sent>
; 4390 :     _NODISCARD friend constexpr difference_type operator-(const move_iterator& _Left,
; 4391 :         const move_sentinel<_Sent>& _Right) noexcept(noexcept(_Left._Current - _Right._Get_last())) /* strengthened */ {
; 4392 :         return _Left._Current - _Right._Get_last();
; 4393 :     }
; 4394 : 
; 4395 :     _NODISCARD friend constexpr reference iter_move(const move_iterator& _It)
; 4396 :         noexcept(noexcept(_RANGES iter_move(_It._Current))) {
; 4397 :         return _RANGES iter_move(_It._Current);
; 4398 :     }
; 4399 : 
; 4400 :     template <indirectly_swappable<_Iter> _Iter2>
; 4401 :     friend constexpr void iter_swap(const move_iterator& _Left, const move_iterator<_Iter2>& _Right)
; 4402 :         noexcept(noexcept(_RANGES iter_swap(_Left._Current, _Right.base()))) {
; 4403 :         _RANGES iter_swap(_Left._Current, _Right.base());
; 4404 :     }
; 4405 : #endif // _HAS_CXX20
; 4406 : 
; 4407 :     template <class _Iter2, enable_if_t<_Range_verifiable_v<_Iter, _Iter2>, int> = 0>
; 4408 :     friend constexpr void _Verify_range(const move_iterator& _First, const move_iterator<_Iter2>& _Last) noexcept {
; 4409 :         _Verify_range(_First._Current, _Last._Get_current());
; 4410 :     }
; 4411 : #if _HAS_CXX20
; 4412 :     template <sentinel_for<_Iter> _Sent>
; 4413 :         requires _Range_verifiable_v<_Iter, _Sent>
; 4414 :     friend constexpr void _Verify_range(const move_iterator& _First, const move_sentinel<_Sent>& _Last) noexcept {
; 4415 :         _Verify_range(_First._Current, _Last._Get_last());
; 4416 :     }
; 4417 : #endif // _HAS_CXX20
; 4418 : 
; 4419 :     using _Prevent_inheriting_unwrap = move_iterator;
; 4420 : 
; 4421 :     template <class _Iter2 = iterator_type, enable_if_t<_Offset_verifiable_v<_Iter2>, int> = 0>
; 4422 :     constexpr void _Verify_offset(const difference_type _Off) const noexcept {
; 4423 :         _Current._Verify_offset(_Off);
; 4424 :     }
; 4425 : 
; 4426 :     template <class _Iter2 = iterator_type, enable_if_t<_Unwrappable_v<const _Iter2&>, int> = 0>
; 4427 :     _NODISCARD constexpr move_iterator<_Unwrapped_t<const _Iter2&>> _Unwrapped() const& noexcept(
; 4428 :         noexcept(static_cast<move_iterator<_Unwrapped_t<const _Iter2&>>>(_Current._Unwrapped()))) {
; 4429 :         return static_cast<move_iterator<_Unwrapped_t<const _Iter2&>>>(_Current._Unwrapped());
; 4430 :     }
; 4431 :     template <class _Iter2 = iterator_type, enable_if_t<_Unwrappable_v<_Iter2>, int> = 0>
; 4432 :     _NODISCARD constexpr move_iterator<_Unwrapped_t<_Iter2>> _Unwrapped() && noexcept(
; 4433 :         noexcept(static_cast<move_iterator<_Unwrapped_t<_Iter2>>>(_STD move(_Current)._Unwrapped()))) {
; 4434 :         return static_cast<move_iterator<_Unwrapped_t<_Iter2>>>(_STD move(_Current)._Unwrapped());
; 4435 :     }
; 4436 : 
; 4437 :     static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<iterator_type>;
; 4438 : 
; 4439 :     template <class _Src, enable_if_t<_Wrapped_seekable_v<iterator_type, const _Src&>, int> = 0>
; 4440 :     constexpr void _Seek_to(const move_iterator<_Src>& _It) noexcept(noexcept(_Current._Seek_to(_It._Get_current()))) {
; 4441 :         _Current._Seek_to(_It._Get_current());
; 4442 :     }
; 4443 :     template <class _Src, enable_if_t<_Wrapped_seekable_v<iterator_type, _Src>, int> = 0>
; 4444 :     constexpr void _Seek_to(move_iterator<_Src>&& _It)
; 4445 :         noexcept(noexcept(_Current._Seek_to(_STD move(_It)._Get_current()))) {
; 4446 :         _Current._Seek_to(_STD move(_It)._Get_current());
; 4447 :     }
; 4448 : 
; 4449 :     _NODISCARD constexpr const iterator_type& _Get_current() const& noexcept {
; 4450 :         return _Current;
; 4451 :     }
; 4452 :     _NODISCARD constexpr iterator_type&& _Get_current() && noexcept {
; 4453 :         return _STD move(_Current);
; 4454 :     }
; 4455 : };
; 4456 : 
; 4457 : _EXPORT_STD template <class _Iter1, class _Iter2>
; 4458 : _NODISCARD _CONSTEXPR17 bool operator==(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)
; 4459 :     noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left.base() == _Right.base()))) /* strengthened */
; 4460 : #if _HAS_CXX20
; 4461 :     requires requires {
; 4462 :         { _Left.base() == _Right.base() } -> _Implicitly_convertible_to<bool>;
; 4463 :     }
; 4464 : #endif // _HAS_CXX20
; 4465 : {
; 4466 :     return _Left.base() == _Right.base();
; 4467 : }
; 4468 : 
; 4469 : #if !_HAS_CXX20
; 4470 : template <class _Iter1, class _Iter2>
; 4471 : _NODISCARD _CONSTEXPR17 bool operator!=(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)
; 4472 :     noexcept(noexcept(_Left == _Right)) /* strengthened */ {
; 4473 :     return !(_Left == _Right);
; 4474 : }
; 4475 : #endif // !_HAS_CXX20
; 4476 : 
; 4477 : _EXPORT_STD template <class _Iter1, class _Iter2>
; 4478 : _NODISCARD _CONSTEXPR17 bool operator<(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)
; 4479 :     noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left.base() < _Right.base()))) /* strengthened */
; 4480 : #if _HAS_CXX20
; 4481 :     requires requires {
; 4482 :         { _Left.base() < _Right.base() } -> _Implicitly_convertible_to<bool>;
; 4483 :     }
; 4484 : #endif // _HAS_CXX20
; 4485 : {
; 4486 :     return _Left.base() < _Right.base();
; 4487 : }
; 4488 : 
; 4489 : _EXPORT_STD template <class _Iter1, class _Iter2>
; 4490 : _NODISCARD _CONSTEXPR17 bool operator>(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)
; 4491 :     noexcept(noexcept(_Right < _Left)) /* strengthened */
; 4492 : #if _HAS_CXX20
; 4493 :     requires requires { _Right < _Left; }
; 4494 : #endif // _HAS_CXX20
; 4495 : {
; 4496 :     return _Right < _Left;
; 4497 : }
; 4498 : 
; 4499 : _EXPORT_STD template <class _Iter1, class _Iter2>
; 4500 : _NODISCARD _CONSTEXPR17 bool operator<=(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)
; 4501 :     noexcept(noexcept(_Right < _Left)) /* strengthened */
; 4502 : #if _HAS_CXX20
; 4503 :     requires requires { _Right < _Left; }
; 4504 : #endif // _HAS_CXX20
; 4505 : {
; 4506 :     return !(_Right < _Left);
; 4507 : }
; 4508 : 
; 4509 : _EXPORT_STD template <class _Iter1, class _Iter2>
; 4510 : _NODISCARD _CONSTEXPR17 bool operator>=(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)
; 4511 :     noexcept(noexcept(_Left < _Right)) /* strengthened */
; 4512 : #if _HAS_CXX20
; 4513 :     requires requires { _Left < _Right; }
; 4514 : #endif // _HAS_CXX20
; 4515 : {
; 4516 :     return !(_Left < _Right);
; 4517 : }
; 4518 : 
; 4519 : #if _HAS_CXX20
; 4520 : _EXPORT_STD template <class _Iter1, three_way_comparable_with<_Iter1> _Iter2>
; 4521 : _NODISCARD constexpr compare_three_way_result_t<_Iter1, _Iter2> operator<=>(const move_iterator<_Iter1>& _Left,
; 4522 :     const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Left.base() <=> _Right.base())) /* strengthened */ {
; 4523 :     return _Left.base() <=> _Right.base();
; 4524 : }
; 4525 : #endif // _HAS_CXX20
; 4526 : 
; 4527 : _EXPORT_STD template <class _Iter1, class _Iter2>
; 4528 : _NODISCARD _CONSTEXPR17 auto operator-(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)
; 4529 :     noexcept(noexcept(_Left.base() - _Right.base())) /* strengthened */
; 4530 :     -> decltype(_Left.base() - _Right.base()) {
; 4531 :     return _Left.base() - _Right.base();
; 4532 : }
; 4533 : 
; 4534 : _EXPORT_STD template <class _Iter>
; 4535 : _NODISCARD _CONSTEXPR17 move_iterator<_Iter> operator+(
; 4536 :     typename move_iterator<_Iter>::difference_type _Off, const move_iterator<_Iter>& _Right)
; 4537 :     noexcept(noexcept(move_iterator<_Iter>(_Right.base() + _Off))) /* strengthened */
; 4538 : #if _HAS_CXX20
; 4539 :     requires requires {
; 4540 :         { _Right.base() + _Off } -> same_as<_Iter>;
; 4541 :     }
; 4542 : #endif // _HAS_CXX20
; 4543 : {
; 4544 :     return move_iterator<_Iter>(_Right.base() + _Off);
; 4545 : }
; 4546 : 
; 4547 : _EXPORT_STD template <class _Iter>
; 4548 : _NODISCARD _CONSTEXPR17 move_iterator<_Iter> make_move_iterator(_Iter _It)
; 4549 :     noexcept(is_nothrow_move_constructible_v<_Iter>) /* strengthened */ {
; 4550 :     return move_iterator<_Iter>(_STD move(_It));
; 4551 : }
; 4552 : 
; 4553 : #if _HAS_CXX20
; 4554 : template <class _Iter1, class _Iter2>
; 4555 :     requires (!sized_sentinel_for<_Iter1, _Iter2>)
; 4556 : constexpr bool disable_sized_sentinel_for<move_iterator<_Iter1>, move_iterator<_Iter2>> = true;
; 4557 : 
; 4558 : _EXPORT_STD struct unreachable_sentinel_t {
; 4559 :     template <weakly_incrementable _Ty>
; 4560 :     _NODISCARD constexpr bool operator==(const _Ty&) const noexcept {
; 4561 :         return false;
; 4562 :     }
; 4563 : };
; 4564 : 
; 4565 : _EXPORT_STD inline constexpr unreachable_sentinel_t unreachable_sentinel{};
; 4566 : 
; 4567 : namespace ranges {
; 4568 :     struct _Distance_unbounded {
; 4569 :         _NODISCARD constexpr _Distance_unbounded operator-() const noexcept {
; 4570 :             return {};
; 4571 :         }
; 4572 :     };
; 4573 : 
; 4574 :     template <class _Checked, class _Iter, class _Sent>
; 4575 :     _NODISCARD constexpr auto _Idl_distance(const _Iter& _First, const _Sent& _Last) {
; 4576 :         // Returns the distance between _First and _Last,
; 4577 :         // an indicator that the distance is infinite, or
; 4578 :         // an indicator that the distance cannot be determined in O(1).
; 4579 :         _STL_INTERNAL_STATIC_ASSERT(same_as<_Unwrapped_t<_Checked>, _Iter>);
; 4580 : 
; 4581 :         if constexpr (sized_sentinel_for<_Sent, _Iter>) {
; 4582 :             return static_cast<iter_difference_t<_Checked>>(_Last - _First);
; 4583 :         } else if constexpr (same_as<_Sent, unreachable_sentinel_t>) {
; 4584 :             return _Distance_unbounded{};
; 4585 :         } else {
; 4586 :             return _Distance_unknown{};
; 4587 :         }
; 4588 :     }
; 4589 : 
; 4590 :     template <range _Rng>
; 4591 :     _NODISCARD constexpr auto _Idl_distance(_Rng& _Range) {
; 4592 :         // Returns the length of _Range if it is finite and can be determined in O(1), or
; 4593 :         // an indicator that the length is infinite, or
; 4594 :         // an indicator that the length cannot be determined in O(1).
; 4595 :         if constexpr (sized_range<_Rng>) {
; 4596 :             return _RANGES distance(_Range);
; 4597 :         } else if constexpr (same_as<sentinel_t<_Rng>, unreachable_sentinel_t>) {
; 4598 :             return _Distance_unbounded{};
; 4599 :         } else {
; 4600 :             return _Distance_unknown{};
; 4601 :         }
; 4602 :     }
; 4603 : } // namespace ranges
; 4604 : #endif // _HAS_CXX20
; 4605 : 
; 4606 : // _Iterator_is_contiguous<_Iter> reports whether an iterator is known to be contiguous.
; 4607 : // (Without concepts, this detection is limited, which will limit when we can activate optimizations.)
; 4608 : 
; 4609 : #if _HAS_CXX20
; 4610 : // When concepts are available, we can detect arbitrary contiguous iterators.
; 4611 : template <class _Iter>
; 4612 : constexpr bool _Iterator_is_contiguous = contiguous_iterator<_Iter>;
; 4613 : 
; 4614 : template <class _Iter>
; 4615 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {
; 4616 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4617 :     return _STD to_address(_Val);
; 4618 : }
; 4619 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 4620 : // When concepts aren't available, we can detect pointers. (Iterators should be unwrapped before using this.)
; 4621 : template <class _Iter>
; 4622 : constexpr bool _Iterator_is_contiguous = is_pointer_v<_Iter>;
; 4623 : 
; 4624 : template <class _Iter>
; 4625 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {
; 4626 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4627 :     return _Val;
; 4628 : }
; 4629 : #endif // ^^^ !_HAS_CXX20 ^^^
; 4630 : 
; 4631 : template <class _Iter>
; 4632 : _NODISCARD constexpr auto _To_address(const move_iterator<_Iter>& _Val) noexcept {
; 4633 :     return _To_address(_Val.base());
; 4634 : }
; 4635 : 
; 4636 : // _Iterators_are_contiguous<_Iter1, _Iter2> reports whether both iterators are known to be contiguous.
; 4637 : 
; 4638 : template <class _Iter1, class _Iter2>
; 4639 : constexpr bool _Iterators_are_contiguous = _Iterator_is_contiguous<_Iter1> && _Iterator_is_contiguous<_Iter2>;
; 4640 : 
; 4641 : template <class _Iter>
; 4642 : constexpr bool _Iterator_is_volatile = is_volatile_v<remove_reference_t<_Iter_ref_t<_Iter>>>;
; 4643 : 
; 4644 : template <class _Source, class _Dest>
; 4645 : constexpr bool _Is_pointer_address_convertible = is_void_v<_Source>
; 4646 :                                               || is_void_v<_Dest>
; 4647 :                                               // NOTE: is_same_v is required for function pointers to work
; 4648 :                                               || is_same_v<remove_cv_t<_Source>, remove_cv_t<_Dest>>
; 4649 : #ifdef __cpp_lib_is_pointer_interconvertible
; 4650 :                                               || is_pointer_interconvertible_base_of_v<_Dest, _Source>
; 4651 : #endif // defined(__cpp_lib_is_pointer_interconvertible)
; 4652 :     ;
; 4653 : 
; 4654 : template <class _Source, class _Dest, class _SourceRef, class _DestRef>
; 4655 : struct _Trivial_cat {
; 4656 :     using _USource = _Unwrap_enum_t<_Source>;
; 4657 :     using _UDest   = _Unwrap_enum_t<_Dest>;
; 4658 : 
; 4659 :     static constexpr bool _Same_size_and_compatible =
; 4660 :         sizeof(_Source) == sizeof(_Dest)
; 4661 :         // If _UDest is bool, _USource also needs to be bool
; 4662 :         // Conversion from non-bool => non-bool | bool => bool | bool => non-bool is fine.
; 4663 :         // Conversion from non-bool => bool is not fine.
; 4664 :         && is_same_v<bool, _USource> >= is_same_v<bool, _UDest>
; 4665 :         && (is_same_v<_USource, _UDest> || (is_integral_v<_USource> && is_integral_v<_UDest>)
; 4666 :             || (is_floating_point_v<_USource> && is_floating_point_v<_UDest>) );
; 4667 : 
; 4668 :     static constexpr bool _Bitcopy_constructible =
; 4669 :         _Same_size_and_compatible && is_trivially_constructible_v<_Dest, _SourceRef>;
; 4670 : 
; 4671 :     static constexpr bool _Bitcopy_assignable =
; 4672 :         _Same_size_and_compatible && is_trivially_assignable_v<_DestRef, _SourceRef>;
; 4673 : };
; 4674 : 
; 4675 : template <class _Source, class _Dest, class _SourceRef, class _DestRef>
; 4676 : struct _Trivial_cat<_Source*, _Dest*, _SourceRef, _DestRef> {
; 4677 :     static constexpr bool _Bitcopy_constructible =
; 4678 :         _Is_pointer_address_convertible<_Source, _Dest> && is_trivially_constructible_v<_Dest*, _SourceRef>;
; 4679 : 
; 4680 :     static constexpr bool _Bitcopy_assignable =
; 4681 :         _Is_pointer_address_convertible<_Source, _Dest> && is_trivially_assignable_v<_DestRef, _SourceRef>;
; 4682 : };
; 4683 : 
; 4684 : struct _False_trivial_cat {
; 4685 :     static constexpr bool _Bitcopy_constructible = false;
; 4686 :     static constexpr bool _Bitcopy_assignable    = false;
; 4687 : };
; 4688 : 
; 4689 : template <class _SourceIt, class _DestIt,
; 4690 :     bool _Are_contiguous = _Iterators_are_contiguous<_SourceIt, _DestIt> && !_Iterator_is_volatile<_SourceIt>
; 4691 :                         && !_Iterator_is_volatile<_DestIt>>
; 4692 : struct _Iter_move_cat : _Trivial_cat<_Iter_value_t<_SourceIt>, _Iter_value_t<_DestIt>,
; 4693 :                             remove_reference_t<_Iter_ref_t<_SourceIt>>&&, _Iter_ref_t<_DestIt>> {};
; 4694 : 
; 4695 : template <class _SourceIt, class _DestIt>
; 4696 : struct _Iter_move_cat<_SourceIt, _DestIt, false> : _False_trivial_cat {};
; 4697 : 
; 4698 : template <class _SourceIt, class _DestIt>
; 4699 : struct _Iter_move_cat<move_iterator<_SourceIt>, _DestIt, false> : _Iter_move_cat<_SourceIt, _DestIt> {};
; 4700 : 
; 4701 : template <class _SourceIt, class _DestIt,
; 4702 :     bool _Are_contiguous = _Iterators_are_contiguous<_SourceIt, _DestIt> && !_Iterator_is_volatile<_SourceIt>
; 4703 :                         && !_Iterator_is_volatile<_DestIt>>
; 4704 : struct _Iter_copy_cat
; 4705 :     : _Trivial_cat<_Iter_value_t<_SourceIt>, _Iter_value_t<_DestIt>, _Iter_ref_t<_SourceIt>, _Iter_ref_t<_DestIt>> {};
; 4706 : 
; 4707 : template <class _SourceIt, class _DestIt>
; 4708 : struct _Iter_copy_cat<_SourceIt, _DestIt, false> : _False_trivial_cat {};
; 4709 : 
; 4710 : template <class _SourceIt, class _DestIt>
; 4711 : struct _Iter_copy_cat<move_iterator<_SourceIt>, _DestIt, false> : _Iter_move_cat<_SourceIt, _DestIt> {};
; 4712 : 
; 4713 : template <class _Iter1, class _Sent1, class _Iter2>
; 4714 : _CONSTEXPR20 void _Verify_ranges_do_not_overlap(const _Iter1& _First1, const _Sent1& _Last1, const _Iter2& _First2) {
; 4715 : #if _ITERATOR_DEBUG_LEVEL == 2
; 4716 :     if constexpr (_Iterators_are_contiguous<_Iter1, _Iter2>
; 4717 : #if _HAS_CXX20
; 4718 :                   && sized_sentinel_for<_Sent1, _Iter1>
; 4719 : #endif // _HAS_CXX20
; 4720 :     ) {
; 4721 : #if _HAS_CXX20
; 4722 :         if (_STD is_constant_evaluated()) {
; 4723 :             return;
; 4724 :         }
; 4725 : #endif // _HAS_CXX20
; 4726 : 
; 4727 :         const auto _Offset     = _Last1 - _First1;
; 4728 :         const auto _Ptr1Offset = _Offset * sizeof(*_STD _To_address(_First1));
; 4729 :         const auto _Ptr2Offset = _Offset * sizeof(*_STD _To_address(_First2));
; 4730 :         // This cast to `cv char*` allows us to compare pointers to distinct types,
; 4731 :         // in case one range provides storage for the other.
; 4732 :         const auto _PtrFirst1 = reinterpret_cast<const volatile char*>(_STD _To_address(_First1));
; 4733 :         const auto _PtrLast1  = _PtrFirst1 + _Ptr1Offset;
; 4734 :         const auto _PtrFirst2 = reinterpret_cast<const volatile char*>(_STD _To_address(_First2));
; 4735 :         const auto _PtrLast2  = _PtrFirst2 + _Ptr2Offset;
; 4736 :         _STL_VERIFY(_PtrLast1 <= _PtrFirst2 || _PtrLast2 <= _PtrFirst1, "ranges should not overlap each other");
; 4737 :     }
; 4738 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 4739 :     (void) _First1;
; 4740 :     (void) _Last1;
; 4741 :     (void) _First2;
; 4742 : #endif // _ITERATOR_DEBUG_LEVEL != 2 ^^^
; 4743 : }
; 4744 : 
; 4745 : template <class _OutCtgIt>
; 4746 : _OutCtgIt _Copy_memmove_tail(
; 4747 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {
; 4748 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4749 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4750 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4751 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);
; 4752 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4753 :         (void) _Object_count;
; 4754 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4755 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);
; 4756 :     } else {
; 4757 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4758 :     }
; 4759 : }
; 4760 : 
; 4761 : template <class _CtgIt, class _OutCtgIt>
; 4762 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {
; 4763 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4764 :     const auto _First_ptr    = _STD _To_address(_First);
; 4765 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4766 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);
; 4767 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4768 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4769 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);
; 4770 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);
; 4771 : }
; 4772 : 
; 4773 : template <class _CtgIt, class _OutCtgIt>
; 4774 : _OutCtgIt _Copy_memmove_n(_CtgIt _First, const size_t _Object_count, _OutCtgIt _Dest) {
; 4775 :     const auto _First_ptr  = _STD _To_address(_First);
; 4776 :     const auto _First_ch   = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4777 :     const auto _Byte_count = _Object_count * sizeof(*_First_ptr);
; 4778 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);
; 4779 : }
; 4780 : 
; 4781 : template <class _It, bool _RequiresMutable = false>
; 4782 : constexpr bool _Is_vb_iterator = false;
; 4783 : 
; 4784 : template <class _VbIt, class _OutIt>
; 4785 : _CONSTEXPR20 _OutIt _Copy_vbool(_VbIt _First, _VbIt _Last, _OutIt _Dest);
; 4786 : 
; 4787 : template <class _VbIt>
; 4788 : _NODISCARD _CONSTEXPR20 _Iter_diff_t<_VbIt> _Count_vbool(_VbIt _First, _VbIt _Last, bool _Val) noexcept;
; 4789 : 
; 4790 : template <class _VbIt>
; 4791 : _CONSTEXPR20 void _Fill_vbool(_VbIt _First, _VbIt _Last, bool _Val) noexcept;
; 4792 : 
; 4793 : template <class _VbIt>
; 4794 : _NODISCARD _CONSTEXPR20 _VbIt _Find_vbool(_VbIt _First, _VbIt _Last, bool _Val) noexcept;
; 4795 : 
; 4796 : template <class _InIt, class _SizeTy, class _OutIt>
; 4797 : _CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {
; 4798 :     // copy _First + [0, _Count) to _Dest + [0, _Count), returning _Dest + _Count
; 4799 :     // note: has callers outside the copy family
; 4800 :     _STL_INTERNAL_STATIC_ASSERT(_Integer_like<_SizeTy>);
; 4801 :     _STL_INTERNAL_CHECK(_Count >= 0);
; 4802 : 
; 4803 :     if constexpr (_Iter_copy_cat<_InIt, _OutIt>::_Bitcopy_assignable) {
; 4804 : #if _HAS_CXX20
; 4805 :         if (!_STD is_constant_evaluated())
; 4806 : #endif // _HAS_CXX20
; 4807 :         {
; 4808 :             return _Copy_memmove_n(_First, static_cast<size_t>(_Count), _Dest);
; 4809 :         }
; 4810 :     }
; 4811 : 
; 4812 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {
; 4813 :         *_Dest = *_First;
; 4814 :     }
; 4815 : 
; 4816 :     return _Dest;
; 4817 : }
; 4818 : 
; 4819 : template <class _InIt, class _Sent, class _OutIt>
; 4820 : using _Sent_copy_cat = conditional_t<
; 4821 : #if _HAS_CXX20
; 4822 :     is_same_v<_Sent, _InIt> || sized_sentinel_for<_Sent, _InIt>,
; 4823 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 4824 :     is_same_v<_Sent, _InIt>,
; 4825 : #endif // ^^^ !_HAS_CXX20 ^^^
; 4826 :     _Iter_copy_cat<_InIt, _OutIt>, _False_trivial_cat>;
; 4827 : 
; 4828 : template <class _InIt, class _Sent, class _OutIt>
; 4829 : _CONSTEXPR20 _OutIt _Copy_unchecked(_InIt _First, _Sent _Last, _OutIt _Dest) {
; 4830 :     // copy [_First, _Last) to [_Dest, ...)
; 4831 :     // note: _Copy_unchecked has callers other than the copy family
; 4832 :     if constexpr (_Is_vb_iterator<_InIt> && _Is_vb_iterator<_OutIt, true>) {
; 4833 :         return _STD _Copy_vbool(_First, _Last, _Dest);
; 4834 :     } else {
; 4835 :         if constexpr (_Sent_copy_cat<_InIt, _Sent, _OutIt>::_Bitcopy_assignable) {
; 4836 : #if _HAS_CXX20
; 4837 :             if (!_STD is_constant_evaluated())
; 4838 : #endif // _HAS_CXX20
; 4839 :             {
; 4840 : #if _HAS_CXX20
; 4841 :                 if constexpr (!is_same_v<_InIt, _Sent>) {
; 4842 :                     return _STD _Copy_memmove_n(_First, static_cast<size_t>(_Last - _First), _Dest);
; 4843 :                 } else
; 4844 : #endif // _HAS_CXX20
; 4845 :                 {
; 4846 :                     return _STD _Copy_memmove(_First, _Last, _Dest);
; 4847 :                 }
; 4848 :             }
; 4849 :         }
; 4850 : 
; 4851 :         for (; _First != _Last; ++_Dest, (void) ++_First) {
; 4852 :             *_Dest = *_First;
; 4853 :         }
; 4854 : 
; 4855 :         return _Dest;
; 4856 :     }
; 4857 : }
; 4858 : 
; 4859 : _EXPORT_STD template <class _InIt, class _OutIt>
; 4860 : _CONSTEXPR20 _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest) { // copy [_First, _Last) to [_Dest, ...)
; 4861 :     _STD _Adl_verify_range(_First, _Last);
; 4862 :     const auto _UFirst = _STD _Get_unwrapped(_First);
; 4863 :     const auto _ULast  = _STD _Get_unwrapped(_Last);
; 4864 :     auto _UDest        = _STD _Get_unwrapped_n(_STD move(_Dest), _STD _Idl_distance<_InIt>(_UFirst, _ULast));
; 4865 :     _STD _Seek_wrapped(_Dest, _STD _Copy_unchecked(_UFirst, _ULast, _STD move(_UDest)));
; 4866 :     return _Dest;
; 4867 : }
; 4868 : 
; 4869 : #if _HAS_CXX17
; 4870 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
; 4871 : _FwdIt2 copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest) noexcept /* terminates */ {
; 4872 :     // copy [_First, _Last) to [_Dest, ...)
; 4873 :     // not parallelized as benchmarks show it isn't worth it
; 4874 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
; 4875 :     _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt2);
; 4876 :     return _STD copy(_First, _Last, _Dest);
; 4877 : }
; 4878 : #endif // _HAS_CXX17
; 4879 : 
; 4880 : #if _HAS_CXX20
; 4881 : namespace ranges {
; 4882 :     template <class _To, class _From>
; 4883 :     concept _Convertible_from = convertible_to<_From, _To>;
; 4884 : 
; 4885 :     _EXPORT_STD template <class _In, class _Out>
; 4886 :     struct in_out_result {
; 4887 :         /* [[no_unique_address]] */ _In in;
; 4888 :         /* [[no_unique_address]] */ _Out out;
; 4889 : 
; 4890 :         template <_Convertible_from<const _In&> _IIn, _Convertible_from<const _Out&> _OOut>
; 4891 :         constexpr operator in_out_result<_IIn, _OOut>() const& {
; 4892 :             return {in, out};
; 4893 :         }
; 4894 : 
; 4895 :         template <_Convertible_from<_In> _IIn, _Convertible_from<_Out> _OOut>
; 4896 :         constexpr operator in_out_result<_IIn, _OOut>() && {
; 4897 :             return {_STD move(in), _STD move(out)};
; 4898 :         }
; 4899 :     };
; 4900 : 
; 4901 :     template <forward_iterator _It, class _Se>
; 4902 :         requires sentinel_for<remove_cvref_t<_Se>, _It>
; 4903 :     _NODISCARD constexpr _Unwrap_iter_t<_It, _Se> _Get_final_iterator_unwrapped(
; 4904 :         const _Unwrap_iter_t<_It, _Se>& _UFirst, _Se&& _Last) {
; 4905 :         // find the iterator in [_UFirst, _Unwrap_sent<_It>(_Last)) which equals _Unwrap_sent<_It>(_Last)
; 4906 :         // [possibly O(N)]
; 4907 :         if constexpr (is_same_v<_Unwrap_iter_t<_It, _Se>, _Unwrap_sent_t<_Se, _It>>) {
; 4908 :             return _RANGES _Unwrap_sent<_It>(_STD forward<_Se>(_Last));
; 4909 :         } else {
; 4910 :             return _RANGES next(_UFirst, _RANGES _Unwrap_sent<_It>(_STD forward<_Se>(_Last)));
; 4911 :         }
; 4912 :     }
; 4913 : 
; 4914 :     template <forward_range _Rng>
; 4915 :     _NODISCARD constexpr auto _Get_final_iterator_unwrapped(_Rng& _Range) {
; 4916 :         // find the (unwrapped) iterator in _Range which equals _Uend(_Range) [possibly O(N)]
; 4917 :         if constexpr (common_range<_Rng>) {
; 4918 :             if constexpr (same_as<decltype(_Uend(_Range)), _Unwrapped_iterator_t<_Rng>>) {
; 4919 :                 return _Uend(_Range);
; 4920 :             } else {
; 4921 :                 return _RANGES _Unwrap_range_sent<_Rng>(_RANGES end(_Range));
; 4922 :             }
; 4923 :         } else if constexpr (sized_range<_Rng>) {
; 4924 :             return _RANGES next(_Ubegin(_Range), _RANGES distance(_Range));
; 4925 :         } else {
; 4926 :             return _RANGES next(_Ubegin(_Range), _Uend(_Range));
; 4927 :         }
; 4928 :     }
; 4929 : 
; 4930 :     template <forward_range _Rng>
; 4931 :     _NODISCARD constexpr auto _Get_final_iterator_unwrapped(_Rng& _Range, const _Unwrapped_iterator_t<_Rng>& _Mid) {
; 4932 :         // find the (unwrapped) iterator in _Range which equals _Uend(_Range) [possibly O(N)]
; 4933 :         // Pre: [ranges::begin(_Range), _Mid) and [_Mid, ranges::end(_Range)) denote ranges
; 4934 :         if constexpr (common_range<_Rng>) {
; 4935 :             if constexpr (same_as<decltype(_Uend(_Range)), _Unwrapped_iterator_t<_Rng>>) {
; 4936 :                 return _Uend(_Range);
; 4937 :             } else {
; 4938 :                 return _Unwrap_range_sent<_Rng>(_RANGES end(_Range));
; 4939 :             }
; 4940 :         } else if constexpr (sized_range<_Rng>) {
; 4941 :             const auto _Dist = _RANGES distance(_Range);
; 4942 :             if constexpr (sized_sentinel_for<_Unwrapped_iterator_t<_Rng>, _Unwrapped_iterator_t<_Rng>>) {
; 4943 :                 return _RANGES next(_Mid, _Dist - (_Mid - _Ubegin(_Range)));
; 4944 :             } else {
; 4945 :                 return _RANGES next(_Ubegin(_Range), _Dist);
; 4946 :             }
; 4947 :         } else {
; 4948 :             return _RANGES next(_Mid, _Uend(_Range));
; 4949 :         }
; 4950 :     }
; 4951 : 
; 4952 : #if _HAS_CXX23
; 4953 :     _EXPORT_STD template <class _Out, class _Ty>
; 4954 :     struct out_value_result {
; 4955 :         /* [[no_unique_address]] */ _Out out;
; 4956 :         /* [[no_unique_address]] */ _Ty value;
; 4957 : 
; 4958 :         template <_Convertible_from<const _Out&> _OOut, _Convertible_from<const _Ty&> _TTy>
; 4959 :         constexpr operator out_value_result<_OOut, _TTy>() const& {
; 4960 :             return {out, value};
; 4961 :         }
; 4962 : 
; 4963 :         template <_Convertible_from<_Out> _OOut, _Convertible_from<_Ty> _TTy>
; 4964 :         constexpr operator out_value_result<_OOut, _TTy>() && {
; 4965 :             return {_STD move(out), _STD move(value)};
; 4966 :         }
; 4967 :     };
; 4968 : #endif // _HAS_CXX23
; 4969 : 
; 4970 :     _EXPORT_STD template <class _In, class _Out>
; 4971 :     using copy_result = in_out_result<_In, _Out>;
; 4972 : 
; 4973 :     template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out>
; 4974 :         requires indirectly_copyable<_It, _Out>
; 4975 :     _NODISCARD constexpr copy_result<_It, _Out> _Copy_unchecked(_It _First, _Se _Last, _Out _Output) {
; 4976 :         if constexpr (_Sent_copy_cat<_It, _Se, _Out>::_Bitcopy_assignable) {
; 4977 :             if (!_STD is_constant_evaluated()) {
; 4978 :                 if constexpr (is_same_v<_It, _Se>) {
; 4979 :                     _Output = _STD _Copy_memmove(_STD move(_First), _Last, _STD move(_Output));
; 4980 :                     return {_STD move(_Last), _STD move(_Output)};
; 4981 :                 } else {
; 4982 :                     const auto _Count = static_cast<size_t>(_Last - _First);
; 4983 :                     _Output           = _STD _Copy_memmove_n(_First, _Count, _STD move(_Output));
; 4984 :                     _First += _Count;
; 4985 :                     return {_STD move(_First), _STD move(_Output)};
; 4986 :                 }
; 4987 :             }
; 4988 :         }
; 4989 : 
; 4990 :         for (; _First != _Last; ++_First, (void) ++_Output) {
; 4991 :             *_Output = *_First;
; 4992 :         }
; 4993 : 
; 4994 :         return {_STD move(_First), _STD move(_Output)};
; 4995 :     }
; 4996 : 
; 4997 :     struct _Copy_fn {
; 4998 :         template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out>
; 4999 :             requires indirectly_copyable<_It, _Out>
; 5000 :         _STATIC_CALL_OPERATOR constexpr copy_result<_It, _Out> operator()(
; 5001 :             _It _First, _Se _Last, _Out _Output) _CONST_CALL_OPERATOR {
; 5002 :             _STD _Adl_verify_range(_First, _Last);
; 5003 :             auto _UFirst      = _RANGES _Unwrap_iter<_Se>(_STD move(_First));
; 5004 :             auto _ULast       = _RANGES _Unwrap_sent<_It>(_STD move(_Last));
; 5005 :             const auto _Count = _RANGES _Idl_distance<_It>(_UFirst, _ULast);
; 5006 :             auto _UResult     = _RANGES _Copy_unchecked(
; 5007 :                     _STD move(_UFirst), _STD move(_ULast), _STD _Get_unwrapped_n(_STD move(_Output), _Count));
; 5008 :             _STD _Seek_wrapped(_First, _STD move(_UResult.in));
; 5009 :             _STD _Seek_wrapped(_Output, _STD move(_UResult.out));
; 5010 :             return {_STD move(_First), _STD move(_Output)};
; 5011 :         }
; 5012 : 
; 5013 :         template <input_range _Rng, weakly_incrementable _Out>
; 5014 :             requires indirectly_copyable<iterator_t<_Rng>, _Out>
; 5015 :         _STATIC_CALL_OPERATOR constexpr copy_result<borrowed_iterator_t<_Rng>, _Out> operator()(
; 5016 :             _Rng&& _Range, _Out _Output) _CONST_CALL_OPERATOR {
; 5017 :             const auto _Count = _RANGES _Idl_distance(_Range);
; 5018 :             auto _First       = _RANGES begin(_Range);
; 5019 :             auto _UResult = _RANGES _Copy_unchecked(_RANGES _Unwrap_range_iter<_Rng>(_STD move(_First)), _Uend(_Range),
; 5020 :                 _STD _Get_unwrapped_n(_STD move(_Output), _Count));
; 5021 :             _STD _Seek_wrapped(_First, _STD move(_UResult.in));
; 5022 :             _STD _Seek_wrapped(_Output, _STD move(_UResult.out));
; 5023 :             return {_STD move(_First), _STD move(_Output)};
; 5024 :         }
; 5025 :     };
; 5026 : 
; 5027 :     _EXPORT_STD inline constexpr _Copy_fn copy;
; 5028 : } // namespace ranges
; 5029 : #endif // _HAS_CXX20
; 5030 : 
; 5031 : _EXPORT_STD template <class _InIt, class _Diff, class _OutIt>
; 5032 : _CONSTEXPR20 _OutIt copy_n(_InIt _First, _Diff _Count_raw, _OutIt _Dest) {
; 5033 :     // copy [_First, _First + _Count) to [_Dest, ...)
; 5034 :     _Algorithm_int_t<_Diff> _Count = _Count_raw;
; 5035 :     if (0 < _Count) {
; 5036 :         if constexpr (_Is_vb_iterator<_InIt> && _Is_vb_iterator<_OutIt, true>) {
; 5037 :             return _STD _Copy_vbool(_First, _First + _Count, _Dest);
; 5038 :         } else {
; 5039 :             auto _UFirst = _STD _Get_unwrapped_n(_First, _Count);
; 5040 :             auto _UDest  = _STD _Get_unwrapped_n(_Dest, _Count);
; 5041 :             if constexpr (_Iter_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Bitcopy_assignable) {
; 5042 : #if _HAS_CXX20
; 5043 :                 if (!_STD is_constant_evaluated())
; 5044 : #endif // _HAS_CXX20
; 5045 :                 {
; 5046 :                     _UDest = _STD _Copy_memmove_n(_UFirst, static_cast<size_t>(_Count), _UDest);
; 5047 :                     _STD _Seek_wrapped(_Dest, _UDest);
; 5048 :                     return _Dest;
; 5049 :                 }
; 5050 :             }
; 5051 : 
; 5052 :             for (;;) {
; 5053 :                 *_UDest = *_UFirst;
; 5054 :                 ++_UDest;
; 5055 :                 --_Count;
; 5056 :                 // note that we avoid an extra ++_First here to allow istream_iterator to work, see LWG-2471
; 5057 :                 if (_Count == 0) {
; 5058 :                     break;
; 5059 :                 }
; 5060 : 
; 5061 :                 ++_UFirst;
; 5062 :             }
; 5063 : 
; 5064 :             _STD _Seek_wrapped(_Dest, _UDest);
; 5065 :         }
; 5066 :     }
; 5067 : 
; 5068 :     return _Dest;
; 5069 : }
; 5070 : 
; 5071 : #if _HAS_CXX17
; 5072 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _Diff, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5073 : _FwdIt2 copy_n(_ExPo&&, _FwdIt1 _First, _Diff _Count_raw, _FwdIt2 _Dest) noexcept /* terminates */ {
; 5074 :     // copy [_First, _First + _Count) to [_Dest, ...)
; 5075 :     // not parallelized as benchmarks show it isn't worth it
; 5076 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
; 5077 :     _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt2);
; 5078 :     return _STD copy_n(_First, _Count_raw, _Dest);
; 5079 : }
; 5080 : #endif // _HAS_CXX17
; 5081 : 
; 5082 : template <class _CtgIt1, class _CtgIt2>
; 5083 : _CtgIt2 _Copy_backward_memmove(_CtgIt1 _First, _CtgIt1 _Last, _CtgIt2 _Dest) {
; 5084 :     // implement copy_backward-like function as memmove
; 5085 :     const auto _First_ptr = _STD _To_address(_First);
; 5086 :     const auto _Last_ptr  = _STD _To_address(_Last);
; 5087 :     const auto _Dest_ptr  = _STD _To_address(_Dest);
; 5088 :     const auto _First_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 5089 :     const auto _Last_ch   = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 5090 :     const auto _Dest_ch   = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 5091 :     const auto _Count     = static_cast<size_t>(_Last_ch - _First_ch);
; 5092 :     const auto _Result    = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);
; 5093 :     if constexpr (is_pointer_v<_CtgIt2>) {
; 5094 :         return static_cast<_CtgIt2>(_Result);
; 5095 :     } else {
; 5096 :         return _Dest - static_cast<_Iter_diff_t<_CtgIt2>>(_Last_ptr - _First_ptr);
; 5097 :     }
; 5098 : }
; 5099 : 
; 5100 : template <class _BidIt1, class _BidIt2>
; 5101 : _BidIt2 _Copy_backward_memmove(move_iterator<_BidIt1> _First, move_iterator<_BidIt1> _Last, _BidIt2 _Dest) {
; 5102 :     return _STD _Copy_backward_memmove(_First.base(), _Last.base(), _Dest);
; 5103 : }
; 5104 : 
; 5105 : template <class _BidIt1, class _BidIt2>
; 5106 : _NODISCARD _CONSTEXPR20 _BidIt2 _Copy_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
; 5107 :     // copy [_First, _Last) backwards to [..., _Dest)
; 5108 :     if constexpr (_Iter_copy_cat<_BidIt1, _BidIt2>::_Bitcopy_assignable) {
; 5109 : #if _HAS_CXX20
; 5110 :         if (!_STD is_constant_evaluated())
; 5111 : #endif // _HAS_CXX20
; 5112 :         {
; 5113 :             return _STD _Copy_backward_memmove(_First, _Last, _Dest);
; 5114 :         }
; 5115 :     }
; 5116 : 
; 5117 :     while (_First != _Last) {
; 5118 :         *--_Dest = *--_Last;
; 5119 :     }
; 5120 : 
; 5121 :     return _Dest;
; 5122 : }
; 5123 : 
; 5124 : _EXPORT_STD template <class _BidIt1, class _BidIt2>
; 5125 : _CONSTEXPR20 _BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
; 5126 :     // copy [_First, _Last) backwards to [..., _Dest)
; 5127 :     _STD _Adl_verify_range(_First, _Last);
; 5128 :     const auto _UFirst = _STD _Get_unwrapped(_First);
; 5129 :     const auto _ULast  = _STD _Get_unwrapped(_Last);
; 5130 :     const auto _UDest  = _STD _Get_unwrapped_n(_Dest, -_STD _Idl_distance<_BidIt1>(_UFirst, _ULast));
; 5131 :     _STD _Seek_wrapped(_Dest, _STD _Copy_backward_unchecked(_UFirst, _ULast, _UDest));
; 5132 :     return _Dest;
; 5133 : }
; 5134 : 
; 5135 : template <class _InIt, class _OutIt>
; 5136 : _CONSTEXPR20 _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {
; 5137 :     // move [_First, _Last) to [_Dest, ...)
; 5138 :     // note: _Move_unchecked has callers other than the move family
; 5139 :     if constexpr (_Is_vb_iterator<_InIt> && _Is_vb_iterator<_OutIt, true>) {
; 5140 :         return _STD _Copy_vbool(_First, _Last, _Dest);
; 5141 :     } else {
; 5142 :         if constexpr (_Iter_move_cat<_InIt, _OutIt>::_Bitcopy_assignable) {
; 5143 : #if _HAS_CXX20
; 5144 :             if (!_STD is_constant_evaluated())
; 5145 : #endif // _HAS_CXX20
; 5146 :             {
; 5147 :                 return _STD _Copy_memmove(_First, _Last, _Dest);
; 5148 :             }
; 5149 :         }
; 5150 : 
; 5151 :         for (; _First != _Last; ++_Dest, (void) ++_First) {
; 5152 :             *_Dest = _STD move(*_First);
; 5153 :         }
; 5154 : 
; 5155 :         return _Dest;
; 5156 :     }
; 5157 : }
; 5158 : 
; 5159 : _EXPORT_STD template <class _InIt, class _OutIt>
; 5160 : _CONSTEXPR20 _OutIt move(_InIt _First, _InIt _Last, _OutIt _Dest) {
; 5161 :     // move [_First, _Last) to [_Dest, ...)
; 5162 :     _STD _Adl_verify_range(_First, _Last);
; 5163 :     const auto _UFirst = _STD _Get_unwrapped(_First);
; 5164 :     const auto _ULast  = _STD _Get_unwrapped(_Last);
; 5165 :     const auto _UDest  = _STD _Get_unwrapped_n(_Dest, _STD _Idl_distance<_InIt>(_UFirst, _ULast));
; 5166 :     _STD _Seek_wrapped(_Dest, _STD _Move_unchecked(_UFirst, _ULast, _UDest));
; 5167 :     return _Dest;
; 5168 : }
; 5169 : 
; 5170 : #if _HAS_CXX17
; 5171 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5172 : _FwdIt2 move(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest) noexcept /* terminates */ {
; 5173 :     // move [_First, _Last) to [_Dest, ...)
; 5174 :     // not parallelized as benchmarks show it isn't worth it
; 5175 :     _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt1);
; 5176 :     _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt2);
; 5177 :     return _STD move(_First, _Last, _Dest);
; 5178 : }
; 5179 : #endif // _HAS_CXX17
; 5180 : 
; 5181 : template <class _BidIt1, class _BidIt2>
; 5182 : _CONSTEXPR20 _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
; 5183 :     // move [_First, _Last) backwards to [..., _Dest)
; 5184 :     // note: _Move_backward_unchecked has callers other than the move_backward family
; 5185 :     if constexpr (_Iter_move_cat<_BidIt1, _BidIt2>::_Bitcopy_assignable) {
; 5186 : #if _HAS_CXX20
; 5187 :         if (!_STD is_constant_evaluated())
; 5188 : #endif // _HAS_CXX20
; 5189 :         {
; 5190 :             return _STD _Copy_backward_memmove(_First, _Last, _Dest);
; 5191 :         }
; 5192 :     }
; 5193 : 
; 5194 :     while (_First != _Last) {
; 5195 :         *--_Dest = _STD move(*--_Last);
; 5196 :     }
; 5197 : 
; 5198 :     return _Dest;
; 5199 : }
; 5200 : 
; 5201 : _EXPORT_STD template <class _BidIt1, class _BidIt2>
; 5202 : _CONSTEXPR20 _BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
; 5203 :     // move [_First, _Last) backwards to [..., _Dest)
; 5204 :     _STD _Adl_verify_range(_First, _Last);
; 5205 :     const auto _UFirst = _STD _Get_unwrapped(_First);
; 5206 :     const auto _ULast  = _STD _Get_unwrapped(_Last);
; 5207 :     const auto _UDest  = _STD _Get_unwrapped_n(_Dest, -_STD _Idl_distance<_BidIt1>(_UFirst, _ULast));
; 5208 :     _STD _Seek_wrapped(_Dest, _STD _Move_backward_unchecked(_UFirst, _ULast, _UDest));
; 5209 :     return _Dest;
; 5210 : }
; 5211 : 
; 5212 : template <class _Ty>
; 5213 : struct _Is_character : false_type {}; // by default, not a character type
; 5214 : 
; 5215 : template <>
; 5216 : struct _Is_character<char> : true_type {}; // chars are characters
; 5217 : 
; 5218 : template <>
; 5219 : struct _Is_character<signed char> : true_type {}; // signed chars are also characters
; 5220 : 
; 5221 : template <>
; 5222 : struct _Is_character<unsigned char> : true_type {}; // unsigned chars are also characters
; 5223 : 
; 5224 : #ifdef __cpp_char8_t
; 5225 : template <>
; 5226 : struct _Is_character<char8_t> : true_type {}; // UTF-8 code units are sort-of characters
; 5227 : #endif // defined(__cpp_char8_t)
; 5228 : 
; 5229 : template <class _Ty>
; 5230 : struct _Is_character_or_bool : _Is_character<_Ty>::type {};
; 5231 : 
; 5232 : template <>
; 5233 : struct _Is_character_or_bool<bool> : true_type {};
; 5234 : 
; 5235 : template <class _Ty>
; 5236 : struct _Is_character_or_byte_or_bool : _Is_character_or_bool<_Ty>::type {};
; 5237 : 
; 5238 : #ifdef __cpp_lib_byte
; 5239 : template <>
; 5240 : struct _Is_character_or_byte_or_bool<byte> : true_type {};
; 5241 : #endif // defined(__cpp_lib_byte)
; 5242 : 
; 5243 : // _Fill_memset_is_safe determines if _FwdIt and _Ty are eligible for memset optimization in fill.
; 5244 : // Need to explicitly test for volatile because _Unwrap_enum_t discards qualifiers.
; 5245 : template <class _FwdIt, class _Ty, bool = _Iterator_is_contiguous<_FwdIt>>
; 5246 : constexpr bool _Fill_memset_is_safe = conjunction_v<is_scalar<_Ty>,
; 5247 :     _Is_character_or_byte_or_bool<_Unwrap_enum_t<remove_reference_t<_Iter_ref_t<_FwdIt>>>>,
; 5248 :     negation<is_volatile<remove_reference_t<_Iter_ref_t<_FwdIt>>>>, is_assignable<_Iter_ref_t<_FwdIt>, const _Ty&>>;
; 5249 : 
; 5250 : template <class _FwdIt, class _Ty>
; 5251 : constexpr bool _Fill_memset_is_safe<_FwdIt, _Ty, false> = false;
; 5252 : 
; 5253 : template <class _FwdIt, class _Ty, bool = _Iterator_is_contiguous<_FwdIt>>
; 5254 : constexpr bool _Fill_zero_memset_is_safe =
; 5255 :     conjunction_v<is_scalar<_Ty>, is_scalar<_Iter_value_t<_FwdIt>>, negation<is_member_pointer<_Iter_value_t<_FwdIt>>>,
; 5256 :         negation<is_volatile<remove_reference_t<_Iter_ref_t<_FwdIt>>>>, is_assignable<_Iter_ref_t<_FwdIt>, const _Ty&>>;
; 5257 : 
; 5258 : template <class _FwdIt, class _Ty>
; 5259 : constexpr bool _Fill_zero_memset_is_safe<_FwdIt, _Ty, false> = false;
; 5260 : 
; 5261 : template <class _CtgIt, class _Ty>
; 5262 : void _Fill_memset(_CtgIt _Dest, const _Ty _Val, const size_t _Count) {
; 5263 :     // implicitly convert (a cast would suppress warnings); also handles _Iter_value_t<_CtgIt> being bool
; 5264 :     _Iter_value_t<_CtgIt> _Dest_val = _Val;
; 5265 :     _CSTD memset(_STD _To_address(_Dest), static_cast<unsigned char>(_Dest_val), _Count);
; 5266 : }
; 5267 : 
; 5268 : template <class _CtgIt>
; 5269 : void _Fill_zero_memset(_CtgIt _Dest, const size_t _Count) {
; 5270 :     _CSTD memset(_STD _To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));
; 5271 : }
; 5272 : 
; 5273 : template <class _Ty>
; 5274 : _NODISCARD bool _Is_all_bits_zero(const _Ty& _Val) {
; 5275 :     // checks if scalar type has all bits set to zero
; 5276 :     _STL_INTERNAL_STATIC_ASSERT(is_scalar_v<_Ty> && !is_member_pointer_v<_Ty>);
; 5277 :     if constexpr (is_same_v<_Ty, nullptr_t>) {
; 5278 :         return true;
; 5279 :     } else {
; 5280 :         constexpr _Ty _Zero{};
; 5281 :         return _CSTD memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;
; 5282 :     }
; 5283 : }
; 5284 : 
; 5285 : _EXPORT_STD template <class _FwdIt, class _Ty>
; 5286 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {
; 5287 :     // copy _Val through [_First, _Last)
; 5288 :     _STD _Adl_verify_range(_First, _Last);
; 5289 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5290 :         _STD _Fill_vbool(_First, _Last, _Val);
; 5291 :     } else {
; 5292 :         auto _UFirst      = _STD _Get_unwrapped(_First);
; 5293 :         const auto _ULast = _STD _Get_unwrapped(_Last);
; 5294 : #if _HAS_CXX20
; 5295 :         if (!_STD is_constant_evaluated())
; 5296 : #endif // _HAS_CXX20
; 5297 :         {
; 5298 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5299 :                 _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5300 :                 return;
; 5301 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5302 :                 if (_STD _Is_all_bits_zero(_Val)) {
; 5303 :                     _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5304 :                     return;
; 5305 :                 }
; 5306 :             }
; 5307 :         }
; 5308 : 
; 5309 :         for (; _UFirst != _ULast; ++_UFirst) {
; 5310 :             *_UFirst = _Val;
; 5311 :         }
; 5312 :     }
; 5313 : }
; 5314 : 
; 5315 : #if _HAS_CXX17
; 5316 : _EXPORT_STD template <class _ExPo, class _FwdIt, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5317 : void fill(_ExPo&&, _FwdIt _First, _FwdIt _Last, const _Ty& _Val) noexcept /* terminates */ {
; 5318 :     // copy _Val through [_First, _Last)
; 5319 :     // not parallelized as benchmarks show it isn't worth it
; 5320 :     _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt);
; 5321 :     return _STD fill(_First, _Last, _Val);
; 5322 : }
; 5323 : #endif // _HAS_CXX17
; 5324 : 
; 5325 : _EXPORT_STD template <class _OutIt, class _Diff, class _Ty>
; 5326 : _CONSTEXPR20 _OutIt fill_n(_OutIt _Dest, const _Diff _Count_raw, const _Ty& _Val) {
; 5327 :     // copy _Val _Count times through [_Dest, ...)
; 5328 :     _Algorithm_int_t<_Diff> _Count = _Count_raw;
; 5329 :     if (0 < _Count) {
; 5330 :         if constexpr (_Is_vb_iterator<_OutIt, true>) {
; 5331 :             const auto _Last = _Dest + static_cast<typename _OutIt::difference_type>(_Count);
; 5332 :             _STD _Fill_vbool(_Dest, _Last, _Val);
; 5333 :             return _Last;
; 5334 :         } else {
; 5335 :             auto _UDest = _STD _Get_unwrapped_n(_Dest, _Count);
; 5336 : #if _HAS_CXX20
; 5337 :             if (!_STD is_constant_evaluated())
; 5338 : #endif // _HAS_CXX20
; 5339 :             {
; 5340 :                 if constexpr (_Fill_memset_is_safe<decltype(_UDest), _Ty>) {
; 5341 :                     _STD _Fill_memset(_UDest, _Val, static_cast<size_t>(_Count));
; 5342 :                     _STD _Seek_wrapped(_Dest, _UDest + _Count);
; 5343 :                     return _Dest;
; 5344 :                 } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UDest), _Ty>) {
; 5345 :                     if (_STD _Is_all_bits_zero(_Val)) {
; 5346 :                         _STD _Fill_zero_memset(_UDest, static_cast<size_t>(_Count));
; 5347 :                         _STD _Seek_wrapped(_Dest, _UDest + _Count);
; 5348 :                         return _Dest;
; 5349 :                     }
; 5350 :                 }
; 5351 :             }
; 5352 : 
; 5353 :             for (; 0 < _Count; --_Count, (void) ++_UDest) {
; 5354 :                 *_UDest = _Val;
; 5355 :             }
; 5356 : 
; 5357 :             _STD _Seek_wrapped(_Dest, _UDest);
; 5358 :         }
; 5359 :     }
; 5360 :     return _Dest;
; 5361 : }
; 5362 : 
; 5363 : #if _HAS_CXX17
; 5364 : _EXPORT_STD template <class _ExPo, class _FwdIt, class _Diff, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5365 : _FwdIt fill_n(_ExPo&&, _FwdIt _Dest, _Diff _Count_raw, const _Ty& _Val) noexcept /* terminates */ {
; 5366 :     // copy _Val _Count times through [_Dest, ...)
; 5367 :     // not parallelized as benchmarks show it isn't worth it
; 5368 :     _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt);
; 5369 :     return _STD fill_n(_Dest, _Count_raw, _Val);
; 5370 : }
; 5371 : #endif // _HAS_CXX17
; 5372 : 
; 5373 : #if _HAS_CXX20
; 5374 : namespace ranges {
; 5375 :     class _Fill_n_fn {
; 5376 :     public:
; 5377 :         template <class _Ty, output_iterator<const _Ty&> _It>
; 5378 :         _STATIC_CALL_OPERATOR constexpr _It operator()(
; 5379 :             _It _First, iter_difference_t<_It> _Count, const _Ty& _Value) _CONST_CALL_OPERATOR {
; 5380 :             if (_Count > 0) {
; 5381 :                 auto _UFirst = _STD _Get_unwrapped_n(_STD move(_First), _Count);
; 5382 :                 if (!_STD is_constant_evaluated()) {
; 5383 :                     if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5384 :                         _STD _Fill_memset(_UFirst, _Value, static_cast<size_t>(_Count));
; 5385 :                         _STD _Seek_wrapped(_First, _UFirst + _Count); // no need to move since _UFirst is a pointer
; 5386 :                         return _First;
; 5387 :                     } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5388 :                         if (_STD _Is_all_bits_zero(_Value)) {
; 5389 :                             _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_Count));
; 5390 :                             _STD _Seek_wrapped(_First, _UFirst + _Count); // no need to move since _UFirst is a pointer
; 5391 :                             return _First;
; 5392 :                         }
; 5393 :                     }
; 5394 :                 }
; 5395 : 
; 5396 :                 for (; _Count > 0; ++_UFirst, (void) --_Count) {
; 5397 :                     *_UFirst = _Value;
; 5398 :                 }
; 5399 : 
; 5400 :                 _STD _Seek_wrapped(_First, _STD move(_UFirst));
; 5401 :             }
; 5402 : 
; 5403 :             return _First;
; 5404 :         }
; 5405 :     };
; 5406 : 
; 5407 :     _EXPORT_STD inline constexpr _Fill_n_fn fill_n;
; 5408 : } // namespace ranges
; 5409 : #endif // _HAS_CXX20
; 5410 : 
; 5411 : template <class _Ty1, class _Ty2, class = void>
; 5412 : constexpr bool _Can_compare_with_operator_equal = false;
; 5413 : 
; 5414 : template <class _Ty1, class _Ty2>
; 5415 : constexpr bool
; 5416 :     _Can_compare_with_operator_equal<_Ty1, _Ty2, void_t<decltype(_STD declval<_Ty1&>() == _STD declval<_Ty2&>())>> =
; 5417 :         true;
; 5418 : 
; 5419 : template <class _Ty1, class _Ty2>
; 5420 : constexpr bool _Is_pointer_address_comparable =
; 5421 :     _Can_compare_with_operator_equal<_Ty1*, _Ty2*>
; 5422 :     && (_Is_pointer_address_convertible<_Ty1, _Ty2> || _Is_pointer_address_convertible<_Ty2, _Ty1>);
; 5423 : 
; 5424 : // _Can_memcmp_elements<_Elem1, _Elem2> reports whether `_Elem1 == _Elem2` can be optimized to memcmp.
; 5425 : // Here, _Elem1 and _Elem2 aren't top-level const, because we remove_const_t before using _Can_memcmp_elements.
; 5426 : 
; 5427 : // Integral types are eligible for memcmp in very specific cases.
; 5428 : // * They must be the same size. (`int == long` is eligible; `int == long long` isn't.)
; 5429 : // * The usual arithmetic conversions must preserve bit patterns. (This is true for `int == unsigned int`,
; 5430 : //   but false for `short == unsigned short`.)
; 5431 : #pragma warning(push)
; 5432 : #pragma warning(disable : 4806) // no value of type 'bool' promoted to type 'char' can equal the given constant
; 5433 : template <class _Elem1, class _Elem2,
; 5434 :     bool = sizeof(_Elem1) == sizeof(_Elem2) && is_integral_v<_Elem1> && is_integral_v<_Elem2>>
; 5435 : constexpr bool _Can_memcmp_elements =
; 5436 :     is_same_v<_Elem1, bool> || is_same_v<_Elem2, bool> || static_cast<_Elem1>(-1) == static_cast<_Elem2>(-1);
; 5437 : #pragma warning(pop)
; 5438 : 
; 5439 : #ifdef __cpp_lib_byte
; 5440 : // Allow memcmping std::byte.
; 5441 : // inline is required here as explicit specializations of variable templates are problematic in C++14.
; 5442 : // However, std::byte is C++17 and above so we are safe.
; 5443 : template <>
; 5444 : inline constexpr bool _Can_memcmp_elements<byte, byte, false> = true;
; 5445 : #endif // defined(__cpp_lib_byte)
; 5446 : 
; 5447 : // Pointer elements are eligible for memcmp when they point to the same type, ignoring cv-qualification.
; 5448 : // This handles pointers to object types, pointers to void, and pointers to function types.
; 5449 : template <class _Ty1, class _Ty2>
; 5450 : constexpr bool _Can_memcmp_elements<_Ty1*, _Ty2*, false> = _Is_pointer_address_comparable<_Ty1, _Ty2>;
; 5451 : 
; 5452 : template <class _Elem1, class _Elem2>
; 5453 : constexpr bool _Can_memcmp_elements<_Elem1, _Elem2, false> = false;
; 5454 : 
; 5455 : // _Can_memcmp_elements_with_pred<_Elem1, _Elem2, _Pr> reports whether the memcmp optimization is applicable,
; 5456 : // given contiguously stored elements. (This avoids having to repeat the metaprogramming that finds the element types.)
; 5457 : // _Elem1 and _Elem2 aren't top-level const here.
; 5458 : template <class _Elem1, class _Elem2, class _Pr>
; 5459 : constexpr bool _Can_memcmp_elements_with_pred = false;
; 5460 : 
; 5461 : // With equal_to<_Elem3> we need to make sure that both _Elem1 and _Elem2 are convertible to _Elem3 without changing
; 5462 : // object representation (we use _Iter_copy_cat for this task) and _Elem3 can be safely memcmp'ed with itself
; 5463 : template <class _Elem1, class _Elem2, class _Elem3>
; 5464 : constexpr bool _Can_memcmp_elements_with_pred<_Elem1, _Elem2, equal_to<_Elem3>> =
; 5465 :     _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible && _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible
; 5466 :     && _Can_memcmp_elements<remove_cv_t<_Elem3>, remove_cv_t<_Elem3>>;
; 5467 : 
; 5468 : // equal_to<> is transparent.
; 5469 : template <class _Elem1, class _Elem2>
; 5470 : constexpr bool _Can_memcmp_elements_with_pred<_Elem1, _Elem2, equal_to<>> = _Can_memcmp_elements<_Elem1, _Elem2>;
; 5471 : 
; 5472 : #if _HAS_CXX20
; 5473 : // ranges::equal_to is also transparent.
; 5474 : template <class _Elem1, class _Elem2>
; 5475 : constexpr bool _Can_memcmp_elements_with_pred<_Elem1, _Elem2, _RANGES equal_to> = _Can_memcmp_elements<_Elem1, _Elem2>;
; 5476 : #endif // _HAS_CXX20
; 5477 : 
; 5478 : // _Equal_memcmp_is_safe<_Iter1, _Iter2, _Pr> reports whether we can activate the memcmp optimization
; 5479 : // for arbitrary iterators and predicates.
; 5480 : // It ignores top-level constness on the iterators and on the elements.
; 5481 : template <class _Iter1, class _Iter2, class _Pr>
; 5482 : constexpr bool _Equal_memcmp_is_safe_helper =
; 5483 :     _Iterators_are_contiguous<_Iter1, _Iter2> && !_Iterator_is_volatile<_Iter1> && !_Iterator_is_volatile<_Iter2>
; 5484 :     && _Can_memcmp_elements_with_pred<_Iter_value_t<_Iter1>, _Iter_value_t<_Iter2>, _Pr>;
; 5485 : 
; 5486 : template <class _Iter1, class _Iter2, class _Pr>
; 5487 : constexpr bool _Equal_memcmp_is_safe =
; 5488 :     _Equal_memcmp_is_safe_helper<remove_const_t<_Iter1>, remove_const_t<_Iter2>, remove_const_t<_Pr>>;
; 5489 : 
; 5490 : // Can we activate the vector algorithms for std::search?
; 5491 : template <class _It1, class _It2, class _Pr>
; 5492 : constexpr bool _Vector_alg_in_search_is_safe = _Equal_memcmp_is_safe<_It1, _It2, _Pr> // can search bitwise
; 5493 :                                             && sizeof(_Iter_value_t<_It1>) <= 2; // pcmpestri compatible element size
; 5494 : 
; 5495 : template <class _CtgIt1, class _CtgIt2>
; 5496 : _NODISCARD int _Memcmp_count(_CtgIt1 _First1, _CtgIt2 _First2, const size_t _Count) {
; 5497 :     _STL_INTERNAL_STATIC_ASSERT(sizeof(_Iter_value_t<_CtgIt1>) == sizeof(_Iter_value_t<_CtgIt2>));
; 5498 :     const auto _First1_ch = reinterpret_cast<const char*>(_STD _To_address(_First1));
; 5499 :     const auto _First2_ch = reinterpret_cast<const char*>(_STD _To_address(_First2));
; 5500 :     return _CSTD memcmp(_First1_ch, _First2_ch, _Count * sizeof(_Iter_value_t<_CtgIt1>));
; 5501 : }
; 5502 : 
; 5503 : _EXPORT_STD template <class _InIt1, class _InIt2, class _Pr>
; 5504 : _NODISCARD _CONSTEXPR20 bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _Pr _Pred) {
; 5505 :     // compare [_First1, _Last1) to [_First2, ...)
; 5506 :     _STD _Adl_verify_range(_First1, _Last1);
; 5507 :     auto _UFirst1      = _STD _Get_unwrapped(_First1);
; 5508 :     const auto _ULast1 = _STD _Get_unwrapped(_Last1);
; 5509 :     auto _UFirst2      = _STD _Get_unwrapped_n(_First2, _STD _Idl_distance<_InIt1>(_UFirst1, _ULast1));
; 5510 :     if constexpr (_Equal_memcmp_is_safe<decltype(_UFirst1), decltype(_UFirst2), _Pr>) {
; 5511 : #if _HAS_CXX20
; 5512 :         if (!_STD is_constant_evaluated())
; 5513 : #endif // _HAS_CXX20
; 5514 :         {
; 5515 :             _STL_INTERNAL_STATIC_ASSERT(
; 5516 :                 sizeof(_Iter_value_t<decltype(_UFirst1)>) == sizeof(_Iter_value_t<decltype(_UFirst2)>));
; 5517 :             const auto _First1_ch = reinterpret_cast<const char*>(_STD _To_address(_UFirst1));
; 5518 :             const auto _Size      = reinterpret_cast<const char*>(_STD _To_address(_ULast1)) - _First1_ch;
; 5519 :             return _CSTD memcmp(_First1_ch, _STD _To_address(_UFirst2), static_cast<size_t>(_Size)) == 0;
; 5520 :         }
; 5521 :     }
; 5522 : 
; 5523 :     for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2) {
; 5524 :         if (!_Pred(*_UFirst1, *_UFirst2)) {
; 5525 :             return false;
; 5526 :         }
; 5527 :     }
; 5528 : 
; 5529 :     return true;
; 5530 : }
; 5531 : 
; 5532 : #if _HAS_CXX17
; 5533 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5534 : _NODISCARD bool equal(_ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2,
; 5535 :     _Pr _Pred) noexcept; // terminates
; 5536 : #endif // _HAS_CXX17
; 5537 : 
; 5538 : _EXPORT_STD template <class _InIt1, class _InIt2>
; 5539 : _NODISCARD _CONSTEXPR20 bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2) {
; 5540 :     // compare [_First1, _Last1) to [_First2, ...)
; 5541 :     return _STD equal(_First1, _Last1, _First2, equal_to<>{});
; 5542 : }
; 5543 : 
; 5544 : #if _HAS_CXX17
; 5545 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5546 : _NODISCARD bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2) noexcept
; 5547 : /* terminates */ {
; 5548 :     // compare [_First1, _Last1) to [_First2, ...)
; 5549 :     return _STD equal(_STD forward<_ExPo>(_Exec), _First1, _Last1, _First2, equal_to{});
; 5550 : }
; 5551 : #endif // _HAS_CXX17
; 5552 : 
; 5553 : _EXPORT_STD template <class _InIt1, class _InIt2, class _Pr>
; 5554 : _NODISCARD _CONSTEXPR20 bool equal(
; 5555 :     const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
; 5556 :     // compare [_First1, _Last1) to [_First2, _Last2)
; 5557 :     _STD _Adl_verify_range(_First1, _Last1);
; 5558 :     _STD _Adl_verify_range(_First2, _Last2);
; 5559 :     auto _UFirst1      = _STD _Get_unwrapped(_First1);
; 5560 :     const auto _ULast1 = _STD _Get_unwrapped(_Last1);
; 5561 :     auto _UFirst2      = _STD _Get_unwrapped(_First2);
; 5562 :     const auto _ULast2 = _STD _Get_unwrapped(_Last2);
; 5563 :     if constexpr (_Is_ranges_random_iter_v<_InIt1> && _Is_ranges_random_iter_v<_InIt2>) {
; 5564 :         if (_ULast1 - _UFirst1 != _ULast2 - _UFirst2) {
; 5565 :             return false;
; 5566 :         }
; 5567 : 
; 5568 :         return _STD equal(_UFirst1, _ULast1, _UFirst2, _STD _Pass_fn(_Pred));
; 5569 :     } else {
; 5570 :         for (;;) {
; 5571 :             if (_UFirst1 == _ULast1) {
; 5572 :                 return _UFirst2 == _ULast2;
; 5573 :             }
; 5574 : 
; 5575 :             if (_UFirst2 == _ULast2) {
; 5576 :                 return false;
; 5577 :             }
; 5578 : 
; 5579 :             if (!_Pred(*_UFirst1, *_UFirst2)) {
; 5580 :                 return false;
; 5581 :             }
; 5582 : 
; 5583 :             ++_UFirst1;
; 5584 :             ++_UFirst2;
; 5585 :         }
; 5586 :     }
; 5587 : }
; 5588 : 
; 5589 : #if _HAS_CXX17
; 5590 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5591 : _NODISCARD bool equal(
; 5592 :     _ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) noexcept; // terminates
; 5593 : #endif // _HAS_CXX17
; 5594 : 
; 5595 : _EXPORT_STD template <class _InIt1, class _InIt2>
; 5596 : _NODISCARD _CONSTEXPR20 bool equal(
; 5597 :     const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
; 5598 :     // compare [_First1, _Last1) to [_First2, _Last2)
; 5599 :     return _STD equal(_First1, _Last1, _First2, _Last2, equal_to<>{});
; 5600 : }
; 5601 : 
; 5602 : #if _HAS_CXX17
; 5603 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5604 : _NODISCARD bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
; 5605 :     const _FwdIt2 _Last2) noexcept /* terminates */ {
; 5606 :     // compare [_First1, _Last1) to [_First2, _Last2)
; 5607 :     return _STD equal(_STD forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, equal_to{});
; 5608 : }
; 5609 : #endif // _HAS_CXX17
; 5610 : 
; 5611 : #if _HAS_CXX20
; 5612 : namespace ranges {
; 5613 :     template <forward_range _Rng, class _It>
; 5614 :     _NODISCARD constexpr iterator_t<_Rng> _Rewrap_iterator(_Rng&& _Range, _It&& _Val) {
; 5615 :         _STL_INTERNAL_STATIC_ASSERT(is_same_v<remove_cvref_t<_It>, _Unwrapped_iterator_t<_Rng>>);
; 5616 : 
; 5617 :         if constexpr (is_same_v<remove_cvref_t<_It>, iterator_t<_Rng>>) {
; 5618 :             return _STD forward<_It>(_Val);
; 5619 :         } else {
; 5620 :             auto _Result = _RANGES begin(_Range);
; 5621 :             _Result._Seek_to(_STD forward<_It>(_Val));
; 5622 :             return _Result;
; 5623 :         }
; 5624 :     }
; 5625 : 
; 5626 :     _EXPORT_STD template <class _In1, class _In2>
; 5627 :     struct in_in_result {
; 5628 :         /* [[no_unique_address]] */ _In1 in1;
; 5629 :         /* [[no_unique_address]] */ _In2 in2;
; 5630 : 
; 5631 :         template <_Convertible_from<const _In1&> _IIn1, _Convertible_from<const _In2&> _IIn2>
; 5632 :         constexpr operator in_in_result<_IIn1, _IIn2>() const& {
; 5633 :             return {in1, in2};
; 5634 :         }
; 5635 : 
; 5636 :         template <_Convertible_from<_In1> _IIn1, _Convertible_from<_In2> _IIn2>
; 5637 :         constexpr operator in_in_result<_IIn1, _IIn2>() && {
; 5638 :             return {_STD move(in1), _STD move(in2)};
; 5639 :         }
; 5640 :     };
; 5641 : 
; 5642 :     _EXPORT_STD template <class _In1, class _In2>
; 5643 :     using mismatch_result = in_in_result<_In1, _In2>;
; 5644 : 
; 5645 :     template <input_iterator _It1, input_iterator _It2, class _Pr, class _Pj1, class _Pj2>
; 5646 :         requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
; 5647 :     _NODISCARD constexpr mismatch_result<_It1, _It2> _Mismatch_n(
; 5648 :         _It1 _First1, _It2 _First2, iter_difference_t<_It1> _Count, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 5649 :         _STL_INTERNAL_CHECK(_Count >= 0);
; 5650 : #if _USE_STD_VECTOR_ALGORITHMS
; 5651 :         if constexpr (_Equal_memcmp_is_safe<_It1, _It2, _Pr> && is_same_v<_Pj1, identity>
; 5652 :                       && is_same_v<_Pj2, identity>) {
; 5653 :             if (!_STD is_constant_evaluated()) {
; 5654 :                 constexpr size_t _Elem_size = sizeof(iter_value_t<_It1>);
; 5655 : 
; 5656 :                 const size_t _Pos = _STD _Mismatch_vectorized<_Elem_size>(
; 5657 :                     _STD _To_address(_First1), _STD _To_address(_First2), static_cast<size_t>(_Count));
; 5658 : 
; 5659 :                 return {_First1 + static_cast<iter_difference_t<_It1>>(_Pos),
; 5660 :                     _First2 + static_cast<iter_difference_t<_It2>>(_Pos)};
; 5661 :             }
; 5662 :         }
; 5663 : #endif // ^^^ _USE_STD_VECTOR_ALGORITHMS ^^^
; 5664 :         for (; _Count != 0; ++_First1, (void) ++_First2, --_Count) {
; 5665 :             if (!_STD invoke(_Pred, _STD invoke(_Proj1, *_First1), _STD invoke(_Proj2, *_First2))) {
; 5666 :                 break;
; 5667 :             }
; 5668 :         }
; 5669 : 
; 5670 :         return {_STD move(_First1), _STD move(_First2)};
; 5671 :     }
; 5672 : 
; 5673 :     template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2, class _Pr,
; 5674 :         class _Pj1, class _Pj2>
; 5675 :         requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
; 5676 :     _NODISCARD constexpr mismatch_result<_It1, _It2> _Mismatch_4(
; 5677 :         _It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 5678 :         for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void) ++_First2) {
; 5679 :             if (!_STD invoke(_Pred, _STD invoke(_Proj1, *_First1), _STD invoke(_Proj2, *_First2))) {
; 5680 :                 break;
; 5681 :             }
; 5682 :         }
; 5683 : 
; 5684 :         return {_STD move(_First1), _STD move(_First2)};
; 5685 :     }
; 5686 : 
; 5687 :     class _Mismatch_fn {
; 5688 :     public:
; 5689 :         template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2,
; 5690 :             class _Pr = ranges::equal_to, class _Pj1 = identity, class _Pj2 = identity>
; 5691 :             requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
; 5692 :         _NODISCARD _STATIC_CALL_OPERATOR constexpr mismatch_result<_It1, _It2> operator()(_It1 _First1, _Se1 _Last1,
; 5693 :             _It2 _First2, _Se2 _Last2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) _CONST_CALL_OPERATOR {
; 5694 :             _STD _Adl_verify_range(_First1, _Last1);
; 5695 :             _STD _Adl_verify_range(_First2, _Last2);
; 5696 : 
; 5697 :             if constexpr (sized_sentinel_for<_Se1, _It1> && sized_sentinel_for<_Se2, _It2>) {
; 5698 :                 iter_difference_t<_It1> _Count1       = _Last1 - _First1;
; 5699 :                 const iter_difference_t<_It2> _Count2 = _Last2 - _First2;
; 5700 :                 if (_Count1 > _Count2) {
; 5701 :                     _Count1 = static_cast<decltype(_Count1)>(_Count2);
; 5702 :                 }
; 5703 : 
; 5704 :                 auto _Result = _RANGES _Mismatch_n(_STD _Get_unwrapped(_STD move(_First1)),
; 5705 :                     _STD _Get_unwrapped(_STD move(_First2)), _Count1, _STD _Pass_fn(_Pred), _STD _Pass_fn(_Proj1),
; 5706 :                     _STD _Pass_fn(_Proj2));
; 5707 :                 _STD _Seek_wrapped(_First1, _STD move(_Result.in1));
; 5708 :                 _STD _Seek_wrapped(_First2, _STD move(_Result.in2));
; 5709 :                 return {_STD move(_First1), _STD move(_First2)};
; 5710 :             } else {
; 5711 :                 auto _Result = _RANGES _Mismatch_4(_RANGES _Unwrap_iter<_Se1>(_STD move(_First1)),
; 5712 :                     _RANGES _Unwrap_sent<_It1>(_STD move(_Last1)), _RANGES _Unwrap_iter<_Se2>(_STD move(_First2)),
; 5713 :                     _RANGES _Unwrap_sent<_It2>(_STD move(_Last2)), _STD _Pass_fn(_Pred), _STD _Pass_fn(_Proj1),
; 5714 :                     _STD _Pass_fn(_Proj2));
; 5715 :                 _STD _Seek_wrapped(_First1, _STD move(_Result.in1));
; 5716 :                 _STD _Seek_wrapped(_First2, _STD move(_Result.in2));
; 5717 :                 return {_STD move(_First1), _STD move(_First2)};
; 5718 :             }
; 5719 :         }
; 5720 : 
; 5721 :         template <input_range _Rng1, input_range _Rng2, class _Pr = ranges::equal_to, class _Pj1 = identity,
; 5722 :             class _Pj2 = identity>
; 5723 :             requires indirectly_comparable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Pr, _Pj1, _Pj2>
; 5724 :         _NODISCARD
; 5725 :             _STATIC_CALL_OPERATOR constexpr mismatch_result<borrowed_iterator_t<_Rng1>, borrowed_iterator_t<_Rng2>>
; 5726 :             operator()(_Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {},
; 5727 :                 _Pj2 _Proj2 = {}) _CONST_CALL_OPERATOR {
; 5728 :             if constexpr (sized_range<_Rng1> && sized_range<_Rng2>) {
; 5729 :                 range_difference_t<_Rng1> _Count1       = _RANGES distance(_Range1);
; 5730 :                 const range_difference_t<_Rng2> _Count2 = _RANGES distance(_Range2);
; 5731 :                 if (_Count1 > _Count2) {
; 5732 :                     _Count1 = static_cast<range_difference_t<_Rng1>>(_Count2);
; 5733 :                 }
; 5734 : 
; 5735 :                 auto _First1 = _RANGES begin(_Range1);
; 5736 :                 auto _First2 = _RANGES begin(_Range2);
; 5737 :                 auto _Result = _RANGES _Mismatch_n(_STD _Get_unwrapped(_STD move(_First1)),
; 5738 :                     _STD _Get_unwrapped(_STD move(_First2)), _Count1, _STD _Pass_fn(_Pred), _STD _Pass_fn(_Proj1),
; 5739 :                     _STD _Pass_fn(_Proj2));
; 5740 :                 _STD _Seek_wrapped(_First1, _STD move(_Result.in1));
; 5741 :                 _STD _Seek_wrapped(_First2, _STD move(_Result.in2));
; 5742 :                 return {_STD move(_First1), _STD move(_First2)};
; 5743 :             } else {
; 5744 :                 auto _First1 = _RANGES begin(_Range1);
; 5745 :                 auto _First2 = _RANGES begin(_Range2);
; 5746 :                 auto _Result = _RANGES _Mismatch_4(_RANGES _Unwrap_range_iter<_Rng1>(_STD move(_First1)),
; 5747 :                     _Uend(_Range1), _RANGES _Unwrap_range_iter<_Rng2>(_STD move(_First2)), _Uend(_Range2),
; 5748 :                     _STD _Pass_fn(_Pred), _STD _Pass_fn(_Proj1), _STD _Pass_fn(_Proj2));
; 5749 :                 _STD _Seek_wrapped(_First1, _STD move(_Result.in1));
; 5750 :                 _STD _Seek_wrapped(_First2, _STD move(_Result.in2));
; 5751 :                 return {_STD move(_First1), _STD move(_First2)};
; 5752 :             }
; 5753 :         }
; 5754 :     };
; 5755 : 
; 5756 :     _EXPORT_STD inline constexpr _Mismatch_fn mismatch;
; 5757 : } // namespace ranges
; 5758 : #endif // _HAS_CXX20
; 5759 : 
; 5760 : template <class _Elem1, class _Elem2>
; 5761 : constexpr bool _Lex_compare_memcmp_classify_elements =
; 5762 : #if _USE_STD_VECTOR_ALGORITHMS
; 5763 :     is_integral_v<_Elem1> && is_integral_v<_Elem2> && sizeof(_Elem1) == sizeof(_Elem2)
; 5764 :     && is_unsigned_v<_Elem1> == is_unsigned_v<_Elem2>;
; 5765 : #else // ^^^ _USE_STD_VECTOR_ALGORITHMS / !_USE_STD_VECTOR_ALGORITHMS vvv
; 5766 :     conjunction_v<_Is_character_or_bool<_Elem1>, _Is_character_or_bool<_Elem2>, is_unsigned<_Elem1>,
; 5767 :         is_unsigned<_Elem2>>;
; 5768 : #endif // ^^^ !_USE_STD_VECTOR_ALGORITHMS ^^^
; 5769 : 
; 5770 : #ifdef __cpp_lib_byte
; 5771 : template <>
; 5772 : inline constexpr bool _Lex_compare_memcmp_classify_elements<byte, byte> = true;
; 5773 : #endif // defined(__cpp_lib_byte)
; 5774 : 
; 5775 : template <class _Elem1, class _Elem2, class _Pr>
; 5776 : struct _Lex_compare_memcmp_classify_pred {
; 5777 :     using _Pred = void;
; 5778 : };
; 5779 : 
; 5780 : template <class _Elem1, class _Elem2, class _Elem3>
; 5781 : struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, less<_Elem3>> {
; 5782 :     using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem3, _Elem3>
; 5783 :                                     && _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible
; 5784 :                                     && _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible,
; 5785 :         less<int>, void>;
; 5786 : };
; 5787 : 
; 5788 : template <class _Elem1, class _Elem2>
; 5789 : struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, less<>> {
; 5790 :     using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, less<int>, void>;
; 5791 : };
; 5792 : 
; 5793 : template <class _Elem1, class _Elem2, class _Elem3>
; 5794 : struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, greater<_Elem3>> {
; 5795 :     using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem3, _Elem3>
; 5796 :                                     && _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible
; 5797 :                                     && _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible,
; 5798 :         greater<int>, void>;
; 5799 : };
; 5800 : 
; 5801 : template <class _Elem1, class _Elem2>
; 5802 : struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, greater<>> {
; 5803 :     using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, greater<int>, void>;
; 5804 : };
; 5805 : 
; 5806 : #if _HAS_CXX20
; 5807 : template <class _Elem1, class _Elem2>
; 5808 : struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, _RANGES less> {
; 5809 :     using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, less<int>, void>;
; 5810 : };
; 5811 : 
; 5812 : template <class _Elem1, class _Elem2>
; 5813 : struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, _RANGES greater> {
; 5814 :     using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, greater<int>, void>;
; 5815 : };
; 5816 : #endif // _HAS_CXX20
; 5817 : 
; 5818 : template <class _It1, class _It2, class _Pr>
; 5819 : using _Lex_compare_memcmp_classify =
; 5820 :     conditional_t<_Iterators_are_contiguous<_It1, _It2> && !_Iterator_is_volatile<_It1> && !_Iterator_is_volatile<_It2>,
; 5821 :         typename _Lex_compare_memcmp_classify_pred<_Iter_value_t<_It1>, _Iter_value_t<_It2>, _Pr>::_Pred, void>;
; 5822 : 
; 5823 : _EXPORT_STD template <class _InIt1, class _InIt2, class _Pr>
; 5824 : _NODISCARD _CONSTEXPR20 bool lexicographical_compare(
; 5825 :     const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
; 5826 :     // order [_First1, _Last1) vs. [_First2, _Last2)
; 5827 :     _STD _Adl_verify_range(_First1, _Last1);
; 5828 :     _STD _Adl_verify_range(_First2, _Last2);
; 5829 :     auto _UFirst1      = _STD _Get_unwrapped(_First1);
; 5830 :     const auto _ULast1 = _STD _Get_unwrapped(_Last1);
; 5831 :     auto _UFirst2      = _STD _Get_unwrapped(_First2);
; 5832 :     const auto _ULast2 = _STD _Get_unwrapped(_Last2);
; 5833 : 
; 5834 :     using _Memcmp_pred = _Lex_compare_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Pr>;
; 5835 :     if constexpr (!is_void_v<_Memcmp_pred>) {
; 5836 : #if _HAS_CXX20
; 5837 :         if (!_STD is_constant_evaluated())
; 5838 : #endif // _HAS_CXX20
; 5839 :         {
; 5840 :             const auto _Num1  = static_cast<size_t>(_ULast1 - _UFirst1);
; 5841 :             const auto _Num2  = static_cast<size_t>(_ULast2 - _UFirst2);
; 5842 :             const size_t _Num = (_STD min)(_Num1, _Num2);
; 5843 : #if _USE_STD_VECTOR_ALGORITHMS
; 5844 :             const auto _First1_ptr = _STD _To_address(_UFirst1);
; 5845 :             const auto _First2_ptr = _STD _To_address(_UFirst2);
; 5846 :             const size_t _Pos      = _Mismatch_vectorized<sizeof(*_First1_ptr)>(_First1_ptr, _First2_ptr, _Num);
; 5847 :             if (_Pos == _Num2) {
; 5848 :                 return false;
; 5849 :             } else if (_Pos == _Num1) {
; 5850 :                 return true;
; 5851 :             } else {
; 5852 :                 return _Pred(_First1_ptr[_Pos], _First2_ptr[_Pos]);
; 5853 :             }
; 5854 : #else // ^^^ _USE_STD_VECTOR_ALGORITHMS / !_USE_STD_VECTOR_ALGORITHMS vvv
; 5855 :             const int _Ans = _STD _Memcmp_count(_UFirst1, _UFirst2, _Num);
; 5856 :             return _Memcmp_pred{}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2);
; 5857 : #endif // ^^^ !_USE_STD_VECTOR_ALGORITHMS ^^^
; 5858 :         }
; 5859 :     }
; 5860 : 
; 5861 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it
; 5862 :         if (_DEBUG_LT_PRED(_Pred, *_UFirst1, *_UFirst2)) {
; 5863 :             return true;
; 5864 :         } else if (_Pred(*_UFirst2, *_UFirst1)) {
; 5865 :             return false;
; 5866 :         }
; 5867 :     }
; 5868 : 
; 5869 :     return _UFirst1 == _ULast1 && _UFirst2 != _ULast2;
; 5870 : }
; 5871 : 
; 5872 : _EXPORT_STD template <class _InIt1, class _InIt2>
; 5873 : _NODISCARD _CONSTEXPR20 bool lexicographical_compare(
; 5874 :     const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
; 5875 :     // order [_First1, _Last1) vs. [_First2, _Last2)
; 5876 :     return _STD lexicographical_compare(_First1, _Last1, _First2, _Last2, less<>{});
; 5877 : }
; 5878 : 
; 5879 : #if _HAS_CXX17
; 5880 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5881 : _NODISCARD bool lexicographical_compare(_ExPo&&, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
; 5882 :     const _FwdIt2 _Last2, _Pr _Pred) noexcept /* terminates */ {
; 5883 :     // order [_First1, _Last1) vs. [_First2, _Last2)
; 5884 :     // not parallelized at present, parallelism expected to be feasible in a future release
; 5885 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
; 5886 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt2);
; 5887 :     return _STD lexicographical_compare(_First1, _Last1, _First2, _Last2, _STD _Pass_fn(_Pred));
; 5888 : }
; 5889 : 
; 5890 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5891 : _NODISCARD bool lexicographical_compare(_ExPo&&, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
; 5892 :     const _FwdIt2 _Last2) noexcept /* terminates */ {
; 5893 :     // order [_First1, _Last1) vs. [_First2, _Last2)
; 5894 :     // not parallelized at present, parallelism expected to be feasible in a future release
; 5895 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
; 5896 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt2);
; 5897 :     return _STD lexicographical_compare(_First1, _Last1, _First2, _Last2);
; 5898 : }
; 5899 : #endif // _HAS_CXX17
; 5900 : 
; 5901 : #if _HAS_CXX20
; 5902 : template <class _Elem1, class _Elem2, class _Cmp>
; 5903 : struct _Lex_compare_three_way_memcmp_classify_comp {
; 5904 :     using _Comp = void;
; 5905 : };
; 5906 : 
; 5907 : template <class _Elem1, class _Elem2>
; 5908 : struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, compare_three_way> {
; 5909 :     using _Comp = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>
; 5910 :                                     && three_way_comparable_with<const _Elem1&, const _Elem2&>,
; 5911 :         compare_three_way, void>;
; 5912 : };
; 5913 : 
; 5914 : template <class _Elem1, class _Elem2>
; 5915 : struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, _Synth_three_way> {
; 5916 :     using _Comp = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>
; 5917 :                                     && three_way_comparable_with<const _Elem1&, const _Elem2&>,
; 5918 :         _Synth_three_way, void>;
; 5919 : };
; 5920 : 
; 5921 : template <class _Elem1, class _Elem2>
; 5922 : struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, _Strong_order::_Cpo> {
; 5923 :     using _Comp =
; 5924 :         conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2> && _Can_strong_order<_Elem1, _Elem2>,
; 5925 :             _Strong_order::_Cpo, void>;
; 5926 : };
; 5927 : 
; 5928 : template <class _Elem1, class _Elem2>
; 5929 : struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, _Weak_order::_Cpo> {
; 5930 :     using _Comp =
; 5931 :         conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2> && _Can_weak_order<_Elem1, _Elem2>,
; 5932 :             _Weak_order::_Cpo, void>;
; 5933 : };
; 5934 : 
; 5935 : template <class _Elem1, class _Elem2>
; 5936 : struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, _Partial_order::_Cpo> {
; 5937 :     using _Comp =
; 5938 :         conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2> && _Can_partial_order<_Elem1, _Elem2>,
; 5939 :             _Partial_order::_Cpo, void>;
; 5940 : };
; 5941 : 
; 5942 : template <class _It1, class _It2, class _Cmp>
; 5943 : using _Lex_compare_three_way_memcmp_classify =
; 5944 :     conditional_t<_Iterators_are_contiguous<_It1, _It2> && !_Iterator_is_volatile<_It1> && !_Iterator_is_volatile<_It2>,
; 5945 :         typename _Lex_compare_three_way_memcmp_classify_comp<_Iter_value_t<_It1>, _Iter_value_t<_It2>, _Cmp>::_Comp,
; 5946 :         void>;
; 5947 : 
; 5948 : _EXPORT_STD template <class _InIt1, class _InIt2, class _Cmp>
; 5949 : _NODISCARD constexpr auto lexicographical_compare_three_way(const _InIt1 _First1, const _InIt1 _Last1,
; 5950 :     const _InIt2 _First2, const _InIt2 _Last2, _Cmp _Comp) -> decltype(_Comp(*_First1, *_First2)) {
; 5951 :     static_assert(
; 5952 :         _Classify_category<decltype(_Comp(*_First1, *_First2))> != _Comparison_category::_Comparison_category_none,
; 5953 :         "The result of the comparator must have comparison category type (N4988 [alg.three.way]/2).");
; 5954 : 
; 5955 :     _STD _Adl_verify_range(_First1, _Last1);
; 5956 :     _STD _Adl_verify_range(_First2, _Last2);
; 5957 :     auto _UFirst1      = _STD _Get_unwrapped(_First1);
; 5958 :     const auto _ULast1 = _STD _Get_unwrapped(_Last1);
; 5959 :     auto _UFirst2      = _STD _Get_unwrapped(_First2);
; 5960 :     const auto _ULast2 = _STD _Get_unwrapped(_Last2);
; 5961 : 
; 5962 :     using _Memcmp_pred = _Lex_compare_three_way_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Cmp>;
; 5963 :     if constexpr (!is_void_v<_Memcmp_pred>) {
; 5964 :         if (!_STD is_constant_evaluated()) {
; 5965 :             const auto _Num1  = static_cast<size_t>(_ULast1 - _UFirst1);
; 5966 :             const auto _Num2  = static_cast<size_t>(_ULast2 - _UFirst2);
; 5967 :             const size_t _Num = (_STD min)(_Num1, _Num2);
; 5968 : #if _USE_STD_VECTOR_ALGORITHMS
; 5969 :             const auto _First1_ptr = _STD to_address(_UFirst1);
; 5970 :             const auto _First2_ptr = _STD to_address(_UFirst2);
; 5971 :             const size_t _Pos      = _Mismatch_vectorized<sizeof(*_First1_ptr)>(_First1_ptr, _First2_ptr, _Num);
; 5972 :             if (_Pos == _Num1) {
; 5973 :                 return _Pos == _Num2 ? strong_ordering::equal : strong_ordering::less;
; 5974 :             } else if (_Pos == _Num2) {
; 5975 :                 return strong_ordering::greater;
; 5976 :             } else {
; 5977 :                 const auto _Val1 = _First1_ptr[_Pos];
; 5978 :                 const auto _Val2 = _First2_ptr[_Pos];
; 5979 :                 __assume(_Val1 != _Val2); // avoid one comparison
; 5980 :                 return _Comp(_Val1, _Val2);
; 5981 :             }
; 5982 : #else // ^^^ _USE_STD_VECTOR_ALGORITHMS / !_USE_STD_VECTOR_ALGORITHMS vvv
; 5983 :             const int _Ans = _STD _Memcmp_count(_UFirst1, _UFirst2, _Num);
; 5984 :             if (_Ans == 0) {
; 5985 :                 return _Num1 <=> _Num2;
; 5986 :             } else {
; 5987 :                 return _Memcmp_pred{}(_Ans, 0);
; 5988 :             }
; 5989 : #endif // ^^^ !_USE_STD_VECTOR_ALGORITHMS ^^^
; 5990 :         }
; 5991 :     }
; 5992 : 
; 5993 :     for (;;) {
; 5994 :         if (_UFirst1 == _ULast1) {
; 5995 :             return _UFirst2 == _ULast2 ? strong_ordering::equal : strong_ordering::less;
; 5996 :         }
; 5997 : 
; 5998 :         if (_UFirst2 == _ULast2) {
; 5999 :             return strong_ordering::greater;
; 6000 :         }
; 6001 : 
; 6002 :         if (const auto _CmpResult = _Comp(*_UFirst1, *_UFirst2); _CmpResult != 0) {
; 6003 :             return _CmpResult;
; 6004 :         }
; 6005 : 
; 6006 :         ++_UFirst1;
; 6007 :         ++_UFirst2;
; 6008 :     }
; 6009 : }
; 6010 : 
; 6011 : _EXPORT_STD template <class _InIt1, class _InIt2>
; 6012 : _NODISCARD constexpr auto lexicographical_compare_three_way(
; 6013 :     const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
; 6014 :     return _STD lexicographical_compare_three_way(_First1, _Last1, _First2, _Last2, compare_three_way{});
; 6015 : }
; 6016 : #endif // _HAS_CXX20
; 6017 : 
; 6018 : template <class _Ty, class _Elem>
; 6019 : struct _Vector_alg_in_find_is_safe_object_pointers : false_type {};
; 6020 : template <class _Ty1, class _Ty2>
; 6021 : struct _Vector_alg_in_find_is_safe_object_pointers<_Ty1*, _Ty2*>
; 6022 :     : conjunction<
; 6023 :           // _Ty1* is an object pointer type
; 6024 :           disjunction<is_object<_Ty1>, is_void<_Ty1>>,
; 6025 :           // _Ty2* is an object pointer type
; 6026 :           disjunction<is_object<_Ty2>, is_void<_Ty2>>,
; 6027 :           // either _Ty1 is the same as _Ty2 (ignoring cv-qualifiers), or one of the two is void
; 6028 :           disjunction<is_same<remove_cv_t<_Ty1>, remove_cv_t<_Ty2>>, is_void<_Ty1>, is_void<_Ty2>>> {};
; 6029 : 
; 6030 : // Can we activate the vector algorithms to find a value in a range of elements?
; 6031 : template <class _Ty, class _Elem>
; 6032 : constexpr bool _Vector_alg_in_find_is_safe_elem = disjunction_v<
; 6033 : #ifdef __cpp_lib_byte
; 6034 :     // We're finding a std::byte in a range of std::byte.
; 6035 :     conjunction<is_same<_Ty, byte>, is_same<_Elem, byte>>,
; 6036 : #endif // defined(__cpp_lib_byte)
; 6037 :     // We're finding an integer in a range of integers.
; 6038 :     // This case is the one that requires careful runtime handling in _Could_compare_equal_to_value_type.
; 6039 :     conjunction<is_integral<_Ty>, is_integral<_Elem>>,
; 6040 :     // We're finding an (object or function) pointer in a range of pointers of the same type.
; 6041 :     conjunction<is_pointer<_Ty>, is_same<_Ty, _Elem>>,
; 6042 :     // We're finding a nullptr in a range of (object or function) pointers.
; 6043 :     conjunction<is_same<_Ty, nullptr_t>, is_pointer<_Elem>>,
; 6044 :     // We're finding an object pointer in a range of object pointers, and:
; 6045 :     // - One of the pointer types is a cv void*.
; 6046 :     // - One of the pointer types is a cv1 U* and the other is a cv2 U*.
; 6047 :     _Vector_alg_in_find_is_safe_object_pointers<_Ty, _Elem>>;
; 6048 : 
; 6049 : // Can we activate the vector algorithms for find/count?
; 6050 : template <class _Iter, class _Ty>
; 6051 : constexpr bool _Vector_alg_in_find_is_safe =
; 6052 :     // The iterator must be contiguous so we can get raw pointers.
; 6053 :     _Iterator_is_contiguous<_Iter>
; 6054 :     // The iterator must not be volatile.
; 6055 :     && !_Iterator_is_volatile<_Iter>
; 6056 :     // The type of the value to find must be compatible with the type of the elements.
; 6057 :     && _Vector_alg_in_find_is_safe_elem<_Ty, _Iter_value_t<_Iter>>;
; 6058 : 
; 6059 : template <class _InIt, class _Ty>
; 6060 : _NODISCARD constexpr bool _Could_compare_equal_to_value_type(const _Ty& _Val) {
; 6061 :     // check whether _Val is within the limits of _Elem
; 6062 :     _STL_INTERNAL_STATIC_ASSERT(_Vector_alg_in_find_is_safe<_InIt, _Ty>);
; 6063 : 
; 6064 :     if constexpr (disjunction_v<
; 6065 : #ifdef __cpp_lib_byte
; 6066 :                       is_same<_Ty, byte>,
; 6067 : #endif // defined(__cpp_lib_byte)
; 6068 :                       is_same<_Ty, bool>, is_pointer<_Ty>, is_same<_Ty, nullptr_t>>) {
; 6069 :         return true;
; 6070 :     } else {
; 6071 :         using _Elem = _Iter_value_t<_InIt>;
; 6072 :         _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Elem> && is_integral_v<_Ty>);
; 6073 : 
; 6074 :         if constexpr (is_same_v<_Elem, bool>) {
; 6075 :             return _Val == true || _Val == false;
; 6076 :         } else if constexpr (is_signed_v<_Elem>) {
; 6077 :             constexpr _Elem _Min = _STD _Min_limit<_Elem>();
; 6078 :             constexpr _Elem _Max = _STD _Max_limit<_Elem>();
; 6079 : 
; 6080 :             if constexpr (is_signed_v<_Ty>) {
; 6081 :                 // signed _Elem, signed _Ty
; 6082 :                 return _Min <= _Val && _Val <= _Max;
; 6083 :             } else {
; 6084 :                 // signed _Elem, unsigned _Ty
; 6085 :                 if constexpr (_Elem{-1} == static_cast<_Ty>(-1)) {
; 6086 :                     // negative values of _Elem can compare equal to values of _Ty
; 6087 :                     return _Val <= _Max || static_cast<_Ty>(_Min) <= _Val;
; 6088 :                 } else {
; 6089 :                     // negative values of _Elem cannot compare equal to values of _Ty
; 6090 :                     return _Val <= _Max;
; 6091 :                 }
; 6092 :             }
; 6093 :         } else {
; 6094 :             constexpr _Elem _Max = _STD _Max_limit<_Elem>();
; 6095 : 
; 6096 :             if constexpr (is_unsigned_v<_Ty>) {
; 6097 :                 // unsigned _Elem, unsigned _Ty
; 6098 :                 return _Val <= _Max;
; 6099 :             } else {
; 6100 :                 // unsigned _Elem, signed _Ty
; 6101 :                 if constexpr (_Ty{-1} == static_cast<_Elem>(-1)) {
; 6102 :                     // negative values of _Ty can compare equal to values of _Elem
; 6103 :                     return _Val <= _Max;
; 6104 :                 } else {
; 6105 :                     // negative values of _Ty cannot compare equal to values of _Elem
; 6106 :                     return 0 <= _Val && _Val <= _Max;
; 6107 :                 }
; 6108 :             }
; 6109 :         }
; 6110 :     }
; 6111 : }
; 6112 : 
; 6113 : template <class _InIt, class _Ty>
; 6114 : _NODISCARD _CONSTEXPR20 _InIt _Find_unchecked(_InIt _First, const _InIt _Last, const _Ty& _Val) {
; 6115 :     // find first matching _Val; choose optimization
; 6116 :     // activate optimization for contiguous iterators to most scalar types (possibly const-qualified)
; 6117 :     if constexpr (_Vector_alg_in_find_is_safe<_InIt, _Ty>) {
; 6118 : #if _HAS_CXX20
; 6119 :         if (!_STD is_constant_evaluated())
; 6120 : #endif // _HAS_CXX20
; 6121 :         {
; 6122 :             if (!_STD _Could_compare_equal_to_value_type<_InIt>(_Val)) {
; 6123 :                 return _Last;
; 6124 :             }
; 6125 : #if _USE_STD_VECTOR_ALGORITHMS
; 6126 :             const auto _First_ptr = _STD _To_address(_First);
; 6127 :             const auto _Result    = _STD _Find_vectorized(_First_ptr, _STD _To_address(_Last), _Val);
; 6128 :             if constexpr (is_pointer_v<_InIt>) {
; 6129 :                 return _Result;
; 6130 :             } else {
; 6131 :                 return _First + (_Result - _First_ptr);
; 6132 :             }
; 6133 : #else // ^^^ _USE_STD_VECTOR_ALGORITHMS / !_USE_STD_VECTOR_ALGORITHMS vvv
; 6134 :             if constexpr (sizeof(_Iter_value_t<_InIt>) <= 2) {
; 6135 :                 const auto _First_ptr = _STD _To_address(_First);
; 6136 :                 const auto _Count     = static_cast<size_t>(_Last - _First);
; 6137 : 
; 6138 :                 using _Ptr_t = remove_reference_t<_Iter_ref_t<_InIt>>*;
; 6139 :                 _Ptr_t _Result;
; 6140 : 
; 6141 :                 if constexpr (sizeof(_Iter_value_t<_InIt>) == 1) {
; 6142 :                     _Result = static_cast<_Ptr_t>(_CSTD memchr(_First_ptr, static_cast<unsigned char>(_Val), _Count));
; 6143 :                 } else {
; 6144 :                     _STL_INTERNAL_STATIC_ASSERT(sizeof(_Iter_value_t<_InIt>) == 2);
; 6145 :                     _Result = reinterpret_cast<_Ptr_t>(const_cast<wchar_t*>(_CSTD wmemchr(
; 6146 :                         reinterpret_cast<const wchar_t*>(_First_ptr), static_cast<wchar_t>(_Val), _Count)));
; 6147 :                 }
; 6148 : 
; 6149 :                 if constexpr (is_pointer_v<_InIt>) {
; 6150 :                     return _Result ? _Result : _Last;
; 6151 :                 } else {
; 6152 :                     return _Result ? _First + (_Result - _First_ptr) : _Last;
; 6153 :                 }
; 6154 :             }
; 6155 : #endif // ^^^ !_USE_STD_VECTOR_ALGORITHMS ^^^
; 6156 :         }
; 6157 :     }
; 6158 : 
; 6159 :     for (; _First != _Last; ++_First) {

  0019c	83 c6 18	 add	 esi, 24			; 00000018H
  0019f	3b f7		 cmp	 esi, edi
  001a1	75 bd		 jne	 SHORT $LL71@ListAndWip
$LN1002@ListAndWip:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 166  :         return _Ptr == _Right._Ptr;

  001a3	3b 35 04 00 00
	00		 cmp	 esi, DWORD PTR ?allowedExecutables@?1??ListAndWipeProcess@@YAXXZ@4V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@B+4
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 186  :             if (std::find(allowedExecutables.begin(), allowedExecutables.end(), exe) != allowedExecutables.end()) {

  001a9	0f 84 d2 00 00
	00		 je	 $LN8@ListAndWip

; 187  :                 std::wcout << index << ". " << exe << " (PID: " << pe32.th32ProcessID << ")\n";

  001af	8b b5 c4 fa ff
	ff		 mov	 esi, DWORD PTR _index$1$[ebp]
  001b5	b9 00 00 00 00	 mov	 ecx, OFFSET ?wcout@std@@3V?$basic_ostream@_WU?$char_traits@_W@std@@@1@A ; std::wcout
  001ba	68 00 00 00 00	 push	 OFFSET ??_C@_02KHOJGJKF@?4?5@
  001bf	56		 push	 esi
  001c0	e8 00 00 00 00	 call	 ??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@H@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::operator<<
  001c5	50		 push	 eax
  001c6	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  001cb	83 bd e4 fd ff
	ff 07		 cmp	 DWORD PTR _exe$10[ebp+20], 7
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 187  :                 std::wcout << index << ". " << exe << " (PID: " << pe32.th32ProcessID << ")\n";

  001d2	8b c8		 mov	 ecx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3446 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

  001d4	ff b5 e0 fd ff
	ff		 push	 DWORD PTR _exe$10[ebp+16]

; 444  :         const value_type* _Result = _Bx._Buf;

  001da	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _exe$10[ebp]

; 445  :         if (_Large_mode_engaged()) {

  001e0	0f 47 85 d0 fd
	ff ff		 cmova	 eax, DWORD PTR _exe$10[ebp]

; 3446 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

  001e7	50		 push	 eax
  001e8	51		 push	 ecx
  001e9	e8 00 00 00 00	 call	 ??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z ; std::_Insert_string<wchar_t,std::char_traits<wchar_t>,unsigned int>
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 187  :                 std::wcout << index << ". " << exe << " (PID: " << pe32.th32ProcessID << ")\n";

  001ee	68 00 00 00 00	 push	 OFFSET ??_C@_07GOJKIMHK@?5?$CIPID?3?5@
  001f3	50		 push	 eax
  001f4	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
  001f9	83 c4 1c	 add	 esp, 28			; 0000001cH
  001fc	8b c8		 mov	 ecx, eax
  001fe	68 00 00 00 00	 push	 OFFSET ??_C@_02MNMNLDAI@?$CJ?6@
  00203	ff b5 d4 fa ff
	ff		 push	 DWORD PTR _pe32$[ebp+8]
  00209	e8 00 00 00 00	 call	 ??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::operator<<
  0020e	50		 push	 eax
  0020f	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 844  :         if (_Mylast != _My_data._Myend) {

  00214	8b 85 ac fa ff
	ff		 mov	 eax, DWORD PTR _processNames$[ebp+4]
  0021a	8d 8d d0 fd ff
	ff		 lea	 ecx, DWORD PTR _exe$10[ebp]
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 187  :                 std::wcout << index << ". " << exe << " (PID: " << pe32.th32ProcessID << ")\n";

  00220	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 844  :         if (_Mylast != _My_data._Myend) {

  00223	51		 push	 ecx
  00224	3b 85 b0 fa ff
	ff		 cmp	 eax, DWORD PTR _processNames$[ebp+8]
  0022a	74 10		 je	 SHORT $LN178@ListAndWip
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0022c	8b c8		 mov	 ecx, eax
  0022e	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 869  :         ++_Mylast;

  00233	83 85 ac fa ff
	ff 18		 add	 DWORD PTR _processNames$[ebp+4], 24 ; 00000018H

; 845  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0023a	eb 0c		 jmp	 SHORT $LN177@ListAndWip
$LN178@ListAndWip:

; 846  :         }
; 847  : 
; 848  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0023c	50		 push	 eax
  0023d	8d 8d a8 fa ff
	ff		 lea	 ecx, DWORD PTR _processNames$[ebp]
  00243	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &>
$LN177@ListAndWip:

; 844  :         if (_Mylast != _My_data._Myend) {

  00248	8b 8d 9c fa ff
	ff		 mov	 ecx, DWORD PTR _processIds$[ebp+4]
  0024e	3b 8d a0 fa ff
	ff		 cmp	 ecx, DWORD PTR _processIds$[ebp+8]
  00254	74 11		 je	 SHORT $LN187@ListAndWip

; 860  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  00256	8b 85 d4 fa ff
	ff		 mov	 eax, DWORD PTR _pe32$[ebp+8]
  0025c	89 01		 mov	 DWORD PTR [ecx], eax

; 869  :         ++_Mylast;

  0025e	83 85 9c fa ff
	ff 04		 add	 DWORD PTR _processIds$[ebp+4], 4

; 845  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00265	eb 13		 jmp	 SHORT $LN186@ListAndWip
$LN187@ListAndWip:

; 846  :         }
; 847  : 
; 848  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00267	8d 85 d4 fa ff
	ff		 lea	 eax, DWORD PTR _pe32$[ebp+8]
  0026d	50		 push	 eax
  0026e	51		 push	 ecx
  0026f	8d 8d 98 fa ff
	ff		 lea	 ecx, DWORD PTR _processIds$[ebp]
  00275	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@AAEPAKQAKABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_reallocate<unsigned long const &>
$LN186@ListAndWip:
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 190  :                 ++index;

  0027a	46		 inc	 esi
  0027b	89 b5 c4 fa ff
	ff		 mov	 DWORD PTR _index$1$[ebp], esi
$LN8@ListAndWip:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00281	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR _exe$10[ebp+20]
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 192  :         } while (Process32Next(hSnap, &pe32));

  00287	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  0028b	83 f9 07	 cmp	 ecx, 7

; 3083 :         if (_My_data._Large_mode_engaged()) {

  0028e	76 35		 jbe	 SHORT $LN139@ListAndWip
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00290	8b 95 d0 fd ff
	ff		 mov	 edx, DWORD PTR _exe$10[ebp]
  00296	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]
  0029d	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0029f	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  002a5	72 14		 jb	 SHORT $LN144@ListAndWip

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  002a7	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  002aa	83 c1 23	 add	 ecx, 35			; 00000023H
  002ad	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  002af	83 c0 fc	 add	 eax, -4			; fffffffcH
  002b2	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  002b5	0f 87 34 0a 00
	00		 ja	 $LN245@ListAndWip
$LN144@ListAndWip:

; 289  :         ::operator delete(_Ptr, _Bytes);

  002bb	51		 push	 ecx
  002bc	52		 push	 edx
  002bd	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  002c2	83 c4 08	 add	 esp, 8
$LN139@ListAndWip:
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 192  :         } while (Process32Next(hSnap, &pe32));

  002c5	8b b5 b8 fa ff
	ff		 mov	 esi, DWORD PTR _hSnap$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  002cb	33 c0		 xor	 eax, eax
  002cd	66 89 85 d0 fd
	ff ff		 mov	 WORD PTR _exe$10[ebp], ax
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 192  :         } while (Process32Next(hSnap, &pe32));

  002d4	8d 85 cc fa ff
	ff		 lea	 eax, DWORD PTR _pe32$[ebp]
  002da	50		 push	 eax
  002db	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3090 :         _My_data._Mysize = 0;

  002dc	c7 85 e0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _exe$10[ebp+16], 0

; 3091 :         _My_data._Myres  = _Small_string_capacity;

  002e6	c7 85 e4 fd ff
	ff 07 00 00 00	 mov	 DWORD PTR _exe$10[ebp+20], 7
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 192  :         } while (Process32Next(hSnap, &pe32));

  002f0	e8 00 00 00 00	 call	 _Process32NextW@8
  002f5	85 c0		 test	 eax, eax
  002f7	0f 85 03 fe ff
	ff		 jne	 $LL5@ListAndWip
$LN4@ListAndWip:

; 193  :     }
; 194  :     CloseHandle(hSnap);

  002fd	56		 push	 esi
  002fe	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CloseHandle@4
  00304	89 b5 c4 fa ff
	ff		 mov	 DWORD PTR tv3261[ebp], esi
  0030a	ff d6		 call	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 1910 :         return _My_data._Myfirst == _My_data._Mylast;

  0030c	8b 85 a8 fa ff
	ff		 mov	 eax, DWORD PTR _processNames$[ebp]
  00312	3b 85 ac fa ff
	ff		 cmp	 eax, DWORD PTR _processNames$[ebp+4]
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 196  :     if (processNames.empty()) {

  00318	75 0a		 jne	 SHORT $LN9@ListAndWip

; 197  :         std::cout << "No allowed anti-cheat processes found\n";

  0031a	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@DBEMKEBP@No?5allowed?5anti?9cheat?5processes@
  0031f	e9 6d 06 00 00	 jmp	 $LN1011@ListAndWip
$LN9@ListAndWip:

; 198  :         return;
; 199  :     }
; 200  : 
; 201  :     int selection = 0;
; 202  :     std::cout << "Select process to terminate and wipe (0 to cancel): ";

  00324	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@OBKIMPA@Select?5process?5to?5terminate?5and@
  00329	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  0032e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00333	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 271  :         long _Result = _Val;

  00336	c7 85 c0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR __Result$6[ebp], 0

; 272  :         _Common_extract_with_num_get(_Result);

  00340	8d 85 c0 fa ff
	ff		 lea	 eax, DWORD PTR __Result$6[ebp]
  00346	b9 00 00 00 00	 mov	 ecx, OFFSET ?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A ; std::cin
  0034b	50		 push	 eax
  0034c	e8 00 00 00 00	 call	 ??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z ; std::basic_istream<char,std::char_traits<char> >::_Common_extract_with_num_get<long>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 214  :         return rdstate() & (ios_base::badbit | ios_base::failbit);

  00351	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  00356	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00359	89 8d bc fa ff
	ff		 mov	 DWORD PTR tv3244[ebp], ecx
  0035f	f6 81 0c 00 00
	00 06		 test	 BYTE PTR ?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A[ecx+12], 6
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 205  :     if (std::cin.fail() || selection <= 0 || selection > (int)processNames.size()) {

  00366	0f 85 eb 05 00
	00		 jne	 $LN11@ListAndWip
  0036c	8b bd c0 fa ff
	ff		 mov	 edi, DWORD PTR __Result$6[ebp]
  00372	85 ff		 test	 edi, edi
  00374	0f 8e dd 05 00
	00		 jle	 $LN11@ListAndWip
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 1915 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0037a	8b 85 a8 fa ff
	ff		 mov	 eax, DWORD PTR _processNames$[ebp]
  00380	8b 8d ac fa ff
	ff		 mov	 ecx, DWORD PTR _processNames$[ebp+4]
  00386	2b c8		 sub	 ecx, eax
  00388	89 85 b8 fa ff
	ff		 mov	 DWORD PTR _processNames$1$[ebp], eax
  0038e	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00393	f7 e9		 imul	 ecx
  00395	c1 fa 02	 sar	 edx, 2
  00398	8b c2		 mov	 eax, edx
  0039a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0039d	03 c2		 add	 eax, edx
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 205  :     if (std::cin.fail() || selection <= 0 || selection > (int)processNames.size()) {

  0039f	3b f8		 cmp	 edi, eax
  003a1	0f 8f aa 05 00
	00		 jg	 $LN1007@ListAndWip

; 209  :         return;
; 210  :     }
; 211  : 
; 212  :     DWORD pid = processIds[selection - 1];

  003a7	0f ae e8	 lfence
  003aa	8b 85 98 fa ff
	ff		 mov	 eax, DWORD PTR _processIds$[ebp]

; 213  :     std::wstring exeName = processNames[selection - 1];

  003b0	8b 8d b8 fa ff
	ff		 mov	 ecx, DWORD PTR _processNames$1$[ebp]
  003b6	8b 44 b8 fc	 mov	 eax, DWORD PTR [eax+edi*4-4]
  003ba	89 85 a4 fa ff
	ff		 mov	 DWORD PTR _pid$[ebp], eax
  003c0	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  003c3	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  003c6	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  003c9	50		 push	 eax
  003ca	8d 8d f8 fc ff
	ff		 lea	 ecx, DWORD PTR _exeName$[ebp]
  003d0	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >

; 214  : 
; 215  :     // --- Driver-assisted kill & wipe ---
; 216  :     if (g_ServiceInstalled) {

  003d5	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?g_ServiceInstalled@@3_NA, 0 ; g_ServiceInstalled
  003dc	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  003e0	74 52		 je	 SHORT $LN14@ListAndWip

; 217  :         if (SendIoctl(IOCTL_KILL_AND_WIPE_PROCESS, &pid, sizeof(pid))) {

  003e2	6a 00		 push	 0
  003e4	6a 00		 push	 0
  003e6	6a 04		 push	 4
  003e8	8d 85 a4 fa ff
	ff		 lea	 eax, DWORD PTR _pid$[ebp]
  003ee	50		 push	 eax
  003ef	68 08 20 22 00	 push	 2236424			; 00222008H
  003f4	e8 00 00 00 00	 call	 ?SendIoctl@@YA_NKPAXK0K@Z ; SendIoctl
  003f9	83 c4 14	 add	 esp, 20			; 00000014H
  003fc	84 c0		 test	 al, al
  003fe	74 07		 je	 SHORT $LN13@ListAndWip

; 218  :             std::wcout << L"Driver: Kill & Wipe request sent for PID " << pid << L"\n";

  00400	68 00 00 00 00	 push	 OFFSET ??_C@_1FE@ILHKNOOP@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?3?$AA?5?$AAK?$AAi?$AAl?$AAl?$AA?5?$AA?$CG?$AA?5@

; 219  :         } else {

  00405	eb 05		 jmp	 SHORT $LN1012@ListAndWip
$LN13@ListAndWip:

; 220  :             std::wcout << L"Driver: Kill & Wipe request failed for PID " << pid << L"\n";

  00407	68 00 00 00 00	 push	 OFFSET ??_C@_1FI@FBPFGPFA@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?3?$AA?5?$AAK?$AAi?$AAl?$AAl?$AA?5?$AA?$CG?$AA?5@
$LN1012@ListAndWip:

; 221  :         }
; 222  :     }
; 223  : 
; 224  :     // --- User-mode backup and wipe ---
; 225  :     HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_TERMINATE, FALSE, pid);

  0040c	68 00 00 00 00	 push	 OFFSET ?wcout@std@@3V?$basic_ostream@_WU?$char_traits@_W@std@@@1@A ; std::wcout
  00411	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
  00416	83 c4 08	 add	 esp, 8
  00419	8b c8		 mov	 ecx, eax
  0041b	68 00 00 00 00	 push	 OFFSET ??_C@_13LBAGMAIH@?$AA?6@
  00420	ff b5 a4 fa ff
	ff		 push	 DWORD PTR _pid$[ebp]
  00426	e8 00 00 00 00	 call	 ??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::operator<<
  0042b	50		 push	 eax
  0042c	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
  00431	83 c4 08	 add	 esp, 8
$LN14@ListAndWip:
  00434	ff b5 a4 fa ff
	ff		 push	 DWORD PTR _pid$[ebp]
  0043a	6a 00		 push	 0
  0043c	68 11 04 00 00	 push	 1041			; 00000411H
  00441	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenProcess@12
  00447	8b f8		 mov	 edi, eax
  00449	89 bd c0 fa ff
	ff		 mov	 DWORD PTR _hProcess$1$[ebp], edi

; 226  :     if (!hProcess) {

  0044f	85 ff		 test	 edi, edi
  00451	75 22		 jne	 SHORT $LN15@ListAndWip

; 227  :         std::cout << "Failed to open process for query and termination\n";

  00453	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@ILHIMEPI@Failed?5to?5open?5process?5for?5quer@
  00458	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  0045d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00462	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1383 :         _Tidy_deallocate();

  00465	8d 8d f8 fc ff
	ff		 lea	 ecx, DWORD PTR _exeName$[ebp]
  0046b	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
  00470	e9 29 05 00 00	 jmp	 $LN39@ListAndWip
$LN15@ListAndWip:
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 231  :     wchar_t exePath[MAX_PATH] = { 0 };

  00475	68 08 02 00 00	 push	 520			; 00000208H
  0047a	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _exePath$[ebp]
  00480	6a 00		 push	 0
  00482	50		 push	 eax
  00483	e8 00 00 00 00	 call	 _memset
  00488	83 c4 0c	 add	 esp, 12			; 0000000cH

; 232  :     if (!GetModuleFileNameExW(hProcess, nullptr, exePath, MAX_PATH)) {

  0048b	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _exePath$[ebp]
  00491	68 04 01 00 00	 push	 260			; 00000104H
  00496	50		 push	 eax
  00497	6a 00		 push	 0
  00499	57		 push	 edi
  0049a	e8 00 00 00 00	 call	 _K32GetModuleFileNameExW@16
  0049f	85 c0		 test	 eax, eax
  004a1	75 25		 jne	 SHORT $LN16@ListAndWip

; 233  :         std::cout << "Failed to get executable path\n";

  004a3	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@GLDIOEL@Failed?5to?5get?5executable?5path?6@
  004a8	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  004ad	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  004b2	83 c4 08	 add	 esp, 8

; 234  :         CloseHandle(hProcess);

  004b5	57		 push	 edi
  004b6	ff d6		 call	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1383 :         _Tidy_deallocate();

  004b8	8d 8d f8 fc ff
	ff		 lea	 ecx, DWORD PTR _exeName$[ebp]
  004be	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
  004c3	e9 d6 04 00 00	 jmp	 $LN39@ListAndWip
$LN16@ListAndWip:
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 238  :     std::wstring exePathStr(exePath);

  004c8	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _exePath$[ebp]
  004ce	50		 push	 eax
  004cf	8d 8d 88 fd ff
	ff		 lea	 ecx, DWORD PTR _exePathStr$[ebp]
  004d5	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >

; 88   :     std::wstring lowerPath = exePath;

  004da	8d 85 88 fd ff
	ff		 lea	 eax, DWORD PTR _exePathStr$[ebp]

; 238  :     std::wstring exePathStr(exePath);

  004e0	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH

; 88   :     std::wstring lowerPath = exePath;

  004e4	50		 push	 eax
  004e5	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR _lowerPath$9[ebp]
  004eb	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  004f0	83 bd cc fd ff
	ff 07		 cmp	 DWORD PTR _lowerPath$9[ebp+20], 7

; 435  :         value_type* _Result = _Bx._Buf;

  004f7	8d 85 b8 fd ff
	ff		 lea	 eax, DWORD PTR _lowerPath$9[ebp]

; 2170 :         return iterator(

  004fd	8b 95 c8 fd ff
	ff		 mov	 edx, DWORD PTR _lowerPath$9[ebp+16]

; 435  :         value_type* _Result = _Bx._Buf;

  00503	8d b5 b8 fd ff
	ff		 lea	 esi, DWORD PTR _lowerPath$9[ebp]

; 436  :         if (_Large_mode_engaged()) {

  00509	0f 47 85 b8 fd
	ff ff		 cmova	 eax, DWORD PTR _lowerPath$9[ebp]

; 435  :         value_type* _Result = _Bx._Buf;

  00510	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR _lowerPath$9[ebp]

; 436  :         if (_Large_mode_engaged()) {

  00516	0f 47 b5 b8 fd
	ff ff		 cmova	 esi, DWORD PTR _lowerPath$9[ebp]
  0051d	0f 47 8d b8 fd
	ff ff		 cmova	 ecx, DWORD PTR _lowerPath$9[ebp]
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 88   :     std::wstring lowerPath = exePath;

  00524	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2170 :         return iterator(

  00528	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
  0052b	89 85 bc fa ff
	ff		 mov	 DWORD PTR __ULast$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 3798 :     for (; _UFirst != _ULast; ++_UFirst, (void) ++_UDest) {

  00531	3b f0		 cmp	 esi, eax
  00533	74 32		 je	 SHORT $LN528@ListAndWip
  00535	2b ce		 sub	 ecx, esi
  00537	8b f9		 mov	 edi, ecx
  00539	0f 1f 80 00 00
	00 00		 npad	 7
$LL529@ListAndWip:

; 3799 :         *_UDest = _Func(*_UFirst);

  00540	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00543	50		 push	 eax
  00544	e8 00 00 00 00	 call	 _towlower
  00549	66 89 04 3e	 mov	 WORD PTR [esi+edi], ax
  0054d	83 c4 04	 add	 esp, 4
  00550	83 c6 02	 add	 esi, 2
  00553	3b b5 bc fa ff
	ff		 cmp	 esi, DWORD PTR __ULast$1$[ebp]
  00559	75 e5		 jne	 SHORT $LL529@ListAndWip
  0055b	8b 95 c8 fd ff
	ff		 mov	 edx, DWORD PTR _lowerPath$9[ebp+16]
  00561	8b bd c0 fa ff
	ff		 mov	 edi, DWORD PTR _hProcess$1$[ebp]
$LN528@ListAndWip:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00567	83 bd cc fd ff
	ff 07		 cmp	 DWORD PTR _lowerPath$9[ebp+20], 7

; 444  :         const value_type* _Result = _Bx._Buf;

  0056e	8d 85 b8 fd ff
	ff		 lea	 eax, DWORD PTR _lowerPath$9[ebp]

; 445  :         if (_Large_mode_engaged()) {

  00574	0f 47 85 b8 fd
	ff ff		 cmova	 eax, DWORD PTR _lowerPath$9[ebp]
  0057b	89 85 b8 fa ff
	ff		 mov	 DWORD PTR __Result$2$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 641  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

  00581	83 fa 09	 cmp	 edx, 9
  00584	72 29		 jb	 SHORT $LN988@ListAndWip
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 252  :         return const_cast<_Ty1*>(static_cast<const _Ty1*>(::__std_search_2(_First1, _Last1, _First2, _Count2)));

  00586	6a 09		 push	 9
  00588	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@NMFIMKAA@?$AA?2?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?2@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 660  :             const auto _End = _Haystack + _Hay_size;

  0058d	8d 34 50	 lea	 esi, DWORD PTR [eax+edx*2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 252  :         return const_cast<_Ty1*>(static_cast<const _Ty1*>(::__std_search_2(_First1, _Last1, _First2, _Count2)));

  00590	56		 push	 esi
  00591	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 653  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible

  00592	0f ae e8	 lfence
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 252  :         return const_cast<_Ty1*>(static_cast<const _Ty1*>(::__std_search_2(_First1, _Last1, _First2, _Count2)));

  00595	e8 00 00 00 00	 call	 ___std_search_2@16
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 663  :             if (_Ptr != _End) {

  0059a	3b c6		 cmp	 eax, esi
  0059c	74 11		 je	 SHORT $LN988@ListAndWip

; 664  :                 return static_cast<size_t>(_Ptr - _Haystack);

  0059e	2b 85 b8 fa ff
	ff		 sub	 eax, DWORD PTR __Result$2$[ebp]
  005a4	d1 f8		 sar	 eax, 1
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 91   :         lowerPath.find(L"\\system32\\") != std::wstring::npos ||

  005a6	83 f8 ff	 cmp	 eax, -1
  005a9	0f 85 42 03 00
	00		 jne	 $LN474@ListAndWip
$LN988@ListAndWip:
  005af	6a 00		 push	 0
  005b1	68 00 00 00 00	 push	 OFFSET ??_C@_1BG@NCCDOFIB@?$AA?2?$AAs?$AAy?$AAs?$AAt?$AAe?$AAm?$AA3?$AA2?$AA?2@
  005b6	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR _lowerPath$9[ebp]
  005bc	e8 00 00 00 00	 call	 ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find
  005c1	83 f8 ff	 cmp	 eax, -1
  005c4	0f 85 27 03 00
	00		 jne	 $LN474@ListAndWip
  005ca	6a 00		 push	 0
  005cc	68 00 00 00 00	 push	 OFFSET ??_C@_1DG@CIFNPBMN@?$AA?2?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?2?$AAs?$AAy?$AAs?$AAt?$AAe?$AAm@
  005d1	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR _lowerPath$9[ebp]
  005d7	e8 00 00 00 00	 call	 ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find
  005dc	83 f8 ff	 cmp	 eax, -1
  005df	0f 85 0c 03 00
	00		 jne	 $LN474@ListAndWip

; 92   :         lowerPath.find(L"\\windows\\system32\\drivers\\") != std::wstring::npos)
; 93   :         return false;
; 94   :     // Allow only Program Files locations
; 95   :     if (lowerPath.find(L"c:\\program files\\") == std::wstring::npos &&

  005e5	6a 00		 push	 0
  005e7	68 00 00 00 00	 push	 OFFSET ??_C@_1CE@OEHNAGL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  005ec	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR _lowerPath$9[ebp]
  005f2	e8 00 00 00 00	 call	 ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find
  005f7	83 f8 ff	 cmp	 eax, -1
  005fa	75 1b		 jne	 SHORT $LN475@ListAndWip
  005fc	6a 00		 push	 0
  005fe	68 00 00 00 00	 push	 OFFSET ??_C@_1DA@NPPKGKBB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  00603	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR _lowerPath$9[ebp]
  00609	e8 00 00 00 00	 call	 ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find
  0060e	83 f8 ff	 cmp	 eax, -1
  00611	0f 84 da 02 00
	00		 je	 $LN474@ListAndWip
$LN475@ListAndWip:

; 96   :         lowerPath.find(L"c:\\program files (x86)\\") == std::wstring::npos)
; 97   :         return false;
; 98   :     return true;

  00617	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR _lowerPath$9[ebp]
  0061d	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  00621	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00626	83 bd 9c fd ff
	ff 07		 cmp	 DWORD PTR _exePathStr$[ebp+20], 7
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 104  :     if (GetNamedSecurityInfoW(filePath.c_str(), SE_FILE_OBJECT, OWNER_SECURITY_INFORMATION, &ownerSid, nullptr, nullptr, nullptr, &sd) != ERROR_SUCCESS)

  0062d	8d 8d b8 fa ff
	ff		 lea	 ecx, DWORD PTR _sd$4[ebp]
  00633	51		 push	 ecx
  00634	6a 00		 push	 0
  00636	6a 00		 push	 0
  00638	6a 00		 push	 0
  0063a	8d 8d c0 fa ff
	ff		 lea	 ecx, DWORD PTR _ownerSid$7[ebp]
  00640	c7 85 c0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _ownerSid$7[ebp], 0
  0064a	51		 push	 ecx
  0064b	6a 01		 push	 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

  0064d	8d 85 88 fd ff
	ff		 lea	 eax, DWORD PTR _exePathStr$[ebp]
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 103  :     PSECURITY_DESCRIPTOR sd = nullptr;

  00653	c7 85 b8 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _sd$4[ebp], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

  0065d	0f 47 85 88 fd
	ff ff		 cmova	 eax, DWORD PTR _exePathStr$[ebp]
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 104  :     if (GetNamedSecurityInfoW(filePath.c_str(), SE_FILE_OBJECT, OWNER_SECURITY_INFORMATION, &ownerSid, nullptr, nullptr, nullptr, &sd) != ERROR_SUCCESS)

  00664	6a 01		 push	 1
  00666	50		 push	 eax
  00667	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetNamedSecurityInfoW@32
  0066d	85 c0		 test	 eax, eax
  0066f	0f 85 69 02 00
	00		 jne	 $LN989@ListAndWip

; 105  :         return false;
; 106  :     WCHAR* sidString = nullptr;

  00675	89 85 bc fa ff
	ff		 mov	 DWORD PTR _sidString$5[ebp], eax

; 107  :     bool isSystemOrAdmin = false;

  0067b	88 85 cb fa ff
	ff		 mov	 BYTE PTR _isSystemOrAdmin$1$[ebp], al

; 108  :     if (ConvertSidToStringSidW(ownerSid, &sidString)) {

  00681	8d 85 bc fa ff
	ff		 lea	 eax, DWORD PTR _sidString$5[ebp]
  00687	50		 push	 eax
  00688	ff b5 c0 fa ff
	ff		 push	 DWORD PTR _ownerSid$7[ebp]
  0068e	e8 00 00 00 00	 call	 _ConvertSidToStringSidW@8
  00693	85 c0		 test	 eax, eax
  00695	0f 84 82 00 00
	00		 je	 $LN601@ListAndWip

; 109  :         if (wcscmp(sidString, L"S-1-5-18") == 0 || // SYSTEM

  0069b	8b b5 bc fa ff
	ff		 mov	 esi, DWORD PTR _sidString$5[ebp]
  006a1	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_1BC@FOGOLNOF@?$AAS?$AA?9?$AA1?$AA?9?$AA5?$AA?9?$AA1?$AA8@
  006a6	8b c6		 mov	 eax, esi
$LL993@ListAndWip:
  006a8	66 8b 10	 mov	 dx, WORD PTR [eax]
  006ab	66 3b 11	 cmp	 dx, WORD PTR [ecx]
  006ae	75 1e		 jne	 SHORT $LN994@ListAndWip
  006b0	66 85 d2	 test	 dx, dx
  006b3	74 15		 je	 SHORT $LN995@ListAndWip
  006b5	66 8b 50 02	 mov	 dx, WORD PTR [eax+2]
  006b9	66 3b 51 02	 cmp	 dx, WORD PTR [ecx+2]
  006bd	75 0f		 jne	 SHORT $LN994@ListAndWip
  006bf	83 c0 04	 add	 eax, 4
  006c2	83 c1 04	 add	 ecx, 4
  006c5	66 85 d2	 test	 dx, dx
  006c8	75 de		 jne	 SHORT $LL993@ListAndWip
$LN995@ListAndWip:
  006ca	33 c0		 xor	 eax, eax
  006cc	eb 05		 jmp	 SHORT $LN996@ListAndWip
$LN994@ListAndWip:
  006ce	1b c0		 sbb	 eax, eax
  006d0	83 c8 01	 or	 eax, 1
$LN996@ListAndWip:
  006d3	85 c0		 test	 eax, eax
  006d5	74 38		 je	 SHORT $LN603@ListAndWip
  006d7	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_1BK@KDDKMJBN@?$AAS?$AA?9?$AA1?$AA?9?$AA5?$AA?9?$AA3?$AA2?$AA?9?$AA5?$AA4?$AA4@
  006dc	8b c6		 mov	 eax, esi
  006de	66 90		 npad	 2
$LL997@ListAndWip:
  006e0	66 8b 10	 mov	 dx, WORD PTR [eax]
  006e3	66 3b 11	 cmp	 dx, WORD PTR [ecx]
  006e6	75 1e		 jne	 SHORT $LN998@ListAndWip
  006e8	66 85 d2	 test	 dx, dx
  006eb	74 15		 je	 SHORT $LN999@ListAndWip
  006ed	66 8b 50 02	 mov	 dx, WORD PTR [eax+2]
  006f1	66 3b 51 02	 cmp	 dx, WORD PTR [ecx+2]
  006f5	75 0f		 jne	 SHORT $LN998@ListAndWip
  006f7	83 c0 04	 add	 eax, 4
  006fa	83 c1 04	 add	 ecx, 4
  006fd	66 85 d2	 test	 dx, dx
  00700	75 de		 jne	 SHORT $LL997@ListAndWip
$LN999@ListAndWip:
  00702	33 c0		 xor	 eax, eax
  00704	eb 05		 jmp	 SHORT $LN1000@ListAndWip
$LN998@ListAndWip:
  00706	1b c0		 sbb	 eax, eax
  00708	83 c8 01	 or	 eax, 1
$LN1000@ListAndWip:
  0070b	85 c0		 test	 eax, eax
  0070d	75 07		 jne	 SHORT $LN602@ListAndWip
$LN603@ListAndWip:

; 110  :             wcscmp(sidString, L"S-1-5-32-544") == 0) // Administrators
; 111  :             isSystemOrAdmin = true;

  0070f	c6 85 cb fa ff
	ff 01		 mov	 BYTE PTR _isSystemOrAdmin$1$[ebp], 1
$LN602@ListAndWip:

; 112  :         LocalFree(sidString);

  00716	56		 push	 esi
  00717	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4
$LN601@ListAndWip:

; 113  :     }
; 114  :     if (sd) LocalFree(sd);

  0071d	8b 85 b8 fa ff
	ff		 mov	 eax, DWORD PTR _sd$4[ebp]
  00723	85 c0		 test	 eax, eax
  00725	74 07		 je	 SHORT $LN604@ListAndWip
  00727	50		 push	 eax
  00728	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4
$LN604@ListAndWip:

; 241  :         CloseHandle(hProcess);
; 242  :         return;
; 243  :     }
; 244  : 
; 245  :     if (!IsFileOwnerSystemOrAdmin(exePathStr)) {

  0072e	80 bd cb fa ff
	ff 00		 cmp	 BYTE PTR _isSystemOrAdmin$1$[ebp], 0
  00735	0f 84 a3 01 00
	00		 je	 $LN989@ListAndWip

; 247  :         CloseHandle(hProcess);
; 248  :         return;
; 249  :     }
; 250  : 
; 251  :     std::wcout << L"Target: " << exePath << L"\n";

  0073b	68 00 00 00 00	 push	 OFFSET ??_C@_13LBAGMAIH@?$AA?6@
  00740	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _exePath$[ebp]
  00746	50		 push	 eax
  00747	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@NNIHPOBO@?$AAT?$AAa?$AAr?$AAg?$AAe?$AAt?$AA?3?$AA?5@
  0074c	68 00 00 00 00	 push	 OFFSET ?wcout@std@@3V?$basic_ostream@_WU?$char_traits@_W@std@@@1@A ; std::wcout
  00751	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
  00756	83 c4 08	 add	 esp, 8
  00759	50		 push	 eax
  0075a	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
  0075f	83 c4 08	 add	 esp, 8
  00762	50		 push	 eax
  00763	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
  00768	83 c4 08	 add	 esp, 8

; 252  : 
; 253  :     // Terminate the process (user-mode fallback)
; 254  :     if (!TerminateProcess(hProcess, 1)) {

  0076b	6a 01		 push	 1
  0076d	57		 push	 edi
  0076e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TerminateProcess@8
  00774	85 c0		 test	 eax, eax
  00776	75 14		 jne	 SHORT $LN19@ListAndWip

; 255  :         std::cout << "Failed to terminate process\n";

  00778	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@DJMCJGKF@Failed?5to?5terminate?5process?6@
  0077d	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  00782	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00787	e9 a1 01 00 00	 jmp	 $LN1013@ListAndWip
$LN19@ListAndWip:

; 256  :         CloseHandle(hProcess);
; 257  :         return;
; 258  :     }
; 259  : 
; 260  :     // Wait for process to actually exit
; 261  :     WaitForSingleObject(hProcess, 5000); // wait max 5 seconds

  0078c	68 88 13 00 00	 push	 5000			; 00001388H
  00791	57		 push	 edi
  00792	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 262  :     CloseHandle(hProcess);

  00798	8b b5 c4 fa ff
	ff		 mov	 esi, DWORD PTR tv3261[ebp]
  0079e	57		 push	 edi
  0079f	ff d6		 call	 esi

; 263  : 
; 264  :     std::wcout << L"Process terminated: " << exeName << L"\n";

  007a1	68 00 00 00 00	 push	 OFFSET ??_C@_13LBAGMAIH@?$AA?6@
  007a6	8d 85 f8 fc ff
	ff		 lea	 eax, DWORD PTR _exeName$[ebp]
  007ac	50		 push	 eax
  007ad	68 00 00 00 00	 push	 OFFSET ??_C@_1CK@HMIPOEEH@?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?5?$AAt?$AAe?$AAr?$AAm?$AAi?$AAn?$AAa@
  007b2	68 00 00 00 00	 push	 OFFSET ?wcout@std@@3V?$basic_ostream@_WU?$char_traits@_W@std@@@1@A ; std::wcout
  007b7	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
  007bc	83 c4 08	 add	 esp, 8
  007bf	50		 push	 eax
  007c0	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  007c5	83 c4 08	 add	 esp, 8
  007c8	50		 push	 eax
  007c9	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
  007ce	83 c4 08	 add	 esp, 8

; 267  :     std::wstring bakPath = exePath;

  007d1	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _exePath$[ebp]
  007d7	8d 8d a0 fd ff
	ff		 lea	 ecx, DWORD PTR _bakPath$[ebp]
  007dd	50		 push	 eax
  007de	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1534 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  007e3	6a 04		 push	 4
  007e5	68 00 00 00 00	 push	 OFFSET ??_C@_19PAKAKPNB@?$AA?4?$AAb?$AAa?$AAk@
  007ea	8d 8d a0 fd ff
	ff		 lea	 ecx, DWORD PTR _bakPath$[ebp]
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 267  :     std::wstring bakPath = exePath;

  007f0	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1534 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  007f4	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 453  :         return _Myres > _Small_string_capacity;

  007f9	83 bd b4 fd ff
	ff 07		 cmp	 DWORD PTR _bakPath$[ebp+20], 7

; 444  :         const value_type* _Result = _Bx._Buf;

  00800	8d 85 a0 fd ff
	ff		 lea	 eax, DWORD PTR _bakPath$[ebp]
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 269  :     if (!CopyFileW(exePath, bakPath.c_str(), FALSE)) {

  00806	6a 00		 push	 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

  00808	0f 47 85 a0 fd
	ff ff		 cmova	 eax, DWORD PTR _bakPath$[ebp]
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 269  :     if (!CopyFileW(exePath, bakPath.c_str(), FALSE)) {

  0080f	50		 push	 eax
  00810	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _exePath$[ebp]
  00816	50		 push	 eax
  00817	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CopyFileW@12
  0081d	85 c0		 test	 eax, eax
  0081f	8d bd a0 fd ff
	ff		 lea	 edi, DWORD PTR _bakPath$[ebp]

; 270  :         std::wcout << L"Failed to create backup at: " << bakPath << L"\n";

  00825	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1DK@GGPBFIDJ@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt@
  0082a	74 05		 je	 SHORT $LN21@ListAndWip

; 271  :     } else {
; 272  :         std::wcout << L"Backup created: " << bakPath << L"\n";

  0082c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1CC@GKFHONNI@?$AAB?$AAa?$AAc?$AAk?$AAu?$AAp?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAe?$AAd?$AA?3@
$LN21@ListAndWip:

; 273  :     }
; 274  : 
; 275  :     LARGE_INTEGER fileSize;
; 276  :     HANDLE hFile = CreateFileW(exePath, GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);

  00831	50		 push	 eax
  00832	68 00 00 00 00	 push	 OFFSET ?wcout@std@@3V?$basic_ostream@_WU?$char_traits@_W@std@@@1@A ; std::wcout
  00837	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
  0083c	57		 push	 edi
  0083d	50		 push	 eax
  0083e	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00843	68 00 00 00 00	 push	 OFFSET ??_C@_13LBAGMAIH@?$AA?6@
  00848	50		 push	 eax
  00849	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
  0084e	83 c4 18	 add	 esp, 24			; 00000018H
  00851	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _exePath$[ebp]
  00857	6a 00		 push	 0
  00859	68 80 00 00 00	 push	 128			; 00000080H
  0085e	6a 03		 push	 3
  00860	6a 00		 push	 0
  00862	6a 01		 push	 1
  00864	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00869	50		 push	 eax
  0086a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileW@28
  00870	8b f8		 mov	 edi, eax

; 277  :     if (hFile == INVALID_HANDLE_VALUE || !GetFileSizeEx(hFile, &fileSize)) {

  00872	83 ff ff	 cmp	 edi, -1
  00875	74 40		 je	 SHORT $LN23@ListAndWip
  00877	8d 85 90 fa ff
	ff		 lea	 eax, DWORD PTR _fileSize$[ebp]
  0087d	50		 push	 eax
  0087e	57		 push	 edi
  0087f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileSizeEx@8
  00885	85 c0		 test	 eax, eax
  00887	74 2e		 je	 SHORT $LN23@ListAndWip

; 280  :         return;
; 281  :     }
; 282  :     CloseHandle(hFile);

  00889	57		 push	 edi
  0088a	ff d6		 call	 esi

; 283  : 
; 284  :     SecureWipeFile(exePathStr, fileSize);

  0088c	ff b5 94 fa ff
	ff		 push	 DWORD PTR _fileSize$[ebp+4]
  00892	8d 85 88 fd ff
	ff		 lea	 eax, DWORD PTR _exePathStr$[ebp]
  00898	ff b5 90 fa ff
	ff		 push	 DWORD PTR _fileSize$[ebp]
  0089e	50		 push	 eax
  0089f	e8 00 00 00 00	 call	 ?SecureWipeFile@@YAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@T_LARGE_INTEGER@@@Z ; SecureWipeFile
  008a4	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1383 :         _Tidy_deallocate();

  008a7	8d 8d a0 fd ff
	ff		 lea	 ecx, DWORD PTR _bakPath$[ebp]
  008ad	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
  008b2	e9 82 00 00 00	 jmp	 $LN635@ListAndWip
$LN23@ListAndWip:
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 278  :         std::cout << "Failed to get file size\n";

  008b7	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@PGKDKKC@Failed?5to?5get?5file?5size?6@
  008bc	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  008c1	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  008c6	83 c4 08	 add	 esp, 8

; 279  :         if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

  008c9	83 ff ff	 cmp	 edi, -1
  008cc	74 03		 je	 SHORT $LN24@ListAndWip
  008ce	57		 push	 edi
  008cf	ff d6		 call	 esi
$LN24@ListAndWip:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1383 :         _Tidy_deallocate();

  008d1	8d 8d a0 fd ff
	ff		 lea	 ecx, DWORD PTR _bakPath$[ebp]
  008d7	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
  008dc	eb 5b		 jmp	 SHORT $LN635@ListAndWip
$LN989@ListAndWip:
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 246  :         std::wcout << L"Refusing to wipe file not owned by SYSTEM or Administrators: " << exePath << L"\n";

  008de	68 00 00 00 00	 push	 OFFSET ??_C@_13LBAGMAIH@?$AA?6@
  008e3	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _exePath$[ebp]
  008e9	50		 push	 eax
  008ea	68 00 00 00 00	 push	 OFFSET ??_C@_1HM@HKLAJMNM@?$AAR?$AAe?$AAf?$AAu?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAt?$AAo?$AA?5?$AAw?$AAi?$AAp@
  008ef	eb 20		 jmp	 SHORT $LN1014@ListAndWip
$LN474@ListAndWip:

; 239  :     if (!IsSafeWipePath(exePathStr)) {
; 240  :         std::wcout << L"Refusing to wipe system or non-Program Files file: " << exePath << L"\n";

  008f1	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR _lowerPath$9[ebp]
  008f7	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  008fb	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
  00900	68 00 00 00 00	 push	 OFFSET ??_C@_13LBAGMAIH@?$AA?6@
  00905	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _exePath$[ebp]
  0090b	50		 push	 eax
  0090c	68 00 00 00 00	 push	 OFFSET ??_C@_1GI@CANLKDBI@?$AAR?$AAe?$AAf?$AAu?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAt?$AAo?$AA?5?$AAw?$AAi?$AAp@
$LN1014@ListAndWip:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1383 :         _Tidy_deallocate();

  00911	68 00 00 00 00	 push	 OFFSET ?wcout@std@@3V?$basic_ostream@_WU?$char_traits@_W@std@@@1@A ; std::wcout
  00916	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
  0091b	83 c4 08	 add	 esp, 8
  0091e	50		 push	 eax
  0091f	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
  00924	83 c4 08	 add	 esp, 8
  00927	50		 push	 eax
  00928	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
$LN1013@ListAndWip:
  0092d	8b b5 c4 fa ff
	ff		 mov	 esi, DWORD PTR tv3261[ebp]
  00933	83 c4 08	 add	 esp, 8
  00936	57		 push	 edi
  00937	ff d6		 call	 esi
$LN635@ListAndWip:
  00939	8d 8d 88 fd ff
	ff		 lea	 ecx, DWORD PTR _exePathStr$[ebp]
  0093f	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
  00944	8d 8d f8 fc ff
	ff		 lea	 ecx, DWORD PTR _exeName$[ebp]
  0094a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
  0094f	eb 4d		 jmp	 SHORT $LN39@ListAndWip
$LN1007@ListAndWip:
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 205  :     if (std::cin.fail() || selection <= 0 || selection > (int)processNames.size()) {

  00951	8b 8d bc fa ff
	ff		 mov	 ecx, DWORD PTR tv3244[ebp]
$LN11@ListAndWip:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  00957	33 d2		 xor	 edx, edx
  00959	b8 04 00 00 00	 mov	 eax, 4
  0095e	39 91 38 00 00
	00		 cmp	 DWORD PTR ?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A[ecx+56], edx
  00964	0f 45 c2	 cmovne	 eax, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 156  :         _Mystate             = _State;

  00967	89 81 0c 00 00
	00		 mov	 DWORD PTR ?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A[ecx+12], eax

; 157  :         const auto _Filtered = _State & _Except;

  0096d	85 81 10 00 00
	00		 test	 DWORD PTR ?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A[ecx+16], eax

; 158  :         if (_Filtered) {

  00973	0f 85 43 03 00
	00		 jne	 $LN1017@ListAndWip
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 207  :         std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

  00979	6a 0a		 push	 10			; 0000000aH
  0097b	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  00980	6a ff		 push	 -1
  00982	b9 00 00 00 00	 mov	 ecx, OFFSET ?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A ; std::cin
  00987	e8 00 00 00 00	 call	 ?ignore@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z ; std::basic_istream<char,std::char_traits<char> >::ignore

; 208  :         std::cout << "Cancelled\n";

  0098c	68 00 00 00 00	 push	 OFFSET ??_C@_0L@GMIBBJLF@Cancelled?6@
$LN1011@ListAndWip:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2090 :         if (_Myfirst) { // destroy and deallocate old array

  00991	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  00996	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0099b	83 c4 08	 add	 esp, 8
$LN39@ListAndWip:
  0099e	8b 95 98 fa ff
	ff		 mov	 edx, DWORD PTR _processIds$[ebp]
  009a4	85 d2		 test	 edx, edx
  009a6	74 51		 je	 SHORT $LN255@ListAndWip

; 2093 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  009a8	8b 8d a0 fa ff
	ff		 mov	 ecx, DWORD PTR _processIds$[ebp+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  009ae	8b c2		 mov	 eax, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2093 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  009b0	2b ca		 sub	 ecx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  009b2	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  009b5	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  009bb	72 14		 jb	 SHORT $LN268@ListAndWip

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  009bd	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  009c0	83 c1 23	 add	 ecx, 35			; 00000023H
  009c3	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  009c5	83 c0 fc	 add	 eax, -4			; fffffffcH
  009c8	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  009cb	0f 87 1e 03 00
	00		 ja	 $LN245@ListAndWip
$LN268@ListAndWip:

; 289  :         ::operator delete(_Ptr, _Bytes);

  009d1	51		 push	 ecx
  009d2	52		 push	 edx
  009d3	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  009d8	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2095 :             _Myfirst = nullptr;

  009db	c7 85 98 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _processIds$[ebp], 0

; 2096 :             _Mylast  = nullptr;

  009e5	c7 85 9c fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _processIds$[ebp+4], 0

; 2097 :             _Myend   = nullptr;

  009ef	c7 85 a0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _processIds$[ebp+8], 0
$LN255@ListAndWip:

; 2090 :         if (_Myfirst) { // destroy and deallocate old array

  009f9	8b b5 a8 fa ff
	ff		 mov	 esi, DWORD PTR _processNames$[ebp]
  009ff	85 f6		 test	 esi, esi
  00a01	74 68		 je	 SHORT $LN216@ListAndWip

; 2091 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

  00a03	8b bd ac fa ff
	ff		 mov	 edi, DWORD PTR _processNames$[ebp+4]
  00a09	3b f7		 cmp	 esi, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1102 :         for (; _First != _Last; ++_First) {

  00a0b	74 17		 je	 SHORT $LN221@ListAndWip
  00a0d	0f 1f 00	 npad	 3
$LL222@ListAndWip:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1383 :         _Tidy_deallocate();

  00a10	8b ce		 mov	 ecx, esi
  00a12	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1102 :         for (; _First != _Last; ++_First) {

  00a17	83 c6 18	 add	 esi, 24			; 00000018H
  00a1a	3b f7		 cmp	 esi, edi
  00a1c	75 f2		 jne	 SHORT $LL222@ListAndWip
  00a1e	8b b5 a8 fa ff
	ff		 mov	 esi, DWORD PTR _processNames$[ebp]
$LN221@ListAndWip:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2093 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00a24	8b 8d b0 fa ff
	ff		 mov	 ecx, DWORD PTR _processNames$[ebp+8]
  00a2a	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00a2f	2b ce		 sub	 ecx, esi
  00a31	f7 e9		 imul	 ecx
  00a33	c1 fa 02	 sar	 edx, 2
  00a36	8b c2		 mov	 eax, edx
  00a38	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00a3b	03 c2		 add	 eax, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00a3d	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00a40	8b c6		 mov	 eax, esi
  00a42	c1 e1 03	 shl	 ecx, 3

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00a45	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00a4b	72 14		 jb	 SHORT $LN246@ListAndWip

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00a4d	8b 70 fc	 mov	 esi, DWORD PTR [eax-4]
  00a50	83 c1 23	 add	 ecx, 35			; 00000023H
  00a53	2b c6		 sub	 eax, esi

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00a55	83 c0 fc	 add	 eax, -4			; fffffffcH
  00a58	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00a5b	0f 87 8e 02 00
	00		 ja	 $LN245@ListAndWip
$LN246@ListAndWip:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00a61	51		 push	 ecx
  00a62	56		 push	 esi
  00a63	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
$LN1010@ListAndWip:
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 285  : }

  00a68	83 c4 08	 add	 esp, 8
$LN216@ListAndWip:
  00a6b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00a6e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00a75	59		 pop	 ecx
  00a76	5f		 pop	 edi
  00a77	5e		 pop	 esi
  00a78	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a7b	33 cd		 xor	 ecx, ebp
  00a7d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a82	8b e5		 mov	 esp, ebp
  00a84	5d		 pop	 ebp
  00a85	c3		 ret	 0
$LN1016@ListAndWip:

; 166  :     static const std::vector<std::wstring> allowedExecutables = {

  00a86	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??ListAndWipeProcess@@YAXXZ@4HA
  00a8b	e8 00 00 00 00	 call	 __Init_thread_header
  00a90	83 c4 04	 add	 esp, 4
  00a93	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??ListAndWipeProcess@@YAXXZ@4HA, -1
  00a9a	0f 85 ad f5 ff
	ff		 jne	 $LN2@ListAndWip
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00aa0	6a 11		 push	 17			; 00000011H
  00aa2	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 166  :     static const std::vector<std::wstring> allowedExecutables = {

  00aa5	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00aac	68 00 00 00 00	 push	 OFFSET ??_C@_1CE@LGHOJOAP@?$AAE?$AAa?$AAs?$AAy?$AAA?$AAn?$AAt?$AAi?$AAC?$AAh?$AAe?$AAa?$AAt?$AA?4?$AAe@
  00ab1	8d 8d 10 fd ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]

; 517  :     size_type _Mysize = 0; // current length of string (size)

  00ab7	c7 85 20 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+16], 0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00ac1	0f 11 85 10 fd
	ff ff		 movups	 XMMWORD PTR $T8[ebp], xmm0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00ac8	c7 85 24 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+20], 0

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00ad2	e8 00 00 00 00	 call	 ??$_Construct@$00PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>
  00ad7	6a 0f		 push	 15			; 0000000fH
  00ad9	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 166  :     static const std::vector<std::wstring> allowedExecutables = {

  00adc	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00ae0	68 00 00 00 00	 push	 OFFSET ??_C@_1CA@FECLNECF@?$AAr?$AAb?$AAx?$AAh?$AAy?$AAp?$AAe?$AAr?$AAi?$AAo?$AAn?$AA?4?$AAe?$AAx?$AAe@
  00ae5	8d 8d 28 fd ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp+24]

; 517  :     size_type _Mysize = 0; // current length of string (size)

  00aeb	c7 85 38 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+40], 0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00af5	0f 11 85 28 fd
	ff ff		 movups	 XMMWORD PTR $T8[ebp+24], xmm0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00afc	c7 85 3c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+44], 0

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00b06	e8 00 00 00 00	 call	 ??$_Construct@$00PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>
  00b0b	6a 07		 push	 7
  00b0d	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 166  :     static const std::vector<std::wstring> allowedExecutables = {

  00b10	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00b14	68 00 00 00 00	 push	 OFFSET ??_C@_1BA@NHFJGJJ@?$AAv?$AAg?$AAk?$AA?4?$AAe?$AAx?$AAe@
  00b19	8d 8d 40 fd ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp+48]

; 517  :     size_type _Mysize = 0; // current length of string (size)

  00b1f	c7 85 50 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+64], 0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00b29	0f 11 85 40 fd
	ff ff		 movups	 XMMWORD PTR $T8[ebp+48], xmm0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00b30	c7 85 54 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+68], 0

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00b3a	e8 00 00 00 00	 call	 ??$_Construct@$00PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>
  00b3f	6a 0c		 push	 12			; 0000000cH
  00b41	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 166  :     static const std::vector<std::wstring> allowedExecutables = {

  00b44	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00b48	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@KHLBIGMC@?$AAV?$AAa?$AAn?$AAg?$AAu?$AAa?$AAr?$AAd?$AA?4?$AAe?$AAx?$AAe@
  00b4d	8d 8d 58 fd ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp+72]

; 517  :     size_type _Mysize = 0; // current length of string (size)

  00b53	c7 85 68 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+88], 0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00b5d	0f 11 85 58 fd
	ff ff		 movups	 XMMWORD PTR $T8[ebp+72], xmm0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00b64	c7 85 6c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+92], 0

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00b6e	e8 00 00 00 00	 call	 ??$_Construct@$00PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>
  00b73	6a 14		 push	 20			; 00000014H
  00b75	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 166  :     static const std::vector<std::wstring> allowedExecutables = {

  00b78	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00b7c	68 00 00 00 00	 push	 OFFSET ??_C@_1CK@DNABAJMK@?$AAR?$AAo?$AAb?$AAl?$AAo?$AAx?$AAP?$AAl?$AAa?$AAy?$AAe?$AAr?$AAB?$AAe?$AAt@
  00b81	8d 8d 70 fd ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp+96]

; 517  :     size_type _Mysize = 0; // current length of string (size)

  00b87	c7 85 80 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+112], 0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00b91	0f 11 85 70 fd
	ff ff		 movups	 XMMWORD PTR $T8[ebp+96], xmm0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00b98	c7 85 84 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+116], 0

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00ba2	e8 00 00 00 00	 call	 ??$_Construct@$00PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\initializer_list

; 34   :         : _First(_First_arg), _Last(_Last_arg) {}

  00ba7	8d 85 10 fd ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 166  :     static const std::vector<std::wstring> allowedExecutables = {

  00bad	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\initializer_list

; 34   :         : _First(_First_arg), _Last(_Last_arg) {}

  00bb1	8d 8d 88 fd ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp+120]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00bb7	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?allowedExecutables@?1??ListAndWipeProcess@@YAXXZ@4V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@B, 0

; 721  :         _Construct_n(_Convert_size<size_type>(_Ilist.size()), _Ilist.begin(), _Ilist.end());

  00bc1	2b c8		 sub	 ecx, eax

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00bc3	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?allowedExecutables@?1??ListAndWipeProcess@@YAXXZ@4V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@B+4, 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\initializer_list

; 45   :         return static_cast<size_t>(_Last - _First);

  00bcd	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00bd2	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?allowedExecutables@?1??ListAndWipeProcess@@YAXXZ@4V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@B+8, 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\initializer_list

; 45   :         return static_cast<size_t>(_Last - _First);

  00bdc	f7 e9		 imul	 ecx
  00bde	c1 fa 02	 sar	 edx, 2
  00be1	8b c2		 mov	 eax, edx
  00be3	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00be6	03 c2		 add	 eax, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2111 :         if (_Count != 0) {

  00be8	0f 84 92 00 00
	00		 je	 $LN438@ListAndWip

; 2051 :         if (_Newcapacity > max_size()) {

  00bee	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  00bf3	76 05		 jbe	 SHORT $LN387@ListAndWip

; 2052 :             _Xlength();

  00bf5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Xlength
$LN387@ListAndWip:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 122  :     return _Count * _Ty_size;

  00bfa	8d 34 40	 lea	 esi, DWORD PTR [eax+eax*2]
  00bfd	c1 e6 03	 shl	 esi, 3

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00c00	56		 push	 esi

; 122  :     return _Count * _Ty_size;

  00c01	0f ae e8	 lfence

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00c04	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2034 :         const pointer _Newvec = _STD _Allocate_at_least_helper(_Getal(), _Newcapacity);

  00c09	8b f8		 mov	 edi, eax

; 2113 :             _Tidy_guard<vector> _Guard{this};

  00c0b	c7 85 b8 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR __Guard$3[ebp], OFFSET ?allowedExecutables@?1??ListAndWipeProcess@@YAXXZ@4V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@B
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00c15	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2035 :         _Myfirst              = _Newvec;

  00c18	89 3d 00 00 00
	00		 mov	 DWORD PTR ?allowedExecutables@?1??ListAndWipeProcess@@YAXXZ@4V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@B, edi

; 2036 :         _Mylast               = _Newvec;

  00c1e	89 3d 04 00 00
	00		 mov	 DWORD PTR ?allowedExecutables@?1??ListAndWipeProcess@@YAXXZ@4V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@B+4, edi

; 2037 :         _Myend                = _Newvec + _Newcapacity;

  00c24	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  00c27	a3 08 00 00 00	 mov	 DWORD PTR ?allowedExecutables@?1??ListAndWipeProcess@@YAXXZ@4V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@B+8, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1833 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00c2c	89 bd dc fd ff
	ff		 mov	 DWORD PTR __Backout$12[ebp], edi
  00c32	89 bd e0 fd ff
	ff		 mov	 DWORD PTR __Backout$12[ebp+4], edi
  00c38	c7 85 e4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR __Backout$12[ebp+8], OFFSET ?allowedExecutables@?1??ListAndWipeProcess@@YAXXZ@4V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@B

; 1901 :     for (; _UFirst != _ULast; ++_UFirst) {

  00c42	8d b5 10 fd ff
	ff		 lea	 esi, DWORD PTR $T8[ebp]
  00c48	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00c4c	8d 85 88 fd ff
	ff		 lea	 eax, DWORD PTR $T8[ebp+120]
  00c52	3b f0		 cmp	 esi, eax
  00c54	74 22		 je	 SHORT $LN405@ListAndWip
  00c56	eb 00		 jmp	 SHORT $LL406@ListAndWip
$LL406@ListAndWip:

; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00c58	56		 push	 esi
  00c59	8b cf		 mov	 ecx, edi
  00c5b	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >

; 1845 :         ++_Last;

  00c60	83 c7 18	 add	 edi, 24			; 00000018H

; 1901 :     for (; _UFirst != _ULast; ++_UFirst) {

  00c63	8d 85 88 fd ff
	ff		 lea	 eax, DWORD PTR $T8[ebp+120]
  00c69	83 c6 18	 add	 esi, 24			; 00000018H

; 1845 :         ++_Last;

  00c6c	89 bd e0 fd ff
	ff		 mov	 DWORD PTR __Backout$12[ebp+4], edi

; 1901 :     for (; _UFirst != _ULast; ++_UFirst) {

  00c72	3b f0		 cmp	 esi, eax
  00c74	75 e2		 jne	 SHORT $LL406@ListAndWip
  00c76	eb 00		 jmp	 SHORT $LN405@ListAndWip
$LN405@ListAndWip:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2120 :                 _My_data._Mylast = _STD _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

  00c78	89 3d 04 00 00
	00		 mov	 DWORD PTR ?allowedExecutables@?1??ListAndWipeProcess@@YAXXZ@4V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@B+4, edi
  00c7e	eb 00		 jmp	 SHORT $LN438@ListAndWip
$LN438@ListAndWip:
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 166  :     static const std::vector<std::wstring> allowedExecutables = {

  00c80	68 00 00 00 00	 push	 OFFSET ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00c85	6a 05		 push	 5
  00c87	6a 18		 push	 24			; 00000018H
  00c89	8d 85 10 fd ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  00c8f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00c93	50		 push	 eax
  00c94	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00c99	68 00 00 00 00	 push	 OFFSET ??__FallowedExecutables@?1??ListAndWipeProcess@@YAXXZ@YAXXZ ; `ListAndWipeProcess'::`2'::`dynamic atexit destructor for 'allowedExecutables''
  00c9e	e8 00 00 00 00	 call	 _atexit
  00ca3	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??ListAndWipeProcess@@YAXXZ@4HA
  00ca8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00caf	e8 00 00 00 00	 call	 __Init_thread_footer
  00cb4	83 c4 08	 add	 esp, 8
  00cb7	e9 91 f3 ff ff	 jmp	 $LN2@ListAndWip
$LN1017@ListAndWip:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 172  :             _THROW(failure(_Msg));

  00cbc	8d 85 b4 fa ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00cc2	6a 01		 push	 1
  00cc4	50		 push	 eax
  00cc5	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  00cca	83 c4 08	 add	 esp, 8
  00ccd	8d 8d d4 fd ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  00cd3	50		 push	 eax
  00cd4	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  00cd9	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  00cde	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00ce3	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  00ce9	50		 push	 eax
  00cea	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN245@ListAndWip:
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 285  : }

  00cef	6a 00		 push	 0
  00cf1	6a 00		 push	 0
  00cf3	6a 00		 push	 0
  00cf5	6a 00		 push	 0
  00cf7	6a 00		 push	 0
  00cf9	e8 00 00 00 00	 call	 __invoke_watson
$LN1009@ListAndWip:
  00cfe	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ListAndWipeProcess@@YAXXZ$7:
  00000	8d 8d a8 fa ff
	ff		 lea	 ecx, DWORD PTR _processNames$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
__unwindfunclet$?ListAndWipeProcess@@YAXXZ$8:
  0000b	8d 8d 98 fa ff
	ff		 lea	 ecx, DWORD PTR _processIds$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
__unwindfunclet$?ListAndWipeProcess@@YAXXZ$9:
  00016	8d 8d d0 fd ff
	ff		 lea	 ecx, DWORD PTR _exe$10[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?ListAndWipeProcess@@YAXXZ$10:
  00021	8d 8d f8 fc ff
	ff		 lea	 ecx, DWORD PTR _exeName$[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?ListAndWipeProcess@@YAXXZ$11:
  0002c	8d 8d 88 fd ff
	ff		 lea	 ecx, DWORD PTR _exePathStr$[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?ListAndWipeProcess@@YAXXZ$31:
  00037	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR _lowerPath$9[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?ListAndWipeProcess@@YAXXZ$12:
  00042	8d 8d a0 fd ff
	ff		 lea	 ecx, DWORD PTR _bakPath$[ebp]
  00048	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?ListAndWipeProcess@@YAXXZ$0:
  0004d	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??ListAndWipeProcess@@YAXXZ@4HA
  00052	e8 00 00 00 00	 call	 __Init_thread_abort
  00057	59		 pop	 ecx
  00058	c3		 ret	 0
__unwindfunclet$?ListAndWipeProcess@@YAXXZ$1:
  00059	8d 8d 10 fd ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  0005f	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?ListAndWipeProcess@@YAXXZ$2:
  00064	8d 8d 28 fd ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp+24]
  0006a	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?ListAndWipeProcess@@YAXXZ$3:
  0006f	8d 8d 40 fd ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp+48]
  00075	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?ListAndWipeProcess@@YAXXZ$4:
  0007a	8d 8d 58 fd ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp+72]
  00080	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?ListAndWipeProcess@@YAXXZ$6:
  00085	68 00 00 00 00	 push	 OFFSET ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0008a	6a 05		 push	 5
  0008c	6a 18		 push	 24			; 00000018H
  0008e	8d 85 10 fd ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0009a	c3		 ret	 0
__unwindfunclet$?ListAndWipeProcess@@YAXXZ$27:
  0009b	8d 8d b8 fa ff
	ff		 lea	 ecx, DWORD PTR __Guard$3[ebp]
  000a1	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::~_Tidy_guard<std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >
__unwindfunclet$?ListAndWipeProcess@@YAXXZ$28:
  000a6	8d 8d dc fd ff
	ff		 lea	 ecx, DWORD PTR __Backout$12[ebp]
  000ac	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
  000b1	cc		 int	 3
  000b2	cc		 int	 3
  000b3	cc		 int	 3
  000b4	cc		 int	 3
  000b5	cc		 int	 3
__ehhandler$?ListAndWipeProcess@@YAXXZ:
  000b6	90		 npad	 1
  000b7	90		 npad	 1
  000b8	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000bc	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000bf	8b 8a 90 fa ff
	ff		 mov	 ecx, DWORD PTR [edx-1392]
  000c5	33 c8		 xor	 ecx, eax
  000c7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cc	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  000cf	33 c8		 xor	 ecx, eax
  000d1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d6	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ListAndWipeProcess@@YAXXZ
  000db	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ListAndWipeProcess@@YAXXZ ENDP				; ListAndWipeProcess
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\random
;	COMDAT ??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator(), COMDAT
; _this$ = ecx

; 1346 :     _NODISCARD result_type operator()() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	57		 push	 edi
  00008	89 75 fc	 mov	 DWORD PTR _this$1$[ebp], esi

; 1347 :         if (this->_Idx == _Nx) {

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	3d 70 02 00 00	 cmp	 eax, 624		; 00000270H
  00012	75 49		 jne	 SHORT $LN2@operator

; 1409 :         for (size_t _Ix = _Nx; _Ix < 2 * _Nx; ++_Ix) { // fill in values

  00014	8d 56 08	 lea	 edx, DWORD PTR [esi+8]
  00017	8b f8		 mov	 edi, eax
  00019	0f 1f 80 00 00
	00 00		 npad	 7
$LL9@operator:

; 1410 :             const _Ty _Tmp = (this->_Ax[_Ix - _Nx] & _HMSK) | (this->_Ax[_Ix - _Nx + _One_mod_n] & _LMSK);

  00020	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00022	8d 52 04	 lea	 edx, DWORD PTR [edx+4]
  00025	33 4a f8	 xor	 ecx, DWORD PTR [edx-8]
  00028	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  0002e	33 4a f8	 xor	 ecx, DWORD PTR [edx-8]

; 1411 :             this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _M_mod_n];

  00031	8b c1		 mov	 eax, ecx
  00033	24 01		 and	 al, 1
  00035	0f b6 c0	 movzx	 eax, al
  00038	f7 d8		 neg	 eax
  0003a	1b c0		 sbb	 eax, eax
  0003c	d1 e9		 shr	 ecx, 1
  0003e	25 df b0 08 99	 and	 eax, -1727483681	; 9908b0dfH
  00043	33 82 2c 06 00
	00		 xor	 eax, DWORD PTR [edx+1580]
  00049	33 c1		 xor	 eax, ecx
  0004b	89 82 b8 09 00
	00		 mov	 DWORD PTR [edx+2488], eax
  00051	83 ef 01	 sub	 edi, 1
  00054	75 ca		 jne	 SHORT $LL9@operator

; 1412 :         }
; 1413 :     }

  00056	8b 06		 mov	 eax, DWORD PTR [esi]
  00058	e9 da 00 00 00	 jmp	 $LN4@operator
$LN2@operator:

; 1348 :             _Refill_upper();
; 1349 :         } else if (2 * _Nx <= this->_Idx) {

  0005d	3d e0 04 00 00	 cmp	 eax, 1248		; 000004e0H
  00062	0f 82 cf 00 00
	00		 jb	 $LN4@operator

; 1386 :             for (size_t _Ix = 0; _Ix < _Wrap_bound_m; ++_Ix) { // fill in lower region

  00068	8d be c4 09 00
	00		 lea	 edi, DWORD PTR [esi+2500]
  0006e	be e3 00 00 00	 mov	 esi, 227		; 000000e3H
  00073	53		 push	 ebx
  00074	8b 1f		 mov	 ebx, DWORD PTR [edi]
$LL14@operator:

; 1387 :                 const _Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix + _Nx + _One_mod_n] & _LMSK);

  00076	8b c3		 mov	 eax, ebx
  00078	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  0007b	8b 1f		 mov	 ebx, DWORD PTR [edi]
  0007d	8b cb		 mov	 ecx, ebx
  0007f	33 c8		 xor	 ecx, eax
  00081	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  00087	33 c8		 xor	 ecx, eax

; 1388 :                 this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix + _Nx + _M_mod_n];

  00089	8b c1		 mov	 eax, ecx
  0008b	24 01		 and	 al, 1
  0008d	0f b6 c0	 movzx	 eax, al
  00090	f7 d8		 neg	 eax
  00092	1b c0		 sbb	 eax, eax
  00094	d1 e9		 shr	 ecx, 1
  00096	25 df b0 08 99	 and	 eax, -1727483681	; 9908b0dfH
  0009b	33 87 30 06 00
	00		 xor	 eax, DWORD PTR [edi+1584]
  000a1	33 c1		 xor	 eax, ecx
  000a3	89 87 3c f6 ff
	ff		 mov	 DWORD PTR [edi-2500], eax
  000a9	83 ee 01	 sub	 esi, 1
  000ac	75 c8		 jne	 SHORT $LL14@operator

; 1389 :             }
; 1390 : 
; 1391 :             for (size_t _Ix = _Wrap_bound_m; _Ix < _Wrap_bound_one; ++_Ix) {

  000ae	8b 7d fc	 mov	 edi, DWORD PTR _this$1$[ebp]
  000b1	be 8c 01 00 00	 mov	 esi, 396		; 0000018cH
  000b6	81 c7 50 0d 00
	00		 add	 edi, 3408		; 00000d50H
  000bc	8b 1f		 mov	 ebx, DWORD PTR [edi]
  000be	66 90		 npad	 2
$LL17@operator:

; 1392 :                 // fill in upper region (avoids modulus operation)
; 1393 :                 const _Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix + _Nx + _One_mod_n] & _LMSK);

  000c0	8b c3		 mov	 eax, ebx
  000c2	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  000c5	8b 1f		 mov	 ebx, DWORD PTR [edi]
  000c7	8b c8		 mov	 ecx, eax
  000c9	33 cb		 xor	 ecx, ebx
  000cb	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  000d1	33 c8		 xor	 ecx, eax

; 1394 :                 this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _M_mod_n];

  000d3	8b c1		 mov	 eax, ecx
  000d5	24 01		 and	 al, 1
  000d7	0f b6 c0	 movzx	 eax, al
  000da	f7 d8		 neg	 eax
  000dc	1b c0		 sbb	 eax, eax
  000de	d1 e9		 shr	 ecx, 1
  000e0	25 df b0 08 99	 and	 eax, -1727483681	; 9908b0dfH
  000e5	33 87 b0 f2 ff
	ff		 xor	 eax, DWORD PTR [edi-3408]
  000eb	33 c1		 xor	 eax, ecx
  000ed	89 87 3c f6 ff
	ff		 mov	 DWORD PTR [edi-2500], eax
  000f3	83 ee 01	 sub	 esi, 1
  000f6	75 c8		 jne	 SHORT $LL17@operator

; 1395 :             }
; 1396 : 
; 1397 :             if constexpr (_One_mod_n == 1) { // fill in _Ax[_Nx - 1]
; 1398 :                 constexpr size_t _Ix = _Wrap_bound_one;
; 1399 : 
; 1400 :                 const _Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix - _Nx + _One_mod_n] & _LMSK);

  000f8	8b 75 fc	 mov	 esi, DWORD PTR _this$1$[ebp]
  000fb	5b		 pop	 ebx
  000fc	8b 86 80 13 00
	00		 mov	 eax, DWORD PTR [esi+4992]
  00102	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00105	33 c8		 xor	 ecx, eax
  00107	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  0010d	33 c8		 xor	 ecx, eax

; 1401 :                 this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _M_mod_n];

  0010f	8b c1		 mov	 eax, ecx
  00111	24 01		 and	 al, 1
  00113	0f b6 c0	 movzx	 eax, al
  00116	f7 d8		 neg	 eax
  00118	1b c0		 sbb	 eax, eax
  0011a	d1 e9		 shr	 ecx, 1
  0011c	25 df b0 08 99	 and	 eax, -1727483681	; 9908b0dfH
  00121	33 86 34 06 00
	00		 xor	 eax, DWORD PTR [esi+1588]
  00127	33 c1		 xor	 eax, ecx
  00129	89 86 c0 09 00
	00		 mov	 DWORD PTR [esi+2496], eax

; 1402 :             }
; 1403 :         }
; 1404 : 
; 1405 :         this->_Idx = 0;

  0012f	33 c0		 xor	 eax, eax
  00131	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN4@operator:

; 1350 :             _Refill_lower();
; 1351 :         }
; 1352 : 
; 1353 :         _Ty _Res = this->_Ax[this->_Idx++] & _WMSK;

  00137	8b 54 86 04	 mov	 edx, DWORD PTR [esi+eax*4+4]
  0013b	40		 inc	 eax
  0013c	89 06		 mov	 DWORD PTR [esi], eax

; 1354 :         _Res ^= (_Res >> _Ux) & _Dxval;

  0013e	8b ca		 mov	 ecx, edx
  00140	8b 86 84 13 00
	00		 mov	 eax, DWORD PTR [esi+4996]
  00146	c1 e9 0b	 shr	 ecx, 11			; 0000000bH
  00149	23 c1		 and	 eax, ecx
  0014b	33 d0		 xor	 edx, eax

; 1355 :         _Res ^= (_Res << _Sx) & _Bx;

  0014d	8b c2		 mov	 eax, edx
  0014f	25 ad 58 3a ff	 and	 eax, -12953427		; ff3a58adH
  00154	c1 e0 07	 shl	 eax, 7
  00157	33 d0		 xor	 edx, eax

; 1356 :         _Res ^= (_Res << _Tx) & _Cx;

  00159	8b c2		 mov	 eax, edx
  0015b	25 8c df ff ff	 and	 eax, -8308		; ffffdf8cH
  00160	c1 e0 0f	 shl	 eax, 15			; 0000000fH
  00163	33 d0		 xor	 edx, eax

; 1357 :         _Res ^= (_Res & _WMSK) >> _Lx;

  00165	8b c2		 mov	 eax, edx
  00167	c1 e8 12	 shr	 eax, 18			; 00000012H

; 1358 :         return _Res;

  0016a	5f		 pop	 edi
  0016b	33 c2		 xor	 eax, edx
  0016d	5e		 pop	 esi

; 1359 :     }

  0016e	8b e5		 mov	 esp, ebp
  00170	5d		 pop	 ebp
  00171	c3		 ret	 0
??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy, COMDAT
; _this$ = ecx

; 2081 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2082 :         auto& _Al         = _Getal();
; 2083 :         auto& _My_data    = _Mypair._Myval2;
; 2084 :         pointer& _Myfirst = _My_data._Myfirst;
; 2085 :         pointer& _Mylast  = _My_data._Mylast;
; 2086 :         pointer& _Myend   = _My_data._Myend;
; 2087 : 
; 2088 :         _My_data._Orphan_all();
; 2089 : 
; 2090 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 3d		 je	 SHORT $LN2@Tidy

; 2091 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2092 :             _ASAN_VECTOR_REMOVE;
; 2093 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000c	2b c8		 sub	 ecx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN15@Tidy

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 22		 ja	 SHORT $LN14@Tidy

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN15@Tidy:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2095 :             _Myfirst = nullptr;

  0002f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00035	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2096 :             _Mylast  = nullptr;

  00038	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 2097 :             _Myend   = nullptr;

  0003f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:

; 2099 :     }

  00046	5e		 pop	 esi
  00047	c3		 ret	 0
$LN14@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00048	6a 00		 push	 0
  0004a	6a 00		 push	 0
  0004c	6a 00		 push	 0
  0004e	6a 00		 push	 0
  00050	6a 00		 push	 0
  00052	e8 00 00 00 00	 call	 __invoke_watson
$LN22@Tidy:
  00057	cc		 int	 3
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 830  :         _Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
$T2 = -68						; size = 20
__Pad$ = -48						; size = 8
__Ok$ = -48						; size = 8
$T3 = -40						; size = 8
$T4 = -36						; size = 4
tv743 = -32						; size = 4
__Count$2$ = -28					; size = 4
__State$ = -24						; size = 4
$T5 = -17						; size = 1
$T6 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 768  : basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const char* _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  0002b	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 773  :     ios_base::iostate _State = ios_base::goodbit;

  0002e	33 db		 xor	 ebx, ebx
  00030	89 5d e8	 mov	 DWORD PTR __State$[ebp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  00033	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
$LL111@operator:
  00036	8a 02		 mov	 al, BYTE PTR [edx]
  00038	42		 inc	 edx
  00039	84 c0		 test	 al, al
  0003b	75 f9		 jne	 SHORT $LL111@operator
  0003d	2b d1		 sub	 edx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 775  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  0003f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  00042	89 55 e4	 mov	 DWORD PTR __Count$2$[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 775  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  00045	8b 01		 mov	 eax, DWORD PTR [ecx]
  00047	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004a	8b 7c 08 24	 mov	 edi, DWORD PTR [eax+ecx+36]
  0004e	8b 74 08 20	 mov	 esi, DWORD PTR [eax+ecx+32]
  00052	85 ff		 test	 edi, edi
  00054	7c 16		 jl	 SHORT $LN17@operator
  00056	7f 0e		 jg	 SHORT $LN113@operator
  00058	85 f6		 test	 esi, esi
  0005a	74 10		 je	 SHORT $LN17@operator
  0005c	85 ff		 test	 edi, edi
  0005e	7c 0c		 jl	 SHORT $LN17@operator
  00060	7f 04		 jg	 SHORT $LN113@operator
  00062	3b f2		 cmp	 esi, edx
  00064	76 06		 jbe	 SHORT $LN17@operator
$LN113@operator:
  00066	2b f2		 sub	 esi, edx
  00068	1b fb		 sbb	 edi, ebx
  0006a	eb 0e		 jmp	 SHORT $LN18@operator
$LN17@operator:
  0006c	0f 57 c0	 xorps	 xmm0, xmm0
  0006f	66 0f 13 45 d0	 movlpd	 QWORD PTR __Pad$[ebp], xmm0
  00074	8b 7d d4	 mov	 edi, DWORD PTR __Pad$[ebp+4]
  00077	8b 75 d0	 mov	 esi, DWORD PTR __Pad$[ebp]
$LN18@operator:

; 776  :     const typename _Myos::sentry _Ok(_Ostr);

  0007a	51		 push	 ecx
  0007b	8d 4d d0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0007e	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry

; 777  : 
; 778  :     if (!_Ok) {

  00083	80 7d d4 00	 cmp	 BYTE PTR __Ok$[ebp+4], 0
  00087	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0008e	75 0a		 jne	 SHORT $LN8@operator

; 779  :         _State |= ios_base::badbit;

  00090	bb 04 00 00 00	 mov	 ebx, 4

; 780  :     } else { // state okay, insert

  00095	e9 4e 01 00 00	 jmp	 $LN123@operator
$LN8@operator:

; 781  :         _TRY_IO_BEGIN
; 782  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  0009a	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0009d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  000a1	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a6	8b 44 08 14	 mov	 eax, DWORD PTR [eax+ecx+20]
  000aa	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000af	83 f8 40	 cmp	 eax, 64			; 00000040H
  000b2	74 6e		 je	 SHORT $LN108@operator
$LL4@operator:

; 783  :             for (; 0 < _Pad; --_Pad) { // pad on left

  000b4	85 ff		 test	 edi, edi
  000b6	7c 6a		 jl	 SHORT $LN108@operator
  000b8	7f 04		 jg	 SHORT $LN114@operator
  000ba	85 f6		 test	 esi, esi
  000bc	74 64		 je	 SHORT $LN108@operator
$LN114@operator:

; 784  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  000be	8b 01		 mov	 eax, DWORD PTR [ecx]
  000c0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c3	8b 54 08 38	 mov	 edx, DWORD PTR [eax+ecx+56]
  000c7	8a 4c 08 40	 mov	 cl, BYTE PTR [eax+ecx+64]
  000cb	89 55 dc	 mov	 DWORD PTR $T4[ebp], edx
  000ce	88 4d ef	 mov	 BYTE PTR $T5[ebp], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 261  :         return *_IPnext ? *_IPcount : 0;

  000d1	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  000d4	83 38 00	 cmp	 DWORD PTR [eax], 0
  000d7	74 23		 je	 SHORT $LN107@operator
  000d9	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  000dc	8b 00		 mov	 eax, DWORD PTR [eax]

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  000de	85 c0		 test	 eax, eax
  000e0	7e 1a		 jle	 SHORT $LN107@operator

; 256  :         --*_IPcount;

  000e2	8b 4a 30	 mov	 ecx, DWORD PTR [edx+48]
  000e5	48		 dec	 eax
  000e6	89 01		 mov	 DWORD PTR [ecx], eax

; 257  :         return (*_IPnext)++;

  000e8	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  000eb	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ed	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  000f0	89 01		 mov	 DWORD PTR [ecx], eax

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  000f2	8a 45 ef	 mov	 al, BYTE PTR $T5[ebp]
  000f5	88 02		 mov	 BYTE PTR [edx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  000f7	0f b6 c0	 movzx	 eax, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  000fa	eb 0e		 jmp	 SHORT $LN78@operator
$LN107@operator:
  000fc	8b 02		 mov	 eax, DWORD PTR [edx]
  000fe	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00101	0f b6 c1	 movzx	 eax, cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  00104	8b 4d dc	 mov	 ecx, DWORD PTR $T4[ebp]
  00107	50		 push	 eax
  00108	ff d2		 call	 edx
$LN78@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  0010a	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 784  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  0010d	75 08		 jne	 SHORT $LN2@operator

; 785  :                     _State |= ios_base::badbit; // insertion failed, quit

  0010f	8d 58 05	 lea	 ebx, DWORD PTR [eax+5]

; 786  :                     break;

  00112	e9 8d 00 00 00	 jmp	 $LN6@operator
$LN2@operator:

; 783  :             for (; 0 < _Pad; --_Pad) { // pad on left

  00117	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0011a	83 c6 ff	 add	 esi, -1
  0011d	83 d7 ff	 adc	 edi, -1
  00120	eb 92		 jmp	 SHORT $LL4@operator
$LN108@operator:

; 791  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  00122	8b 01		 mov	 eax, DWORD PTR [ecx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 171  :         return xsputn(_Ptr, _Count);

  00124	6a 00		 push	 0
  00126	ff 75 e4	 push	 DWORD PTR __Count$2$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 791  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  00129	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 171  :         return xsputn(_Ptr, _Count);

  0012c	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 791  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  0012f	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 171  :         return xsputn(_Ptr, _Count);

  00133	8b 01		 mov	 eax, DWORD PTR [ecx]
  00135	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00138	ff d0		 call	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 791  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  0013a	3b 45 e4	 cmp	 eax, DWORD PTR __Count$2$[ebp]
  0013d	75 62		 jne	 SHORT $LN115@operator
  0013f	85 d2		 test	 edx, edx
  00141	75 5e		 jne	 SHORT $LN115@operator
$LL7@operator:

; 792  :             _State |= ios_base::badbit;
; 793  :         }
; 794  : 
; 795  :         if (_State == ios_base::goodbit) {
; 796  :             for (; 0 < _Pad; --_Pad) { // pad on right

  00143	85 ff		 test	 edi, edi
  00145	7c 5d		 jl	 SHORT $LN6@operator
  00147	7f 04		 jg	 SHORT $LN116@operator
  00149	85 f6		 test	 esi, esi
  0014b	74 57		 je	 SHORT $LN6@operator
$LN116@operator:

; 797  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  0014d	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00150	8b 02		 mov	 eax, DWORD PTR [edx]
  00152	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00155	8b 4c 10 38	 mov	 ecx, DWORD PTR [eax+edx+56]
  00159	8a 44 10 40	 mov	 al, BYTE PTR [eax+edx+64]
  0015d	88 45 ef	 mov	 BYTE PTR $T6[ebp], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 261  :         return *_IPnext ? *_IPcount : 0;

  00160	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00163	83 38 00	 cmp	 DWORD PTR [eax], 0
  00166	74 20		 je	 SHORT $LN56@operator
  00168	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0016b	8b 02		 mov	 eax, DWORD PTR [edx]

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  0016d	85 c0		 test	 eax, eax
  0016f	7e 17		 jle	 SHORT $LN56@operator

; 256  :         --*_IPcount;

  00171	48		 dec	 eax
  00172	89 02		 mov	 DWORD PTR [edx], eax

; 257  :         return (*_IPnext)++;

  00174	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00177	8b 11		 mov	 edx, DWORD PTR [ecx]
  00179	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0017c	89 01		 mov	 DWORD PTR [ecx], eax

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  0017e	8a 45 ef	 mov	 al, BYTE PTR $T6[ebp]
  00181	88 02		 mov	 BYTE PTR [edx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  00183	0f b6 c0	 movzx	 eax, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  00186	eb 0c		 jmp	 SHORT $LN57@operator
$LN56@operator:
  00188	8b 01		 mov	 eax, DWORD PTR [ecx]
  0018a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

  0018d	0f b6 45 ef	 movzx	 eax, BYTE PTR $T6[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  00191	50		 push	 eax
  00192	ff d2		 call	 edx
$LN57@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 522  :         return _Left == _Right;

  00194	83 f8 ff	 cmp	 eax, -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 797  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00197	74 08		 je	 SHORT $LN115@operator

; 792  :             _State |= ios_base::badbit;
; 793  :         }
; 794  : 
; 795  :         if (_State == ios_base::goodbit) {
; 796  :             for (; 0 < _Pad; --_Pad) { // pad on right

  00199	83 c6 ff	 add	 esi, -1
  0019c	83 d7 ff	 adc	 edi, -1
  0019f	eb a2		 jmp	 SHORT $LL7@operator
$LN115@operator:

; 798  :                     _State |= ios_base::badbit; // insertion failed, quit
; 799  :                     break;
; 800  :                 }
; 801  :             }
; 802  :         }
; 803  : 
; 804  :         _Ostr.width(0);

  001a1	83 cb 04	 or	 ebx, 4
$LN6@operator:
  001a4	8b 75 08	 mov	 esi, DWORD PTR __Ostr$[ebp]
  001a7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  001ae	8b 06		 mov	 eax, DWORD PTR [esi]
  001b0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 284  :         _Wide                      = _Newwidth;

  001b3	c7 44 30 20 00
	00 00 00	 mov	 DWORD PTR [eax+esi+32], 0
  001bb	c7 44 30 24 00
	00 00 00	 mov	 DWORD PTR [eax+esi+36], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
  001c3	eb 26		 jmp	 SHORT $LN22@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 805  :         _CATCH_IO_(ios_base, _Ostr)

  001c5	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  001c8	6a 01		 push	 1
  001ca	6a 04		 push	 4
  001cc	8b 02		 mov	 eax, DWORD PTR [edx]
  001ce	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001d1	03 ca		 add	 ecx, edx
  001d3	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
  001d8	b8 00 00 00 00	 mov	 eax, $LN23@operator
  001dd	c3		 ret	 0
$LN23@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
  001de	8b 5d e8	 mov	 ebx, DWORD PTR __State$[ebp]
  001e1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN123@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 808  :     _Ostr.setstate(_State);

  001e8	8b 75 08	 mov	 esi, DWORD PTR __Ostr$[ebp]
$LN22@operator:
  001eb	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  001ed	33 ff		 xor	 edi, edi
  001ef	b9 04 00 00 00	 mov	 ecx, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 808  :     _Ostr.setstate(_State);

  001f4	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 51   :         clear(rdstate() | _State, _Reraise);

  001f7	8b 44 32 0c	 mov	 eax, DWORD PTR [edx+esi+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 808  :     _Ostr.setstate(_State);

  001fb	03 d6		 add	 edx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 51   :         clear(rdstate() | _State, _Reraise);

  001fd	0b c3		 or	 eax, ebx

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  001ff	39 7a 38	 cmp	 DWORD PTR [edx+56], edi
  00202	0f 45 cf	 cmovne	 ecx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 155  :         _State &= _Statmask;

  00205	0b c8		 or	 ecx, eax

; 156  :         _Mystate             = _State;
; 157  :         const auto _Filtered = _State & _Except;

  00207	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0020a	83 e1 17	 and	 ecx, 23			; 00000017H
  0020d	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00210	23 c1		 and	 eax, ecx

; 158  :         if (_Filtered) {

  00212	75 41		 jne	 SHORT $LN125@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 111  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  00214	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception

; 112  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 113  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 114  : #endif // ^^^ !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION ^^^
; 115  : 
; 116  :             if (_Zero_uncaught_exceptions) {

  00219	84 c0		 test	 al, al
  0021b	75 08		 jne	 SHORT $LN40@operator

; 117  :                 this->_Myostr._Osfx();

  0021d	8b 4d d0	 mov	 ecx, DWORD PTR __Ok$[ebp]
  00220	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN40@operator:

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

  00225	8b 4d d0	 mov	 ecx, DWORD PTR __Ok$[ebp]
  00228	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3
  0022f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00231	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00234	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]

; 78   :             if (_Rdbuf) {

  00238	85 c9		 test	 ecx, ecx
  0023a	74 05		 je	 SHORT $LN46@operator

; 79   :                 _Rdbuf->_Unlock();

  0023c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0023e	ff 52 08	 call	 DWORD PTR [edx+8]
$LN46@operator:

; 809  :     return _Ostr;

  00241	8b c6		 mov	 eax, esi

; 810  : }

  00243	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00246	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0024d	59		 pop	 ecx
  0024e	5f		 pop	 edi
  0024f	5e		 pop	 esi
  00250	5b		 pop	 ebx
  00251	8b e5		 mov	 esp, ebp
  00253	5d		 pop	 ebp
  00254	c3		 ret	 0
$LN125@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 164  :             if (_Filtered & ios_base::badbit) {

  00255	a8 04		 test	 al, 4
  00257	74 07		 je	 SHORT $LN31@operator

; 165  :                 _Msg = "ios_base::badbit set";

  00259	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  0025e	eb 0f		 jmp	 SHORT $LN33@operator
$LN31@operator:

; 166  :             } else if (_Filtered & ios_base::failbit) {

  00260	a8 02		 test	 al, 2
  00262	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
  00267	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
  0026c	0f 44 f0	 cmove	 esi, eax
$LN33@operator:

; 167  :                 _Msg = "ios_base::failbit set";
; 168  :             } else {
; 169  :                 _Msg = "ios_base::eofbit set";
; 170  :             }
; 171  : 
; 172  :             _THROW(failure(_Msg));

  0026f	8d 45 d8	 lea	 eax, DWORD PTR $T3[ebp]
  00272	6a 01		 push	 1
  00274	50		 push	 eax
  00275	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  0027a	83 c4 08	 add	 esp, 8
  0027d	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  00280	50		 push	 eax
  00281	56		 push	 esi
  00282	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  00287	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  0028c	8d 45 bc	 lea	 eax, DWORD PTR $T2[ebp]
  0028f	50		 push	 eax
  00290	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN120@operator:
  00295	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
;	COMDAT ??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b d1		 mov	 edx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 61   :     __CLR_OR_THIS_CALL ~basic_ostream() noexcept override {}

  00025	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  00028	8d 72 f8	 lea	 esi, DWORD PTR [edx-8]
  0002b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002e	c7 44 10 f8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003b	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  0003e	89 44 11 f4	 mov	 DWORD PTR [ecx+edx-12], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 368  :         _Ios_base_dtor(this);

  00042	52		 push	 edx
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  00050	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00055	83 c4 04	 add	 esp, 4
  00058	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0005c	74 0b		 je	 SHORT $LN21@scalar
  0005e	6a 50		 push	 80			; 00000050H
  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00066	83 c4 08	 add	 esp, 8
$LN21@scalar:
  00069	8b c6		 mov	 eax, esi
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5e		 pop	 esi
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
  0007d	cc		 int	 3
  0007e	cc		 int	 3
  0007f	cc		 int	 3
  00080	cc		 int	 3
  00081	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
$T2 = -56						; size = 20
__Ok$3 = -36						; size = 8
$T4 = -28						; size = 8
__State$5 = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::flush, COMDAT
; _this$ = ecx

; 562  :     basic_ostream& __CLR_OR_THIS_CALL flush() { // flush output stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 563  :         const auto _Rdbuf = _Myios::rdbuf();

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00035	8b 7c 30 38	 mov	 edi, DWORD PTR [eax+esi+56]

; 564  :         if (_Rdbuf) { // buffer exists, flush it

  00039	85 ff		 test	 edi, edi
  0003b	0f 84 b8 00 00
	00		 je	 $LN75@flush

; 565  :             const sentry _Ok(*this);

  00041	56		 push	 esi
  00042	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$3[ebp]
  00045	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry

; 566  : 
; 567  :             if (_Ok) {

  0004a	80 7d e0 00	 cmp	 BYTE PTR __Ok$3[ebp+4], 0
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00055	74 75		 je	 SHORT $LN58@flush
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 121  :         return sync();

  00057	8b 07		 mov	 eax, DWORD PTR [edi]
  00059	8b cf		 mov	 ecx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 568  :                 ios_base::iostate _State = ios_base::goodbit;

  0005b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __State$5[ebp], 0

; 569  :                 _TRY_IO_BEGIN

  00062	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 121  :         return sync();

  00066	ff 50 34	 call	 DWORD PTR [eax+52]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 571  :                     _State |= ios_base::badbit; // sync failed

  00069	33 c9		 xor	 ecx, ecx
  0006b	ba 04 00 00 00	 mov	 edx, 4
  00070	83 f8 ff	 cmp	 eax, -1
  00073	89 4d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ecx
  00076	8b fa		 mov	 edi, edx
  00078	0f 45 f9	 cmovne	 edi, ecx
  0007b	eb 2b		 jmp	 SHORT $LN10@flush
__catch$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$0:

; 572  :                 }
; 573  :                 _CATCH_IO_END

  0007d	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00080	6a 01		 push	 1
  00082	6a 04		 push	 4
  00084	8b 02		 mov	 eax, DWORD PTR [edx]
  00086	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00089	03 ca		 add	 ecx, edx
  0008b	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
  00090	b8 00 00 00 00	 mov	 eax, $LN11@flush
  00095	c3		 ret	 0
$LN11@flush:
  00096	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00099	ba 04 00 00 00	 mov	 edx, 4
  0009e	8b 7d e8	 mov	 edi, DWORD PTR __State$5[ebp]
  000a1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN10@flush:

; 574  :                 _Myios::setstate(_State);

  000a8	8b 06		 mov	 eax, DWORD PTR [esi]
  000aa	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 51   :         clear(rdstate() | _State, _Reraise);

  000ad	8b 44 31 0c	 mov	 eax, DWORD PTR [ecx+esi+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 574  :                 _Myios::setstate(_State);

  000b1	03 ce		 add	 ecx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 51   :         clear(rdstate() | _State, _Reraise);

  000b3	0b c7		 or	 eax, edi

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  000b5	33 ff		 xor	 edi, edi
  000b7	39 79 38	 cmp	 DWORD PTR [ecx+56], edi
  000ba	0f 45 d7	 cmovne	 edx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 155  :         _State &= _Statmask;

  000bd	0b d0		 or	 edx, eax

; 156  :         _Mystate             = _State;
; 157  :         const auto _Filtered = _State & _Except;

  000bf	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  000c2	83 e2 17	 and	 edx, 23			; 00000017H
  000c5	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  000c8	23 c2		 and	 eax, edx

; 158  :         if (_Filtered) {

  000ca	75 41		 jne	 SHORT $LN83@flush
$LN58@flush:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 111  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  000cc	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  000d1	84 c0		 test	 al, al

; 112  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 113  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 114  : #endif // ^^^ !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION ^^^
; 115  : 
; 116  :             if (_Zero_uncaught_exceptions) {

  000d3	75 08		 jne	 SHORT $LN69@flush

; 117  :                 this->_Myostr._Osfx();

  000d5	8b 4d dc	 mov	 ecx, DWORD PTR __Ok$3[ebp]
  000d8	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN69@flush:

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

  000dd	8b 4d dc	 mov	 ecx, DWORD PTR __Ok$3[ebp]
  000e0	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3
  000e7	8b 01		 mov	 eax, DWORD PTR [ecx]
  000e9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000ec	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]

; 78   :             if (_Rdbuf) {

  000f0	85 c9		 test	 ecx, ecx
  000f2	74 05		 je	 SHORT $LN75@flush

; 79   :                 _Rdbuf->_Unlock();

  000f4	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f6	ff 50 08	 call	 DWORD PTR [eax+8]
$LN75@flush:

; 575  :             }
; 576  :         }
; 577  :         return *this;

  000f9	8b c6		 mov	 eax, esi

; 578  :     }

  000fb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000fe	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00105	59		 pop	 ecx
  00106	5f		 pop	 edi
  00107	5e		 pop	 esi
  00108	5b		 pop	 ebx
  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c3		 ret	 0
$LN83@flush:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 164  :             if (_Filtered & ios_base::badbit) {

  0010d	a8 04		 test	 al, 4
  0010f	74 07		 je	 SHORT $LN60@flush

; 165  :                 _Msg = "ios_base::badbit set";

  00111	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  00116	eb 0f		 jmp	 SHORT $LN62@flush
$LN60@flush:

; 166  :             } else if (_Filtered & ios_base::failbit) {

  00118	a8 02		 test	 al, 2
  0011a	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
  0011f	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
  00124	0f 44 f0	 cmove	 esi, eax
$LN62@flush:

; 167  :                 _Msg = "ios_base::failbit set";
; 168  :             } else {
; 169  :                 _Msg = "ios_base::eofbit set";
; 170  :             }
; 171  : 
; 172  :             _THROW(failure(_Msg));

  00127	8d 45 e4	 lea	 eax, DWORD PTR $T4[ebp]
  0012a	6a 01		 push	 1
  0012c	50		 push	 eax
  0012d	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  00132	83 c4 08	 add	 esp, 8
  00135	8d 4d c8	 lea	 ecx, DWORD PTR $T2[ebp]
  00138	50		 push	 eax
  00139	56		 push	 esi
  0013a	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  0013f	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00144	8d 45 c8	 lea	 eax, DWORD PTR $T2[ebp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN81@flush:
  0014d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$2:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::flush
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T2 = -44						; size = 20
$T3 = -24						; size = 8
__$EHRec$ = -16						; size = 16
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Osfx, COMDAT
; _this$ = ecx

; 159  :     void __CLR_OR_THIS_CALL _Osfx() noexcept { // perform any wrapup

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 206  :         return rdstate() == ios_base::goodbit;

  0002d	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 160  :         _TRY_BEGIN

  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 206  :         return rdstate() == ios_base::goodbit;

  00036	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00039	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 161  :         if (this->good() && this->flags() & ios_base::unitbuf) {

  0003e	75 38		 jne	 SHORT $LN21@Osfx
  00040	f6 44 30 14 02	 test	 BYTE PTR [eax+esi+20], 2
  00045	74 31		 je	 SHORT $LN21@Osfx

; 162  :             if (_Myios::rdbuf()->pubsync() == -1) { // flush stream as needed

  00047	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf

; 121  :         return sync();

  0004b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004d	ff 50 34	 call	 DWORD PTR [eax+52]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 162  :             if (_Myios::rdbuf()->pubsync() == -1) { // flush stream as needed

  00050	83 f8 ff	 cmp	 eax, -1
  00053	75 23		 jne	 SHORT $LN21@Osfx

; 163  :                 _Myios::setstate(ios_base::badbit);

  00055	8b 06		 mov	 eax, DWORD PTR [esi]
  00057	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 155  :         _State &= _Statmask;

  0005a	8b 44 31 0c	 mov	 eax, DWORD PTR [ecx+esi+12]
  0005e	83 e0 13	 and	 eax, 19			; 00000013H
  00061	83 c8 04	 or	 eax, 4

; 156  :         _Mystate             = _State;

  00064	89 44 31 0c	 mov	 DWORD PTR [ecx+esi+12], eax

; 157  :         const auto _Filtered = _State & _Except;

  00068	8b 4c 31 10	 mov	 ecx, DWORD PTR [ecx+esi+16]
  0006c	23 c8		 and	 ecx, eax

; 158  :         if (_Filtered) {

  0006e	75 1a		 jne	 SHORT $LN34@Osfx
  00070	eb 06		 jmp	 SHORT $LN21@Osfx
__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 167  :         _CATCH_END

  00072	b8 00 00 00 00	 mov	 eax, $LN21@Osfx
  00077	c3		 ret	 0
$LN21@Osfx:

; 168  :     }

  00078	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0007b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00082	59		 pop	 ecx
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
$LN34@Osfx:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 164  :             if (_Filtered & ios_base::badbit) {

  0008a	f6 c1 04	 test	 cl, 4
  0008d	74 07		 je	 SHORT $LN23@Osfx

; 165  :                 _Msg = "ios_base::badbit set";

  0008f	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  00094	eb 10		 jmp	 SHORT $LN25@Osfx
$LN23@Osfx:

; 166  :             } else if (_Filtered & ios_base::failbit) {

  00096	f6 c1 02	 test	 cl, 2
  00099	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
  0009e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
  000a3	0f 44 f0	 cmove	 esi, eax
$LN25@Osfx:

; 167  :                 _Msg = "ios_base::failbit set";
; 168  :             } else {
; 169  :                 _Msg = "ios_base::eofbit set";
; 170  :             }
; 171  : 
; 172  :             _THROW(failure(_Msg));

  000a6	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  000a9	6a 01		 push	 1
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  000b1	83 c4 08	 add	 esp, 8
  000b4	8d 4d d4	 lea	 ecx, DWORD PTR $T2[ebp]
  000b7	50		 push	 eax
  000b8	56		 push	 esi
  000b9	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  000be	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  000c3	8d 45 d4	 lea	 eax, DWORD PTR $T2[ebp]
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN32@Osfx:
  000cc	cc		 int	 3
  000cd	cc		 int	 3
  000ce	cc		 int	 3
  000cf	cc		 int	 3
  000d0	cc		 int	 3
  000d1	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 61   :     __CLR_OR_THIS_CALL ~basic_ostream() noexcept override {}

  00000	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00003	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00006	c7 44 08 f8 00
	00 00 00	 mov	 DWORD PTR [eax+ecx-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  0000e	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00011	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00014	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  00017	89 44 0a f4	 mov	 DWORD PTR [edx+ecx-12], eax
  0001b	c3		 ret	 0
??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
;	COMDAT ??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_ios<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 368  :         _Ios_base_dtor(this);

  00025	56		 push	 esi
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
  00033	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00038	83 c4 04	 add	 esp, 4
  0003b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0003f	74 0b		 je	 SHORT $LN15@scalar
  00041	6a 48		 push	 72			; 00000048H
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00049	83 c4 08	 add	 esp, 8
$LN15@scalar:
  0004c	8b c6		 mov	 eax, esi
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00051	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00058	59		 pop	 ecx
  00059	5e		 pop	 esi
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
  00060	cc		 int	 3
  00061	cc		 int	 3
  00062	cc		 int	 3
  00063	cc		 int	 3
  00064	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
;	COMDAT ??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ PROC	; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 160  :     __CLR_OR_THIS_CALL basic_ios() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b c1		 mov	 eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 373  :     size_t _Stdstr{0}; // if > 0 index of standard stream to suppress destruction

  00009	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 374  : 
; 375  : protected:
; 376  :     __CLR_OR_THIS_CALL ios_base() {}
; 377  : 
; 378  :     void __CLR_OR_THIS_CALL _Init() { // initialize a new ios_base
; 379  :         _Ploc   = nullptr;
; 380  :         _Stdstr = 0;
; 381  :         _Except = goodbit;
; 382  :         _Fmtfl  = skipws | dec;
; 383  :         _Prec   = 6;
; 384  :         _Wide   = 0;
; 385  :         _Arr    = nullptr;
; 386  :         _Calls  = nullptr;
; 387  :         clear(goodbit);
; 388  :         _Ploc = new locale;
; 389  :     }
; 390  : 
; 391  : private:
; 392  :     struct _Iosarray : _Crt_new_delete { // list element for open-ended sparse array of longs/pointers
; 393  :     public:
; 394  :         __CLR_OR_THIS_CALL _Iosarray(int _Idx, _Iosarray* _Link)
; 395  :             : _Next(_Link), _Index(_Idx), _Lo(0), _Vp(nullptr) {} // construct node for index _Idx and link it in
; 396  : 
; 397  :         _Iosarray* _Next; // pointer to next node
; 398  :         int _Index; // index of this node
; 399  :         long _Lo; // stored long value
; 400  :         void* _Vp; // stored pointer value
; 401  :     };
; 402  : 
; 403  :     struct _Fnarray : _Crt_new_delete { // list element for open-ended sparse array of event handlers
; 404  :         __CLR_OR_THIS_CALL _Fnarray(int _Idx, event_callback _Pnew, _Fnarray* _Link)
; 405  :             : _Next(_Link), _Index(_Idx), _Pfn(_Pnew) {} // construct node for index _Idx and link it in
; 406  : 
; 407  :         _Fnarray* _Next; // pointer to next node
; 408  :         int _Index; // index of this node
; 409  :         event_callback _Pfn; // pointer to event handler
; 410  :     };
; 411  : 
; 412  :     void __CLR_OR_THIS_CALL _Callfns(event _Ev) { // call all event handlers, reporting event
; 413  :         for (_Fnarray* _Pfa = _Calls; _Pfa; _Pfa = _Pfa->_Next) {
; 414  :             (*_Pfa->_Pfn)(_Ev, *this, _Pfa->_Index);
; 415  :         }
; 416  :     }
; 417  : 
; 418  :     _Iosarray& __CLR_OR_THIS_CALL _Findarr(int _Idx) { // locate or make a variable array element
; 419  :         _Iosarray* _Ptr1;
; 420  :         _Iosarray* _Ptr2;
; 421  : 
; 422  :         for (_Ptr1 = _Arr, _Ptr2 = nullptr; _Ptr1; _Ptr1 = _Ptr1->_Next) {
; 423  :             if (_Ptr1->_Index == _Idx) {
; 424  :                 return *_Ptr1; // found element, return it
; 425  :             } else if (!_Ptr2 && _Ptr1->_Lo == 0 && !_Ptr1->_Vp) {
; 426  :                 _Ptr2 = _Ptr1; // found recycling candidate
; 427  :             }
; 428  :         }
; 429  : 
; 430  :         if (_Ptr2) { // recycle existing element
; 431  :             _Ptr2->_Index = _Idx;
; 432  :             return *_Ptr2;
; 433  :         }
; 434  : 
; 435  :         _Arr = new _Iosarray(_Idx, _Arr); // make a new element
; 436  :         return *_Arr;
; 437  :     }
; 438  : 
; 439  :     void __CLR_OR_THIS_CALL _Tidy() noexcept { // discard storage for an ios_base
; 440  :         _Callfns(erase_event);
; 441  :         _Iosarray* _Ptr1;
; 442  :         _Iosarray* _Ptr2;
; 443  : 
; 444  :         for (_Ptr1 = _Arr; _Ptr1; _Ptr1 = _Ptr2) { // delete array element
; 445  :             _Ptr2 = _Ptr1->_Next;
; 446  :             delete _Ptr1;
; 447  :         }
; 448  :         _Arr = nullptr;
; 449  : 
; 450  :         _Fnarray* _Pfa1;
; 451  :         _Fnarray* _Pfa2;
; 452  :         for (_Pfa1 = _Calls; _Pfa1; _Pfa1 = _Pfa2) { // delete callback element
; 453  :             _Pfa2 = _Pfa1->_Next;
; 454  :             delete _Pfa1;
; 455  :         }
; 456  :         _Calls = nullptr;
; 457  :     }
; 458  : 
; 459  :     iostate _Mystate{}; // stream state

  00010	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 460  :     iostate _Except{}; // exception mask

  00017	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 461  :     fmtflags _Fmtfl{}; // format flags

  0001e	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 462  :     streamsize _Prec{}; // field precision

  00025	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  0002c	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 463  :     streamsize _Wide{}; // field width

  00033	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
  0003a	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 464  :     _Iosarray* _Arr{nullptr}; // pointer to first node of long/pointer array

  00041	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0

; 465  :     _Fnarray* _Calls{nullptr}; // pointer to first node of call list

  00048	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0

; 466  :     locale* _Ploc{nullptr}; // pointer to locale

  0004f	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 160  :     __CLR_OR_THIS_CALL basic_ios() {}

  00056	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@

; 161  : 
; 162  : private:
; 163  :     _Mysb* _Mystrbuf{}; // pointer to stream buffer

  0005c	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0

; 164  :     _Myos* _Tiestr{}; // pointer to tied output stream

  00063	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0

; 165  :     _Elem _Fillch{}; // the fill character

  0006a	c6 41 40 00	 mov	 BYTE PTR [ecx+64], 0

; 160  :     __CLR_OR_THIS_CALL basic_ios() {}

  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ ENDP	; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
;	COMDAT ?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z
_TEXT	SEGMENT
$T2 = -40						; size = 20
$T3 = -20						; size = 8
$T4 = -20						; size = 8
__$EHRec$ = -12						; size = 12
__Strbuf$ = 8						; size = 4
__Isstd$ = 12						; size = 1
?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::init, COMDAT
; _this$ = ecx

; 144  :     void __CLR_OR_THIS_CALL init(_Mysb* _Strbuf = nullptr, bool _Isstd = false) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 388  :         _Ploc = new locale;

  0002a	6a 08		 push	 8
  0002c	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
  00033	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0003a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00041	c7 46 14 01 02
	00 00		 mov	 DWORD PTR [esi+20], 513	; 00000201H
  00048	c7 46 18 06 00
	00 00		 mov	 DWORD PTR [esi+24], 6
  0004f	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
  00056	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
  0005d	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  00064	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
  0006b	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0

; 156  :         _Mystate             = _State;

  00072	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 388  :         _Ploc = new locale;

  00079	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0007e	8b f8		 mov	 edi, eax
  00080	83 c4 04	 add	 esp, 4
  00083	85 ff		 test	 edi, edi
  00085	74 16		 je	 SHORT $LN7@init
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 272  :     locale() noexcept : _Ptr(_Init(true)) {}

  00087	6a 01		 push	 1
  00089	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00090	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@_N@Z ; std::locale::_Init
  00095	83 c4 04	 add	 esp, 4
  00098	89 47 04	 mov	 DWORD PTR [edi+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 388  :         _Ploc = new locale;

  0009b	eb 02		 jmp	 SHORT $LN8@init
$LN7@init:
  0009d	33 ff		 xor	 edi, edi
$LN8@init:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 147  :         _Mystrbuf = _Strbuf;

  0009f	8b 45 08	 mov	 eax, DWORD PTR __Strbuf$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 388  :         _Ploc = new locale;

  000a2	89 7e 30	 mov	 DWORD PTR [esi+48], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 147  :         _Mystrbuf = _Strbuf;

  000a5	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 148  :         _Tiestr   = nullptr;

  000a8	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  000af	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]

; 269  :         _Ptr->_Incref();

  000b2	8b cf		 mov	 ecx, edi
  000b4	89 7d f0	 mov	 DWORD PTR $T3[ebp+4], edi
  000b7	8b 07		 mov	 eax, DWORD PTR [edi]
  000b9	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 113  :         return _STD use_facet<_Ctype>(getloc()).widen(_Byte);

  000bc	8d 45 ec	 lea	 eax, DWORD PTR $T3[ebp]
  000bf	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  000cc	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 2755 :         return do_widen(_Byte);

  000cf	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d1	6a 20		 push	 32			; 00000020H
  000d3	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  000d6	8b c8		 mov	 ecx, eax
  000d8	ff d2		 call	 edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 113  :         return _STD use_facet<_Ctype>(getloc()).widen(_Byte);

  000da	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000e1	8a d8		 mov	 bl, al
  000e3	85 ff		 test	 edi, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

  000e5	74 13		 je	 SHORT $LN43@init

; 355  :             delete _Ptr->_Decref();

  000e7	8b 17		 mov	 edx, DWORD PTR [edi]
  000e9	8b cf		 mov	 ecx, edi
  000eb	ff 52 08	 call	 DWORD PTR [edx+8]
  000ee	85 c0		 test	 eax, eax
  000f0	74 08		 je	 SHORT $LN43@init
  000f2	8b 10		 mov	 edx, DWORD PTR [eax]
  000f4	8b c8		 mov	 ecx, eax
  000f6	6a 01		 push	 1
  000f8	ff 12		 call	 DWORD PTR [edx]
$LN43@init:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 151  :         if (!_Mystrbuf) {

  000fa	83 7e 38 00	 cmp	 DWORD PTR [esi+56], 0
  000fe	88 5e 40	 mov	 BYTE PTR [esi+64], bl
  00101	75 13		 jne	 SHORT $LN51@init
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 155  :         _State &= _Statmask;

  00103	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]

; 157  :         const auto _Filtered = _State & _Except;

  00106	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00109	83 e0 13	 and	 eax, 19			; 00000013H
  0010c	83 c8 04	 or	 eax, 4
  0010f	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00112	23 c8		 and	 ecx, eax

; 158  :         if (_Filtered) {

  00114	75 23		 jne	 SHORT $LN64@init
$LN51@init:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 155  :         if (_Isstd) {

  00116	80 7d 0c 00	 cmp	 BYTE PTR __Isstd$[ebp], 0
  0011a	74 09		 je	 SHORT $LN3@init

; 156  :             _Addstd(this); // special handling for standard streams

  0011c	56		 push	 esi
  0011d	e8 00 00 00 00	 call	 ?_Addstd@ios_base@std@@SAXPAV12@@Z ; std::ios_base::_Addstd
  00122	83 c4 04	 add	 esp, 4
$LN3@init:

; 158  :     }

  00125	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00128	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0012f	59		 pop	 ecx
  00130	5f		 pop	 edi
  00131	5e		 pop	 esi
  00132	5b		 pop	 ebx
  00133	8b e5		 mov	 esp, ebp
  00135	5d		 pop	 ebp
  00136	c2 08 00	 ret	 8
$LN64@init:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 164  :             if (_Filtered & ios_base::badbit) {

  00139	f6 c1 04	 test	 cl, 4
  0013c	74 07		 je	 SHORT $LN53@init

; 165  :                 _Msg = "ios_base::badbit set";

  0013e	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  00143	eb 10		 jmp	 SHORT $LN55@init
$LN53@init:

; 166  :             } else if (_Filtered & ios_base::failbit) {

  00145	f6 c1 02	 test	 cl, 2
  00148	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
  0014d	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
  00152	0f 44 f0	 cmove	 esi, eax
$LN55@init:

; 167  :                 _Msg = "ios_base::failbit set";
; 168  :             } else {
; 169  :                 _Msg = "ios_base::eofbit set";
; 170  :             }
; 171  : 
; 172  :             _THROW(failure(_Msg));

  00155	8d 45 ec	 lea	 eax, DWORD PTR $T4[ebp]
  00158	6a 01		 push	 1
  0015a	50		 push	 eax
  0015b	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  00160	83 c4 08	 add	 esp, 8
  00163	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  00166	50		 push	 eax
  00167	56		 push	 esi
  00168	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  0016d	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00172	8d 45 d8	 lea	 eax, DWORD PTR $T2[ebp]
  00175	50		 push	 eax
  00176	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN62@init:
  0017b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z$1:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::init
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::setstate, COMDAT
; _this$ = ecx

; 49   :     void __CLR_OR_THIS_CALL setstate(iostate _State, bool _Reraise = false) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  00003	ff 75 0c	 push	 DWORD PTR __Reraise$[ebp]
  00006	33 d2		 xor	 edx, edx
  00008	b8 04 00 00 00	 mov	 eax, 4
  0000d	39 51 38	 cmp	 DWORD PTR [ecx+56], edx
  00010	0f 45 c2	 cmovne	 eax, edx
  00013	0b 41 0c	 or	 eax, DWORD PTR [ecx+12]
  00016	0b 45 08	 or	 eax, DWORD PTR __State$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 50   :         // merge _State into state, possibly reraise exception
; 51   :         clear(rdstate() | _State, _Reraise);
; 52   :     }

  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::setstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
;	COMDAT ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ PROC	; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 36   :     __CLR_OR_THIS_CALL ~basic_ios() noexcept override {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 368  :         _Ios_base_dtor(this);

  00022	51		 push	 ecx
  00023	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ios_base@std@@6B@
  00030	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00035	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 36   :     __CLR_OR_THIS_CALL ~basic_ios() noexcept override {}

  00038	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00042	59		 pop	 ecx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
  00047	cc		 int	 3
  00048	cc		 int	 3
  00049	cc		 int	 3
  0004a	cc		 int	 3
  0004b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP	; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\random
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\random
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\random
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
;	COMDAT ?SecureWipeFile@@YAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@T_LARGE_INTEGER@@@Z
_TEXT	SEGMENT
__Ptr$1$ = -5060					; size = 4
_randomBuffer$ = -5056					; size = 12
_totalWritten$ = -5044					; size = 8
_totalWritten$1$ = -5040				; size = 4
_bytesWritten$ = -5036					; size = 4
_hFile$1$ = -5032					; size = 4
$T2 = -5028						; size = 4
_totalWritten$2$ = -5024				; size = 4
_writeFailed$1$ = -5017					; size = 1
_gen$ = -5016						; size = 5000
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_filePath$ = 8						; size = 4
_fileSize$ = 12						; size = 8
?SecureWipeFile@@YAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@T_LARGE_INTEGER@@@Z PROC ; SecureWipeFile, COMDAT

; 118  : void SecureWipeFile(const std::wstring& filePath, LARGE_INTEGER fileSize) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SecureWipeFile@@YAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@T_LARGE_INTEGER@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 c0 13 00 00	 mov	 eax, 5056		; 000013c0H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00032	8b 45 08	 mov	 eax, DWORD PTR _filePath$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00035	83 78 14 07	 cmp	 DWORD PTR [eax+20], 7

; 445  :         if (_Large_mode_engaged()) {

  00039	76 02		 jbe	 SHORT $LN84@SecureWipe

; 446  :             _Result = _Unfancy(_Bx._Ptr);

  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
$LN84@SecureWipe:
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 119  :     HANDLE hFile = CreateFileW(

  0003d	6a 00		 push	 0
  0003f	68 80 00 00 00	 push	 128			; 00000080H
  00044	6a 03		 push	 3
  00046	6a 00		 push	 0
  00048	6a 07		 push	 7
  0004a	68 00 00 00 40	 push	 1073741824		; 40000000H
  0004f	50		 push	 eax
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileW@28
  00056	8b d8		 mov	 ebx, eax
  00058	89 9d 58 ec ff
	ff		 mov	 DWORD PTR _hFile$1$[ebp], ebx

; 120  :         filePath.c_str(),
; 121  :         GENERIC_WRITE,
; 122  :         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
; 123  :         nullptr,
; 124  :         OPEN_EXISTING,
; 125  :         FILE_ATTRIBUTE_NORMAL,
; 126  :         nullptr);
; 127  :     if (hFile == INVALID_HANDLE_VALUE) {

  0005e	83 fb ff	 cmp	 ebx, -1
  00061	75 17		 jne	 SHORT $LN7@SecureWipe

; 128  :         std::cout << "Failed to open file for overwrite\n";

  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@JHGEGGMB@Failed?5to?5open?5file?5for?5overwri@
  00068	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  0006d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00072	83 c4 08	 add	 esp, 8

; 129  :         return;

  00075	e9 36 02 00 00	 jmp	 $LN78@SecureWipe
$LN7@SecureWipe:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0007a	c7 85 40 ec ff
	ff 00 00 00 00	 mov	 DWORD PTR _randomBuffer$[ebp], 0
  00084	c7 85 44 ec ff
	ff 00 00 00 00	 mov	 DWORD PTR _randomBuffer$[ebp+4], 0
  0008e	c7 85 48 ec ff
	ff 00 00 00 00	 mov	 DWORD PTR _randomBuffer$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 136  :         return ::operator new(_Bytes);

  00098	68 23 10 00 00	 push	 4131			; 00001023H
  0009d	0f ae e8	 lfence
  000a0	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000a5	83 c4 04	 add	 esp, 4

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  000a8	85 c0		 test	 eax, eax
  000aa	0f 84 1c 02 00
	00		 je	 $LN214@SecureWipe

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000b0	8d 78 23	 lea	 edi, DWORD PTR [eax+35]
  000b3	83 e7 e0	 and	 edi, -32		; ffffffe0H

; 2072 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  000b6	68 00 10 00 00	 push	 4096			; 00001000H
  000bb	6a 00		 push	 0
  000bd	57		 push	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2037 :         _Myend                = _Newvec + _Newcapacity;

  000be	8d b7 00 10 00
	00		 lea	 esi, DWORD PTR [edi+4096]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000c4	89 bd 3c ec ff
	ff		 mov	 DWORD PTR __Ptr$1$[ebp], edi

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000ca	89 47 fc	 mov	 DWORD PTR [edi-4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2035 :         _Myfirst              = _Newvec;

  000cd	89 bd 40 ec ff
	ff		 mov	 DWORD PTR _randomBuffer$[ebp], edi

; 2037 :         _Myend                = _Newvec + _Newcapacity;

  000d3	89 b5 48 ec ff
	ff		 mov	 DWORD PTR _randomBuffer$[ebp+8], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 2072 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  000d9	e8 00 00 00 00	 call	 _memset
  000de	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2115 :                 _My_data._Mylast = _STD _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

  000e1	89 b5 44 ec ff
	ff		 mov	 DWORD PTR _randomBuffer$[ebp+4], esi
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 132  :     std::vector<BYTE> randomBuffer(4096);

  000e7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\random

; 5640 :         return _Random_device();

  000ee	e8 00 00 00 00	 call	 ?_Random_device@std@@YAIXZ ; std::_Random_device

; 1278 :         : _Dxval(_Dxarg) {

  000f3	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _gen$[ebp+4996], -1
  000fa	ba 01 00 00 00	 mov	 edx, 1

; 1289 :         _Ty _Prev = this->_Ax[0] = _Xx0 & _WMSK;

  000ff	89 85 6c ec ff
	ff		 mov	 DWORD PTR _gen$[ebp+4], eax
$LL191@SecureWipe:

; 1290 :         for (size_t _Ix = 1; _Ix < _Nx; ++_Ix) {
; 1291 :             _Prev = this->_Ax[_Ix] = (_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;

  00105	8b c8		 mov	 ecx, eax
  00107	c1 e9 1e	 shr	 ecx, 30			; 0000001eH
  0010a	33 c8		 xor	 ecx, eax
  0010c	69 c1 65 89 07
	6c		 imul	 eax, ecx, 1812433253
  00112	03 c2		 add	 eax, edx
  00114	89 84 95 6c ec
	ff ff		 mov	 DWORD PTR _gen$[ebp+edx*4+4], eax
  0011b	42		 inc	 edx
  0011c	81 fa 70 02 00
	00		 cmp	 edx, 624		; 00000270H
  00122	72 e1		 jb	 SHORT $LL191@SecureWipe
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 142  :     while (totalWritten < fileSize.QuadPart) {

  00124	8b 4d 10	 mov	 ecx, DWORD PTR _fileSize$[ebp+4]
  00127	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\random

; 1294 :         this->_Idx = _Nx;

  0012a	c7 85 68 ec ff
	ff 70 02 00 00	 mov	 DWORD PTR _gen$[ebp], 624 ; 00000270H
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 137  :     DWORD bytesWritten = 0;

  00134	c7 85 54 ec ff
	ff 00 00 00 00	 mov	 DWORD PTR _bytesWritten$[ebp], 0

; 138  :     LONGLONG totalWritten = 0;

  0013e	66 0f 13 85 4c
	ec ff ff	 movlpd	 QWORD PTR _totalWritten$[ebp], xmm0

; 139  :     bool writeFailed = false;

  00146	c6 85 67 ec ff
	ff 00		 mov	 BYTE PTR _writeFailed$1$[ebp], 0

; 142  :     while (totalWritten < fileSize.QuadPart) {

  0014d	85 c9		 test	 ecx, ecx
  0014f	0f 8c 13 01 00
	00		 jl	 $LN3@SecureWipe
  00155	7f 0a		 jg	 SHORT $LN208@SecureWipe
  00157	83 7d 0c 00	 cmp	 DWORD PTR _fileSize$[ebp], 0
  0015b	0f 86 07 01 00
	00		 jbe	 $LN3@SecureWipe
$LN208@SecureWipe:

; 144  :         DWORD toWrite = static_cast<DWORD>(std::min<LONGLONG>(randomBuffer.size(), fileSize.QuadPart - totalWritten));

  00161	8b 85 50 ec ff
	ff		 mov	 eax, DWORD PTR _totalWritten$[ebp+4]
  00167	8d 8f 00 10 00
	00		 lea	 ecx, DWORD PTR [edi+4096]
  0016d	8b 9d 4c ec ff
	ff		 mov	 ebx, DWORD PTR _totalWritten$[ebp]
  00173	8b d1		 mov	 edx, ecx
  00175	2b d7		 sub	 edx, edi
  00177	89 85 60 ec ff
	ff		 mov	 DWORD PTR _totalWritten$2$[ebp], eax
  0017d	8b 45 0c	 mov	 eax, DWORD PTR _fileSize$[ebp]
  00180	89 95 5c ec ff
	ff		 mov	 DWORD PTR $T2[ebp], edx
  00186	89 9d 50 ec ff
	ff		 mov	 DWORD PTR _totalWritten$1$[ebp], ebx
  0018c	0f 1f 40 00	 npad	 4
$LL2@SecureWipe:

; 143  :         for (auto& b : randomBuffer) b = static_cast<BYTE>(dis(gen));

  00190	8b f7		 mov	 esi, edi
  00192	3b f9		 cmp	 edi, ecx
  00194	74 34		 je	 SHORT $LN5@SecureWipe
  00196	8b bd 48 ec ff
	ff		 mov	 edi, DWORD PTR _randomBuffer$[ebp+8]
  0019c	bb 00 01 00 00	 mov	 ebx, 256		; 00000100H
$LL6@SecureWipe:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\random

; 1534 :         return _Mybase::operator()();

  001a1	8d 8d 68 ec ff
	ff		 lea	 ecx, DWORD PTR _gen$[ebp]
  001a7	e8 00 00 00 00	 call	 ??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()

; 2188 :             return _Uprod{_Ret} * _Uprod{_Index};

  001ac	f7 e3		 mul	 ebx
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 143  :         for (auto& b : randomBuffer) b = static_cast<BYTE>(dis(gen));

  001ae	88 16		 mov	 BYTE PTR [esi], dl
  001b0	46		 inc	 esi
  001b1	3b f7		 cmp	 esi, edi
  001b3	75 ec		 jne	 SHORT $LL6@SecureWipe
  001b5	8b bd 3c ec ff
	ff		 mov	 edi, DWORD PTR __Ptr$1$[ebp]
  001bb	8b 9d 50 ec ff
	ff		 mov	 ebx, DWORD PTR _totalWritten$1$[ebp]
  001c1	8b 95 5c ec ff
	ff		 mov	 edx, DWORD PTR $T2[ebp]
  001c7	8b 45 0c	 mov	 eax, DWORD PTR _fileSize$[ebp]
$LN5@SecureWipe:

; 144  :         DWORD toWrite = static_cast<DWORD>(std::min<LONGLONG>(randomBuffer.size(), fileSize.QuadPart - totalWritten));

  001ca	8b f0		 mov	 esi, eax
  001cc	8b 45 10	 mov	 eax, DWORD PTR _fileSize$[ebp+4]
  001cf	2b f3		 sub	 esi, ebx
  001d1	1b 85 60 ec ff
	ff		 sbb	 eax, DWORD PTR _totalWritten$2$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 101  :     return _Right < _Left ? _Right : _Left;

  001d7	85 c0		 test	 eax, eax
  001d9	7f 06		 jg	 SHORT $LN74@SecureWipe
  001db	7c 06		 jl	 SHORT $LN75@SecureWipe
  001dd	3b f2		 cmp	 esi, edx
  001df	72 02		 jb	 SHORT $LN75@SecureWipe
$LN74@SecureWipe:
  001e1	8b f2		 mov	 esi, edx
$LN75@SecureWipe:
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 145  :         if (!WriteFile(hFile, randomBuffer.data(), toWrite, &bytesWritten, nullptr) || bytesWritten != toWrite) {

  001e3	6a 00		 push	 0
  001e5	8d 85 54 ec ff
	ff		 lea	 eax, DWORD PTR _bytesWritten$[ebp]
  001eb	50		 push	 eax
  001ec	56		 push	 esi
  001ed	57		 push	 edi
  001ee	ff b5 58 ec ff
	ff		 push	 DWORD PTR _hFile$1$[ebp]
  001f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  001fa	85 c0		 test	 eax, eax
  001fc	74 4b		 je	 SHORT $LN185@SecureWipe
  001fe	8b 85 54 ec ff
	ff		 mov	 eax, DWORD PTR _bytesWritten$[ebp]
  00204	3b c6		 cmp	 eax, esi
  00206	75 41		 jne	 SHORT $LN185@SecureWipe

; 142  :     while (totalWritten < fileSize.QuadPart) {

  00208	8b 95 5c ec ff
	ff		 mov	 edx, DWORD PTR $T2[ebp]
  0020e	8d 8f 00 10 00
	00		 lea	 ecx, DWORD PTR [edi+4096]

; 148  :             break;
; 149  :         }
; 150  :         totalWritten += bytesWritten;

  00214	03 d8		 add	 ebx, eax
  00216	8b 85 60 ec ff
	ff		 mov	 eax, DWORD PTR _totalWritten$2$[ebp]
  0021c	89 9d 50 ec ff
	ff		 mov	 DWORD PTR _totalWritten$1$[ebp], ebx
  00222	83 d0 00	 adc	 eax, 0
  00225	3b 45 10	 cmp	 eax, DWORD PTR _fileSize$[ebp+4]
  00228	89 85 60 ec ff
	ff		 mov	 DWORD PTR _totalWritten$2$[ebp], eax
  0022e	8b 45 0c	 mov	 eax, DWORD PTR _fileSize$[ebp]
  00231	0f 8c 59 ff ff
	ff		 jl	 $LL2@SecureWipe

; 142  :     while (totalWritten < fileSize.QuadPart) {

  00237	7f 29		 jg	 SHORT $LN210@SecureWipe
  00239	8d 8f 00 10 00
	00		 lea	 ecx, DWORD PTR [edi+4096]
  0023f	3b d8		 cmp	 ebx, eax
  00241	0f 82 49 ff ff
	ff		 jb	 $LL2@SecureWipe

; 145  :         if (!WriteFile(hFile, randomBuffer.data(), toWrite, &bytesWritten, nullptr) || bytesWritten != toWrite) {

  00247	eb 19		 jmp	 SHORT $LN210@SecureWipe
$LN185@SecureWipe:

; 146  :             std::cout << "Failed to write random data to file\n";

  00249	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@GPLPEJGN@Failed?5to?5write?5random?5data?5to?5@
  0024e	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  00253	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00258	83 c4 08	 add	 esp, 8

; 147  :             writeFailed = true;

  0025b	c6 85 67 ec ff
	ff 01		 mov	 BYTE PTR _writeFailed$1$[ebp], 1
$LN210@SecureWipe:

; 151  :     }
; 152  : 
; 153  :     // Truncate file to zero length
; 154  :     SetFilePointer(hFile, 0, nullptr, FILE_BEGIN);

  00262	8b 9d 58 ec ff
	ff		 mov	 ebx, DWORD PTR _hFile$1$[ebp]
$LN3@SecureWipe:
  00268	6a 00		 push	 0
  0026a	6a 00		 push	 0
  0026c	6a 00		 push	 0
  0026e	53		 push	 ebx
  0026f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointer@16

; 155  :     SetEndOfFile(hFile);

  00275	53		 push	 ebx
  00276	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEndOfFile@4

; 156  : 
; 157  :     CloseHandle(hFile);

  0027c	53		 push	 ebx
  0027d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 830  :         _Tidy();

  00283	80 bd 67 ec ff
	ff 00		 cmp	 BYTE PTR _writeFailed$1$[ebp], 0
  0028a	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BL@KNKFCKIE@Executable?5securely?5wiped?6@
  0028f	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0DB@PHJEDLD@Executable?5wipe?5incomplete?5due?5@
  00294	0f 44 c1	 cmove	 eax, ecx
  00297	50		 push	 eax
  00298	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  0029d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002a2	83 c4 08	 add	 esp, 8
  002a5	8d 8d 40 ec ff
	ff		 lea	 ecx, DWORD PTR _randomBuffer$[ebp]
  002ab	e8 00 00 00 00	 call	 ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
$LN78@SecureWipe:
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 162  : }

  002b0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002b3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002ba	59		 pop	 ecx
  002bb	5f		 pop	 edi
  002bc	5e		 pop	 esi
  002bd	5b		 pop	 ebx
  002be	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002c1	33 cd		 xor	 ecx, ebp
  002c3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002c8	8b e5		 mov	 esp, ebp
  002ca	5d		 pop	 ebp
  002cb	c3		 ret	 0
$LN214@SecureWipe:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  002cc	6a 00		 push	 0
  002ce	6a 00		 push	 0
  002d0	6a 00		 push	 0
  002d2	6a 00		 push	 0
  002d4	6a 00		 push	 0
  002d6	e8 00 00 00 00	 call	 __invoke_watson
$LN212@SecureWipe:
  002db	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SecureWipeFile@@YAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@T_LARGE_INTEGER@@@Z$0:
  00000	8d 8d 40 ec ff
	ff		 lea	 ecx, DWORD PTR _randomBuffer$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$?SecureWipeFile@@YAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@T_LARGE_INTEGER@@@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 30 ec ff
	ff		 mov	 ecx, DWORD PTR [edx-5072]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SecureWipeFile@@YAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@T_LARGE_INTEGER@@@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SecureWipeFile@@YAXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@T_LARGE_INTEGER@@@Z ENDP ; SecureWipeFile
; Function compile flags: /Ogtp
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
;	COMDAT ?IsFileOwnerSystemOrAdmin@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
_TEXT	SEGMENT
_sd$ = -8						; size = 4
_ownerSid$ = -4						; size = 4
_filePath$ = 8						; size = 4
_sidString$ = 8						; size = 4
?IsFileOwnerSystemOrAdmin@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z PROC ; IsFileOwnerSystemOrAdmin, COMDAT

; 101  : bool IsFileOwnerSystemOrAdmin(const std::wstring& filePath) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

  00006	8b 45 08	 mov	 eax, DWORD PTR _filePath$[ebp]
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 102  :     PSID ownerSid = nullptr;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ownerSid$[ebp], 0

; 103  :     PSECURITY_DESCRIPTOR sd = nullptr;

  00010	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _sd$[ebp], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00017	83 78 14 07	 cmp	 DWORD PTR [eax+20], 7

; 445  :         if (_Large_mode_engaged()) {

  0001b	76 02		 jbe	 SHORT $LN12@IsFileOwne

; 446  :             _Result = _Unfancy(_Bx._Ptr);

  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
$LN12@IsFileOwne:
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 104  :     if (GetNamedSecurityInfoW(filePath.c_str(), SE_FILE_OBJECT, OWNER_SECURITY_INFORMATION, &ownerSid, nullptr, nullptr, nullptr, &sd) != ERROR_SUCCESS)

  0001f	8d 4d f8	 lea	 ecx, DWORD PTR _sd$[ebp]
  00022	51		 push	 ecx
  00023	6a 00		 push	 0
  00025	6a 00		 push	 0
  00027	6a 00		 push	 0
  00029	8d 4d fc	 lea	 ecx, DWORD PTR _ownerSid$[ebp]
  0002c	51		 push	 ecx
  0002d	6a 01		 push	 1
  0002f	6a 01		 push	 1
  00031	50		 push	 eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetNamedSecurityInfoW@32
  00038	85 c0		 test	 eax, eax
  0003a	74 06		 je	 SHORT $LN2@IsFileOwne

; 105  :         return false;

  0003c	32 c0		 xor	 al, al

; 116  : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
$LN2@IsFileOwne:
  00042	53		 push	 ebx

; 106  :     WCHAR* sidString = nullptr;
; 107  :     bool isSystemOrAdmin = false;
; 108  :     if (ConvertSidToStringSidW(ownerSid, &sidString)) {

  00043	8d 45 08	 lea	 eax, DWORD PTR _sidString$[ebp]
  00046	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _sidString$[ebp], 0
  0004d	50		 push	 eax
  0004e	ff 75 fc	 push	 DWORD PTR _ownerSid$[ebp]
  00051	32 db		 xor	 bl, bl
  00053	e8 00 00 00 00	 call	 _ConvertSidToStringSidW@8
  00058	85 c0		 test	 eax, eax
  0005a	74 7d		 je	 SHORT $LN3@IsFileOwne

; 109  :         if (wcscmp(sidString, L"S-1-5-18") == 0 || // SYSTEM

  0005c	56		 push	 esi
  0005d	8b 75 08	 mov	 esi, DWORD PTR _sidString$[ebp]
  00060	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_1BC@FOGOLNOF@?$AAS?$AA?9?$AA1?$AA?9?$AA5?$AA?9?$AA1?$AA8@
  00065	8b c6		 mov	 eax, esi
$LL18@IsFileOwne:
  00067	66 8b 10	 mov	 dx, WORD PTR [eax]
  0006a	66 3b 11	 cmp	 dx, WORD PTR [ecx]
  0006d	75 1e		 jne	 SHORT $LN19@IsFileOwne
  0006f	66 85 d2	 test	 dx, dx
  00072	74 15		 je	 SHORT $LN20@IsFileOwne
  00074	66 8b 50 02	 mov	 dx, WORD PTR [eax+2]
  00078	66 3b 51 02	 cmp	 dx, WORD PTR [ecx+2]
  0007c	75 0f		 jne	 SHORT $LN19@IsFileOwne
  0007e	83 c0 04	 add	 eax, 4
  00081	83 c1 04	 add	 ecx, 4
  00084	66 85 d2	 test	 dx, dx
  00087	75 de		 jne	 SHORT $LL18@IsFileOwne
$LN20@IsFileOwne:
  00089	33 c0		 xor	 eax, eax
  0008b	eb 05		 jmp	 SHORT $LN21@IsFileOwne
$LN19@IsFileOwne:
  0008d	1b c0		 sbb	 eax, eax
  0008f	83 c8 01	 or	 eax, 1
$LN21@IsFileOwne:
  00092	85 c0		 test	 eax, eax
  00094	74 39		 je	 SHORT $LN5@IsFileOwne
  00096	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_1BK@KDDKMJBN@?$AAS?$AA?9?$AA1?$AA?9?$AA5?$AA?9?$AA3?$AA2?$AA?9?$AA5?$AA4?$AA4@
  0009b	8b c6		 mov	 eax, esi
  0009d	0f 1f 00	 npad	 3
$LL22@IsFileOwne:
  000a0	66 8b 10	 mov	 dx, WORD PTR [eax]
  000a3	66 3b 11	 cmp	 dx, WORD PTR [ecx]
  000a6	75 1e		 jne	 SHORT $LN23@IsFileOwne
  000a8	66 85 d2	 test	 dx, dx
  000ab	74 15		 je	 SHORT $LN24@IsFileOwne
  000ad	66 8b 50 02	 mov	 dx, WORD PTR [eax+2]
  000b1	66 3b 51 02	 cmp	 dx, WORD PTR [ecx+2]
  000b5	75 0f		 jne	 SHORT $LN23@IsFileOwne
  000b7	83 c0 04	 add	 eax, 4
  000ba	83 c1 04	 add	 ecx, 4
  000bd	66 85 d2	 test	 dx, dx
  000c0	75 de		 jne	 SHORT $LL22@IsFileOwne
$LN24@IsFileOwne:
  000c2	33 c0		 xor	 eax, eax
  000c4	eb 05		 jmp	 SHORT $LN25@IsFileOwne
$LN23@IsFileOwne:
  000c6	1b c0		 sbb	 eax, eax
  000c8	83 c8 01	 or	 eax, 1
$LN25@IsFileOwne:
  000cb	85 c0		 test	 eax, eax
  000cd	75 02		 jne	 SHORT $LN4@IsFileOwne
$LN5@IsFileOwne:

; 110  :             wcscmp(sidString, L"S-1-5-32-544") == 0) // Administrators
; 111  :             isSystemOrAdmin = true;

  000cf	b3 01		 mov	 bl, 1
$LN4@IsFileOwne:

; 112  :         LocalFree(sidString);

  000d1	56		 push	 esi
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4
  000d8	5e		 pop	 esi
$LN3@IsFileOwne:

; 113  :     }
; 114  :     if (sd) LocalFree(sd);

  000d9	8b 4d f8	 mov	 ecx, DWORD PTR _sd$[ebp]
  000dc	85 c9		 test	 ecx, ecx
  000de	74 07		 je	 SHORT $LN6@IsFileOwne
  000e0	51		 push	 ecx
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4
$LN6@IsFileOwne:

; 115  :     return isSystemOrAdmin;

  000e7	8a c3		 mov	 al, bl
  000e9	5b		 pop	 ebx

; 116  : }

  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c3		 ret	 0
?IsFileOwnerSystemOrAdmin@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ENDP ; IsFileOwnerSystemOrAdmin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
;	COMDAT ?IsSafeWipePath@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
_TEXT	SEGMENT
_lowerPath$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_exePath$ = 8						; size = 4
?IsSafeWipePath@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z PROC ; IsSafeWipePath, COMDAT

; 86   : bool IsSafeWipePath(const std::wstring& exePath) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?IsSafeWipePath@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 45 08	 mov	 eax, DWORD PTR _exePath$[ebp]

; 88   :     std::wstring lowerPath = exePath;

  0002e	8d 4d d8	 lea	 ecx, DWORD PTR _lowerPath$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00037	8b 55 ec	 mov	 edx, DWORD PTR _lowerPath$[ebp+20]

; 435  :         value_type* _Result = _Bx._Buf;

  0003a	8d 45 d8	 lea	 eax, DWORD PTR _lowerPath$[ebp]

; 2170 :         return iterator(

  0003d	8b 4d e8	 mov	 ecx, DWORD PTR _lowerPath$[ebp+16]

; 435  :         value_type* _Result = _Bx._Buf;

  00040	8d 75 d8	 lea	 esi, DWORD PTR _lowerPath$[ebp]

; 453  :         return _Myres > _Small_string_capacity;

  00043	83 fa 07	 cmp	 edx, 7
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 88   :     std::wstring lowerPath = exePath;

  00046	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 435  :         value_type* _Result = _Bx._Buf;

  0004d	8d 7d d8	 lea	 edi, DWORD PTR _lowerPath$[ebp]

; 436  :         if (_Large_mode_engaged()) {

  00050	0f 47 45 d8	 cmova	 eax, DWORD PTR _lowerPath$[ebp]
  00054	0f 47 7d d8	 cmova	 edi, DWORD PTR _lowerPath$[ebp]

; 2170 :         return iterator(

  00058	8d 1c 48	 lea	 ebx, DWORD PTR [eax+ecx*2]

; 436  :         if (_Large_mode_engaged()) {

  0005b	8b 45 d8	 mov	 eax, DWORD PTR _lowerPath$[ebp]
  0005e	0f 47 f0	 cmova	 esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 3798 :     for (; _UFirst != _ULast; ++_UFirst, (void) ++_UDest) {

  00061	3b f3		 cmp	 esi, ebx
  00063	74 22		 je	 SHORT $LN59@IsSafeWipe
  00065	2b fe		 sub	 edi, esi
$LL60@IsSafeWipe:

; 3799 :         *_UDest = _Func(*_UFirst);

  00067	0f b7 06	 movzx	 eax, WORD PTR [esi]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 _towlower
  00070	66 89 04 37	 mov	 WORD PTR [edi+esi], ax
  00074	83 c4 04	 add	 esp, 4
  00077	83 c6 02	 add	 esi, 2
  0007a	3b f3		 cmp	 esi, ebx
  0007c	75 e9		 jne	 SHORT $LL60@IsSafeWipe
  0007e	8b 55 ec	 mov	 edx, DWORD PTR _lowerPath$[ebp+20]
  00081	8b 4d e8	 mov	 ecx, DWORD PTR _lowerPath$[ebp+16]
  00084	8b 45 d8	 mov	 eax, DWORD PTR _lowerPath$[ebp]
$LN59@IsSafeWipe:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00087	83 fa 07	 cmp	 edx, 7

; 444  :         const value_type* _Result = _Bx._Buf;

  0008a	8d 7d d8	 lea	 edi, DWORD PTR _lowerPath$[ebp]

; 445  :         if (_Large_mode_engaged()) {

  0008d	0f 47 f8	 cmova	 edi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 641  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

  00090	83 f9 09	 cmp	 ecx, 9
  00093	72 21		 jb	 SHORT $LN143@IsSafeWipe
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 252  :         return const_cast<_Ty1*>(static_cast<const _Ty1*>(::__std_search_2(_First1, _Last1, _First2, _Count2)));

  00095	6a 09		 push	 9
  00097	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@NMFIMKAA@?$AA?2?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?2@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 660  :             const auto _End = _Haystack + _Hay_size;

  0009c	8d 34 4f	 lea	 esi, DWORD PTR [edi+ecx*2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 252  :         return const_cast<_Ty1*>(static_cast<const _Ty1*>(::__std_search_2(_First1, _Last1, _First2, _Count2)));

  0009f	56		 push	 esi
  000a0	57		 push	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 653  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible

  000a1	0f ae e8	 lfence
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 252  :         return const_cast<_Ty1*>(static_cast<const _Ty1*>(::__std_search_2(_First1, _Last1, _First2, _Count2)));

  000a4	e8 00 00 00 00	 call	 ___std_search_2@16
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 663  :             if (_Ptr != _End) {

  000a9	3b c6		 cmp	 eax, esi
  000ab	74 09		 je	 SHORT $LN143@IsSafeWipe

; 664  :                 return static_cast<size_t>(_Ptr - _Haystack);

  000ad	2b c7		 sub	 eax, edi
  000af	d1 f8		 sar	 eax, 1
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 91   :         lowerPath.find(L"\\system32\\") != std::wstring::npos ||

  000b1	83 f8 ff	 cmp	 eax, -1
  000b4	75 54		 jne	 SHORT $LN3@IsSafeWipe
$LN143@IsSafeWipe:
  000b6	6a 00		 push	 0
  000b8	68 00 00 00 00	 push	 OFFSET ??_C@_1BG@NCCDOFIB@?$AA?2?$AAs?$AAy?$AAs?$AAt?$AAe?$AAm?$AA3?$AA2?$AA?2@
  000bd	8d 4d d8	 lea	 ecx, DWORD PTR _lowerPath$[ebp]
  000c0	e8 00 00 00 00	 call	 ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find
  000c5	83 f8 ff	 cmp	 eax, -1
  000c8	75 40		 jne	 SHORT $LN3@IsSafeWipe
  000ca	6a 00		 push	 0
  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_1DG@CIFNPBMN@?$AA?2?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?2?$AAs?$AAy?$AAs?$AAt?$AAe?$AAm@
  000d1	8d 4d d8	 lea	 ecx, DWORD PTR _lowerPath$[ebp]
  000d4	e8 00 00 00 00	 call	 ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find
  000d9	83 f8 ff	 cmp	 eax, -1
  000dc	75 2c		 jne	 SHORT $LN3@IsSafeWipe

; 92   :         lowerPath.find(L"\\windows\\system32\\drivers\\") != std::wstring::npos)
; 93   :         return false;
; 94   :     // Allow only Program Files locations
; 95   :     if (lowerPath.find(L"c:\\program files\\") == std::wstring::npos &&

  000de	6a 00		 push	 0
  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_1CE@OEHNAGL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  000e5	8d 4d d8	 lea	 ecx, DWORD PTR _lowerPath$[ebp]
  000e8	e8 00 00 00 00	 call	 ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find
  000ed	83 f8 ff	 cmp	 eax, -1
  000f0	75 14		 jne	 SHORT $LN4@IsSafeWipe
  000f2	6a 00		 push	 0
  000f4	68 00 00 00 00	 push	 OFFSET ??_C@_1DA@NPPKGKBB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  000f9	8d 4d d8	 lea	 ecx, DWORD PTR _lowerPath$[ebp]
  000fc	e8 00 00 00 00	 call	 ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find
  00101	83 f8 ff	 cmp	 eax, -1
  00104	74 04		 je	 SHORT $LN3@IsSafeWipe
$LN4@IsSafeWipe:

; 98   :     return true;

  00106	b3 01		 mov	 bl, 1
  00108	eb 02		 jmp	 SHORT $LN8@IsSafeWipe
$LN3@IsSafeWipe:
  0010a	32 db		 xor	 bl, bl
$LN8@IsSafeWipe:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1383 :         _Tidy_deallocate();

  0010c	8d 4d d8	 lea	 ecx, DWORD PTR _lowerPath$[ebp]
  0010f	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 98   :     return true;

  00114	8a c3		 mov	 al, bl

; 99   : }

  00116	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00119	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00120	59		 pop	 ecx
  00121	5f		 pop	 edi
  00122	5e		 pop	 esi
  00123	5b		 pop	 ebx
  00124	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00127	33 cd		 xor	 ecx, ebp
  00129	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsSafeWipePath@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _lowerPath$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?IsSafeWipePath@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?IsSafeWipePath@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?IsSafeWipePath@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ENDP ; IsSafeWipePath
; Function compile flags: /Ogtp
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
;	COMDAT ?ConsoleHandler@@YGHK@Z
_TEXT	SEGMENT
_dwCtrlType$ = 8					; size = 4
?ConsoleHandler@@YGHK@Z PROC				; ConsoleHandler, COMDAT

; 71   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     switch (dwCtrlType)

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwCtrlType$[ebp]
  00006	83 f8 06	 cmp	 eax, 6
  00009	77 2a		 ja	 SHORT $LN9@ConsoleHan
  0000b	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN14@ConsoleHan[eax]
  00012	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN15@ConsoleHan[eax*4]
$LN4@ConsoleHan:

; 64   :     RunMenu();

  00019	e8 00 00 00 00	 call	 ?RunMenu@@YAXXZ		; RunMenu

; 65   : 
; 66   :     if (g_ServiceInstalled)

  0001e	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?g_ServiceInstalled@@3_NA, 0 ; g_ServiceInstalled
  00025	74 05		 je	 SHORT $LN12@ConsoleHan

; 67   :         UnloadDriver();

  00027	e8 00 00 00 00	 call	 ?UnloadDriver@@YA_NXZ	; UnloadDriver
$LN12@ConsoleHan:

; 73   :     {
; 74   :     case CTRL_C_EVENT:
; 75   :     case CTRL_CLOSE_EVENT:
; 76   :     case CTRL_BREAK_EVENT:
; 77   :     case CTRL_LOGOFF_EVENT:
; 78   :     case CTRL_SHUTDOWN_EVENT:
; 79   :         CleanupOnExit();
; 80   :         return TRUE;

  0002c	b8 01 00 00 00	 mov	 eax, 1

; 83   : }
; 84   : }

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN9@ConsoleHan:

; 81   :     default:
; 82   :         return FALSE;

  00035	33 c0		 xor	 eax, eax

; 83   : }
; 84   : }

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
  0003b	90		 npad	 1
$LN15@ConsoleHan:
  0003c	00 00 00 00	 DD	 $LN4@ConsoleHan
  00040	00 00 00 00	 DD	 $LN9@ConsoleHan
$LN14@ConsoleHan:
  00044	00		 DB	 0
  00045	00		 DB	 0
  00046	00		 DB	 0
  00047	01		 DB	 1
  00048	01		 DB	 1
  00049	00		 DB	 0
  0004a	00		 DB	 0
?ConsoleHandler@@YGHK@Z ENDP				; ConsoleHandler
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
;	COMDAT ?CleanupOnExit@@YAXXZ
_TEXT	SEGMENT
?CleanupOnExit@@YAXXZ PROC				; CleanupOnExit, COMDAT

; 64   :     RunMenu();

  00000	e8 00 00 00 00	 call	 ?RunMenu@@YAXXZ		; RunMenu

; 65   : 
; 66   :     if (g_ServiceInstalled)

  00005	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?g_ServiceInstalled@@3_NA, 0 ; g_ServiceInstalled
  0000c	0f 85 00 00 00
	00		 jne	 ?UnloadDriver@@YA_NXZ	; UnloadDriver

; 67   :         UnloadDriver();
; 68   : }

  00012	c3		 ret	 0
?CleanupOnExit@@YAXXZ ENDP				; CleanupOnExit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
;	COMDAT ?RunMenu@@YAXXZ
_TEXT	SEGMENT
$T1 = -28						; size = 20
$T2 = -8						; size = 8
__Result$3 = -4						; size = 4
?RunMenu@@YAXXZ PROC					; RunMenu, COMDAT

; 288  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 289  :     int choice = -1;

  00009	83 ce ff	 or	 esi, -1
  0000c	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_0BE@MMCBKBP@Protection?5enabled?6@
  00011	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_0BF@DONBIPBH@Protection?5disabled?6@
  00016	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL2@RunMenu:

; 292  :     {
; 293  :         std::cout << "\n1. Enable Protection"

  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@BNCCJELM@?60?4?5Exit?6Choice?3?5@
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OCJOJNKG@?64?4?5Kill?5?$CG?5Wipe?5Anti?9Cheat?5EXE@
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@HCKJMIGK@?63?4?5Create?5Service?5?$CIrequired?$CJ@
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@OJMELANK@?62?4?5Disable?5Protection@
  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@JOPEPBBN@?61?4?5Enable?5Protection@
  00039	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  0003e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00043	83 c4 08	 add	 esp, 8
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0004c	83 c4 08	 add	 esp, 8
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00055	83 c4 08	 add	 esp, 8
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0005e	83 c4 08	 add	 esp, 8
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00067	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 271  :         long _Result = _Val;

  0006a	89 75 fc	 mov	 DWORD PTR __Result$3[ebp], esi

; 272  :         _Common_extract_with_num_get(_Result);

  0006d	8d 45 fc	 lea	 eax, DWORD PTR __Result$3[ebp]
  00070	b9 00 00 00 00	 mov	 ecx, OFFSET ?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A ; std::cin
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z ; std::basic_istream<char,std::char_traits<char> >::_Common_extract_with_num_get<long>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 214  :         return rdstate() & (ios_base::badbit | ios_base::failbit);

  0007b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream

; 273  :         _Val = _Result;

  00080	8b 75 fc	 mov	 esi, DWORD PTR __Result$3[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 214  :         return rdstate() & (ios_base::badbit | ios_base::failbit);

  00083	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00086	f6 81 0c 00 00
	00 06		 test	 BYTE PTR ?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A[ecx+12], 6
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 300  :         if (std::cin.fail())

  0008d	74 3f		 je	 SHORT $LN6@RunMenu
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios

; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  0008f	33 d2		 xor	 edx, edx
  00091	b8 04 00 00 00	 mov	 eax, 4
  00096	39 91 38 00 00
	00		 cmp	 DWORD PTR ?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A[ecx+56], edx
  0009c	0f 45 c2	 cmovne	 eax, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 156  :         _Mystate             = _State;

  0009f	89 81 0c 00 00
	00		 mov	 DWORD PTR ?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A[ecx+12], eax

; 157  :         const auto _Filtered = _State & _Except;

  000a5	85 81 10 00 00
	00		 test	 DWORD PTR ?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A[ecx+16], eax

; 158  :         if (_Filtered) {

  000ab	0f 85 dc 00 00
	00		 jne	 $LN39@RunMenu
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 303  :             std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

  000b1	6a 0a		 push	 10			; 0000000aH
  000b3	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  000b8	6a ff		 push	 -1
  000ba	b9 00 00 00 00	 mov	 ecx, OFFSET ?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A ; std::cin
  000bf	e8 00 00 00 00	 call	 ?ignore@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z ; std::basic_istream<char,std::char_traits<char> >::ignore

; 304  :             std::cout << "Invalid input\n";

  000c4	68 00 00 00 00	 push	 OFFSET ??_C@_0P@NFDEKPFN@Invalid?5input?6@

; 305  :             continue;

  000c9	e9 a3 00 00 00	 jmp	 $LN51@RunMenu
$LN6@RunMenu:

; 306  :         }
; 307  : 
; 308  :         switch (choice)

  000ce	83 fe 04	 cmp	 esi, 4
  000d1	0f 87 95 00 00
	00		 ja	 $LN18@RunMenu
  000d7	ff 24 b5 00 00
	00 00		 jmp	 DWORD PTR $LN45@RunMenu[esi*4]
$LN7@RunMenu:

; 309  :         {
; 310  :         case 1:
; 311  :             if (SendIoctl(IOCTL_ENABLE_PROTECTION))

  000de	6a 00		 push	 0
  000e0	6a 00		 push	 0
  000e2	6a 00		 push	 0
  000e4	6a 00		 push	 0
  000e6	68 00 20 22 00	 push	 2236416			; 00222000H
  000eb	e8 00 00 00 00	 call	 ?SendIoctl@@YA_NKPAXK0K@Z ; SendIoctl

; 312  :                 std::cout << "Protection enabled\n";
; 313  :             else
; 314  :                 std::cout << "Failed to enable protection\n";
; 315  :             break;

  000f0	84 c0		 test	 al, al
  000f2	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BN@EGKIEGE@Failed?5to?5enable?5protection?6@
  000f7	0f 45 cf	 cmovne	 ecx, edi
  000fa	51		 push	 ecx
  000fb	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  00100	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00105	83 c4 1c	 add	 esp, 28			; 0000001cH
  00108	eb 74		 jmp	 SHORT $LN4@RunMenu
$LN10@RunMenu:

; 316  : 
; 317  :         case 2:
; 318  :             if (SendIoctl(IOCTL_DISABLE_PROTECTION))

  0010a	6a 00		 push	 0
  0010c	6a 00		 push	 0
  0010e	6a 00		 push	 0
  00110	6a 00		 push	 0
  00112	68 04 20 22 00	 push	 2236420			; 00222004H
  00117	e8 00 00 00 00	 call	 ?SendIoctl@@YA_NKPAXK0K@Z ; SendIoctl

; 319  :                 std::cout << "Protection disabled\n";
; 320  :             else
; 321  :                 std::cout << "Failed to disable protection\n";
; 322  :             break;

  0011c	84 c0		 test	 al, al
  0011e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BO@DDDAMELB@Failed?5to?5disable?5protection?6@
  00123	0f 45 cb	 cmovne	 ecx, ebx
  00126	51		 push	 ecx
  00127	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  0012c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00131	83 c4 1c	 add	 esp, 28			; 0000001cH
  00134	eb 48		 jmp	 SHORT $LN4@RunMenu
$LN13@RunMenu:

; 323  :         case 3:
; 324  :         {
; 325  :             if (InstallService())

  00136	e8 00 00 00 00	 call	 ?InstallService@@YA_NXZ	; InstallService
  0013b	84 c0		 test	 al, al
  0013d	74 18		 je	 SHORT $LN14@RunMenu

; 326  :             {
; 327  :                 std::cout << "Service installed and started successfully\n";

  0013f	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@HEBMLGBH@Service?5installed?5and?5started?5s@
  00144	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  00149	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 328  :                 g_ServiceInstalled = true;

  0014e	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?g_ServiceInstalled@@3_NA, 1 ; g_ServiceInstalled

; 329  :             }

  00155	eb 24		 jmp	 SHORT $LN52@RunMenu
$LN14@RunMenu:

; 330  :             else
; 331  :             {
; 332  :                 std::cout << "Failed to install/start service\n";

  00157	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@ELPLAANP@Failed?5to?5install?1start?5service@

; 333  :             }
; 334  :             break;

  0015c	eb 13		 jmp	 SHORT $LN51@RunMenu
$LN16@RunMenu:

; 335  :         }
; 336  : 
; 337  :         case 4:
; 338  :             ListAndWipeProcess();

  0015e	e8 00 00 00 00	 call	 ?ListAndWipeProcess@@YAXXZ ; ListAndWipeProcess

; 339  :             break;

  00163	eb 19		 jmp	 SHORT $LN4@RunMenu
$LN17@RunMenu:

; 340  : 
; 341  :         case 0:
; 342  :             std::cout << "Exiting\n";

  00165	68 00 00 00 00	 push	 OFFSET ??_C@_08IEHHMBPO@Exiting?6@

; 343  :             break;

  0016a	eb 05		 jmp	 SHORT $LN51@RunMenu
$LN18@RunMenu:

; 344  : 
; 345  :         default:
; 346  :             std::cout << "Invalid choice\n";

  0016c	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@MECFPBGI@Invalid?5choice?6@
$LN51@RunMenu:

; 290  : 
; 291  :     while (choice != 0)

  00171	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  00176	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
$LN52@RunMenu:
  0017b	83 c4 08	 add	 esp, 8
$LN4@RunMenu:
  0017e	85 f6		 test	 esi, esi
  00180	0f 85 9a fe ff
	ff		 jne	 $LL2@RunMenu

; 350  : }

  00186	5f		 pop	 edi
  00187	5e		 pop	 esi
  00188	5b		 pop	 ebx
  00189	8b e5		 mov	 esp, ebp
  0018b	5d		 pop	 ebp
  0018c	c3		 ret	 0
$LN39@RunMenu:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 172  :             _THROW(failure(_Msg));

  0018d	8d 45 f8	 lea	 eax, DWORD PTR $T2[ebp]
  00190	6a 01		 push	 1
  00192	50		 push	 eax
  00193	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  00198	83 c4 08	 add	 esp, 8
  0019b	8d 4d e4	 lea	 ecx, DWORD PTR $T1[ebp]
  0019e	50		 push	 eax
  0019f	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  001a4	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  001a9	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  001ae	8d 45 e4	 lea	 eax, DWORD PTR $T1[ebp]
  001b1	50		 push	 eax
  001b2	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN50@RunMenu:
  001b7	90		 npad	 1
$LN45@RunMenu:
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 350  : }

  001b8	00 00 00 00	 DD	 $LN17@RunMenu
  001bc	00 00 00 00	 DD	 $LN7@RunMenu
  001c0	00 00 00 00	 DD	 $LN10@RunMenu
  001c4	00 00 00 00	 DD	 $LN13@RunMenu
  001c8	00 00 00 00	 DD	 $LN16@RunMenu
?RunMenu@@YAXXZ ENDP					; RunMenu
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp
;	COMDAT ?SendIoctl@@YA_NKPAXK0K@Z
_TEXT	SEGMENT
_outBuf$GSCopy$1$ = -76					; size = 4
_bytesReturned$ = -72					; size = 4
$T2 = -65						; size = 1
$T3 = -64						; size = 24
_protectedExe$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_ioctl$ = 8						; size = 4
_inBuf$ = 12						; size = 4
_inBufSize$ = 16					; size = 4
_outBuf$ = 20						; size = 4
_outBufSize$ = 24					; size = 4
?SendIoctl@@YA_NKPAXK0K@Z PROC				; SendIoctl, COMDAT

; 466  : bool SendIoctl(DWORD ioctl, void* inBuf, DWORD inBufSize, void* outBuf, DWORD outBufSize) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SendIoctl@@YA_NKPAXK0K@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b 45 14	 mov	 eax, DWORD PTR _outBuf$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0002d	8d 4d c0	 lea	 ecx, DWORD PTR $T3[ebp]
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 466  : bool SendIoctl(DWORD ioctl, void* inBuf, DWORD inBufSize, void* outBuf, DWORD outBufSize) {

  00030	8b 75 0c	 mov	 esi, DWORD PTR _inBuf$[ebp]
  00033	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00036	6a 1f		 push	 31			; 0000001fH
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_1EA@FPCIDGNJ@?$AAE?$AAz?$AAA?$AAn?$AAt?$AAi?$AAA?$AAn?$AAt?$AAi?$AAC?$AAh?$AAe?$AAa?$AAt@
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 466  : bool SendIoctl(DWORD ioctl, void* inBuf, DWORD inBufSize, void* outBuf, DWORD outBufSize) {

  0003d	89 45 b4	 mov	 DWORD PTR _outBuf$GSCopy$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00040	0f 11 45 c0	 movups	 XMMWORD PTR $T3[ebp], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

  00044	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+16], 0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0004b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 0

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00052	e8 00 00 00 00	 call	 ??$_Construct@$00PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>

; 1780 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00057	6a 04		 push	 4
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_19BKJMDJK@?$AA?2?$AA?2?$AA?4?$AA?2@
  0005e	6a 00		 push	 0
  00060	8d 4d c0	 lea	 ecx, DWORD PTR $T3[ebp]
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 467  :     std::wstring protectedExe = L"\\\\.\\" + std::wstring(PROTECTED_EXE_NAME); // see next fix

  00063	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1780 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0006a	e8 00 00 00 00	 call	 ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert

; 517  :     size_type _Mysize = 0; // current length of string (size)

  0006f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _protectedExe$[ebp+16], 0
  00076	0f 57 c0	 xorps	 xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00079	0f 11 45 d8	 movups	 XMMWORD PTR _protectedExe$[ebp], xmm0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0007d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _protectedExe$[ebp+20], 0

; 1291 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  00084	33 c9		 xor	 ecx, ecx
  00086	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00089	0f 11 45 d8	 movups	 XMMWORD PTR _protectedExe$[ebp], xmm0
  0008d	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00092	66 0f d6 45 e8	 movq	 QWORD PTR _protectedExe$[ebp+16], xmm0
  00097	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  0009e	c7 40 14 07 00
	00 00		 mov	 DWORD PTR [eax+20], 7
  000a5	66 89 08	 mov	 WORD PTR [eax], cx

; 453  :         return _Myres > _Small_string_capacity;

  000a8	8b 4d d4	 mov	 ecx, DWORD PTR $T3[ebp+20]
  000ab	83 f9 07	 cmp	 ecx, 7

; 3083 :         if (_My_data._Large_mode_engaged()) {

  000ae	76 32		 jbe	 SHORT $LN87@SendIoctl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000b0	8b 55 c0	 mov	 edx, DWORD PTR $T3[ebp]
  000b3	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]
  000ba	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000bc	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000c2	72 14		 jb	 SHORT $LN92@SendIoctl

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000c4	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000c7	83 c1 23	 add	 ecx, 35			; 00000023H
  000ca	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000cc	83 c0 fc	 add	 eax, -4			; fffffffcH
  000cf	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000d2	0f 87 c2 00 00
	00		 ja	 $LN158@SendIoctl
$LN92@SendIoctl:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000d8	51		 push	 ecx
  000d9	52		 push	 edx
  000da	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000df	83 c4 08	 add	 esp, 8
$LN87@SendIoctl:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  000e2	83 7d ec 07	 cmp	 DWORD PTR _protectedExe$[ebp+20], 7

; 444  :         const value_type* _Result = _Bx._Buf;

  000e6	8d 45 d8	 lea	 eax, DWORD PTR _protectedExe$[ebp]
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 468  :     HANDLE hDevice = CreateFileW(protectedExe.c_str(), GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);

  000e9	6a 00		 push	 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

  000eb	0f 47 45 d8	 cmova	 eax, DWORD PTR _protectedExe$[ebp]
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 468  :     HANDLE hDevice = CreateFileW(protectedExe.c_str(), GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);

  000ef	6a 00		 push	 0
  000f1	6a 03		 push	 3
  000f3	6a 00		 push	 0
  000f5	6a 00		 push	 0
  000f7	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  000fc	50		 push	 eax
  000fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileW@28
  00103	8b f8		 mov	 edi, eax

; 469  :     if (hDevice == INVALID_HANDLE_VALUE)

  00105	83 ff ff	 cmp	 edi, -1
  00108	74 38		 je	 SHORT $LN4@SendIoctl

; 470  :         return false;
; 471  : 
; 472  :     DWORD bytesReturned = 0;
; 473  :     BOOL result = DeviceIoControl(hDevice, ioctl, inBuf, inBufSize, outBuf, outBufSize, &bytesReturned, nullptr);

  0010a	6a 00		 push	 0
  0010c	8d 45 b8	 lea	 eax, DWORD PTR _bytesReturned$[ebp]
  0010f	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _bytesReturned$[ebp], 0
  00116	50		 push	 eax
  00117	ff 75 18	 push	 DWORD PTR _outBufSize$[ebp]
  0011a	ff 75 b4	 push	 DWORD PTR _outBuf$GSCopy$1$[ebp]
  0011d	ff 75 10	 push	 DWORD PTR _inBufSize$[ebp]
  00120	56		 push	 esi
  00121	ff 75 08	 push	 DWORD PTR _ioctl$[ebp]
  00124	57		 push	 edi
  00125	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32

; 474  :     CloseHandle(hDevice);

  0012b	57		 push	 edi
  0012c	8b f0		 mov	 esi, eax
  0012e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 475  :     return result && bytesReturned > 0;

  00134	85 f6		 test	 esi, esi
  00136	74 0a		 je	 SHORT $LN4@SendIoctl
  00138	83 7d b8 00	 cmp	 DWORD PTR _bytesReturned$[ebp], 0
  0013c	c6 45 bf 01	 mov	 BYTE PTR $T2[ebp], 1
  00140	77 04		 ja	 SHORT $LN5@SendIoctl
$LN4@SendIoctl:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00142	c6 45 bf 00	 mov	 BYTE PTR $T2[ebp], 0
$LN5@SendIoctl:
  00146	8b 4d ec	 mov	 ecx, DWORD PTR _protectedExe$[ebp+20]
  00149	83 f9 07	 cmp	 ecx, 7

; 3083 :         if (_My_data._Large_mode_engaged()) {

  0014c	76 2e		 jbe	 SHORT $LN144@SendIoctl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0014e	8b 55 d8	 mov	 edx, DWORD PTR _protectedExe$[ebp]
  00151	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]
  00158	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0015a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00160	72 10		 jb	 SHORT $LN149@SendIoctl

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00162	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00165	83 c1 23	 add	 ecx, 35			; 00000023H
  00168	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0016a	83 c0 fc	 add	 eax, -4			; fffffffcH
  0016d	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00170	77 37		 ja	 SHORT $LN159@SendIoctl
$LN149@SendIoctl:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00172	51		 push	 ecx
  00173	52		 push	 edx
  00174	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00179	83 c4 08	 add	 esp, 8
$LN144@SendIoctl:
; File C:\EzAntiAntiCheat\EzAntiAntiCheat\source\main.cpp

; 475  :     return result && bytesReturned > 0;

  0017c	8a 45 bf	 mov	 al, BYTE PTR $T2[ebp]

; 476  : }

  0017f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00182	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00189	59		 pop	 ecx
  0018a	5f		 pop	 edi
  0018b	5e		 pop	 esi
  0018c	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018f	33 cd		 xor	 ecx, ebp
  00191	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00196	8b e5		 mov	 esp, ebp
  00198	5d		 pop	 ebp
  00199	c3		 ret	 0
$LN158@SendIoctl:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0019a	6a 00		 push	 0
  0019c	6a 00		 push	 0
  0019e	6a 00		 push	 0
  001a0	6a 00		 push	 0
  001a2	6a 00		 push	 0
  001a4	e8 00 00 00 00	 call	 __invoke_watson
$LN159@SendIoctl:
  001a9	6a 00		 push	 0
  001ab	6a 00		 push	 0
  001ad	6a 00		 push	 0
  001af	6a 00		 push	 0
  001b1	6a 00		 push	 0
  001b3	e8 00 00 00 00	 call	 __invoke_watson
$LN156@SendIoctl:
  001b8	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SendIoctl@@YA_NKPAXK0K@Z$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?SendIoctl@@YA_NKPAXK0K@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SendIoctl@@YA_NKPAXK0K@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SendIoctl@@YA_NKPAXK0K@Z ENDP				; SendIoctl
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
__File$ = 12						; size = 4
??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z PROC		; std::_Fputc<char>, COMDAT

; 113  : inline bool _Fputc(char _Byte, FILE* _File) { // put a char element to a C stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 114  :     return _CSTD fputc(_Byte, _File) != EOF;

  00003	ff 75 0c	 push	 DWORD PTR __File$[ebp]
  00006	0f be 45 08	 movsx	 eax, BYTE PTR __Byte$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 _fputc
  00010	83 c4 08	 add	 esp, 8
  00013	83 f8 ff	 cmp	 eax, -1
  00016	0f 95 c0	 setne	 al

; 115  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z ENDP		; std::_Fputc<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
;	COMDAT ??_Gios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Gios_base@std@@UAEPAXI@Z PROC			; std::ios_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_Gios_base@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 368  :         _Ios_base_dtor(this);

  00025	56		 push	 esi
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
  00033	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00038	83 c4 04	 add	 esp, 4
  0003b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0003f	74 0b		 je	 SHORT $LN10@scalar
  00041	6a 38		 push	 56			; 00000038H
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00049	83 c4 08	 add	 esp, 8
$LN10@scalar:
  0004c	8b c6		 mov	 eax, esi
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00051	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00058	59		 pop	 ecx
  00059	5e		 pop	 esi
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
  00060	cc		 int	 3
  00061	cc		 int	 3
  00062	cc		 int	 3
  00063	cc		 int	 3
  00064	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_Gios_base@std@@UAEPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_Gios_base@std@@UAEPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_Gios_base@std@@UAEPAXI@Z ENDP			; std::ios_base::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
;	COMDAT ??1ios_base@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1ios_base@std@@UAE@XZ PROC				; std::ios_base::~ios_base, COMDAT
; _this$ = ecx

; 367  :     virtual __CLR_OR_THIS_CALL ~ios_base() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1ios_base@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 368  :         _Ios_base_dtor(this);

  00022	51		 push	 ecx
  00023	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ios_base@std@@6B@
  00029	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  0002e	83 c4 04	 add	 esp, 4

; 369  :     }

  00031	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00034	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0003b	59		 pop	 ecx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
  00040	cc		 int	 3
  00041	cc		 int	 3
  00042	cc		 int	 3
  00043	cc		 int	 3
  00044	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1ios_base@std@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1ios_base@std@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1ios_base@std@@UAE@XZ ENDP				; std::ios_base::~ios_base
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
;	COMDAT ?clear@ios_base@std@@QAEXH_N@Z
_TEXT	SEGMENT
$T1 = -28						; size = 20
$T2 = -8						; size = 8
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@ios_base@std@@QAEXH_N@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 154  :     void __CLR_OR_THIS_CALL clear(iostate _State, bool _Reraise) { // set state, possibly reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 155  :         _State &= _Statmask;

  00003	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  00006	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00009	83 e0 17	 and	 eax, 23			; 00000017H

; 156  :         _Mystate             = _State;

  0000c	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 157  :         const auto _Filtered = _State & _Except;

  0000f	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00012	56		 push	 esi
  00013	23 c8		 and	 ecx, eax

; 158  :         if (_Filtered) {

  00015	74 08		 je	 SHORT $LN2@clear

; 159  :             if (_Reraise) {

  00017	80 7d 0c 00	 cmp	 BYTE PTR __Reraise$[ebp], 0
  0001b	74 12		 je	 SHORT $LN3@clear
  0001d	eb 07		 jmp	 SHORT $LN14@clear
$LN2@clear:

; 173  :         }
; 174  :     }

  0001f	5e		 pop	 esi
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
$LN14@clear:

; 160  :                 _RERAISE;

  00026	6a 00		 push	 0
  00028	6a 00		 push	 0
  0002a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@clear:

; 161  :             }
; 162  : 
; 163  :             const char* _Msg;
; 164  :             if (_Filtered & ios_base::badbit) {

  0002f	f6 c1 04	 test	 cl, 4
  00032	74 07		 je	 SHORT $LN4@clear

; 165  :                 _Msg = "ios_base::badbit set";

  00034	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  00039	eb 10		 jmp	 SHORT $LN6@clear
$LN4@clear:

; 166  :             } else if (_Filtered & ios_base::failbit) {

  0003b	f6 c1 02	 test	 cl, 2
  0003e	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
  00043	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
  00048	0f 44 f0	 cmove	 esi, eax
$LN6@clear:

; 167  :                 _Msg = "ios_base::failbit set";
; 168  :             } else {
; 169  :                 _Msg = "ios_base::eofbit set";
; 170  :             }
; 171  : 
; 172  :             _THROW(failure(_Msg));

  0004b	8d 45 f8	 lea	 eax, DWORD PTR $T2[ebp]
  0004e	6a 01		 push	 1
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  00056	83 c4 08	 add	 esp, 8
  00059	8d 4d e4	 lea	 ecx, DWORD PTR $T1[ebp]
  0005c	50		 push	 eax
  0005d	56		 push	 esi
  0005e	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  00063	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00068	8d 45 e4	 lea	 eax, DWORD PTR $T1[ebp]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN12@clear:
  00071	cc		 int	 3
?clear@ios_base@std@@QAEXH_N@Z ENDP			; std::ios_base::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfailure@ios_base@std@@UAEPAXI@Z PROC		; std::ios_base::failure::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN28@scalar
  0001e	6a 14		 push	 20			; 00000014H
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN28@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gfailure@ios_base@std@@UAEPAXI@Z ENDP		; std::ios_base::failure::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0failure@ios_base@std@@QAE@ABV012@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0failure@ios_base@std@@QAE@ABV012@@Z PROC		; std::ios_base::failure::failure, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  00004	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  00007	0f 57 c0	 xorps	 xmm0, xmm0

; 73   :     {

  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx

; 72   :         : _Data()

  0000d	8d 47 04	 lea	 eax, DWORD PTR [edi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  00010	50		 push	 eax
  00011	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7exception@std@@6B@
  00017	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0001b	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ___std_exception_copy
  00024	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
  0002a	83 c4 08	 add	 esp, 8
  0002d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00030	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00033	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00036	8b c7		 mov	 eax, edi
  00038	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  0003b	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7failure@ios_base@std@@6B@
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
??0failure@ios_base@std@@QAE@ABV012@@Z ENDP		; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT
??1failure@ios_base@std@@UAE@XZ PROC			; std::ios_base::failure::~failure, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1failure@ios_base@std@@UAE@XZ ENDP			; std::ios_base::failure::~failure
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase
;	COMDAT ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
_TEXT	SEGMENT
tv319 = -48						; size = 4
_this$ = -44						; size = 4
_this$GSCopy$ = -44					; size = 4
__Errcode$2$ = -44					; size = 4
$T2 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
__Errcode$ = 12						; size = 4
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z PROC	; std::ios_base::failure::failure, COMDAT
; _this$ = ecx

; 116  :         explicit failure(const char* _Message, const error_code& _Errcode = _STD make_error_code(io_errc::stream))

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b f1		 mov	 esi, ecx
  0002c	89 75 d4	 mov	 DWORD PTR _this$[ebp], esi
  0002f	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp]
  00032	0f 57 c0	 xorps	 xmm0, xmm0
  00035	8b 55 08	 mov	 edx, DWORD PTR __Message$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  00038	8b ca		 mov	 ecx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 116  :         explicit failure(const char* _Message, const error_code& _Errcode = _STD make_error_code(io_errc::stream))

  0003a	89 75 d4	 mov	 DWORD PTR _this$GSCopy$[ebp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0003d	0f 11 45 d8	 movups	 XMMWORD PTR $T2[ebp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 117  :             : system_error(_Errcode, _Message) {} // construct with message

  00041	8b 38		 mov	 edi, DWORD PTR [eax]
  00043	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00046	89 45 d4	 mov	 DWORD PTR __Errcode$2$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  00049	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 517  :     size_type _Mysize = 0; // current length of string (size)

  0004c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00053	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  0005a	89 45 d0	 mov	 DWORD PTR tv319[ebp], eax
  0005d	0f 1f 00	 npad	 3
$LL59@failure:
  00060	8a 01		 mov	 al, BYTE PTR [ecx]
  00062	41		 inc	 ecx
  00063	84 c0		 test	 al, al
  00065	75 f9		 jne	 SHORT $LL59@failure
  00067	2b 4d d0	 sub	 ecx, DWORD PTR tv319[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0006a	51		 push	 ecx
  0006b	52		 push	 edx
  0006c	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  0006f	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error

; 490  :     system_error(error_code _Errcode, const char* _Message) : _Mybase(_Errcode, _Message) {}

  00074	8d 45 d8	 lea	 eax, DWORD PTR $T2[ebp]
  00077	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0007e	50		 push	 eax
  0007f	ff 75 d4	 push	 DWORD PTR __Errcode$2$[ebp]
  00082	8b ce		 mov	 ecx, esi
  00084	57		 push	 edi
  00085	e8 00 00 00 00	 call	 ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  0008a	8b 4d ec	 mov	 ecx, DWORD PTR $T2[ebp+20]
  0008d	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3083 :         if (_My_data._Large_mode_engaged()) {

  00090	76 28		 jbe	 SHORT $LN46@failure
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00092	8b 55 d8	 mov	 edx, DWORD PTR $T2[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00095	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00096	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00098	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0009e	72 10		 jb	 SHORT $LN51@failure

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000a0	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000a3	83 c1 23	 add	 ecx, 35			; 00000023H
  000a6	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000a8	83 c0 fc	 add	 eax, -4			; fffffffcH
  000ab	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000ae	77 2f		 ja	 SHORT $LN63@failure
$LN51@failure:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000b0	51		 push	 ecx
  000b1	52		 push	 edx
  000b2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000b7	83 c4 08	 add	 esp, 8
$LN46@failure:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 117  :             : system_error(_Errcode, _Message) {} // construct with message

  000ba	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7failure@ios_base@std@@6B@
  000c0	8b c6		 mov	 eax, esi
  000c2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000cc	59		 pop	 ecx
  000cd	5f		 pop	 edi
  000ce	5e		 pop	 esi
  000cf	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d2	33 cd		 xor	 ecx, ebp
  000d4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c2 08 00	 ret	 8
$LN63@failure:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000df	6a 00		 push	 0
  000e1	6a 00		 push	 0
  000e3	6a 00		 push	 0
  000e5	6a 00		 push	 0
  000e7	6a 00		 push	 0
  000e9	e8 00 00 00 00	 call	 __invoke_watson
$LN61@failure:
  000ee	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z$1:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ENDP	; std::ios_base::failure::failure
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ctype@_W@std@@MAEPAXI@Z PROC			; std::ctype<wchar_t>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2969 :     __CLR_OR_THIS_CALL ~ctype() noexcept override {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 2970 :         if (_Ctype._Delfl) {

  00006	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@_W@std@@6B@
  00010	74 0b		 je	 SHORT $LN6@scalar

; 2971 :             _CSTD free(const_cast<short*>(_Ctype._Table));

  00012	ff 76 0c	 push	 DWORD PTR [esi+12]
  00015	e8 00 00 00 00	 call	 _free
  0001a	83 c4 04	 add	 esp, 4
$LN6@scalar:

; 2972 :         }
; 2973 : 
; 2974 :         _CSTD free(_Ctype._LocaleName);

  0001d	ff 76 14	 push	 DWORD PTR [esi+20]
  00020	e8 00 00 00 00	 call	 _free
  00025	83 c4 04	 add	 esp, 4

; 2975 :     }

  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0002e	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00032	74 0b		 je	 SHORT $LN11@scalar
  00034	6a 44		 push	 68			; 00000044H
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003c	83 c4 08	 add	 esp, 8
$LN11@scalar:
  0003f	8b c6		 mov	 eax, esi
  00041	5e		 pop	 esi
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
??_G?$ctype@_W@std@@MAEPAXI@Z ENDP			; std::ctype<wchar_t>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_narrow@?$ctype@_W@std@@MBEPB_WPB_W0DPAD@Z
_TEXT	SEGMENT
__Mbst$1 = -24						; size = 8
tv147 = -16						; size = 4
__Buf$2 = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dflt$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@_W@std@@MBEPB_WPB_W0DPAD@Z PROC	; std::ctype<wchar_t>::do_narrow, COMDAT
; _this$ = ecx

; 3072 :         char* _Dest) const { // narrow elements in [_First, _Last) to chars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx

; 3073 :         _Adl_verify_range(_First, _Last);
; 3074 :         for (; _First != _Last; ++_First, ++_Dest) {

  00011	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00018	57		 push	 edi
  00019	8b 7d 14	 mov	 edi, DWORD PTR __Dest$[ebp]
  0001c	3b f3		 cmp	 esi, ebx
  0001e	74 41		 je	 SHORT $LN14@do_narrow
  00020	83 c1 18	 add	 ecx, 24			; 00000018H
  00023	89 4d f0	 mov	 DWORD PTR tv147[ebp], ecx
$LL4@do_narrow:

; 3075 :             *_Dest = _Donarrow(*_First, _Dflt);

  00026	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00029	0f 57 c0	 xorps	 xmm0, xmm0

; 3064 :         return _Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1 ? _Dflt : _Buf[0];

  0002c	51		 push	 ecx
  0002d	8d 4d e8	 lea	 ecx, DWORD PTR __Mbst$1[ebp]
  00030	66 0f 13 45 e8	 movlpd	 QWORD PTR __Mbst$1[ebp], xmm0
  00035	51		 push	 ecx
  00036	50		 push	 eax
  00037	8d 45 f4	 lea	 eax, DWORD PTR __Buf$2[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 __Wcrtomb
  00040	0f b6 4d 10	 movzx	 ecx, BYTE PTR __Dflt$[ebp]

; 3073 :         _Adl_verify_range(_First, _Last);
; 3074 :         for (; _First != _Last; ++_First, ++_Dest) {

  00044	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]

; 3064 :         return _Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1 ? _Dflt : _Buf[0];

  00047	0f b6 55 f4	 movzx	 edx, BYTE PTR __Buf$2[ebp]
  0004b	83 c4 10	 add	 esp, 16			; 00000010H
  0004e	83 f8 01	 cmp	 eax, 1
  00051	0f 45 d1	 cmovne	 edx, ecx

; 3073 :         _Adl_verify_range(_First, _Last);
; 3074 :         for (; _First != _Last; ++_First, ++_Dest) {

  00054	8b 4d f0	 mov	 ecx, DWORD PTR tv147[ebp]
  00057	83 c6 02	 add	 esi, 2

; 3075 :             *_Dest = _Donarrow(*_First, _Dflt);

  0005a	88 57 ff	 mov	 BYTE PTR [edi-1], dl
  0005d	3b f3		 cmp	 esi, ebx
  0005f	75 c5		 jne	 SHORT $LL4@do_narrow
$LN14@do_narrow:

; 3076 :         }
; 3077 : 
; 3078 :         return _First;
; 3079 :     }

  00061	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00064	8b c6		 mov	 eax, esi
  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	33 cd		 xor	 ecx, ebp
  0006a	5b		 pop	 ebx
  0006b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 10 00	 ret	 16			; 00000010H
?do_narrow@?$ctype@_W@std@@MBEPB_WPB_W0DPAD@Z ENDP	; std::ctype<wchar_t>::do_narrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_narrow@?$ctype@_W@std@@MBED_WD@Z
_TEXT	SEGMENT
__Mbst$1 = -20						; size = 8
__Buf$2 = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
__Ch$ = 8						; size = 2
__Dflt$ = 12						; size = 1
?do_narrow@?$ctype@_W@std@@MBED_WD@Z PROC		; std::ctype<wchar_t>::do_narrow, COMDAT
; _this$ = ecx

; 3067 :     virtual char __CLR_OR_THIS_CALL do_narrow(_Elem _Ch, char _Dflt) const { // narrow element to char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3064 :         return _Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1 ? _Dflt : _Buf[0];

  00010	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00013	0f 57 c0	 xorps	 xmm0, xmm0
  00016	50		 push	 eax
  00017	8d 45 ec	 lea	 eax, DWORD PTR __Mbst$1[ebp]
  0001a	66 0f 13 45 ec	 movlpd	 QWORD PTR __Mbst$1[ebp], xmm0
  0001f	50		 push	 eax
  00020	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  00023	8d 45 f4	 lea	 eax, DWORD PTR __Buf$2[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 __Wcrtomb
  0002c	0f b6 4d 0c	 movzx	 ecx, BYTE PTR __Dflt$[ebp]
  00030	83 c4 10	 add	 esp, 16			; 00000010H
  00033	0f b6 55 f4	 movzx	 edx, BYTE PTR __Buf$2[ebp]
  00037	83 f8 01	 cmp	 eax, 1
  0003a	0f 45 d1	 cmovne	 edx, ecx

; 3068 :         return _Donarrow(_Ch, _Dflt);
; 3069 :     }

  0003d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00040	33 cd		 xor	 ecx, ebp
  00042	8a c2		 mov	 al, dl
  00044	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8
?do_narrow@?$ctype@_W@std@@MBED_WD@Z ENDP		; std::ctype<wchar_t>::do_narrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_widen@?$ctype@_W@std@@MBEPBDPBD0PA_W@Z
_TEXT	SEGMENT
__Mbst$1 = -12						; size = 8
tv140 = -4						; size = 4
__First$ = 8						; size = 4
__Byte$ = 8						; size = 1
__Last$ = 12						; size = 4
__Wc$2 = 12						; size = 2
__Dest$ = 16						; size = 4
?do_widen@?$ctype@_W@std@@MBEPBDPBD0PA_W@Z PROC		; std::ctype<wchar_t>::do_widen, COMDAT
; _this$ = ecx

; 3052 :         const char* _First, const char* _Last, _Elem* _Dest) const { // widen chars in [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 3053 :         _Adl_verify_range(_First, _Last);
; 3054 :         for (; _First != _Last; ++_First, ++_Dest) {

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0000a	56		 push	 esi
  0000b	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000e	3b f3		 cmp	 esi, ebx
  00010	74 50		 je	 SHORT $LN12@do_widen
  00012	83 c1 18	 add	 ecx, 24			; 00000018H
  00015	57		 push	 edi
  00016	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
  00019	89 4d fc	 mov	 DWORD PTR tv140[ebp], ecx
  0001c	0f 1f 40 00	 npad	 4
$LL4@do_widen:

; 3055 :             *_Dest = _Dowiden(*_First);

  00020	8a 06		 mov	 al, BYTE PTR [esi]
  00022	0f 57 c0	 xorps	 xmm0, xmm0
  00025	88 45 08	 mov	 BYTE PTR __Byte$[ebp], al

; 3044 :         return _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0 ? static_cast<wchar_t>(WEOF) : _Wc;

  00028	8d 45 f4	 lea	 eax, DWORD PTR __Mbst$1[ebp]
  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Byte$[ebp]
  00032	66 0f 13 45 f4	 movlpd	 QWORD PTR __Mbst$1[ebp], xmm0
  00037	50		 push	 eax
  00038	8d 45 0c	 lea	 eax, DWORD PTR __Wc$2[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 __Mbrtowc
  00041	0f b7 4d 0c	 movzx	 ecx, WORD PTR __Wc$2[ebp]

; 3053 :         _Adl_verify_range(_First, _Last);
; 3054 :         for (; _First != _Last; ++_First, ++_Dest) {

  00045	8d 7f 02	 lea	 edi, DWORD PTR [edi+2]

; 3044 :         return _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0 ? static_cast<wchar_t>(WEOF) : _Wc;

  00048	83 c4 14	 add	 esp, 20			; 00000014H
  0004b	85 c0		 test	 eax, eax
  0004d	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00052	0f 48 c8	 cmovs	 ecx, eax

; 3053 :         _Adl_verify_range(_First, _Last);
; 3054 :         for (; _First != _Last; ++_First, ++_Dest) {

  00055	46		 inc	 esi

; 3055 :             *_Dest = _Dowiden(*_First);

  00056	66 89 4f fe	 mov	 WORD PTR [edi-2], cx
  0005a	8b 4d fc	 mov	 ecx, DWORD PTR tv140[ebp]
  0005d	3b f3		 cmp	 esi, ebx
  0005f	75 bf		 jne	 SHORT $LL4@do_widen

; 3053 :         _Adl_verify_range(_First, _Last);
; 3054 :         for (; _First != _Last; ++_First, ++_Dest) {

  00061	5f		 pop	 edi
$LN12@do_widen:

; 3056 :         }
; 3057 : 
; 3058 :         return _First;
; 3059 :     }

  00062	8b c6		 mov	 eax, esi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 0c 00	 ret	 12			; 0000000cH
?do_widen@?$ctype@_W@std@@MBEPBDPBD0PA_W@Z ENDP		; std::ctype<wchar_t>::do_widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_widen@?$ctype@_W@std@@MBE_WD@Z
_TEXT	SEGMENT
__Mbst$1 = -12						; size = 8
__Wc$2 = -4						; size = 2
__Byte$ = 8						; size = 1
__Byte$ = 8						; size = 1
?do_widen@?$ctype@_W@std@@MBE_WD@Z PROC			; std::ctype<wchar_t>::do_widen, COMDAT
; _this$ = ecx

; 3047 :     virtual _Elem __CLR_OR_THIS_CALL do_widen(char _Byte) const { // widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 3048 :         return _Dowiden(_Byte);

  00006	8a 45 08	 mov	 al, BYTE PTR __Byte$[ebp]
  00009	0f 57 c0	 xorps	 xmm0, xmm0
  0000c	88 45 08	 mov	 BYTE PTR __Byte$[ebp], al

; 3044 :         return _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0 ? static_cast<wchar_t>(WEOF) : _Wc;

  0000f	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00012	50		 push	 eax
  00013	8d 45 f4	 lea	 eax, DWORD PTR __Mbst$1[ebp]
  00016	66 0f 13 45 f4	 movlpd	 QWORD PTR __Mbst$1[ebp], xmm0
  0001b	50		 push	 eax
  0001c	6a 01		 push	 1
  0001e	8d 45 08	 lea	 eax, DWORD PTR __Byte$[ebp]
  00021	50		 push	 eax
  00022	8d 45 fc	 lea	 eax, DWORD PTR __Wc$2[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 __Mbrtowc
  0002b	0f b7 4d fc	 movzx	 ecx, WORD PTR __Wc$2[ebp]
  0002f	83 c4 14	 add	 esp, 20			; 00000014H
  00032	85 c0		 test	 eax, eax
  00034	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00039	0f 48 ca	 cmovs	 ecx, edx

; 3048 :         return _Dowiden(_Byte);

  0003c	66 8b c1	 mov	 ax, cx

; 3049 :     }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?do_widen@?$ctype@_W@std@@MBE_WD@Z ENDP			; std::ctype<wchar_t>::do_widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_toupper@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z PROC	; std::ctype<wchar_t>::do_toupper, COMDAT
; _this$ = ecx

; 3032 :         const _Elem* _Last) const { // convert [_First, _Last) in place to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3033 :         _Adl_verify_range(_First, _Last);
; 3034 :         for (; _First != _Last; ++_First) {

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 1c		 je	 SHORT $LN10@do_toupper
  0000f	53		 push	 ebx
  00010	8d 59 08	 lea	 ebx, DWORD PTR [ecx+8]
$LL4@do_toupper:

; 3035 :             *_First = _Towupper(*_First, &_Ctype);

  00013	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00016	53		 push	 ebx
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 __Towupper
  0001d	66 89 06	 mov	 WORD PTR [esi], ax
  00020	83 c4 08	 add	 esp, 8
  00023	83 c6 02	 add	 esi, 2
  00026	3b f7		 cmp	 esi, edi
  00028	75 e9		 jne	 SHORT $LL4@do_toupper

; 3033 :         _Adl_verify_range(_First, _Last);
; 3034 :         for (; _First != _Last; ++_First) {

  0002a	5b		 pop	 ebx
$LN10@do_toupper:
  0002b	5f		 pop	 edi

; 3036 :         }
; 3037 : 
; 3038 :         return _First;
; 3039 :     }

  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
?do_toupper@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z ENDP	; std::ctype<wchar_t>::do_toupper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_toupper@?$ctype@_W@std@@MBE_W_W@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 2
?do_toupper@?$ctype@_W@std@@MBE_W_W@Z PROC		; std::ctype<wchar_t>::do_toupper, COMDAT
; _this$ = ecx

; 3027 :     virtual _Elem __CLR_OR_THIS_CALL do_toupper(_Elem _Ch) const { // convert element to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3028 :         return _Towupper(_Ch, &_Ctype);

  00003	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00006	50		 push	 eax
  00007	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  0000a	e8 00 00 00 00	 call	 __Towupper
  0000f	83 c4 08	 add	 esp, 8

; 3029 :     }

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?do_toupper@?$ctype@_W@std@@MBE_W_W@Z ENDP		; std::ctype<wchar_t>::do_toupper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_tolower@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z PROC	; std::ctype<wchar_t>::do_tolower, COMDAT
; _this$ = ecx

; 3018 :         const _Elem* _Last) const { // convert [_First, _Last) in place to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3019 :         _Adl_verify_range(_First, _Last);
; 3020 :         for (; _First != _Last; ++_First) {

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 1c		 je	 SHORT $LN10@do_tolower
  0000f	53		 push	 ebx
  00010	8d 59 08	 lea	 ebx, DWORD PTR [ecx+8]
$LL4@do_tolower:

; 3021 :             *_First = _Towlower(*_First, &_Ctype);

  00013	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00016	53		 push	 ebx
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 __Towlower
  0001d	66 89 06	 mov	 WORD PTR [esi], ax
  00020	83 c4 08	 add	 esp, 8
  00023	83 c6 02	 add	 esi, 2
  00026	3b f7		 cmp	 esi, edi
  00028	75 e9		 jne	 SHORT $LL4@do_tolower

; 3019 :         _Adl_verify_range(_First, _Last);
; 3020 :         for (; _First != _Last; ++_First) {

  0002a	5b		 pop	 ebx
$LN10@do_tolower:
  0002b	5f		 pop	 edi

; 3022 :         }
; 3023 : 
; 3024 :         return _First;
; 3025 :     }

  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
?do_tolower@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z ENDP	; std::ctype<wchar_t>::do_tolower
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_tolower@?$ctype@_W@std@@MBE_W_W@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 2
?do_tolower@?$ctype@_W@std@@MBE_W_W@Z PROC		; std::ctype<wchar_t>::do_tolower, COMDAT
; _this$ = ecx

; 3013 :     virtual _Elem __CLR_OR_THIS_CALL do_tolower(_Elem _Ch) const { // convert element to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3014 :         return _Towlower(_Ch, &_Ctype);

  00003	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00006	50		 push	 eax
  00007	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  0000a	e8 00 00 00 00	 call	 __Towlower
  0000f	83 c4 08	 add	 esp, 8

; 3015 :     }

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?do_tolower@?$ctype@_W@std@@MBE_W_W@Z ENDP		; std::ctype<wchar_t>::do_tolower
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_scan_not@?$ctype@_W@std@@MBEPB_WFPB_W0@Z
_TEXT	SEGMENT
__Maskval$ = 8						; size = 2
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?do_scan_not@?$ctype@_W@std@@MBEPB_WFPB_W0@Z PROC	; std::ctype<wchar_t>::do_scan_not, COMDAT
; _this$ = ecx

; 3004 :         const _Elem* _Last) const { // find first in [_First, _Last) not fitting mask classification

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 3005 :         _Adl_verify_range(_First, _Last);
; 3006 :         while (_First != _Last && is(_Maskval, *_First)) {

  00005	8b 75 0c	 mov	 esi, DWORD PTR __First$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	57		 push	 edi
  0000b	8b 7d 10	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	3b f7		 cmp	 esi, edi
  00010	74 1b		 je	 SHORT $LN11@do_scan_no
$LL2@do_scan_no:
  00012	0f b7 0e	 movzx	 ecx, WORD PTR [esi]

; 2894 :         return do_is(_Maskval, _Ch);

  00015	8b 03		 mov	 eax, DWORD PTR [ebx]
  00017	51		 push	 ecx
  00018	ff 75 08	 push	 DWORD PTR __Maskval$[ebp]
  0001b	8b cb		 mov	 ecx, ebx
  0001d	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00020	ff d0		 call	 eax

; 3005 :         _Adl_verify_range(_First, _Last);
; 3006 :         while (_First != _Last && is(_Maskval, *_First)) {

  00022	84 c0		 test	 al, al
  00024	74 07		 je	 SHORT $LN11@do_scan_no

; 3007 :             ++_First;

  00026	83 c6 02	 add	 esi, 2
  00029	3b f7		 cmp	 esi, edi
  0002b	75 e5		 jne	 SHORT $LL2@do_scan_no
$LN11@do_scan_no:
  0002d	5f		 pop	 edi

; 3008 :         }
; 3009 : 
; 3010 :         return _First;
; 3011 :     }

  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	5d		 pop	 ebp
  00033	c2 0c 00	 ret	 12			; 0000000cH
?do_scan_not@?$ctype@_W@std@@MBEPB_WFPB_W0@Z ENDP	; std::ctype<wchar_t>::do_scan_not
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_scan_is@?$ctype@_W@std@@MBEPB_WFPB_W0@Z
_TEXT	SEGMENT
__Maskval$ = 8						; size = 2
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?do_scan_is@?$ctype@_W@std@@MBEPB_WFPB_W0@Z PROC	; std::ctype<wchar_t>::do_scan_is, COMDAT
; _this$ = ecx

; 2994 :         const _Elem* _Last) const { // find first in [_First, _Last) that fits mask classification

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 2995 :         _Adl_verify_range(_First, _Last);
; 2996 :         while (_First != _Last && !is(_Maskval, *_First)) {

  00005	8b 75 0c	 mov	 esi, DWORD PTR __First$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	57		 push	 edi
  0000b	8b 7d 10	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	3b f7		 cmp	 esi, edi
  00010	74 1b		 je	 SHORT $LN11@do_scan_is
$LL2@do_scan_is:
  00012	0f b7 0e	 movzx	 ecx, WORD PTR [esi]

; 2894 :         return do_is(_Maskval, _Ch);

  00015	8b 03		 mov	 eax, DWORD PTR [ebx]
  00017	51		 push	 ecx
  00018	ff 75 08	 push	 DWORD PTR __Maskval$[ebp]
  0001b	8b cb		 mov	 ecx, ebx
  0001d	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00020	ff d0		 call	 eax

; 2995 :         _Adl_verify_range(_First, _Last);
; 2996 :         while (_First != _Last && !is(_Maskval, *_First)) {

  00022	84 c0		 test	 al, al
  00024	75 07		 jne	 SHORT $LN11@do_scan_is

; 2997 :             ++_First;

  00026	83 c6 02	 add	 esi, 2
  00029	3b f7		 cmp	 esi, edi
  0002b	75 e5		 jne	 SHORT $LL2@do_scan_is
$LN11@do_scan_is:
  0002d	5f		 pop	 edi

; 2998 :         }
; 2999 : 
; 3000 :         return _First;
; 3001 :     }

  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	5d		 pop	 ebp
  00033	c2 0c 00	 ret	 12			; 0000000cH
?do_scan_is@?$ctype@_W@std@@MBEPB_WFPB_W0@Z ENDP	; std::ctype<wchar_t>::do_scan_is
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_is@?$ctype@_W@std@@MBEPB_WPB_W0PAF@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_is@?$ctype@_W@std@@MBEPB_WPB_W0PAF@Z PROC		; std::ctype<wchar_t>::do_is, COMDAT
; _this$ = ecx

; 2988 :         mask* _Dest) const { // get mask sequence for elements in [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2989 :         _Adl_verify_range(_First, _Last);
; 2990 :         return _CSTD _Getwctypes(_First, _Last, _Dest, &_Ctype);

  00003	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00006	50		 push	 eax
  00007	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 __Getwctypes
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 2991 :     }

  00018	5d		 pop	 ebp
  00019	c2 0c 00	 ret	 12			; 0000000cH
?do_is@?$ctype@_W@std@@MBEPB_WPB_W0PAF@Z ENDP		; std::ctype<wchar_t>::do_is
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_is@?$ctype@_W@std@@MBE_NF_W@Z
_TEXT	SEGMENT
__Maskval$ = 8						; size = 2
__Ch$ = 12						; size = 2
?do_is@?$ctype@_W@std@@MBE_NF_W@Z PROC			; std::ctype<wchar_t>::do_is, COMDAT
; _this$ = ecx

; 2983 :         mask _Maskval, _Elem _Ch) const { // test if element fits any mask classifications

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2984 :         return (_CSTD _Getwctype(_Ch, &_Ctype) & _Maskval) != 0;

  00003	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00006	50		 push	 eax
  00007	ff 75 0c	 push	 DWORD PTR __Ch$[ebp]
  0000a	e8 00 00 00 00	 call	 __Getwctype
  0000f	83 c4 08	 add	 esp, 8
  00012	66 85 45 08	 test	 WORD PTR __Maskval$[ebp], ax
  00016	0f 95 c0	 setne	 al

; 2985 :     }

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?do_is@?$ctype@_W@std@@MBE_NF_W@Z ENDP			; std::ctype<wchar_t>::do_is
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??1?$ctype@_W@std@@MAE@XZ
_TEXT	SEGMENT
??1?$ctype@_W@std@@MAE@XZ PROC				; std::ctype<wchar_t>::~ctype<wchar_t>, COMDAT
; _this$ = ecx

; 2969 :     __CLR_OR_THIS_CALL ~ctype() noexcept override {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2970 :         if (_Ctype._Delfl) {

  00003	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@_W@std@@6B@
  0000d	74 0b		 je	 SHORT $LN2@ctype

; 2971 :             _CSTD free(const_cast<short*>(_Ctype._Table));

  0000f	ff 76 0c	 push	 DWORD PTR [esi+12]
  00012	e8 00 00 00 00	 call	 _free
  00017	83 c4 04	 add	 esp, 4
$LN2@ctype:

; 2972 :         }
; 2973 : 
; 2974 :         _CSTD free(_Ctype._LocaleName);

  0001a	ff 76 14	 push	 DWORD PTR [esi+20]
  0001d	e8 00 00 00 00	 call	 _free
  00022	83 c4 04	 add	 esp, 4

; 2975 :     }

  00025	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0002b	5e		 pop	 esi
  0002c	c3		 ret	 0
??1?$ctype@_W@std@@MAE@XZ ENDP				; std::ctype<wchar_t>::~ctype<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -96						; size = 52
$T3 = -44						; size = 16
__Lock$4 = -28						; size = 4
$T5 = -24						; size = 4
__Psave$1$ = -24					; size = 4
$T6 = -20						; size = 4
__Lock$7 = -16						; size = 4
$T8 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
__Psave_guard$9 = 8					; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT

; 435  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 436  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

  00027	6a 00		 push	 0
  00029	8d 4d e4	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  0002c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T6[ebp], 0
  00033	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 91   :             if (_Id == 0) { // still zero, allocate stamp

  00038	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id

; 437  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

  0003e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	89 45 e8	 mov	 DWORD PTR __Psave$1$[ebp], eax

; 91   :             if (_Id == 0) { // still zero, allocate stamp

  0004d	85 ff		 test	 edi, edi
  0004f	75 2f		 jne	 SHORT $LN11@use_facet

; 92   :                 _BEGIN_LOCK(_LOCK_LOCALE)

  00051	57		 push	 edi
  00052	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$7[ebp]
  00055	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 93   :                 if (_Id == 0) {

  0005a	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, edi ; std::ctype<char>::id
  00060	75 10		 jne	 SHORT $LN12@use_facet

; 94   :                     _Id = static_cast<size_t>(++_Id_cnt);

  00062	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00067	40		 inc	 eax
  00068	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  0006d	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, eax ; std::ctype<char>::id
$LN12@use_facet:

; 95   :                 }
; 96   :                 _END_LOCK()

  00072	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$7[ebp]
  00075	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0007a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id
$LN11@use_facet:

; 377  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  00080	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00083	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
  0008a	89 4d f0	 mov	 DWORD PTR $T8[ebp], ecx
  0008d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00090	3b 7a 0c	 cmp	 edi, DWORD PTR [edx+12]
  00093	73 16		 jae	 SHORT $LN19@use_facet
  00095	0f ae e8	 lfence
  00098	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0009b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0009e	8b 34 01	 mov	 esi, DWORD PTR [ecx+eax]

; 378  :         if (_Facptr || !_Ptr->_Xparent) {

  000a1	85 f6		 test	 esi, esi
  000a3	0f 85 ca 00 00
	00		 jne	 $LN77@use_facet
  000a9	eb 05		 jmp	 SHORT $LN81@use_facet
$LN19@use_facet:

; 374  :     }
; 375  : 
; 376  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object
; 377  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  000ab	33 f6		 xor	 esi, esi
  000ad	89 4d f0	 mov	 DWORD PTR $T8[ebp], ecx
$LN81@use_facet:

; 378  :         if (_Facptr || !_Ptr->_Xparent) {

  000b0	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0
  000b4	74 16		 je	 SHORT $LN14@use_facet

; 379  :             return _Facptr; // found facet or not transparent
; 380  :         }
; 381  : 
; 382  :         // look in current locale
; 383  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

  000b6	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 384  :         if (_Id < _Ptr0->_Facetcount) {

  000bb	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  000be	73 14		 jae	 SHORT $LN82@use_facet

; 385  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

  000c0	0f ae e8	 lfence
  000c3	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c6	8b 75 f0	 mov	 esi, DWORD PTR $T8[ebp]
  000c9	8b 34 06	 mov	 esi, DWORD PTR [esi+eax]
$LN14@use_facet:

; 438  : 
; 439  :     const size_t _Id         = _Facet::id._Get_index();
; 440  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);
; 441  : 
; 442  :     if (!_Pf) {

  000cc	85 f6		 test	 esi, esi
  000ce	0f 85 9f 00 00
	00		 jne	 $LN77@use_facet
$LN82@use_facet:

; 443  :         if (_Psave) {

  000d4	8b 45 e8	 mov	 eax, DWORD PTR __Psave$1$[ebp]
  000d7	85 c0		 test	 eax, eax
  000d9	74 07		 je	 SHORT $LN3@use_facet

; 444  :             _Pf = _Psave; // lazy facet already allocated

  000db	8b f0		 mov	 esi, eax

; 445  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

  000dd	e9 91 00 00 00	 jmp	 $LN77@use_facet
$LN3@use_facet:

; 2797 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->_C_str()));

  000e2	6a 18		 push	 24			; 00000018H
  000e4	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000e9	8b f0		 mov	 esi, eax
  000eb	83 c4 04	 add	 esp, 4
  000ee	89 75 e8	 mov	 DWORD PTR $T5[ebp], esi
  000f1	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000f5	85 f6		 test	 esi, esi
  000f7	74 4d		 je	 SHORT $LN24@use_facet

; 373  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  000f9	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  000fc	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000ff	85 c9		 test	 ecx, ecx
  00101	74 0c		 je	 SHORT $LN32@use_facet
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo

; 190  :         return _Myptr ? _Myptr : &_Nul;

  00103	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00106	85 c0		 test	 eax, eax
  00108	75 0a		 jne	 SHORT $LN33@use_facet
  0010a	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 373  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  0010d	eb 05		 jmp	 SHORT $LN33@use_facet
$LN32@use_facet:
  0010f	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@@
$LN33@use_facet:

; 2797 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->_C_str()));

  00114	50		 push	 eax
  00115	8d 4d a0	 lea	 ecx, DWORD PTR $T2[ebp]
  00118	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo

; 277  :         return ::_Getctype();

  0011d	8d 45 d4	 lea	 eax, DWORD PTR $T3[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 2797 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->_C_str()));

  00120	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR $T6[ebp], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo

; 277  :         return ::_Getctype();

  00127	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 143  :             : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs)) // non-atomic initialization

  00128	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 2791 :     __CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {

  0012f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo

; 277  :         return ::_Getctype();

  00135	e8 00 00 00 00	 call	 __Getctype
  0013a	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 2819 :         _Ctype = _Lobj._Getctype();

  0013d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00140	0f 11 46 08	 movups	 XMMWORD PTR [esi+8], xmm0

; 2797 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->_C_str()));

  00144	eb 02		 jmp	 SHORT $LN25@use_facet
$LN24@use_facet:
  00146	33 f6		 xor	 esi, esi
$LN25@use_facet:
  00148	f6 45 ec 01	 test	 BYTE PTR $T6[ebp], 1
  0014c	74 08		 je	 SHORT $LN29@use_facet
  0014e	8d 4d a0	 lea	 ecx, DWORD PTR $T2[ebp]
  00151	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN29@use_facet:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00156	89 75 08	 mov	 DWORD PTR __Psave_guard$9[ebp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale

; 458  :             _Facet_Register(_Pfmod);

  00159	56		 push	 esi
  0015a	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0015e	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register

; 459  : #endif // ^^^ !defined(_M_CEE) ^^^
; 460  : 
; 461  :             _Pfmod->_Incref();

  00163	8b 16		 mov	 edx, DWORD PTR [esi]
  00165	83 c4 04	 add	 esp, 4
  00168	8b ce		 mov	 ecx, esi
  0016a	ff 52 04	 call	 DWORD PTR [edx+4]

; 462  :             _Facetptr<_Facet>::_Psave = _Psave;

  0016d	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::ctype<char> >::_Psave
$LN77@use_facet:

; 463  :             _Pf                       = _Psave;
; 464  : 
; 465  :             (void) _Psave_guard.release();
; 466  :         }
; 467  :     }
; 468  : 
; 469  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

  00173	8d 4d e4	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00176	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0017b	8b c6		 mov	 eax, esi

; 470  :     _END_LOCK()
; 471  : } // end of use_facet body

  0017d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00180	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00187	59		 pop	 ecx
  00188	5f		 pop	 edi
  00189	5e		 pop	 esi
  0018a	8b e5		 mov	 esp, ebp
  0018c	5d		 pop	 ebp
  0018d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$2:
  00008	6a 18		 push	 24			; 00000018H
  0000a	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00013	83 c4 08	 add	 esp, 8
  00016	c3		 ret	 0
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$1:
  00017	8d 4d 08	 lea	 ecx, DWORD PTR __Psave_guard$9[ebp]
  0001a	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
  0001f	cc		 int	 3
  00020	cc		 int	 3
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
  00024	90		 npad	 1
  00025	90		 npad	 1
  00026	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002d	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  00030	33 c8		 xor	 ecx, eax
  00032	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00037	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  0003c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ctype@D@std@@MAEPAXI@Z PROC			; std::ctype<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2814 :     __CLR_OR_THIS_CALL ~ctype() noexcept override {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 2823 :         if (0 < _Ctype._Delfl) {

  00006	8b 46 10	 mov	 eax, DWORD PTR [esi+16]

; 2814 :     __CLR_OR_THIS_CALL ~ctype() noexcept override {

  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@

; 2823 :         if (0 < _Ctype._Delfl) {

  0000f	85 c0		 test	 eax, eax
  00011	7e 0a		 jle	 SHORT $LN20@scalar

; 2824 :             _CSTD free(const_cast<short*>(_Ctype._Table));

  00013	ff 76 0c	 push	 DWORD PTR [esi+12]
  00016	e8 00 00 00 00	 call	 _free
  0001b	eb 0a		 jmp	 SHORT $LN21@scalar
$LN20@scalar:

; 2825 :         } else if (_Ctype._Delfl < 0) {

  0001d	79 0b		 jns	 SHORT $LN13@scalar

; 2826 :             delete[] _Ctype._Table;

  0001f	ff 76 0c	 push	 DWORD PTR [esi+12]
  00022	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
$LN21@scalar:

; 2827 :         }
; 2828 : 
; 2829 :         _CSTD free(_Ctype._LocaleName);

  00027	83 c4 04	 add	 esp, 4
$LN13@scalar:
  0002a	ff 76 14	 push	 DWORD PTR [esi+20]
  0002d	e8 00 00 00 00	 call	 _free
  00032	83 c4 04	 add	 esp, 4

; 2816 :     }

  00035	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0003b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0003f	74 0b		 je	 SHORT $LN16@scalar
  00041	6a 18		 push	 24			; 00000018H
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00049	83 c4 08	 add	 esp, 8
$LN16@scalar:
  0004c	8b c6		 mov	 eax, esi
  0004e	5e		 pop	 esi
  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
??_G?$ctype@D@std@@MAEPAXI@Z ENDP			; std::ctype<char>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z PROC		; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2876 :         char* _Dest) const { // narrow elements in [_First, _Last) to chars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2877 :         _Adl_verify_range(_First, _Last);
; 2878 :         _CSTD memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	51		 push	 ecx
  0000c	52		 push	 edx
  0000d	ff 75 14	 push	 DWORD PTR __Dest$[ebp]
  00010	e8 00 00 00 00	 call	 _memcpy

; 2879 :         return _Last;

  00015	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2880 :     }

  0001b	5d		 pop	 ebp
  0001c	c2 10 00	 ret	 16			; 00000010H
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z ENDP		; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
___formal$ = 12						; size = 1
?do_narrow@?$ctype@D@std@@MBEDDD@Z PROC			; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2871 :     virtual _Elem __CLR_OR_THIS_CALL do_narrow(_Elem _Ch, char) const { // narrow char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2872 :         return _Ch;

  00003	8a 45 08	 mov	 al, BYTE PTR __Ch$[ebp]

; 2873 :     }

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
?do_narrow@?$ctype@D@std@@MBEDDD@Z ENDP			; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z PROC		; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2865 :         const char* _First, const char* _Last, _Elem* _Dest) const { // widen chars in [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2866 :         _Adl_verify_range(_First, _Last);
; 2867 :         _CSTD memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	51		 push	 ecx
  0000c	52		 push	 edx
  0000d	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00010	e8 00 00 00 00	 call	 _memcpy

; 2868 :         return _Last;

  00015	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2869 :     }

  0001b	5d		 pop	 ebp
  0001c	c2 0c 00	 ret	 12			; 0000000cH
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
?do_widen@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2860 :     virtual _Elem __CLR_OR_THIS_CALL do_widen(char _Byte) const { // widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2861 :         return _Byte;

  00003	8a 45 08	 mov	 al, BYTE PTR __Byte$[ebp]

; 2862 :     }

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?do_widen@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2851 :         const _Elem* _Last) const { // convert [_First, _Last) in place to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2852 :         _Adl_verify_range(_First, _Last);
; 2853 :         for (; _First != _Last; ++_First) {

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 19		 je	 SHORT $LN10@do_toupper
  0000f	53		 push	 ebx
  00010	8d 59 08	 lea	 ebx, DWORD PTR [ecx+8]
$LL4@do_toupper:

; 2854 :             *_First = static_cast<_Elem>(_Toupper(static_cast<unsigned char>(*_First), &_Ctype));

  00013	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00016	53		 push	 ebx
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 __Toupper
  0001d	88 06		 mov	 BYTE PTR [esi], al
  0001f	83 c4 08	 add	 esp, 8
  00022	46		 inc	 esi
  00023	3b f7		 cmp	 esi, edi
  00025	75 ec		 jne	 SHORT $LL4@do_toupper

; 2852 :         _Adl_verify_range(_First, _Last);
; 2853 :         for (; _First != _Last; ++_First) {

  00027	5b		 pop	 ebx
$LN10@do_toupper:
  00028	5f		 pop	 edi

; 2855 :         }
; 2856 : 
; 2857 :         return _First;
; 2858 :     }

  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_toupper@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2846 :     virtual _Elem __CLR_OR_THIS_CALL do_toupper(_Elem _Ch) const { // convert element to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2847 :         return static_cast<_Elem>(_Toupper(static_cast<unsigned char>(_Ch), &_Ctype));

  00003	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00006	50		 push	 eax
  00007	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 __Toupper
  00011	83 c4 08	 add	 esp, 8

; 2848 :     }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?do_toupper@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2837 :         const _Elem* _Last) const { // convert [_First, _Last) in place to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2838 :         _Adl_verify_range(_First, _Last);
; 2839 :         for (; _First != _Last; ++_First) {

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 19		 je	 SHORT $LN10@do_tolower
  0000f	53		 push	 ebx
  00010	8d 59 08	 lea	 ebx, DWORD PTR [ecx+8]
$LL4@do_tolower:

; 2840 :             *_First = static_cast<_Elem>(_Tolower(static_cast<unsigned char>(*_First), &_Ctype));

  00013	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00016	53		 push	 ebx
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 __Tolower
  0001d	88 06		 mov	 BYTE PTR [esi], al
  0001f	83 c4 08	 add	 esp, 8
  00022	46		 inc	 esi
  00023	3b f7		 cmp	 esi, edi
  00025	75 ec		 jne	 SHORT $LL4@do_tolower

; 2838 :         _Adl_verify_range(_First, _Last);
; 2839 :         for (; _First != _Last; ++_First) {

  00027	5b		 pop	 ebx
$LN10@do_tolower:
  00028	5f		 pop	 edi

; 2841 :         }
; 2842 : 
; 2843 :         return _First;
; 2844 :     }

  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_tolower@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2832 :     virtual _Elem __CLR_OR_THIS_CALL do_tolower(_Elem _Ch) const { // convert element to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2833 :         return static_cast<_Elem>(_Tolower(static_cast<unsigned char>(_Ch), &_Ctype));

  00003	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00006	50		 push	 eax
  00007	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 __Tolower
  00011	83 c4 08	 add	 esp, 8

; 2834 :     }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?do_tolower@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT
??1?$ctype@D@std@@MAE@XZ PROC				; std::ctype<char>::~ctype<char>, COMDAT
; _this$ = ecx

; 2814 :     __CLR_OR_THIS_CALL ~ctype() noexcept override {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2823 :         if (0 < _Ctype._Delfl) {

  00003	8b 46 10	 mov	 eax, DWORD PTR [esi+16]

; 2814 :     __CLR_OR_THIS_CALL ~ctype() noexcept override {

  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@

; 2823 :         if (0 < _Ctype._Delfl) {

  0000c	85 c0		 test	 eax, eax
  0000e	7e 0a		 jle	 SHORT $LN12@ctype

; 2824 :             _CSTD free(const_cast<short*>(_Ctype._Table));

  00010	ff 76 0c	 push	 DWORD PTR [esi+12]
  00013	e8 00 00 00 00	 call	 _free
  00018	eb 0a		 jmp	 SHORT $LN13@ctype
$LN12@ctype:

; 2825 :         } else if (_Ctype._Delfl < 0) {

  0001a	79 0b		 jns	 SHORT $LN7@ctype

; 2826 :             delete[] _Ctype._Table;

  0001c	ff 76 0c	 push	 DWORD PTR [esi+12]
  0001f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
$LN13@ctype:

; 2827 :         }
; 2828 : 
; 2829 :         _CSTD free(_Ctype._LocaleName);

  00024	83 c4 04	 add	 esp, 4
$LN7@ctype:
  00027	ff 76 14	 push	 DWORD PTR [esi+20]
  0002a	e8 00 00 00 00	 call	 _free
  0002f	83 c4 04	 add	 esp, 4

; 2815 :         _Tidy();
; 2816 :     }

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  00038	5e		 pop	 esi
  00039	c3		 ret	 0
??1?$ctype@D@std@@MAE@XZ ENDP				; std::ctype<char>::~ctype<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gctype_base@std@@UAEPAXI@Z PROC			; std::ctype_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  00010	74 0b		 je	 SHORT $LN5@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_Gctype_base@std@@UAEPAXI@Z ENDP			; std::ctype_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT
??1ctype_base@std@@UAE@XZ PROC				; std::ctype_base::~ctype_base, COMDAT
; _this$ = ecx

; 2450 :     __CLR_OR_THIS_CALL ~ctype_base() noexcept override {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
  00006	c3		 ret	 0
??1ctype_base@std@@UAE@XZ ENDP				; std::ctype_base::~ctype_base
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gcodecvt_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gcodecvt_base@std@@UAEPAXI@Z PROC			; std::codecvt_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  00010	74 0b		 je	 SHORT $LN5@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_Gcodecvt_base@std@@UAEPAXI@Z ENDP			; std::codecvt_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_encoding@codecvt_base@std@@MBEHXZ
_TEXT	SEGMENT
?do_encoding@codecvt_base@std@@MBEHXZ PROC		; std::codecvt_base::do_encoding, COMDAT
; _this$ = ecx

; 666  :         return 1; // -1 ==> state dependent, 0 ==> varying length

  00000	b8 01 00 00 00	 mov	 eax, 1

; 667  :     }

  00005	c3		 ret	 0
?do_encoding@codecvt_base@std@@MBEHXZ ENDP		; std::codecvt_base::do_encoding
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_max_length@codecvt_base@std@@MBEHXZ
_TEXT	SEGMENT
?do_max_length@codecvt_base@std@@MBEHXZ PROC		; std::codecvt_base::do_max_length, COMDAT
; _this$ = ecx

; 661  :         // return maximum length required for a conversion (from codecvt)
; 662  :         return 1;

  00000	b8 01 00 00 00	 mov	 eax, 1

; 663  :     }

  00005	c3		 ret	 0
?do_max_length@codecvt_base@std@@MBEHXZ ENDP		; std::codecvt_base::do_max_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?do_always_noconv@codecvt_base@std@@MBE_NXZ
_TEXT	SEGMENT
?do_always_noconv@codecvt_base@std@@MBE_NXZ PROC	; std::codecvt_base::do_always_noconv, COMDAT
; _this$ = ecx

; 656  :         // return true if conversions never change input (from codecvt)
; 657  :         return false;

  00000	32 c0		 xor	 al, al

; 658  :     }

  00002	c3		 ret	 0
?do_always_noconv@codecvt_base@std@@MBE_NXZ ENDP	; std::codecvt_base::do_always_noconv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Mbst2$ = -24						; size = 8
__Mbst1$ = -16						; size = 8
__Count1$1$ = -8					; size = 4
__Wc$ = -4						; size = 2
__Ptr$ = 8						; size = 4
__Ptrdest$1$ = 8					; size = 4
___formal$ = 12						; size = 4
__Cvt$ = 16						; size = 4
??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z PROC	; std::_Maklocstr<wchar_t>, COMDAT

; 544  : inline wchar_t* __CRTDECL _Maklocstr(const char* _Ptr, wchar_t*, const _Locinfo::_Cvtvec& _Cvt) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx

; 545  :     // convert C string to wchar_t sequence using _Cvtvec
; 546  :     size_t _Count;
; 547  :     size_t _Count1;
; 548  :     size_t _Wchars;
; 549  :     const char* _Ptr1;
; 550  :     int _Bytes;
; 551  :     wchar_t _Wc;
; 552  :     mbstate_t _Mbst1 = {};
; 553  : 
; 554  :     _Count1 = _CSTD strlen(_Ptr) + 1;

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  0000a	0f 57 c0	 xorps	 xmm0, xmm0
  0000d	8b cb		 mov	 ecx, ebx
  0000f	66 0f 13 45 f0	 movlpd	 QWORD PTR __Mbst1$[ebp], xmm0
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00019	0f 1f 80 00 00
	00 00		 npad	 7
$LL22@Maklocstr:
  00020	8a 01		 mov	 al, BYTE PTR [ecx]
  00022	41		 inc	 ecx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL22@Maklocstr
  00027	2b ca		 sub	 ecx, edx

; 555  :     for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count; _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars) {

  00029	33 f6		 xor	 esi, esi
  0002b	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0002e	89 45 f8	 mov	 DWORD PTR __Count1$1$[ebp], eax
  00031	8b f8		 mov	 edi, eax
  00033	85 c0		 test	 eax, eax
  00035	74 23		 je	 SHORT $LN14@Maklocstr
$LL4@Maklocstr:

; 556  :         if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) {

  00037	ff 75 10	 push	 DWORD PTR __Cvt$[ebp]
  0003a	8d 45 f0	 lea	 eax, DWORD PTR __Mbst1$[ebp]
  0003d	50		 push	 eax
  0003e	57		 push	 edi
  0003f	8d 45 fc	 lea	 eax, DWORD PTR __Wc$[ebp]
  00042	53		 push	 ebx
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 __Mbrtowc
  00049	83 c4 14	 add	 esp, 20			; 00000014H
  0004c	85 c0		 test	 eax, eax
  0004e	7e 07		 jle	 SHORT $LN23@Maklocstr

; 555  :     for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count; _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars) {

  00050	03 d8		 add	 ebx, eax
  00052	46		 inc	 esi
  00053	2b f8		 sub	 edi, eax
  00055	75 e0		 jne	 SHORT $LL4@Maklocstr
$LN23@Maklocstr:
  00057	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
$LN14@Maklocstr:

; 557  :             break;
; 558  :         }
; 559  :     }
; 560  : 
; 561  :     ++_Wchars; // count terminating nul

  0005a	46		 inc	 esi

; 562  : 
; 563  :     wchar_t* _Ptrdest = static_cast<wchar_t*>(_calloc_dbg(_Wchars, sizeof(wchar_t), _CRT_BLOCK, __FILE__, __LINE__));

  0005b	6a 02		 push	 2
  0005d	56		 push	 esi
  0005e	e8 00 00 00 00	 call	 _calloc
  00063	83 c4 08	 add	 esp, 8
  00066	89 45 08	 mov	 DWORD PTR __Ptrdest$1$[ebp], eax

; 564  : 
; 565  :     if (!_Ptrdest) {

  00069	85 c0		 test	 eax, eax
  0006b	74 44		 je	 SHORT $LN33@Maklocstr

; 567  :     }
; 568  : 
; 569  :     wchar_t* _Ptrnext = _Ptrdest;

  0006d	0f 57 c0	 xorps	 xmm0, xmm0
  00070	8b f8		 mov	 edi, eax

; 570  :     mbstate_t _Mbst2  = {};

  00072	66 0f 13 45 e8	 movlpd	 QWORD PTR __Mbst2$[ebp], xmm0

; 571  : 
; 572  :     for (; 0 < _Wchars; _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext) {

  00077	85 f6		 test	 esi, esi
  00079	74 2a		 je	 SHORT $LN15@Maklocstr
  0007b	0f 1f 44 00 00	 npad	 5
$LL7@Maklocstr:

; 573  :         if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) {

  00080	ff 75 10	 push	 DWORD PTR __Cvt$[ebp]
  00083	8d 45 e8	 lea	 eax, DWORD PTR __Mbst2$[ebp]
  00086	50		 push	 eax
  00087	ff 75 f8	 push	 DWORD PTR __Count1$1$[ebp]
  0008a	53		 push	 ebx
  0008b	57		 push	 edi
  0008c	e8 00 00 00 00	 call	 __Mbrtowc
  00091	83 c4 14	 add	 esp, 20			; 00000014H
  00094	85 c0		 test	 eax, eax
  00096	7e 0a		 jle	 SHORT $LN24@Maklocstr

; 571  : 
; 572  :     for (; 0 < _Wchars; _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext) {

  00098	03 d8		 add	 ebx, eax
  0009a	83 c7 02	 add	 edi, 2
  0009d	83 ee 01	 sub	 esi, 1
  000a0	75 de		 jne	 SHORT $LL7@Maklocstr
$LN24@Maklocstr:
  000a2	8b 45 08	 mov	 eax, DWORD PTR __Ptrdest$1$[ebp]
$LN15@Maklocstr:

; 574  :             break;
; 575  :         }
; 576  :     }
; 577  : 
; 578  :     *_Ptrnext = L'\0';

  000a5	33 c9		 xor	 ecx, ecx
  000a7	66 89 0f	 mov	 WORD PTR [edi], cx

; 579  : 
; 580  :     return _Ptrdest;
; 581  : }

  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
$LN33@Maklocstr:

; 566  :         _Xbad_alloc();

  000b1	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN31@Maklocstr:
  000b6	cc		 int	 3
??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 354  :         if (_Ptr) {

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	85 c9		 test	 ecx, ecx
  00005	74 11		 je	 SHORT $LN4@locale

; 355  :             delete _Ptr->_Decref();

  00007	8b 01		 mov	 eax, DWORD PTR [ecx]
  00009	ff 50 08	 call	 DWORD PTR [eax+8]
  0000c	85 c0		 test	 eax, eax
  0000e	74 08		 je	 SHORT $LN4@locale
  00010	8b 10		 mov	 edx, DWORD PTR [eax]
  00012	8b c8		 mov	 ecx, eax
  00014	6a 01		 push	 1
  00016	ff 12		 call	 DWORD PTR [edx]
$LN4@locale:

; 356  :         }
; 357  :     }

  00018	c3		 ret	 0
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gfacet@locale@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfacet@locale@std@@MAEPAXI@Z PROC			; std::locale::facet::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  00010	74 0b		 je	 SHORT $LN5@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_Gfacet@locale@std@@MAEPAXI@Z ENDP			; std::locale::facet::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??1facet@locale@std@@MAE@XZ
_TEXT	SEGMENT
??1facet@locale@std@@MAE@XZ PROC			; std::locale::facet::~facet, COMDAT
; _this$ = ecx

; 146  :         __CLR_OR_THIS_CALL ~facet() noexcept override {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
  00006	c3		 ret	 0
??1facet@locale@std@@MAE@XZ ENDP			; std::locale::facet::~facet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
_TEXT	SEGMENT
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ PROC	; std::locale::facet::_Decref, COMDAT
; _this$ = ecx

; 131  :             if (_MT_DECR(_Myrefs) == 0) {

  00000	83 c8 ff	 or	 eax, -1
  00003	f0 0f c1 41 04	 lock	  xadd	 DWORD PTR [ecx+4], eax
  00008	b8 00 00 00 00	 mov	 eax, 0
  0000d	0f 44 c1	 cmove	 eax, ecx

; 132  :                 return this;
; 133  :             }
; 134  : 
; 135  :             return nullptr;
; 136  :         }

  00010	c3		 ret	 0
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ENDP	; std::locale::facet::_Decref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?_Incref@facet@locale@std@@UAEXXZ
_TEXT	SEGMENT
?_Incref@facet@locale@std@@UAEXXZ PROC			; std::locale::facet::_Incref, COMDAT
; _this$ = ecx

; 127  :             _MT_INCR(_Myrefs);

  00000	f0 ff 41 04	 lock	  inc	 DWORD PTR [ecx+4]

; 128  :         }

  00004	c3		 ret	 0
?_Incref@facet@locale@std@@UAEXXZ ENDP			; std::locale::facet::_Incref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
;	COMDAT ??1?$_Yarn@_W@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Yarn@_W@std@@QAE@XZ PROC				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 181  :     __CLR_OR_THIS_CALL ~_Yarn() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 203  :         if (_Myptr) {

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN8@Yarn

; 204  : #ifdef _DEBUG
; 205  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 206  : #else
; 207  :             _CSTD free(_Myptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4
$LN8@Yarn:

; 182  :         _Tidy();
; 183  :     }

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	5e		 pop	 esi
  00019	c3		 ret	 0
??1?$_Yarn@_W@std@@QAE@XZ ENDP				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
;	COMDAT ??1?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::~_Yarn<char>, COMDAT
; _this$ = ecx

; 181  :     __CLR_OR_THIS_CALL ~_Yarn() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 203  :         if (_Myptr) {

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN8@Yarn

; 204  : #ifdef _DEBUG
; 205  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 206  : #else
; 207  :             _CSTD free(_Myptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4
$LN8@Yarn:

; 182  :         _Tidy();
; 183  :     }

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	5e		 pop	 esi
  00019	c3		 ret	 0
??1?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::~_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
;	COMDAT ??1_Locinfo@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Locinfo@std@@QAE@XZ PROC				; std::_Locinfo::~_Locinfo, COMDAT
; _this$ = ecx

; 256  :     __CLR_OR_THIS_CALL ~_Locinfo() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Locinfo@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 257  :         _Locinfo_dtor(this);

  00025	56		 push	 esi
  00026	e8 00 00 00 00	 call	 ?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z ; std::_Locinfo::_Locinfo_dtor

; 203  :         if (_Myptr) {

  0002b	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]

; 257  :         _Locinfo_dtor(this);

  0002e	83 c4 04	 add	 esp, 4

; 203  :         if (_Myptr) {

  00031	85 c0		 test	 eax, eax
  00033	74 09		 je	 SHORT $LN8@Locinfo

; 204  : #ifdef _DEBUG
; 205  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 206  : #else
; 207  :             _CSTD free(_Myptr);

  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _free
  0003b	83 c4 04	 add	 esp, 4
$LN8@Locinfo:

; 208  : #endif
; 209  :         }
; 210  : 
; 211  :         _Myptr = nullptr;

  0003e	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0

; 203  :         if (_Myptr) {

  00045	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00048	85 c0		 test	 eax, eax
  0004a	74 09		 je	 SHORT $LN15@Locinfo

; 204  : #ifdef _DEBUG
; 205  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 206  : #else
; 207  :             _CSTD free(_Myptr);

  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _free
  00052	83 c4 04	 add	 esp, 4
$LN15@Locinfo:

; 208  : #endif
; 209  :         }
; 210  : 
; 211  :         _Myptr = nullptr;

  00055	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0

; 203  :         if (_Myptr) {

  0005c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0005f	85 c0		 test	 eax, eax
  00061	74 09		 je	 SHORT $LN22@Locinfo

; 204  : #ifdef _DEBUG
; 205  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 206  : #else
; 207  :             _CSTD free(_Myptr);

  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _free
  00069	83 c4 04	 add	 esp, 4
$LN22@Locinfo:

; 208  : #endif
; 209  :         }
; 210  : 
; 211  :         _Myptr = nullptr;

  0006c	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 203  :         if (_Myptr) {

  00073	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00076	85 c0		 test	 eax, eax
  00078	74 09		 je	 SHORT $LN29@Locinfo

; 204  : #ifdef _DEBUG
; 205  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 206  : #else
; 207  :             _CSTD free(_Myptr);

  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _free
  00080	83 c4 04	 add	 esp, 4
$LN29@Locinfo:

; 208  : #endif
; 209  :         }
; 210  : 
; 211  :         _Myptr = nullptr;

  00083	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 203  :         if (_Myptr) {

  0008a	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0008d	85 c0		 test	 eax, eax
  0008f	74 09		 je	 SHORT $LN36@Locinfo

; 204  : #ifdef _DEBUG
; 205  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 206  : #else
; 207  :             _CSTD free(_Myptr);

  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 _free
  00097	83 c4 04	 add	 esp, 4
$LN36@Locinfo:

; 208  : #endif
; 209  :         }
; 210  : 
; 211  :         _Myptr = nullptr;

  0009a	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 203  :         if (_Myptr) {

  000a1	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000a4	85 c0		 test	 eax, eax
  000a6	74 09		 je	 SHORT $LN43@Locinfo

; 204  : #ifdef _DEBUG
; 205  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 206  : #else
; 207  :             _CSTD free(_Myptr);

  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 _free
  000ae	83 c4 04	 add	 esp, 4
$LN43@Locinfo:

; 258  :     }

  000b1	8b ce		 mov	 ecx, esi

; 211  :         _Myptr = nullptr;

  000b3	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 258  :     }

  000ba	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  000bf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c9	59		 pop	 ecx
  000ca	5e		 pop	 esi
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
  000cf	cc		 int	 3
  000d0	cc		 int	 3
  000d1	cc		 int	 3
  000d2	cc		 int	 3
  000d3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Locinfo@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Locinfo@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Locinfo@std@@QAE@XZ ENDP				; std::_Locinfo::~_Locinfo
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo
;	COMDAT ??0_Locinfo@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Pch$ = 8						; size = 4
??0_Locinfo@std@@QAE@PBD@Z PROC				; std::_Locinfo::_Locinfo, COMDAT
; _this$ = ecx

; 234  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0_Locinfo@std@@QAE@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 141  : 
; 142  :     __CLR_OR_THIS_CALL _Yarn(const _Yarn& _Right) noexcept : _Myptr(nullptr), _Nul(0) {
; 143  :         *this = _Right;
; 144  :     }
; 145  : 
; 146  :     __CLR_OR_THIS_CALL _Yarn(const _Elem* _Right) noexcept : _Myptr(nullptr), _Nul(0) {
; 147  :         *this = _Right;
; 148  :     }
; 149  : 
; 150  :     _Yarn& __CLR_OR_THIS_CALL operator=(const _Yarn& _Right) noexcept {
; 151  :         return *this = _Right._Myptr;
; 152  :     }
; 153  : 
; 154  :     _Yarn& __CLR_OR_THIS_CALL operator=(const _Elem* _Right) noexcept {
; 155  :         if (_Myptr != _Right) { // new value, discard old and copy new
; 156  :             _Tidy();
; 157  : 
; 158  :             if (_Right) { // new is not empty, copy it
; 159  :                 const _Elem* _Ptr = _Right;
; 160  :                 while (*_Ptr != _Elem{}) {
; 161  :                     ++_Ptr;
; 162  :                 }
; 163  : 
; 164  :                 const auto _Count = (++_Ptr - _Right) * sizeof(_Elem);
; 165  : 
; 166  : #ifdef _DEBUG
; 167  :                 _Myptr = static_cast<_Elem*>(_malloc_dbg(_Count, _CRT_BLOCK, __FILE__, __LINE__));
; 168  : #else
; 169  :                 _Myptr = static_cast<_Elem*>(_CSTD malloc(_Count));
; 170  : #endif
; 171  : 
; 172  :                 if (_Myptr) {
; 173  :                     _CSTD memcpy(_Myptr, _Right, _Count);
; 174  :                 }
; 175  :             }
; 176  :         }
; 177  : 
; 178  :         return *this;
; 179  :     }
; 180  : 
; 181  :     __CLR_OR_THIS_CALL ~_Yarn() noexcept {
; 182  :         _Tidy();
; 183  :     }
; 184  : 
; 185  :     _NODISCARD bool __CLR_OR_THIS_CALL empty() const noexcept {
; 186  :         return _Myptr == nullptr;
; 187  :     }
; 188  : 
; 189  :     _Ret_z_ const _Elem* __CLR_OR_THIS_CALL c_str() const noexcept {
; 190  :         return _Myptr ? _Myptr : &_Nul;
; 191  :     }
; 192  : 
; 193  :     _NODISCARD bool __CLR_OR_THIS_CALL _Empty() const noexcept {
; 194  :         return _Myptr == nullptr;
; 195  :     }
; 196  : 
; 197  :     _Ret_z_ const _Elem* __CLR_OR_THIS_CALL _C_str() const noexcept {
; 198  :         return _Myptr ? _Myptr : &_Nul;
; 199  :     }
; 200  : 
; 201  : private:
; 202  :     void __CLR_OR_THIS_CALL _Tidy() noexcept {
; 203  :         if (_Myptr) {
; 204  : #ifdef _DEBUG
; 205  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 206  : #else
; 207  :             _CSTD free(_Myptr);
; 208  : #endif
; 209  :         }
; 210  : 
; 211  :         _Myptr = nullptr;
; 212  :     }
; 213  : 
; 214  :     _Elem* _Myptr; // pointer to allocated string
; 215  :     _Elem _Nul; // nul terminator for unallocated string
; 216  : };
; 217  : 
; 218  : extern "C++" class _CRTIMP2_PURE_IMPORT _Locinfo { // summary of all stuff specific to a locale used by standard facets
; 219  : public:
; 220  :     using _Collvec  = ::_Collvec;
; 221  :     using _Ctypevec = ::_Ctypevec;
; 222  :     using _Cvtvec   = ::_Cvtvec;
; 223  :     using _Timevec  = _STD _Timevec;
; 224  : 
; 225  :     static void __CLRCALL_PURE_OR_CDECL _Locinfo_ctor(_Locinfo*, const char*);
; 226  :     static void __CLRCALL_PURE_OR_CDECL _Locinfo_ctor(_Locinfo*, int, const char*);
; 227  :     static void __CLRCALL_PURE_OR_CDECL _Locinfo_dtor(_Locinfo*);
; 228  :     static _Locinfo& __CLRCALL_PURE_OR_CDECL _Locinfo_Addcats(_Locinfo*, int, const char*);
; 229  : 
; 230  :     __CLR_OR_THIS_CALL _Locinfo(const char* _Pch = "C")
; 231  : #ifndef _M_CEE_PURE
; 232  :         : _Lock(_LOCK_LOCALE)

  00029	6a 00		 push	 0
  0002b	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 140  :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

  00037	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0003e	c6 46 08 00	 mov	 BYTE PTR [esi+8], 0
  00042	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00049	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
  0004d	33 c0		 xor	 eax, eax
  0004f	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00056	66 89 46 18	 mov	 WORD PTR [esi+24], ax
  0005a	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  0005d	66 89 46 20	 mov	 WORD PTR [esi+32], ax
  00061	89 46 24	 mov	 DWORD PTR [esi+36], eax
  00064	88 46 28	 mov	 BYTE PTR [esi+40], al
  00067	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  0006a	88 46 30	 mov	 BYTE PTR [esi+48], al

; 235  :         if (_Pch) {

  0006d	8b 45 08	 mov	 eax, DWORD PTR __Pch$[ebp]
  00070	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00074	85 c0		 test	 eax, eax
  00076	74 1e		 je	 SHORT $LN2@Locinfo

; 236  :             _Locinfo_ctor(this, _Pch);

  00078	50		 push	 eax
  00079	56		 push	 esi
  0007a	e8 00 00 00 00	 call	 ?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z ; std::_Locinfo::_Locinfo_ctor
  0007f	83 c4 08	 add	 esp, 8

; 241  :     }

  00082	8b c6		 mov	 eax, esi
  00084	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00087	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008e	59		 pop	 ecx
  0008f	5e		 pop	 esi
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c2 04 00	 ret	 4
$LN2@Locinfo:

; 237  :             return;
; 238  :         }
; 239  : 
; 240  :         _Xruntime_error("bad locale name");

  00096	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@ELKIONDK@bad?5locale?5name@
  0009b	e8 00 00 00 00	 call	 ?_Xruntime_error@std@@YAXPBD@Z ; std::_Xruntime_error
$LN30@Locinfo:
  000a0	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00019	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 14	 add	 ecx, 20			; 00000014H
  00024	e9 00 00 00 00	 jmp	 ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4:
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0002f	e9 00 00 00 00	 jmp	 ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5:
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 24	 add	 ecx, 36			; 00000024H
  0003a	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6:
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00045	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
  0004a	cc		 int	 3
  0004b	cc		 int	 3
  0004c	cc		 int	 3
  0004d	cc		 int	 3
  0004e	cc		 int	 3
__ehhandler$??0_Locinfo@std@@QAE@PBD@Z:
  0004f	90		 npad	 1
  00050	90		 npad	 1
  00051	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00055	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00058	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0005b	33 c8		 xor	 ecx, eax
  0005d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00062	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z
  00067	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0_Locinfo@std@@QAE@PBD@Z ENDP				; std::_Locinfo::_Locinfo
; Function compile flags: /Ogtp
;	COMDAT ??_G_Facet_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Facet_base@std@@UAEPAXI@Z PROC			; std::_Facet_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  00010	74 0b		 je	 SHORT $LN5@scalar
  00012	6a 04		 push	 4
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_G_Facet_base@std@@UAEPAXI@Z ENDP			; std::_Facet_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xfacet
;	COMDAT ??1_Facet_base@std@@UAE@XZ
_TEXT	SEGMENT
??1_Facet_base@std@@UAE@XZ PROC				; std::_Facet_base::~_Facet_base, COMDAT
; _this$ = ecx

; 25   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept {} // ensure that derived classes can be destroyed properly

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
  00006	c3		 ret	 0
??1_Facet_base@std@@UAE@XZ ENDP				; std::_Facet_base::~_Facet_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\typeinfo
;	COMDAT ?_Throw_bad_cast@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_cast@std@@YAXXZ PROC			; std::_Throw_bad_cast, COMDAT

; 62   : [[noreturn]] inline void _Throw_bad_cast() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 63   :     _THROW(bad_cast{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_cast@std@@QAE@XZ	; std::bad_cast::bad_cast
  0000e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_cast@std@@YAXXZ ENDP			; std::_Throw_bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??_Gbad_cast@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_cast@std@@UAEPAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN13@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_cast@std@@UAEPAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0bad_cast@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_cast@std@@QAE@ABV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_cast@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_cast@std@@QAE@ABV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??1bad_cast@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_cast@std@@UAE@XZ PROC				; std::bad_cast::~bad_cast, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_cast@std@@UAE@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_typeinfo.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_cast@std@@QAE@XZ PROC				; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx

; 153  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 154  :     }

  00003	8b c1		 mov	 eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

; 66   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 67   :     {
; 68   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_typeinfo.h

; 153  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_cast@std@@6B@

; 154  :     }

  00017	c3		 ret	 0
??0bad_cast@std@@QAE@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ
_TEXT	SEGMENT
??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ PROC ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>, COMDAT

; 669  :     static _Constexpr_immortalize_impl<_Ty> _Static;
; 670  :     return _Static._Storage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A ; `std::_Immortalize_memcpy_image<std::_Iostream_error_category2>'::`2'::_Static

; 671  : }

  00005	c3		 ret	 0
??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ ENDP ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G_Iostream_error_category2@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Iostream_error_category2@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category2::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	74 0b		 je	 SHORT $LN5@scalar
  0000c	6a 08		 push	 8
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00014	83 c4 08	 add	 esp, 8
$LN5@scalar:
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
??_G_Iostream_error_category2@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category2::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category2::message, COMDAT
; _this$ = ecx

; 555  :     _NODISCARD string message(int _Errcode) const override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 556  :         if (_Errcode == static_cast<int>(io_errc::stream)) {

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp]
  00007	56		 push	 esi
  00008	83 f8 01	 cmp	 eax, 1
  0000b	75 5a		 jne	 SHORT $LN2@message
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0000d	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00010	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00013	6a 20		 push	 32			; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00015	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

  00018	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0001f	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00026	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 913  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  0002b	89 06		 mov	 DWORD PTR [esi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0002d	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 915  :         _My_data._Mysize = _Count;

  00030	c7 46 10 15 00
	00 00		 mov	 DWORD PTR [esi+16], 21	; 00000015H

; 916  :         _My_data._Myres  = _New_capacity;

  00037	c7 46 14 1f 00
	00 00		 mov	 DWORD PTR [esi+20], 31	; 0000001fH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0003e	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ?_Iostream_error@?4??message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB
  00045	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  00048	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?_Iostream_error@?4??message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB+16
  0004e	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00051	8a 0d 14 00 00
	00		 mov	 cl, BYTE PTR ?_Iostream_error@?4??message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB+20
  00057	88 48 14	 mov	 BYTE PTR [eax+20], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 922  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  0005a	c6 40 15 00	 mov	 BYTE PTR [eax+21], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error

; 563  :     }

  0005e	8b c6		 mov	 eax, esi
  00060	5e		 pop	 esi
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 08 00	 ret	 8
$LN2@message:
  00067	57		 push	 edi

; 561  :             return _Syserror_map(_Errcode);

  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0006e	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error

; 561  :             return _Syserror_map(_Errcode);

  00071	8b d0		 mov	 edx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  00073	8b ca		 mov	 ecx, edx
  00075	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error

; 561  :             return _Syserror_map(_Errcode);

  00078	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0007b	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

  0007e	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  00085	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00088	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0008f	90		 npad	 1
$LL66@message:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  00090	8a 01		 mov	 al, BYTE PTR [ecx]
  00092	41		 inc	 ecx
  00093	84 c0		 test	 al, al
  00095	75 f9		 jne	 SHORT $LL66@message
  00097	2b cf		 sub	 ecx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00099	51		 push	 ecx
  0009a	52		 push	 edx
  0009b	8b ce		 mov	 ecx, esi
  0009d	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error

; 561  :             return _Syserror_map(_Errcode);

  000a2	5f		 pop	 edi

; 563  :     }

  000a3	8b c6		 mov	 eax, esi
  000a5	5e		 pop	 esi
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c2 08 00	 ret	 8
?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category2::message
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?name@_Iostream_error_category2@std@@UBEPBDXZ
_TEXT	SEGMENT
?name@_Iostream_error_category2@std@@UBEPBDXZ PROC	; std::_Iostream_error_category2::name, COMDAT
; _this$ = ecx

; 552  :         return "iostream";

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08LLGCOLLL@iostream@

; 553  :     }

  00005	c3		 ret	 0
?name@_Iostream_error_category2@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category2::name
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??_Gsystem_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gsystem_error@std@@UAEPAXI@Z PROC			; std::system_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN23@scalar
  0001e	6a 14		 push	 20			; 00000014H
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN23@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gsystem_error@std@@UAEPAXI@Z ENDP			; std::system_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0system_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0system_error@std@@QAE@ABV01@@Z PROC			; std::system_error::system_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  00004	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  00007	0f 57 c0	 xorps	 xmm0, xmm0

; 73   :     {

  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx

; 72   :         : _Data()

  0000d	8d 47 04	 lea	 eax, DWORD PTR [edi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  00010	50		 push	 eax
  00011	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7exception@std@@6B@
  00017	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0001b	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ___std_exception_copy
  00024	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
  0002a	83 c4 08	 add	 esp, 8
  0002d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00030	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00033	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00036	8b c7		 mov	 eax, edi
  00038	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  0003b	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7system_error@std@@6B@
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
??0system_error@std@@QAE@ABV01@@Z ENDP			; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??1system_error@std@@UAE@XZ
_TEXT	SEGMENT
??1system_error@std@@UAE@XZ PROC			; std::system_error::~system_error, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1system_error@std@@UAE@XZ ENDP			; std::system_error::~system_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??_G_System_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_System_error@std@@UAEPAXI@Z PROC			; std::_System_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN18@scalar
  0001e	6a 14		 push	 20			; 00000014H
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN18@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_G_System_error@std@@UAEPAXI@Z ENDP			; std::_System_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0_System_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0_System_error@std@@QAE@ABV01@@Z PROC			; std::_System_error::_System_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  00004	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  00007	0f 57 c0	 xorps	 xmm0, xmm0

; 73   :     {

  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx

; 72   :         : _Data()

  0000d	8d 47 04	 lea	 eax, DWORD PTR [edi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  00010	50		 push	 eax
  00011	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7exception@std@@6B@
  00017	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0001b	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ___std_exception_copy
  00024	83 c4 08	 add	 esp, 8
  00027	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
  0002d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00030	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00033	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00036	8b c7		 mov	 eax, edi
  00038	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
??0_System_error@std@@QAE@ABV01@@Z ENDP			; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\stdexcept
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T2 = -104						; size = 24
__Errcode$ = -80					; size = 8
__InitData$3 = -80					; size = 8
_this$ = -76						; size = 4
_this$GSCopy$ = -76					; size = 4
_this$GSCopy$1$ = -72					; size = 4
$T4 = -72						; size = 4
__Result$1$ = -68					; size = 4
__Errcode$1$ = -68					; size = 4
$T5 = -64						; size = 24
$T6 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Errcode$ = 8						; size = 8
__Message$ = 16						; size = 4
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_System_error::_System_error, COMDAT
; _this$ = ecx

; 475  :     _System_error(error_code _Errcode, const string& _Message)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b f1		 mov	 esi, ecx
  0002c	89 75 b8	 mov	 DWORD PTR _this$GSCopy$1$[ebp], esi
  0002f	89 75 b4	 mov	 DWORD PTR _this$[ebp], esi
  00032	8b 45 10	 mov	 eax, DWORD PTR __Message$[ebp]
  00035	0f 57 c0	 xorps	 xmm0, xmm0
  00038	89 75 b4	 mov	 DWORD PTR _this$GSCopy$[ebp], esi
  0003b	89 45 bc	 mov	 DWORD PTR __Result$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0003e	0f 11 45 98	 movups	 XMMWORD PTR $T2[ebp], xmm0

; 453  :         return _Myres > _Small_string_capacity;

  00042	83 78 14 0f	 cmp	 DWORD PTR [eax+20], 15	; 0000000fH

; 718  :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00046	8b 78 10	 mov	 edi, DWORD PTR [eax+16]

; 517  :     size_type _Mysize = 0; // current length of string (size)

  00049	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00050	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 0

; 445  :         if (_Large_mode_engaged()) {

  00057	76 05		 jbe	 SHORT $LN22@System_err

; 446  :             _Result = _Unfancy(_Bx._Ptr);

  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	89 45 bc	 mov	 DWORD PTR __Result$1$[ebp], eax
$LN22@System_err:

; 881  :         if (_Count > max_size()) {

  0005e	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  00064	0f 87 90 01 00
	00		 ja	 $LN223@System_err

; 883  :         }
; 884  : 
; 885  :         auto& _Al       = _Getal();
; 886  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 887  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 888  : 
; 889  :         if (_Count <= _Small_string_capacity) {

  0006a	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  0006d	77 13		 ja	 SHORT $LN30@System_err
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0006f	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 890  :             _My_data._Mysize = _Count;

  00072	89 7d a8	 mov	 DWORD PTR $T2[ebp+16], edi

; 891  :             _My_data._Myres  = _Small_string_capacity;

  00075	c7 45 ac 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0007c	0f 11 45 98	 movups	 XMMWORD PTR $T2[ebp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 908  :             return;

  00080	eb 45		 jmp	 SHORT $LN50@System_err
$LN30@System_err:

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

  00082	8b f7		 mov	 esi, edi
  00084	83 ce 0f	 or	 esi, 15			; 0000000fH
  00087	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0008d	76 07		 jbe	 SHORT $LN36@System_err

; 2980 :             return _Max;

  0008f	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  00094	eb 0a		 jmp	 SHORT $LN35@System_err
$LN36@System_err:

; 2981 :         }
; 2982 : 
; 2983 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 2984 :             return _Max;
; 2985 :         }
; 2986 : 
; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00096	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  0009b	3b f0		 cmp	 esi, eax
  0009d	0f 42 f0	 cmovb	 esi, eax
$LN35@System_err:

; 825  :         ++_Capacity; // Take null terminator into consideration

  000a0	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 829  :             _Fancy_ptr = _Allocate_at_least_helper(_Al, _Capacity);

  000a9	8b c8		 mov	 ecx, eax

; 915  :         _My_data._Mysize = _Count;

  000ab	89 7d a8	 mov	 DWORD PTR $T2[ebp+16], edi

; 917  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 918  :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 919  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 920  :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 921  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 922  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 923  :         } else { // _Strat == _Construct_strategy::_From_string
; 924  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

  000ae	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  000b1	89 4d 98	 mov	 DWORD PTR $T2[ebp], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b4	50		 push	 eax
  000b5	ff 75 bc	 push	 DWORD PTR __Result$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 916  :         _My_data._Myres  = _New_capacity;

  000b8	89 75 ac	 mov	 DWORD PTR $T2[ebp+20], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000bb	51		 push	 ecx
  000bc	e8 00 00 00 00	 call	 _memcpy
  000c1	8b 75 b8	 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  000c4	83 c4 10	 add	 esp, 16			; 00000010H
$LN50@System_err:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error

; 476  :         : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode) {}

  000c7	8b 4d 0c	 mov	 ecx, DWORD PTR __Errcode$[ebp+4]
  000ca	8b 45 08	 mov	 eax, DWORD PTR __Errcode$[ebp]
  000cd	89 45 bc	 mov	 DWORD PTR __Errcode$1$[ebp], eax
  000d0	89 4d b8	 mov	 DWORD PTR $T4[ebp], ecx
  000d3	89 4d b4	 mov	 DWORD PTR __Errcode$[ebp+4], ecx

; 463  :     static string _Makestr(error_code _Errcode, string _Message) { // compose error message

  000d6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2494 :         return _Mypair._Myval2._Mysize == 0;

  000dd	85 ff		 test	 edi, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error

; 464  :         if (!_Message.empty()) {

  000df	74 12		 je	 SHORT $LN55@System_err
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1534 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000e1	6a 02		 push	 2
  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5@
  000e8	8d 4d 98	 lea	 ecx, DWORD PTR $T2[ebp]
  000eb	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  000f0	8b 4d b8	 mov	 ecx, DWORD PTR $T4[ebp]
$LN55@System_err:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error

; 207  :         return category().message(value());

  000f3	ff 75 bc	 push	 DWORD PTR __Errcode$1$[ebp]
  000f6	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f8	8d 55 d8	 lea	 edx, DWORD PTR $T6[ebp]
  000fb	52		 push	 edx
  000fc	ff 50 08	 call	 DWORD PTR [eax+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  000ff	83 7d ec 0f	 cmp	 DWORD PTR $T6[ebp+20], 15 ; 0000000fH

; 444  :         const value_type* _Result = _Bx._Buf;

  00103	8d 45 d8	 lea	 eax, DWORD PTR $T6[ebp]

; 1483 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00106	ff 75 e8	 push	 DWORD PTR $T6[ebp+16]

; 445  :         if (_Large_mode_engaged()) {

  00109	0f 47 45 d8	 cmova	 eax, DWORD PTR $T6[ebp]

; 1483 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0010d	8d 4d 98	 lea	 ecx, DWORD PTR $T2[ebp]
  00110	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error

; 468  :         _Message.append(_Errcode.message());

  00111	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1483 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00115	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 453  :         return _Myres > _Small_string_capacity;

  0011a	8b 4d ec	 mov	 ecx, DWORD PTR $T6[ebp+20]
  0011d	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3083 :         if (_My_data._Large_mode_engaged()) {

  00120	76 2c		 jbe	 SHORT $LN102@System_err
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00122	8b 55 d8	 mov	 edx, DWORD PTR $T6[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00125	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00126	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00128	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0012e	72 14		 jb	 SHORT $LN107@System_err

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00130	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00133	83 c1 23	 add	 ecx, 35			; 00000023H
  00136	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00138	83 c0 fc	 add	 eax, -4			; fffffffcH
  0013b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0013e	0f 87 bb 00 00
	00		 ja	 $LN224@System_err
$LN107@System_err:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00144	51		 push	 ecx
  00145	52		 push	 edx
  00146	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0014b	83 c4 08	 add	 esp, 8
$LN102@System_err:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1286 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0014e	0f 10 4d 98	 movups	 xmm1, XMMWORD PTR $T2[ebp]

; 444  :         const value_type* _Result = _Bx._Buf;

  00152	8d 4d c0	 lea	 ecx, DWORD PTR $T5[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

; 60   :     {

  00155	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1286 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0015b	f3 0f 7e 45 a8	 movq	 xmm0, QWORD PTR $T2[ebp+16]
  00160	66 0f d6 45 d0	 movq	 QWORD PTR $T5[ebp+16], xmm0
  00165	0f 57 c0	 xorps	 xmm0, xmm0

; 453  :         return _Myres > _Small_string_capacity;

  00168	83 7d d4 0f	 cmp	 DWORD PTR $T5[ebp+20], 15 ; 0000000fH

; 445  :         if (_Large_mode_engaged()) {

  0016c	66 0f 7e c8	 movd	 eax, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

; 59   :         : _Data()

  00170	66 0f d6 46 04	 movq	 QWORD PTR [esi+4], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1286 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00175	0f 11 4d c0	 movups	 XMMWORD PTR $T5[ebp], xmm1

; 445  :         if (_Large_mode_engaged()) {

  00179	0f 47 c8	 cmova	 ecx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

; 61   :         __std_exception_data _InitData = { _Message, true };

  0017c	c6 45 b4 01	 mov	 BYTE PTR __InitData$3[ebp+4], 1
  00180	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00183	89 4d b0	 mov	 DWORD PTR __InitData$3[ebp], ecx

; 62   :         __std_exception_copy(&_InitData, &_Data);

  00186	50		 push	 eax
  00187	8d 45 b0	 lea	 eax, DWORD PTR __InitData$3[ebp]
  0018a	50		 push	 eax
  0018b	e8 00 00 00 00	 call	 ___std_exception_copy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00190	8b 4d d4	 mov	 ecx, DWORD PTR $T5[ebp+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

; 62   :         __std_exception_copy(&_InitData, &_Data);

  00193	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\stdexcept

; 104  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) {}

  00196	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  0019c	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3083 :         if (_My_data._Large_mode_engaged()) {

  0019f	76 28		 jbe	 SHORT $LN209@System_err
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001a1	8b 55 c0	 mov	 edx, DWORD PTR $T5[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  001a4	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001a5	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  001a7	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  001ad	72 10		 jb	 SHORT $LN214@System_err

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001af	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  001b2	83 c1 23	 add	 ecx, 35			; 00000023H
  001b5	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001b7	83 c0 fc	 add	 eax, -4			; fffffffcH
  001ba	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001bd	77 4f		 ja	 SHORT $LN225@System_err
$LN214@System_err:

; 289  :         ::operator delete(_Ptr, _Bytes);

  001bf	51		 push	 ecx
  001c0	52		 push	 edx
  001c1	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001c6	83 c4 08	 add	 esp, 8
$LN209@System_err:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error

; 476  :         : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode) {}

  001c9	8b 4d 08	 mov	 ecx, DWORD PTR __Errcode$[ebp]
  001cc	8b c6		 mov	 eax, esi
  001ce	8b 55 0c	 mov	 edx, DWORD PTR __Errcode$[ebp+4]
  001d1	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_System_error@std@@6B@
  001d7	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  001da	89 56 10	 mov	 DWORD PTR [esi+16], edx
  001dd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001e0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e7	59		 pop	 ecx
  001e8	5f		 pop	 edi
  001e9	5e		 pop	 esi
  001ea	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ed	33 cd		 xor	 ecx, ebp
  001ef	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f4	8b e5		 mov	 esp, ebp
  001f6	5d		 pop	 ebp
  001f7	c2 0c 00	 ret	 12			; 0000000cH
$LN223@System_err:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 882  :             _Xlen_string(); // result too long

  001fa	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN224@System_err:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001ff	6a 00		 push	 0
  00201	6a 00		 push	 0
  00203	6a 00		 push	 0
  00205	6a 00		 push	 0
  00207	6a 00		 push	 0
  00209	e8 00 00 00 00	 call	 __invoke_watson
$LN225@System_err:
  0020e	6a 00		 push	 0
  00210	6a 00		 push	 0
  00212	6a 00		 push	 0
  00214	6a 00		 push	 0
  00216	6a 00		 push	 0
  00218	e8 00 00 00 00	 call	 __invoke_watson
$LN221@System_err:
  0021d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$5:
  00000	8d 4d 98	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$6:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR $T6[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a 98	 mov	 ecx, DWORD PTR [edx-104]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_System_error::_System_error
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Ec$ = 12						; size = 4
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z PROC ; std::make_error_code, COMDAT

; 429  : _EXPORT_STD _NODISCARD inline error_code make_error_code(io_errc _Ec) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 171  :     error_code(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Ec$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx
  0000b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A ; `std::_Immortalize_memcpy_image<std::_Iostream_error_category2>'::`2'::_Static

; 430  :     return error_code(static_cast<int>(_Ec), _STD iostream_category());
; 431  : }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ENDP ; std::make_error_code
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 416  : _NODISCARD inline bool error_category::equivalent(const error_code& _Code, int _Errval) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 103  :         return _Bit_cast<uintptr_t>(_Addr) == _Bit_cast<uintptr_t>(_Right._Addr);

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 416  : _NODISCARD inline bool error_category::equivalent(const error_code& _Code, int _Errval) const noexcept {

  00006	56		 push	 esi

; 103  :         return _Bit_cast<uintptr_t>(_Addr) == _Bit_cast<uintptr_t>(_Right._Addr);

  00007	8b 75 08	 mov	 esi, DWORD PTR __Code$[ebp]
  0000a	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0000d	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]

; 417  :     return *this == _Code.category() && _Code.value() == _Errval;

  00010	75 0e		 jne	 SHORT $LN3@equivalent
  00012	8b 06		 mov	 eax, DWORD PTR [esi]
  00014	3b 45 0c	 cmp	 eax, DWORD PTR __Errval$[ebp]
  00017	75 07		 jne	 SHORT $LN3@equivalent
  00019	b0 01		 mov	 al, 1
  0001b	5e		 pop	 esi

; 418  : }

  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
$LN3@equivalent:

; 417  :     return *this == _Code.category() && _Code.value() == _Errval;

  00020	32 c0		 xor	 al, al
  00022	5e		 pop	 esi

; 418  : }

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 412  : _NODISCARD inline bool error_category::equivalent(int _Errval, const error_condition& _Cond) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 413  :     return default_error_condition(_Errval) == _Cond;

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8d 55 f8	 lea	 edx, DWORD PTR $T1[ebp]
  00008	83 ec 08	 sub	 esp, 8
  0000b	56		 push	 esi
  0000c	ff 75 08	 push	 DWORD PTR __Errval$[ebp]
  0000f	52		 push	 edx
  00010	ff 50 0c	 call	 DWORD PTR [eax+12]

; 103  :         return _Bit_cast<uintptr_t>(_Addr) == _Bit_cast<uintptr_t>(_Right._Addr);

  00013	8b 75 0c	 mov	 esi, DWORD PTR __Cond$[ebp]
  00016	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00019	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0001c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001f	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]

; 305  :         return _Left.category() == _Right.category() && _Left.value() == _Right.value();

  00022	75 0f		 jne	 SHORT $LN6@equivalent
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	3b 06		 cmp	 eax, DWORD PTR [esi]
  00028	75 09		 jne	 SHORT $LN6@equivalent
  0002a	b0 01		 mov	 al, 1
  0002c	5e		 pop	 esi

; 414  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
$LN6@equivalent:

; 305  :         return _Left.category() == _Right.category() && _Left.value() == _Right.value();

  00033	32 c0		 xor	 al, al
  00035	5e		 pop	 esi

; 414  : }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 407  : _NODISCARD inline error_condition error_category::default_error_condition(int _Errval) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  :     error_condition(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Errval$[ebp]
  00009	89 10		 mov	 DWORD PTR [eax], edx
  0000b	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 408  :     // make error_condition for error code
; 409  :     return error_condition(_Errval, *this);
; 410  : }

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 87   :     _CONSTEXPR20 virtual ~error_category() noexcept = default;

  00000	c2 00 00	 ret	 0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN13@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3080 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 453  :         return _Myres > _Small_string_capacity;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 07	 cmp	 ecx, 7

; 3081 :         auto& _My_data = _Mypair._Myval2;
; 3082 :         _My_data._Orphan_all();
; 3083 :         if (_My_data._Large_mode_engaged()) {

  00009	76 2d		 jbe	 SHORT $LN16@Tidy_deall
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00014	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001a	72 12		 jb	 SHORT $LN21@Tidy_deall

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001c	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001f	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00022	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	77 21		 ja	 SHORT $LN20@Tidy_deall

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002c	8b c2		 mov	 eax, edx
$LN21@Tidy_deall:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0002e	51		 push	 ecx
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00035	83 c4 08	 add	 esp, 8
$LN16@Tidy_deall:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00038	33 c0		 xor	 eax, eax
  0003a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00041	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00048	66 89 06	 mov	 WORD PTR [esi], ax
  0004b	5e		 pop	 esi

; 3094 :     }

  0004c	c3		 ret	 0
$LN20@Tidy_deall:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004d	6a 00		 push	 0
  0004f	6a 00		 push	 0
  00051	6a 00		 push	 0
  00053	6a 00		 push	 0
  00055	6a 00		 push	 0
  00057	e8 00 00 00 00	 call	 __invoke_watson
$LN29@Tidy_deall:
  0005c	cc		 int	 3
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIQB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIQB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find, COMDAT
; _this$ = ecx

; 2619 :     /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8d 4a 02	 lea	 ecx, DWORD PTR [edx+2]
  0000d	0f 1f 00	 npad	 3
$LL61@find:
  00010	66 8b 02	 mov	 ax, WORD PTR [edx]
  00013	83 c2 02	 add	 edx, 2
  00016	66 85 c0	 test	 ax, ax
  00019	75 f5		 jne	 SHORT $LL61@find

; 2620 :         // look for [_Ptr, <null>) beginning at or after _Off
; 2621 :         return static_cast<size_type>(_Traits_find<_Traits>(

  0001b	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  0001e	2b d1		 sub	 edx, ecx
  00020	d1 fa		 sar	 edx, 1

; 453  :         return _Myres > _Small_string_capacity;

  00022	83 7f 14 07	 cmp	 DWORD PTR [edi+20], 7

; 445  :         if (_Large_mode_engaged()) {

  00026	76 02		 jbe	 SHORT $LN9@find

; 446  :             _Result = _Unfancy(_Bx._Ptr);

  00028	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN9@find:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 641  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

  0002a	3b d6		 cmp	 edx, esi
  0002c	77 31		 ja	 SHORT $LN20@find
  0002e	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00031	8b ce		 mov	 ecx, esi
  00033	2b ca		 sub	 ecx, edx
  00035	3b c1		 cmp	 eax, ecx
  00037	77 26		 ja	 SHORT $LN20@find

; 642  :         // xpos cannot exist, report failure
; 643  :         // N4950 [string.view.find]/3 says:
; 644  :         // 1. _Start_at <= xpos
; 645  :         // 2. xpos + _Needle_size <= _Hay_size;
; 646  :         // therefore:
; 647  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 648  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 649  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 650  :         return static_cast<size_t>(-1);
; 651  :     }
; 652  : 
; 653  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible

  00039	0f ae e8	 lfence
  0003c	85 d2		 test	 edx, edx
  0003e	74 22		 je	 SHORT $LN17@find
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 252  :         return const_cast<_Ty1*>(static_cast<const _Ty1*>(::__std_search_2(_First1, _Last1, _First2, _Count2)));

  00040	52		 push	 edx
  00041	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 660  :             const auto _End = _Haystack + _Hay_size;

  00044	8d 34 77	 lea	 esi, DWORD PTR [edi+esi*2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 252  :         return const_cast<_Ty1*>(static_cast<const _Ty1*>(::__std_search_2(_First1, _Last1, _First2, _Count2)));

  00047	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 659  :         if (!_STD _Is_constant_evaluated()) {

  00048	8d 04 47	 lea	 eax, DWORD PTR [edi+eax*2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 252  :         return const_cast<_Ty1*>(static_cast<const _Ty1*>(::__std_search_2(_First1, _Last1, _First2, _Count2)));

  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ___std_search_2@16
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 663  :             if (_Ptr != _End) {

  00051	3b c6		 cmp	 eax, esi
  00053	74 0a		 je	 SHORT $LN20@find

; 664  :                 return static_cast<size_t>(_Ptr - _Haystack);

  00055	2b c7		 sub	 eax, edi
  00057	5f		 pop	 edi
  00058	d1 f8		 sar	 eax, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2623 :     }

  0005a	5e		 pop	 esi
  0005b	5d		 pop	 ebp
  0005c	c2 08 00	 ret	 8
$LN20@find:
  0005f	83 c8 ff	 or	 eax, -1
$LN17@find:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5d		 pop	 ebp
  00065	c2 08 00	 ret	 8
?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIQB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IQB_WI@Z
_TEXT	SEGMENT
tv629 = -20						; size = 4
$T1 = -16						; size = 4
__New_ptr$1$ = -12					; size = 4
tv637 = -12						; size = 4
tv631 = -8						; size = 4
__Result$1$ = -4					; size = 4
$T2 = -4						; size = 4
tv633 = -4						; size = 4
tv636 = -4						; size = 4
__Off$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
tv628 = 16						; size = 4
?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IQB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert, COMDAT
; _this$ = ecx

; 1730 :         const size_type _Off, _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx

; 469  :         if (_Mysize < _Off) {

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  0000e	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  00011	3b f1		 cmp	 esi, ecx
  00013	0f 82 e4 01 00
	00		 jb	 $LN95@insert

; 1731 :         // insert [_Ptr, _Ptr + _Count) at _Off
; 1732 :         _Mypair._Myval2._Check_offset(_Off);
; 1733 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 1734 : 
; 1735 :         // We can't check for overlapping ranges when constant evaluated since comparison of pointers into string
; 1736 :         // literals is unspecified, so always reallocate and copy to the new buffer if constant evaluated.
; 1737 : #if _HAS_CXX20
; 1738 :         const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size && !_STD is_constant_evaluated();
; 1739 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 1740 :         const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size;

  00019	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  0001c	8b c2		 mov	 eax, edx
  0001e	8b 5d 10	 mov	 ebx, DWORD PTR __Count$[ebp]
  00021	2b c6		 sub	 eax, esi
  00023	89 55 f0	 mov	 DWORD PTR $T1[ebp], edx
  00026	3b d8		 cmp	 ebx, eax

; 1741 : #endif // ^^^ !_HAS_CXX20 ^^^
; 1742 : 
; 1743 :         if (_Check_overlap) {

  00028	0f 87 a3 00 00
	00		 ja	 $LN2@insert

; 1744 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1745 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  0002e	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]

; 435  :         value_type* _Result = _Bx._Buf;

  00031	89 7d fc	 mov	 DWORD PTR __Result$1$[ebp], edi

; 1744 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1745 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00034	0f ae e8	 lfence
  00037	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 435  :         value_type* _Result = _Bx._Buf;

  0003a	8b c7		 mov	 eax, edi

; 453  :         return _Myres > _Small_string_capacity;

  0003c	83 7f 14 07	 cmp	 DWORD PTR [edi+20], 7

; 436  :         if (_Large_mode_engaged()) {

  00040	76 05		 jbe	 SHORT $LN14@insert

; 437  :             _Result = _Unfancy(_Bx._Ptr);

  00042	8b 07		 mov	 eax, DWORD PTR [edi]
  00044	89 45 fc	 mov	 DWORD PTR __Result$1$[ebp], eax
$LN14@insert:

; 1746 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 1747 :             _Elem* const _Insert_at = _Old_ptr + _Off;

  00047	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]

; 1748 :             // the range [_Ptr, _Ptr + _Ptr_shifted_after) is left alone by moving the suffix out,
; 1749 :             // while the range [_Ptr + _Ptr_shifted_after, _Ptr + _Count) shifts down by _Count
; 1750 :             size_type _Ptr_shifted_after;
; 1751 :             if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {

  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0004d	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  00050	89 45 f4	 mov	 DWORD PTR tv637[ebp], eax
  00053	03 c1		 add	 eax, ecx
  00055	3b c2		 cmp	 eax, edx
  00057	76 18		 jbe	 SHORT $LN5@insert
  00059	8b 45 fc	 mov	 eax, DWORD PTR __Result$1$[ebp]
  0005c	8d 04 70	 lea	 eax, DWORD PTR [eax+esi*2]
  0005f	3b c8		 cmp	 ecx, eax
  00061	77 0e		 ja	 SHORT $LN5@insert

; 1752 :                 // inserted content is before the shifted region, or does not alias
; 1753 :                 _Ptr_shifted_after = _Count; // none of _Ptr's data shifts
; 1754 :             } else if (_Insert_at <= _Ptr) { // all of [_Ptr, _Ptr + _Count) shifts

  00063	3b d1		 cmp	 edx, ecx
  00065	77 04		 ja	 SHORT $LN6@insert

; 1755 :                 _Ptr_shifted_after = 0;

  00067	33 db		 xor	 ebx, ebx

; 1756 :             } else { // [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts

  00069	eb 06		 jmp	 SHORT $LN5@insert
$LN6@insert:

; 1757 :                 _Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);

  0006b	8b da		 mov	 ebx, edx
  0006d	2b d9		 sub	 ebx, ecx
  0006f	d1 fb		 sar	 ebx, 1
$LN5@insert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00071	2b 75 08	 sub	 esi, DWORD PTR __Off$[ebp]
  00074	8d 04 75 02 00
	00 00		 lea	 eax, DWORD PTR [esi*2+2]
  0007b	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1760 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

  0007c	8b 45 f4	 mov	 eax, DWORD PTR tv637[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0007f	52		 push	 edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1760 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

  00080	03 c2		 add	 eax, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 _memmove

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00088	8b 4d fc	 mov	 ecx, DWORD PTR __Result$1$[ebp]
  0008b	8d 34 1b	 lea	 esi, DWORD PTR [ebx+ebx]
  0008e	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00091	56		 push	 esi
  00092	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00095	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 _memcpy
  0009e	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  000a1	8b c1		 mov	 eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1762 :             _Traits::copy(

  000a3	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000a6	2b c3		 sub	 eax, ebx
  000a8	03 c0		 add	 eax, eax
  000aa	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1762 :             _Traits::copy(

  000ab	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]
  000ae	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000b1	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  000b4	8b 4d fc	 mov	 ecx, DWORD PTR __Result$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b7	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1762 :             _Traits::copy(

  000b8	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000bb	03 c6		 add	 eax, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 _memcpy
  000c3	83 c4 24	 add	 esp, 36			; 00000024H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1776 :     }

  000c6	8b c7		 mov	 eax, edi
  000c8	5f		 pop	 edi
  000c9	5e		 pop	 esi
  000ca	5b		 pop	 ebx
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c2 0c 00	 ret	 12			; 0000000cH
$LN2@insert:

; 3029 :         if (max_size() - _Old_size < _Size_increase) {

  000d1	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH
  000d6	2b c6		 sub	 eax, esi
  000d8	3b c3		 cmp	 eax, ebx
  000da	0f 82 22 01 00
	00		 jb	 $LN96@insert

; 3031 :         }
; 3032 : 
; 3033 :         const size_type _New_size     = _Old_size + _Size_increase;

  000e0	8d 0c 1e	 lea	 ecx, DWORD PTR [esi+ebx]

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

  000e3	83 c9 07	 or	 ecx, 7
  000e6	81 f9 fe ff ff
	7f		 cmp	 ecx, 2147483646		; 7ffffffeH

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  000ec	77 30		 ja	 SHORT $LN93@insert

; 2980 :             return _Max;
; 2981 :         }
; 2982 : 
; 2983 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  000ee	8b c2		 mov	 eax, edx
  000f0	d1 e8		 shr	 eax, 1
  000f2	89 45 fc	 mov	 DWORD PTR tv633[ebp], eax
  000f5	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH
  000fa	2b 45 fc	 sub	 eax, DWORD PTR tv633[ebp]
  000fd	3b d0		 cmp	 edx, eax
  000ff	77 1d		 ja	 SHORT $LN93@insert

; 2984 :             return _Max;
; 2985 :         }
; 2986 : 
; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00101	8b 45 fc	 mov	 eax, DWORD PTR tv633[ebp]
  00104	03 c2		 add	 eax, edx
  00106	3b c8		 cmp	 ecx, eax
  00108	0f 42 c8	 cmovb	 ecx, eax
  0010b	89 4d fc	 mov	 DWORD PTR $T2[ebp], ecx

; 825  :         ++_Capacity; // Take null terminator into consideration

  0010e	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  00111	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00116	0f 87 eb 00 00
	00		 ja	 $LN97@insert
  0011c	eb 0c		 jmp	 SHORT $LN52@insert
$LN93@insert:

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  0011e	c7 45 fc fe ff
	ff 7f		 mov	 DWORD PTR $T2[ebp], 2147483646 ; 7ffffffeH
  00125	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN52@insert:
  0012a	03 c0		 add	 eax, eax

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0012c	50		 push	 eax

; 122  :     return _Count * _Ty_size;

  0012d	0f ae e8	 lfence

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00130	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3042 :         _My_data._Myres       = _New_capacity;

  00135	8b 4d fc	 mov	 ecx, DWORD PTR $T2[ebp]

; 3043 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  00138	8d 14 1b	 lea	 edx, DWORD PTR [ebx+ebx]
  0013b	89 45 f4	 mov	 DWORD PTR __New_ptr$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0013e	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3041 :         _My_data._Mysize      = _New_size;

  00141	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]

; 3043 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  00144	89 55 fc	 mov	 DWORD PTR tv636[ebp], edx
  00147	8b 55 f4	 mov	 edx, DWORD PTR __New_ptr$1$[ebp]
  0014a	89 47 10	 mov	 DWORD PTR [edi+16], eax
  0014d	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00150	2b f0		 sub	 esi, eax
  00152	89 4f 14	 mov	 DWORD PTR [edi+20], ecx

; 3044 :         if (_Old_capacity > _Small_string_capacity) {

  00155	0f ae e8	 lfence
  00158	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  0015b	03 45 10	 add	 eax, DWORD PTR __Count$[ebp]
  0015e	8d 1c 11	 lea	 ebx, DWORD PTR [ecx+edx]
  00161	89 5d f8	 mov	 DWORD PTR tv631[ebp], ebx
  00164	8d 34 75 02 00
	00 00		 lea	 esi, DWORD PTR [esi*2+2]
  0016b	8b 5d f0	 mov	 ebx, DWORD PTR $T1[ebp]
  0016e	89 75 ec	 mov	 DWORD PTR tv629[ebp], esi
  00171	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00174	89 45 10	 mov	 DWORD PTR tv628[ebp], eax
  00177	51		 push	 ecx
  00178	83 fb 07	 cmp	 ebx, 7
  0017b	76 46		 jbe	 SHORT $LN31@insert

; 3045 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0017d	8b 37		 mov	 esi, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0017f	56		 push	 esi
  00180	52		 push	 edx
  00181	e8 00 00 00 00	 call	 _memcpy
  00186	ff 75 fc	 push	 DWORD PTR tv636[ebp]
  00189	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  0018c	ff 75 f8	 push	 DWORD PTR tv631[ebp]
  0018f	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1773 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  00194	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00197	ff 75 ec	 push	 DWORD PTR tv629[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1773 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  0019a	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  0019d	03 c6		 add	 eax, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0019f	50		 push	 eax
  001a0	ff 75 10	 push	 DWORD PTR tv628[ebp]
  001a3	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3047 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

  001a8	53		 push	 ebx
  001a9	56		 push	 esi
  001aa	57		 push	 edi
  001ab	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAAV?$allocator@_W@2@QA_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Deallocate_for_capacity

; 1767 :         return _Reallocate_grow_by(

  001b0	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]

; 3047 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

  001b3	83 c4 30	 add	 esp, 48			; 00000030H

; 1767 :         return _Reallocate_grow_by(

  001b6	89 07		 mov	 DWORD PTR [edi], eax

; 1776 :     }

  001b8	8b c7		 mov	 eax, edi
  001ba	5f		 pop	 edi
  001bb	5e		 pop	 esi
  001bc	5b		 pop	 ebx
  001bd	8b e5		 mov	 esp, ebp
  001bf	5d		 pop	 ebp
  001c0	c2 0c 00	 ret	 12			; 0000000cH
$LN31@insert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  001c3	57		 push	 edi
  001c4	52		 push	 edx
  001c5	e8 00 00 00 00	 call	 _memcpy
  001ca	ff 75 fc	 push	 DWORD PTR tv636[ebp]
  001cd	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  001d0	ff 75 f8	 push	 DWORD PTR tv631[ebp]
  001d3	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1773 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  001d8	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  001db	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1773 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  001dc	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  001df	03 c7		 add	 eax, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  001e1	50		 push	 eax
  001e2	ff 75 10	 push	 DWORD PTR tv628[ebp]
  001e5	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1767 :         return _Reallocate_grow_by(

  001ea	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  001ed	83 c4 24	 add	 esp, 36			; 00000024H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1767 :         return _Reallocate_grow_by(

  001f0	89 07		 mov	 DWORD PTR [edi], eax

; 1776 :     }

  001f2	8b c7		 mov	 eax, edi
  001f4	5f		 pop	 edi
  001f5	5e		 pop	 esi
  001f6	5b		 pop	 ebx
  001f7	8b e5		 mov	 esp, ebp
  001f9	5d		 pop	 ebp
  001fa	c2 0c 00	 ret	 12			; 0000000cH
$LN95@insert:

; 470  :             _Xran();

  001fd	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
$LN96@insert:

; 3030 :             _Xlen_string(); // result too long

  00202	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN97@insert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00207	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN91@insert:
  0020c	cc		 int	 3
?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IQB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z
_TEXT	SEGMENT
__New_ptr$1$ = -12					; size = 4
__Old_size$1$ = -8					; size = 4
tv470 = -8						; size = 4
__New_size$1$ = -4					; size = 4
tv469 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
tv477 = 12						; size = 4
tv484 = 12						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 1510 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx

; 1511 :         // append [_Ptr, _Ptr + _Count)
; 1512 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 1513 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000e	8b 5f 14	 mov	 ebx, DWORD PTR [edi+20]
  00011	8b c3		 mov	 eax, ebx
  00013	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  00016	2b c2		 sub	 eax, edx
  00018	89 55 f8	 mov	 DWORD PTR __Old_size$1$[ebp], edx
  0001b	3b c8		 cmp	 ecx, eax
  0001d	77 39		 ja	 SHORT $LN2@append

; 1514 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1515 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  0001f	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 435  :         value_type* _Result = _Bx._Buf;

  00022	8b f7		 mov	 esi, edi

; 1514 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1515 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00024	89 45 0c	 mov	 DWORD PTR tv484[ebp], eax
  00027	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 453  :         return _Myres > _Small_string_capacity;

  0002a	83 fb 07	 cmp	 ebx, 7

; 436  :         if (_Large_mode_engaged()) {

  0002d	76 02		 jbe	 SHORT $LN5@append

; 437  :             _Result = _Unfancy(_Bx._Ptr);

  0002f	8b 37		 mov	 esi, DWORD PTR [edi]
$LN5@append:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00031	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  00034	50		 push	 eax
  00035	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1517 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00038	8d 04 56	 lea	 eax, DWORD PTR [esi+edx*2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 _memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1518 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00041	8b 45 0c	 mov	 eax, DWORD PTR tv484[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00044	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1518 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00047	33 c9		 xor	 ecx, ecx
  00049	66 89 0c 46	 mov	 WORD PTR [esi+eax*2], cx

; 1531 :     }

  0004d	8b c7		 mov	 eax, edi
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 08 00	 ret	 8
$LN2@append:

; 3029 :         if (max_size() - _Old_size < _Size_increase) {

  00058	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH
  0005d	2b c2		 sub	 eax, edx
  0005f	3b c1		 cmp	 eax, ecx
  00061	0f 82 f0 00 00
	00		 jb	 $LN71@append

; 3031 :         }
; 3032 : 
; 3033 :         const size_type _New_size     = _Old_size + _Size_increase;

  00067	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

  0006a	8b f0		 mov	 esi, eax

; 3033 :         const size_type _New_size     = _Old_size + _Size_increase;

  0006c	89 45 fc	 mov	 DWORD PTR __New_size$1$[ebp], eax

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

  0006f	83 ce 07	 or	 esi, 7
  00072	81 fe fe ff ff
	7f		 cmp	 esi, 2147483646		; 7ffffffeH

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00078	77 27		 ja	 SHORT $LN69@append

; 2980 :             return _Max;
; 2981 :         }
; 2982 : 
; 2983 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0007a	8b cb		 mov	 ecx, ebx
  0007c	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH
  00081	d1 e9		 shr	 ecx, 1
  00083	2b c1		 sub	 eax, ecx
  00085	3b d8		 cmp	 ebx, eax
  00087	77 18		 ja	 SHORT $LN69@append

; 2984 :             return _Max;
; 2985 :         }
; 2986 : 
; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00089	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  0008c	3b f0		 cmp	 esi, eax
  0008e	0f 42 f0	 cmovb	 esi, eax

; 825  :         ++_Capacity; // Take null terminator into consideration

  00091	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  00094	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00099	0f 87 bd 00 00
	00		 ja	 $LN72@append
  0009f	eb 0a		 jmp	 SHORT $LN37@append
$LN69@append:

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  000a1	be fe ff ff 7f	 mov	 esi, 2147483646		; 7ffffffeH
  000a6	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN37@append:
  000ab	03 c0		 add	 eax, eax

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000ad	50		 push	 eax

; 122  :     return _Count * _Ty_size;

  000ae	0f ae e8	 lfence

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000b1	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3041 :         _My_data._Mysize      = _New_size;

  000b6	8b 4d fc	 mov	 ecx, DWORD PTR __New_size$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000b9	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3041 :         _My_data._Mysize      = _New_size;

  000bc	89 4f 10	 mov	 DWORD PTR [edi+16], ecx

; 3042 :         _My_data._Myres       = _New_capacity;
; 3043 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  000bf	8b 4d f8	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  000c2	89 77 14	 mov	 DWORD PTR [edi+20], esi
  000c5	89 45 f4	 mov	 DWORD PTR __New_ptr$1$[ebp], eax
  000c8	8d 14 09	 lea	 edx, DWORD PTR [ecx+ecx]
  000cb	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]

; 3044 :         if (_Old_capacity > _Small_string_capacity) {

  000ce	52		 push	 edx
  000cf	8d 34 09	 lea	 esi, DWORD PTR [ecx+ecx]
  000d2	89 75 0c	 mov	 DWORD PTR tv477[ebp], esi
  000d5	8d 0c 02	 lea	 ecx, DWORD PTR [edx+eax]
  000d8	8b 75 fc	 mov	 esi, DWORD PTR __New_size$1$[ebp]
  000db	89 4d f8	 mov	 DWORD PTR tv470[ebp], ecx
  000de	8d 0c 70	 lea	 ecx, DWORD PTR [eax+esi*2]
  000e1	8b 75 0c	 mov	 esi, DWORD PTR tv477[ebp]
  000e4	89 4d fc	 mov	 DWORD PTR tv469[ebp], ecx
  000e7	83 fb 07	 cmp	 ebx, 7
  000ea	76 3d		 jbe	 SHORT $LN16@append

; 3045 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  000ec	0f ae e8	 lfence
  000ef	8b 37		 mov	 esi, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000f1	56		 push	 esi
  000f2	50		 push	 eax
  000f3	e8 00 00 00 00	 call	 _memcpy
  000f8	ff 75 0c	 push	 DWORD PTR tv477[ebp]
  000fb	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  000fe	ff 75 f8	 push	 DWORD PTR tv470[ebp]
  00101	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1528 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00106	8b 45 fc	 mov	 eax, DWORD PTR tv469[ebp]
  00109	33 c9		 xor	 ecx, ecx

; 3047 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

  0010b	53		 push	 ebx
  0010c	56		 push	 esi
  0010d	57		 push	 edi

; 1528 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0010e	66 89 08	 mov	 WORD PTR [eax], cx

; 3047 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

  00111	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAAV?$allocator@_W@2@QA_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Deallocate_for_capacity

; 1519 :             return *this;
; 1520 :         }
; 1521 : 
; 1522 :         return _Reallocate_grow_by(

  00116	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]

; 3047 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

  00119	83 c4 24	 add	 esp, 36			; 00000024H

; 1519 :             return *this;
; 1520 :         }
; 1521 : 
; 1522 :         return _Reallocate_grow_by(

  0011c	89 07		 mov	 DWORD PTR [edi], eax

; 1531 :     }

  0011e	8b c7		 mov	 eax, edi
  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	5b		 pop	 ebx
  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c2 08 00	 ret	 8
$LN16@append:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00129	57		 push	 edi
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 _memcpy
  00130	56		 push	 esi
  00131	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00134	ff 75 f8	 push	 DWORD PTR tv470[ebp]
  00137	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1528 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0013c	8b 45 fc	 mov	 eax, DWORD PTR tv469[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0013f	83 c4 18	 add	 esp, 24			; 00000018H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1528 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00142	33 c9		 xor	 ecx, ecx
  00144	66 89 08	 mov	 WORD PTR [eax], cx

; 1519 :             return *this;
; 1520 :         }
; 1521 : 
; 1522 :         return _Reallocate_grow_by(

  00147	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
  0014a	89 07		 mov	 DWORD PTR [edi], eax

; 1531 :     }

  0014c	8b c7		 mov	 eax, edi
  0014e	5f		 pop	 edi
  0014f	5e		 pop	 esi
  00150	5b		 pop	 ebx
  00151	8b e5		 mov	 esp, ebp
  00153	5d		 pop	 ebp
  00154	c2 08 00	 ret	 8
$LN71@append:

; 3030 :             _Xlen_string(); // result too long

  00157	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN72@append:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  0015c	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@append:
  00161	cc		 int	 3
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 1383 :         _Tidy_deallocate();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAAV?$allocator@_W@2@QA_WI@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Capacity$ = 16					; size = 4
?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAAV?$allocator@_W@2@QA_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Deallocate_for_capacity, COMDAT

; 850  :         _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00003	8b 45 10	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00006	8d 0c 45 02 00
	00 00		 lea	 ecx, DWORD PTR [eax*2+2]
  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Old_ptr$[ebp]

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00010	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00016	72 12		 jb	 SHORT $LN14@Deallocate

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00018	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001b	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001e	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00020	83 c0 fc	 add	 eax, -4			; fffffffcH
  00023	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00026	77 0e		 ja	 SHORT $LN13@Deallocate

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00028	8b c2		 mov	 eax, edx
$LN14@Deallocate:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0002a	51		 push	 ecx
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00031	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 853  :     }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN13@Deallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00036	6a 00		 push	 0
  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	6a 00		 push	 0
  0003e	6a 00		 push	 0
  00040	e8 00 00 00 00	 call	 __invoke_watson
$LN18@Deallocate:
  00045	cc		 int	 3
?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAAV?$allocator@_W@2@QA_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Deallocate_for_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 2
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 785  :         : _Mypair(_Zero_then_variadic_args_t{}) { // construct from _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b d9		 mov	 ebx, ecx
  00007	0f 57 c0	 xorps	 xmm0, xmm0
  0000a	57		 push	 edi

; 881  :         if (_Count > max_size()) {

  0000b	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0000e	0f 11 03	 movups	 XMMWORD PTR [ebx], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

  00011	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00018	c7 43 14 00 00
	00 00		 mov	 DWORD PTR [ebx+20], 0

; 881  :         if (_Count > max_size()) {

  0001f	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00025	0f 87 bc 00 00
	00		 ja	 $LN73@basic_stri

; 883  :         }
; 884  : 
; 885  :         auto& _Al       = _Getal();
; 886  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 887  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 888  : 
; 889  :         if (_Count <= _Small_string_capacity) {

  0002b	83 ff 07	 cmp	 edi, 7
  0002e	77 3b		 ja	 SHORT $LN18@basic_stri

; 890  :             _My_data._Mysize = _Count;

  00030	89 7b 10	 mov	 DWORD PTR [ebx+16], edi

; 891  :             _My_data._Myres  = _Small_string_capacity;

  00033	c7 43 14 07 00
	00 00		 mov	 DWORD PTR [ebx+20], 7
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h

; 517  :         for (; 0 < _N; ++_Su, --_N)

  0003a	85 ff		 test	 edi, edi
  0003c	74 1d		 je	 SHORT $LN26@basic_stri
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 890  :             _My_data._Mysize = _Count;

  0003e	8b 45 0c	 mov	 eax, DWORD PTR __Ch$[ebp]
  00041	8b cf		 mov	 ecx, edi
  00043	0f b7 d0	 movzx	 edx, ax
  00046	8b fb		 mov	 edi, ebx
  00048	8b c2		 mov	 eax, edx
  0004a	c1 e2 10	 shl	 edx, 16			; 00000010H
  0004d	0b c2		 or	 eax, edx
  0004f	d1 e9		 shr	 ecx, 1
  00051	f3 ab		 rep stosd
  00053	13 c9		 adc	 ecx, ecx
  00055	66 f3 ab	 rep stosw
  00058	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
$LN26@basic_stri:

; 892  : 
; 893  :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 894  :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 895  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  0005b	33 c0		 xor	 eax, eax
  0005d	66 89 04 7b	 mov	 WORD PTR [ebx+edi*2], ax

; 786  :         _Construct<_Construct_strategy::_From_char>(_Ch, _Count);
; 787  :     }

  00061	8b c3		 mov	 eax, ebx
  00063	5f		 pop	 edi
  00064	5b		 pop	 ebx
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 08 00	 ret	 8
$LN18@basic_stri:

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

  0006b	8b c7		 mov	 eax, edi
  0006d	83 c8 07	 or	 eax, 7
  00070	3d fe ff ff 7f	 cmp	 eax, 2147483646		; 7ffffffeH

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00075	76 56		 jbe	 SHORT $LN29@basic_stri

; 2980 :             return _Max;

  00077	c7 45 fc fe ff
	ff 7f		 mov	 DWORD PTR $T1[ebp], 2147483646 ; 7ffffffeH
  0007e	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN43@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 122  :     return _Count * _Ty_size;

  00083	03 c0		 add	 eax, eax
  00085	56		 push	 esi

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00086	50		 push	 eax

; 122  :     return _Count * _Ty_size;

  00087	0f ae e8	 lfence

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0008a	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 912  :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

  0008f	8b f0		 mov	 esi, eax

; 914  : 
; 915  :         _My_data._Mysize = _Count;

  00091	89 7b 10	 mov	 DWORD PTR [ebx+16], edi

; 916  :         _My_data._Myres  = _New_capacity;

  00094	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 122  :     return _Count * _Ty_size;

  00097	8b cf		 mov	 ecx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 916  :         _My_data._Myres  = _New_capacity;

  00099	89 43 14	 mov	 DWORD PTR [ebx+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0009c	83 c4 04	 add	 esp, 4

; 122  :     return _Count * _Ty_size;

  0009f	8b 45 0c	 mov	 eax, DWORD PTR __Ch$[ebp]
  000a2	8b fe		 mov	 edi, esi
  000a4	0f b7 d0	 movzx	 edx, ax
  000a7	8b c2		 mov	 eax, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 913  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000a9	89 33		 mov	 DWORD PTR [ebx], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 122  :     return _Count * _Ty_size;

  000ab	c1 e2 10	 shl	 edx, 16			; 00000010H
  000ae	0b c2		 or	 eax, edx
  000b0	d1 e9		 shr	 ecx, 1
  000b2	f3 ab		 rep stosd
  000b4	13 c9		 adc	 ecx, ecx
  000b6	66 f3 ab	 rep stosw
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 919  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  000b9	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  000bc	33 c9		 xor	 ecx, ecx
  000be	66 89 0c 46	 mov	 WORD PTR [esi+eax*2], cx

; 786  :         _Construct<_Construct_strategy::_From_char>(_Ch, _Count);
; 787  :     }

  000c2	8b c3		 mov	 eax, ebx

; 919  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  000c4	5e		 pop	 esi

; 786  :         _Construct<_Construct_strategy::_From_char>(_Ch, _Count);
; 787  :     }

  000c5	5f		 pop	 edi
  000c6	5b		 pop	 ebx
  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c2 08 00	 ret	 8
$LN29@basic_stri:

; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

  000cd	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  000d2	3b c1		 cmp	 eax, ecx
  000d4	0f 42 c1	 cmovb	 eax, ecx
  000d7	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax

; 825  :         ++_Capacity; // Take null terminator into consideration

  000da	40		 inc	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  000db	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  000e0	76 a1		 jbe	 SHORT $LN43@basic_stri

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  000e2	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN73@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 882  :             _Xlen_string(); // result too long

  000e7	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN71@basic_stri:
  000ec	cc		 int	 3
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 768  :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 768  :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0000c	8b c2		 mov	 eax, edx

; 768  :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  0000e	57		 push	 edi

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0000f	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

  00012	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00019	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
  0001c	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LL20@basic_stri:
  00023	66 8b 08	 mov	 cx, WORD PTR [eax]
  00026	83 c0 02	 add	 eax, 2
  00029	66 85 c9	 test	 cx, cx
  0002c	75 f5		 jne	 SHORT $LL20@basic_stri
  0002e	2b c7		 sub	 eax, edi

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00030	8b ce		 mov	 ecx, esi

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00032	d1 f8		 sar	 eax, 1

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00034	50		 push	 eax
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 ??$_Construct@$00PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>

; 770  :     }

  0003b	5f		 pop	 edi
  0003c	8b c6		 mov	 eax, esi
  0003e	5e		 pop	 esi
  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 717  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 718  :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0000e	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

  00011	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00018	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 453  :         return _Myres > _Small_string_capacity;

  0001f	83 78 14 07	 cmp	 DWORD PTR [eax+20], 7

; 718  :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00023	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]

; 445  :         if (_Large_mode_engaged()) {

  00026	76 05		 jbe	 SHORT $LN17@basic_stri

; 446  :             _Result = _Unfancy(_Bx._Ptr);

  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	89 45 08	 mov	 DWORD PTR __Right$[ebp], eax
$LN17@basic_stri:

; 881  :         if (_Count > max_size()) {

  0002d	81 fb fe ff ff
	7f		 cmp	 ebx, 2147483646		; 7ffffffeH
  00033	77 7e		 ja	 SHORT $LN62@basic_stri

; 883  :         }
; 884  : 
; 885  :         auto& _Al       = _Getal();
; 886  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 887  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 888  : 
; 889  :         if (_Count <= _Small_string_capacity) {

  00035	83 fb 07	 cmp	 ebx, 7
  00038	77 19		 ja	 SHORT $LN25@basic_stri

; 890  :             _My_data._Mysize = _Count;

  0003a	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 891  :             _My_data._Myres  = _Small_string_capacity;

  0003d	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00044	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 719  :     }

  00047	8b c6		 mov	 eax, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00049	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 719  :     }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
$LN25@basic_stri:

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

  00053	8b fb		 mov	 edi, ebx
  00055	83 cf 07	 or	 edi, 7
  00058	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0005e	76 3a		 jbe	 SHORT $LN31@basic_stri

; 2980 :             return _Max;

  00060	bf fe ff ff 7f	 mov	 edi, 2147483646		; 7ffffffeH
  00065	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN45@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 122  :     return _Count * _Ty_size;

  0006a	03 c0		 add	 eax, eax

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0006c	50		 push	 eax

; 122  :     return _Count * _Ty_size;

  0006d	0f ae e8	 lfence

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00070	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00075	8d 0c 5d 02 00
	00 00		 lea	 ecx, DWORD PTR [ebx*2+2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 913  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  0007c	89 06		 mov	 DWORD PTR [esi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0007e	51		 push	 ecx
  0007f	ff 75 08	 push	 DWORD PTR __Right$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 915  :         _My_data._Mysize = _Count;

  00082	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00085	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 916  :         _My_data._Myres  = _New_capacity;

  00086	89 7e 14	 mov	 DWORD PTR [esi+20], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00089	e8 00 00 00 00	 call	 _memcpy
  0008e	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 719  :     }

  00091	8b c6		 mov	 eax, esi
  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
$LN31@basic_stri:

; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0009a	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  0009f	3b f8		 cmp	 edi, eax
  000a1	0f 42 f8	 cmovb	 edi, eax

; 825  :         ++_Capacity; // Take null terminator into consideration

  000a4	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  000a7	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  000ac	76 bc		 jbe	 SHORT $LN45@basic_stri

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  000ae	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN62@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 882  :             _Xlen_string(); // result too long

  000b3	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN60@basic_stri:
  000b8	cc		 int	 3
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran, COMDAT

; 482  :         _Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3080 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 453  :         return _Myres > _Small_string_capacity;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3081 :         auto& _My_data = _Mypair._Myval2;
; 3082 :         _My_data._Orphan_all();
; 3083 :         if (_My_data._Large_mode_engaged()) {

  00009	76 27		 jbe	 SHORT $LN16@Tidy_deall
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0000d	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN21@Tidy_deall

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN20@Tidy_deall

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN21@Tidy_deall:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN16@Tidy_deall:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3090 :         _My_data._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3091 :         _My_data._Myres  = _Small_string_capacity;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 3092 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi

; 3094 :     }

  00044	c3		 ret	 0
$LN20@Tidy_deall:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	6a 00		 push	 0
  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	e8 00 00 00 00	 call	 __invoke_watson
$LN29@Tidy_deall:
  00054	cc		 int	 3
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z
_TEXT	SEGMENT
tv509 = -12						; size = 4
__New_ptr$1$ = -8					; size = 4
$T1 = -4						; size = 4
__Ch$ = 8						; size = 1
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back, COMDAT
; _this$ = ecx

; 2291 :     _CONSTEXPR20 void push_back(const _Elem _Ch) { // insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

  0000a	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0000d	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]
  00010	89 4d fc	 mov	 DWORD PTR $T1[ebp], ecx
  00013	3b d9		 cmp	 ebx, ecx
  00015	73 20		 jae	 SHORT $LN2@push_back

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  00017	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  0001a	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 453  :         return _Myres > _Small_string_capacity;

  0001d	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 436  :         if (_Large_mode_engaged()) {

  00020	76 02		 jbe	 SHORT $LN5@push_back

; 437  :             _Result = _Unfancy(_Bx._Ptr);

  00022	8b 36		 mov	 esi, DWORD PTR [esi]
$LN5@push_back:

; 2296 :             _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

  00024	8a 45 08	 mov	 al, BYTE PTR __Ch$[ebp]
  00027	88 04 1e	 mov	 BYTE PTR [esi+ebx], al

; 2298 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

  0002a	c6 44 1e 01 00	 mov	 BYTE PTR [esi+ebx+1], 0
  0002f	5e		 pop	 esi

; 2311 :     }

  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
$LN2@push_back:

; 3029 :         if (max_size() - _Old_size < _Size_increase) {

  00037	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH
  0003c	8b c2		 mov	 eax, edx
  0003e	2b c3		 sub	 eax, ebx
  00040	83 f8 01	 cmp	 eax, 1
  00043	0f 82 be 00 00
	00		 jb	 $LN74@push_back
  00049	57		 push	 edi

; 3031 :         }
; 3032 : 
; 3033 :         const size_type _New_size     = _Old_size + _Size_increase;

  0004a	8d 7b 01	 lea	 edi, DWORD PTR [ebx+1]

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

  0004d	83 cf 0f	 or	 edi, 15			; 0000000fH
  00050	3b fa		 cmp	 edi, edx

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00052	76 04		 jbe	 SHORT $LN20@push_back

; 2980 :             return _Max;

  00054	8b fa		 mov	 edi, edx
  00056	eb 18		 jmp	 SHORT $LN19@push_back
$LN20@push_back:

; 2981 :         }
; 2982 : 
; 2983 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00058	8b c1		 mov	 eax, ecx
  0005a	d1 e8		 shr	 eax, 1
  0005c	2b d0		 sub	 edx, eax
  0005e	3b ca		 cmp	 ecx, edx
  00060	76 07		 jbe	 SHORT $LN21@push_back

; 2984 :             return _Max;

  00062	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
  00067	eb 07		 jmp	 SHORT $LN19@push_back
$LN21@push_back:

; 2985 :         }
; 2986 : 
; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00069	03 c1		 add	 eax, ecx
  0006b	3b f8		 cmp	 edi, eax
  0006d	0f 42 f8	 cmovb	 edi, eax
$LN19@push_back:

; 825  :         ++_Capacity; // Take null terminator into consideration

  00070	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
  00079	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3042 :         _My_data._Myres       = _New_capacity;

  0007c	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 3043 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 3044 :         if (_Old_capacity > _Small_string_capacity) {

  0007f	83 7d fc 0f	 cmp	 DWORD PTR $T1[ebp], 15	; 0000000fH
  00083	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  00086	89 45 f8	 mov	 DWORD PTR __New_ptr$1$[ebp], eax
  00089	8d 3c 18	 lea	 edi, DWORD PTR [eax+ebx]
  0008c	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0008f	89 7d f4	 mov	 DWORD PTR tv509[ebp], edi
  00092	53		 push	 ebx
  00093	76 51		 jbe	 SHORT $LN13@push_back

; 3045 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  00095	8b 3e		 mov	 edi, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00097	57		 push	 edi
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2307 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

  0009e	8b 4d f4	 mov	 ecx, DWORD PTR tv509[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2307 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

  000a4	8a 45 08	 mov	 al, BYTE PTR __Ch$[ebp]
  000a7	88 01		 mov	 BYTE PTR [ecx], al

; 2308 :                     _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  000a9	c6 41 01 00	 mov	 BYTE PTR [ecx+1], 0

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  000ad	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  000b0	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000b1	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000b7	72 12		 jb	 SHORT $LN51@push_back

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000b9	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  000bc	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000bf	2b fa		 sub	 edi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000c1	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  000c4	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000c7	77 43		 ja	 SHORT $LN50@push_back

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000c9	8b fa		 mov	 edi, edx
$LN51@push_back:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000cb	51		 push	 ecx
  000cc	57		 push	 edi
  000cd	0f ae e8	 lfence
  000d0	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3051 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000d5	8b 45 f8	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  000d8	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3051 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000db	89 06		 mov	 DWORD PTR [esi], eax
  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi

; 2311 :     }

  000df	5b		 pop	 ebx
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c2 04 00	 ret	 4
$LN13@push_back:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000e6	56		 push	 esi
  000e7	50		 push	 eax
  000e8	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2307 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

  000ed	8a 45 08	 mov	 al, BYTE PTR __Ch$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000f0	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2307 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

  000f3	88 07		 mov	 BYTE PTR [edi], al

; 3051 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000f5	8b 45 f8	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]

; 2308 :                     _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  000f8	c6 47 01 00	 mov	 BYTE PTR [edi+1], 0
  000fc	5f		 pop	 edi

; 3051 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000fd	89 06		 mov	 DWORD PTR [esi], eax
  000ff	5e		 pop	 esi

; 2311 :     }

  00100	5b		 pop	 ebx
  00101	8b e5		 mov	 esp, ebp
  00103	5d		 pop	 ebp
  00104	c2 04 00	 ret	 4
$LN74@push_back:

; 3030 :             _Xlen_string(); // result too long

  00107	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN50@push_back:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0010c	6a 00		 push	 0
  0010e	6a 00		 push	 0
  00110	6a 00		 push	 0
  00112	6a 00		 push	 0
  00114	6a 00		 push	 0
  00116	e8 00 00 00 00	 call	 __invoke_watson
$LN71@push_back:
  0011b	cc		 int	 3
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__New_ptr$1$ = -12					; size = 4
__Old_size$1$ = -8					; size = 4
tv510 = -8						; size = 4
$T1 = -4						; size = 4
__Count$ = 8						; size = 4
__New_size$1$ = 8					; size = 4
tv523 = 8						; size = 4
__Ch$ = 12						; size = 1
tv517 = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1537 :     _CONSTEXPR20 basic_string& append(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 1538 :         // append _Count * _Ch
; 1539 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 1540 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  00011	8b c2		 mov	 eax, edx
  00013	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00016	2b c1		 sub	 eax, ecx
  00018	89 4d f8	 mov	 DWORD PTR __Old_size$1$[ebp], ecx
  0001b	89 55 fc	 mov	 DWORD PTR $T1[ebp], edx
  0001e	3b d8		 cmp	 ebx, eax
  00020	77 30		 ja	 SHORT $LN2@append

; 1541 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1542 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00022	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00025	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 435  :         value_type* _Result = _Bx._Buf;

  00028	8b c7		 mov	 eax, edi

; 453  :         return _Myres > _Small_string_capacity;

  0002a	83 fa 0f	 cmp	 edx, 15			; 0000000fH

; 436  :         if (_Large_mode_engaged()) {

  0002d	76 02		 jbe	 SHORT $LN5@append

; 437  :             _Result = _Unfancy(_Bx._Ptr);

  0002f	8b 07		 mov	 eax, DWORD PTR [edi]
$LN5@append:

; 1543 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 1544 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

  00031	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 493  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  00034	0f be 45 0c	 movsx	 eax, BYTE PTR __Ch$[ebp]
  00038	53		 push	 ebx
  00039	50		 push	 eax
  0003a	56		 push	 esi
  0003b	e8 00 00 00 00	 call	 _memset
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1545 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00043	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0

; 1558 :     }

  00047	8b c7		 mov	 eax, edi
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8
$LN2@append:

; 3029 :         if (max_size() - _Old_size < _Size_increase) {

  00052	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00057	2b c1		 sub	 eax, ecx
  00059	3b c3		 cmp	 eax, ebx
  0005b	0f 82 f0 00 00
	00		 jb	 $LN82@append

; 3031 :         }
; 3032 : 
; 3033 :         const size_type _New_size     = _Old_size + _Size_increase;

  00061	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

  00064	8b f0		 mov	 esi, eax

; 3033 :         const size_type _New_size     = _Old_size + _Size_increase;

  00066	89 45 08	 mov	 DWORD PTR __New_size$1$[ebp], eax

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

  00069	83 ce 0f	 or	 esi, 15			; 0000000fH
  0006c	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00072	76 07		 jbe	 SHORT $LN23@append

; 2980 :             return _Max;

  00074	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  00079	eb 1e		 jmp	 SHORT $LN22@append
$LN23@append:

; 2981 :         }
; 2982 : 
; 2983 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0007b	8b ca		 mov	 ecx, edx
  0007d	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00082	d1 e9		 shr	 ecx, 1
  00084	2b c1		 sub	 eax, ecx
  00086	3b d0		 cmp	 edx, eax
  00088	76 07		 jbe	 SHORT $LN24@append

; 2984 :             return _Max;

  0008a	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  0008f	eb 08		 jmp	 SHORT $LN22@append
$LN24@append:

; 2985 :         }
; 2986 : 
; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00091	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  00094	3b f0		 cmp	 esi, eax
  00096	0f 42 f0	 cmovb	 esi, eax
$LN22@append:

; 825  :         ++_Capacity; // Take null terminator into consideration

  00099	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3041 :         _My_data._Mysize      = _New_size;

  000a2	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000a5	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3044 :         if (_Old_capacity > _Small_string_capacity) {

  000a8	83 7d fc 0f	 cmp	 DWORD PTR $T1[ebp], 15	; 0000000fH
  000ac	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  000af	0f be 4d 0c	 movsx	 ecx, BYTE PTR __Ch$[ebp]
  000b3	89 4d 0c	 mov	 DWORD PTR tv517[ebp], ecx
  000b6	8b 4d f8	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  000b9	89 77 14	 mov	 DWORD PTR [edi+20], esi
  000bc	89 45 f4	 mov	 DWORD PTR __New_ptr$1$[ebp], eax
  000bf	51		 push	 ecx
  000c0	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  000c3	8d 14 1e	 lea	 edx, DWORD PTR [esi+ebx]
  000c6	89 75 08	 mov	 DWORD PTR tv523[ebp], esi
  000c9	89 55 f8	 mov	 DWORD PTR tv510[ebp], edx
  000cc	76 59		 jbe	 SHORT $LN16@append

; 3045 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  000ce	8b 37		 mov	 esi, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d0	56		 push	 esi
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 _memcpy

; 493  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  000d7	53		 push	 ebx
  000d8	ff 75 0c	 push	 DWORD PTR tv517[ebp]
  000db	ff 75 08	 push	 DWORD PTR tv523[ebp]
  000de	e8 00 00 00 00	 call	 _memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1555 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  000e3	8b 45 f8	 mov	 eax, DWORD PTR tv510[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 493  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  000e6	83 c4 18	 add	 esp, 24			; 00000018H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  000e9	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  000ec	41		 inc	 ecx

; 1555 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  000ed	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000f0	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000f6	72 12		 jb	 SHORT $LN57@append

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f8	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  000fb	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000fe	2b f2		 sub	 esi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00100	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  00103	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00106	77 4e		 ja	 SHORT $LN56@append

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00108	8b f2		 mov	 esi, edx
$LN57@append:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0010a	51		 push	 ecx
  0010b	56		 push	 esi
  0010c	0f ae e8	 lfence
  0010f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1549 :         return _Reallocate_grow_by(

  00114	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00117	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1549 :         return _Reallocate_grow_by(

  0011a	89 07		 mov	 DWORD PTR [edi], eax

; 1558 :     }

  0011c	8b c7		 mov	 eax, edi
  0011e	5f		 pop	 edi
  0011f	5e		 pop	 esi
  00120	5b		 pop	 ebx
  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c2 08 00	 ret	 8
$LN16@append:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00127	57		 push	 edi
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 _memcpy

; 493  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  0012e	53		 push	 ebx
  0012f	ff 75 0c	 push	 DWORD PTR tv517[ebp]
  00132	56		 push	 esi
  00133	e8 00 00 00 00	 call	 _memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1555 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00138	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 493  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  0013b	83 c4 18	 add	 esp, 24			; 00000018H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1555 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0013e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1549 :         return _Reallocate_grow_by(

  00141	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
  00144	89 07		 mov	 DWORD PTR [edi], eax

; 1558 :     }

  00146	8b c7		 mov	 eax, edi
  00148	5f		 pop	 edi
  00149	5e		 pop	 esi
  0014a	5b		 pop	 ebx
  0014b	8b e5		 mov	 esp, ebp
  0014d	5d		 pop	 ebp
  0014e	c2 08 00	 ret	 8
$LN82@append:

; 3030 :             _Xlen_string(); // result too long

  00151	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN56@append:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00156	6a 00		 push	 0
  00158	6a 00		 push	 0
  0015a	6a 00		 push	 0
  0015c	6a 00		 push	 0
  0015e	6a 00		 push	 0
  00160	e8 00 00 00 00	 call	 __invoke_watson
$LN79@append:
  00165	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__New_ptr$1$ = -16					; size = 4
__Old_size$1$ = -12					; size = 4
tv503 = -8						; size = 4
$T1 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
$T2 = 12						; size = 4
tv508 = 12						; size = 4
tv516 = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1510 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 1511 :         // append [_Ptr, _Ptr + _Count)
; 1512 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 1513 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  00011	8b c2		 mov	 eax, edx
  00013	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  00016	2b c6		 sub	 eax, esi
  00018	89 75 f4	 mov	 DWORD PTR __Old_size$1$[ebp], esi
  0001b	89 55 fc	 mov	 DWORD PTR $T1[ebp], edx
  0001e	3b d8		 cmp	 ebx, eax
  00020	77 2d		 ja	 SHORT $LN2@append

; 1514 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1515 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00022	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
  00025	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 435  :         value_type* _Result = _Bx._Buf;

  00028	8b c7		 mov	 eax, edi

; 453  :         return _Myres > _Small_string_capacity;

  0002a	83 fa 0f	 cmp	 edx, 15			; 0000000fH

; 436  :         if (_Large_mode_engaged()) {

  0002d	76 02		 jbe	 SHORT $LN5@append

; 437  :             _Result = _Unfancy(_Bx._Ptr);

  0002f	8b 07		 mov	 eax, DWORD PTR [edi]
$LN5@append:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00031	53		 push	 ebx
  00032	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1517 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00035	03 f0		 add	 esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00037	56		 push	 esi
  00038	e8 00 00 00 00	 call	 _memmove
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1518 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00040	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0

; 1531 :     }

  00044	8b c7		 mov	 eax, edi
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8
$LN2@append:

; 3029 :         if (max_size() - _Old_size < _Size_increase) {

  0004f	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00054	2b c6		 sub	 eax, esi
  00056	3b c3		 cmp	 eax, ebx
  00058	0f 82 f1 00 00
	00		 jb	 $LN83@append

; 3031 :         }
; 3032 : 
; 3033 :         const size_type _New_size     = _Old_size + _Size_increase;

  0005e	8d 0c 1e	 lea	 ecx, DWORD PTR [esi+ebx]

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

  00061	83 c9 0f	 or	 ecx, 15			; 0000000fH
  00064	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0006a	76 07		 jbe	 SHORT $LN23@append

; 2980 :             return _Max;

  0006c	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  00071	eb 24		 jmp	 SHORT $LN81@append
$LN23@append:

; 2981 :         }
; 2982 : 
; 2983 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00073	8b c2		 mov	 eax, edx
  00075	d1 e8		 shr	 eax, 1
  00077	89 45 0c	 mov	 DWORD PTR tv508[ebp], eax
  0007a	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0007f	2b 45 0c	 sub	 eax, DWORD PTR tv508[ebp]
  00082	3b d0		 cmp	 edx, eax
  00084	76 07		 jbe	 SHORT $LN24@append

; 2984 :             return _Max;

  00086	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  0008b	eb 0a		 jmp	 SHORT $LN81@append
$LN24@append:

; 2985 :         }
; 2986 : 
; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0008d	8b 45 0c	 mov	 eax, DWORD PTR tv508[ebp]
  00090	03 c2		 add	 eax, edx
  00092	3b c8		 cmp	 ecx, eax
  00094	0f 42 c8	 cmovb	 ecx, eax
$LN81@append:

; 825  :         ++_Capacity; // Take null terminator into consideration

  00097	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0009a	89 4d 0c	 mov	 DWORD PTR $T2[ebp], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3041 :         _My_data._Mysize      = _New_size;

  000a3	8d 0c 1e	 lea	 ecx, DWORD PTR [esi+ebx]
  000a6	89 45 f0	 mov	 DWORD PTR __New_ptr$1$[ebp], eax
  000a9	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000ac	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3042 :         _My_data._Myres       = _New_capacity;

  000af	8b 4d 0c	 mov	 ecx, DWORD PTR $T2[ebp]
  000b2	89 4f 14	 mov	 DWORD PTR [edi+20], ecx

; 3043 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  000b5	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  000b8	89 4d 0c	 mov	 DWORD PTR tv516[ebp], ecx
  000bb	03 cb		 add	 ecx, ebx

; 3044 :         if (_Old_capacity > _Small_string_capacity) {

  000bd	83 7d fc 0f	 cmp	 DWORD PTR $T1[ebp], 15	; 0000000fH
  000c1	89 4d f8	 mov	 DWORD PTR tv503[ebp], ecx
  000c4	76 5c		 jbe	 SHORT $LN16@append
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c6	ff 75 f4	 push	 DWORD PTR __Old_size$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3045 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  000c9	8b 37		 mov	 esi, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000cb	56		 push	 esi
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 _memcpy
  000d2	53		 push	 ebx
  000d3	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  000d6	ff 75 0c	 push	 DWORD PTR tv516[ebp]
  000d9	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1528 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  000de	8b 45 f8	 mov	 eax, DWORD PTR tv503[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000e1	83 c4 18	 add	 esp, 24			; 00000018H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  000e4	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  000e7	41		 inc	 ecx

; 1528 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  000e8	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000eb	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000f1	72 12		 jb	 SHORT $LN57@append

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f3	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  000f6	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000f9	2b f2		 sub	 esi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000fb	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  000fe	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00101	77 51		 ja	 SHORT $LN56@append

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00103	8b f2		 mov	 esi, edx
$LN57@append:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00105	51		 push	 ecx
  00106	56		 push	 esi
  00107	0f ae e8	 lfence
  0010a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1522 :         return _Reallocate_grow_by(

  0010f	8b 45 f0	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00112	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1522 :         return _Reallocate_grow_by(

  00115	89 07		 mov	 DWORD PTR [edi], eax

; 1531 :     }

  00117	8b c7		 mov	 eax, edi
  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi
  0011b	5b		 pop	 ebx
  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c2 08 00	 ret	 8
$LN16@append:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00122	56		 push	 esi
  00123	57		 push	 edi
  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 _memcpy
  0012a	53		 push	 ebx
  0012b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0012e	ff 75 0c	 push	 DWORD PTR tv516[ebp]
  00131	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1528 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00136	8b 45 f8	 mov	 eax, DWORD PTR tv503[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00139	83 c4 18	 add	 esp, 24			; 00000018H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1528 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0013c	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1522 :         return _Reallocate_grow_by(

  0013f	8b 45 f0	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
  00142	89 07		 mov	 DWORD PTR [edi], eax

; 1531 :     }

  00144	8b c7		 mov	 eax, edi
  00146	5f		 pop	 edi
  00147	5e		 pop	 esi
  00148	5b		 pop	 ebx
  00149	8b e5		 mov	 esp, ebp
  0014b	5d		 pop	 ebp
  0014c	c2 08 00	 ret	 8
$LN83@append:

; 3030 :             _Xlen_string(); // result too long

  0014f	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN56@append:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00154	6a 00		 push	 0
  00156	6a 00		 push	 0
  00158	6a 00		 push	 0
  0015a	6a 00		 push	 0
  0015c	6a 00		 push	 0
  0015e	e8 00 00 00 00	 call	 __invoke_watson
$LN79@append:
  00163	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1383 :         _Tidy_deallocate();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 785  :         : _Mypair(_Zero_then_variadic_args_t{}) { // construct from _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 881  :         if (_Count > max_size()) {

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	0f 57 c0	 xorps	 xmm0, xmm0

; 785  :         : _Mypair(_Zero_then_variadic_args_t{}) { // construct from _Count * _Ch

  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0000d	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

  00010	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00017	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0

; 881  :         if (_Count > max_size()) {

  0001e	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  00024	77 7c		 ja	 SHORT $LN46@basic_stri

; 883  :         }
; 884  : 
; 885  :         auto& _Al       = _Getal();
; 886  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 887  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 888  : 
; 889  :         if (_Count <= _Small_string_capacity) {

  00026	83 fb 0f	 cmp	 ebx, 15			; 0000000fH
  00029	77 25		 ja	 SHORT $LN18@basic_stri
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 493  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  0002b	0f be 45 0c	 movsx	 eax, BYTE PTR __Ch$[ebp]
  0002f	53		 push	 ebx
  00030	50		 push	 eax
  00031	57		 push	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 890  :             _My_data._Mysize = _Count;

  00032	89 5f 10	 mov	 DWORD PTR [edi+16], ebx

; 891  :             _My_data._Myres  = _Small_string_capacity;

  00035	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 493  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  0003c	e8 00 00 00 00	 call	 _memset
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 895  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  00044	c6 04 3b 00	 mov	 BYTE PTR [ebx+edi], 0

; 786  :         _Construct<_Construct_strategy::_From_char>(_Ch, _Count);
; 787  :     }

  00048	8b c7		 mov	 eax, edi
  0004a	5f		 pop	 edi
  0004b	5b		 pop	 ebx
  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
$LN18@basic_stri:

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

  00050	83 cb 0f	 or	 ebx, 15			; 0000000fH
  00053	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00059	76 07		 jbe	 SHORT $LN24@basic_stri

; 2980 :             return _Max;

  0005b	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  00060	eb 0a		 jmp	 SHORT $LN23@basic_stri
$LN24@basic_stri:

; 2981 :         }
; 2982 : 
; 2983 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 2984 :             return _Max;
; 2985 :         }
; 2986 : 
; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00062	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  00067	3b d8		 cmp	 ebx, eax
  00069	0f 42 d8	 cmovb	 ebx, eax
$LN23@basic_stri:

; 825  :         ++_Capacity; // Take null terminator into consideration

  0006c	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  0006f	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 493  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  00076	0f be 4d 0c	 movsx	 ecx, BYTE PTR __Ch$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 912  :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

  0007a	8b f0		 mov	 esi, eax

; 914  : 
; 915  :         _My_data._Mysize = _Count;

  0007c	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 493  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  0007f	50		 push	 eax
  00080	51		 push	 ecx
  00081	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 913  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00082	89 37		 mov	 DWORD PTR [edi], esi

; 914  : 
; 915  :         _My_data._Mysize = _Count;

  00084	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 916  :         _My_data._Myres  = _New_capacity;

  00087	89 5f 14	 mov	 DWORD PTR [edi+20], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 493  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  0008a	e8 00 00 00 00	 call	 _memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 919  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  0008f	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 493  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  00092	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 919  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  00095	c6 04 06 00	 mov	 BYTE PTR [esi+eax], 0

; 786  :         _Construct<_Construct_strategy::_From_char>(_Ch, _Count);
; 787  :     }

  00099	8b c7		 mov	 eax, edi

; 919  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  0009b	5e		 pop	 esi

; 786  :         _Construct<_Construct_strategy::_From_char>(_Ch, _Count);
; 787  :     }

  0009c	5f		 pop	 edi
  0009d	5b		 pop	 ebx
  0009e	5d		 pop	 ebp
  0009f	c2 08 00	 ret	 8
$LN46@basic_stri:

; 882  :             _Xlen_string(); // result too long

  000a2	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN44@basic_stri:
  000a7	cc		 int	 3
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 531  :     _Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlen_strin:
  0000a	cc		 int	 3
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 107  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 108  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN18@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN18@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 144  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 145  :     }

  00003	8b c1		 mov	 eax, ecx

; 66   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 67   :     {
; 68   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 144  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 145  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN13@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN8@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN8@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 97   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 92   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 73   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 75   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h
;	COMDAT _wmemcmp
_TEXT	SEGMENT
___index$ = -8						; size = 4
tv369 = -8						; size = 4
tv393 = -8						; size = 4
tv396 = -4						; size = 4
___mask$1$ = -4						; size = 4
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
tv391 = 12						; size = 4
__N$ = 16						; size = 4
_wmemcmp PROC						; COMDAT

; 349  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 350  :         size_t __count = 0;
; 351  : 
; 352  :     #if !defined(_M_CEE)
; 353  :     #if defined(_M_ARM64) || defined(_M_ARM64EC) || defined(_M_HYBRID_X86_ARM64)
; 354  : 
; 355  :         unsigned long __index = 0;
; 356  :         wchar_t const* __s1 = _S1;
; 357  :         wchar_t const* __s2 = _S2;
; 358  : 
; 359  :         while (__count + 8 <= _N)
; 360  :         {
; 361  :             uint16x8_t __v1 = vreinterpretq_u16_u8(vld1q_u8((unsigned char const *)__s1));
; 362  :             uint16x8_t __v2 = vreinterpretq_u16_u8(vld1q_u8((unsigned char const *)__s2));
; 363  :             __v1 = vceqq_u16(__v1, __v2);
; 364  :             unsigned __int64 __mask = vget_lane_u64(vreinterpret_u64_u8(vshrn_n_u16(__v1, 4)), 0);
; 365  :             __mask = ~__mask;
; 366  :             if (__mask != 0)
; 367  :             {
; 368  :                 _BitScanForward64(&__index, __mask);
; 369  :                 __index >>= 3;
; 370  :                 return _S1[__count + __index] < _S2[__count + __index] ? -1 : 1;
; 371  :             }
; 372  : 
; 373  :             __count += 8;
; 374  :             __s1 += 8;
; 375  :             __s2 += 8;
; 376  :         }
; 377  : 
; 378  :         if (__count + 4 <= _N)
; 379  :         {
; 380  :             uint16x4_t __v1 = vreinterpret_u16_u8(vld1_u8((unsigned char const *)__s1));
; 381  :             uint16x4_t __v2 = vreinterpret_u16_u8(vld1_u8((unsigned char const *)__s2));
; 382  :             __v1 = veor_u16(__v1, __v2);
; 383  :             unsigned __int64 __mask = vget_lane_u64(vreinterpret_u64_u16(__v1), 0);
; 384  :             if (__mask != 0)
; 385  :             {
; 386  :                 _BitScanForward64(&__index, __mask);
; 387  :                 __index >>= 4;
; 388  :                 return _S1[__count + __index] < _S2[__count + __index] ? -1 : 1;
; 389  :             }
; 390  : 
; 391  :             __count += 4;
; 392  :         }
; 393  : 
; 394  :     #elif (defined(_M_IX86) && _M_IX86_FP >= 2) || defined(_M_X64)
; 395  : 
; 396  :         unsigned long __index = 0;
; 397  :         wchar_t const* __s1 = _S1;

  00006	8b 55 08	 mov	 edx, DWORD PTR __S1$[ebp]
  00009	33 c0		 xor	 eax, eax
  0000b	56		 push	 esi

; 398  :         wchar_t const* __s2 = _S2;

  0000c	8b 75 0c	 mov	 esi, DWORD PTR __S2$[ebp]
  0000f	57		 push	 edi

; 399  : 
; 400  :     #if !defined(__clang__) || defined(__AVX2__)
; 401  :         if (_Avx2WmemEnabled)

  00010	8b 7d 10	 mov	 edi, DWORD PTR __N$[ebp]
  00013	89 45 f8	 mov	 DWORD PTR ___index$[ebp], eax
  00016	39 05 00 00 00
	00		 cmp	 DWORD PTR __Avx2WmemEnabled, eax
  0001c	74 40		 je	 SHORT $LN17@wmemcmp

; 402  :         {
; 403  :             while (__count + 16 <= _N)

  0001e	83 ff 10	 cmp	 edi, 16			; 00000010H
  00021	72 3b		 jb	 SHORT $LN17@wmemcmp
  00023	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]
  00026	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL2@wmemcmp:

; 404  :             {
; 405  :                 __m256i __v1 = _mm256_loadu_si256((__m256i const*)__s1);
; 406  :                 __m256i __v2 = _mm256_loadu_si256((__m256i const*)__s2);
; 407  :                 __v1 = _mm256_cmpeq_epi16(__v1, __v2);

  00030	c5 fe 6f 06	 vmovdqu ymm0, YMMWORD PTR [esi]
  00034	c5 fd 75 02	 vpcmpeqw ymm0, ymm0, YMMWORD PTR [edx]

; 408  :                 unsigned int __mask = (unsigned int)_mm256_movemask_epi8(__v1);

  00038	c5 fd d7 f8	 vpmovmskb edi, ymm0
  0003c	89 7d fc	 mov	 DWORD PTR ___mask$1$[ebp], edi

; 409  :                 if (__mask != 0xffffffff)

  0003f	83 ff ff	 cmp	 edi, -1
  00042	8b 7d 10	 mov	 edi, DWORD PTR __N$[ebp]
  00045	0f 85 97 00 00
	00		 jne	 $LN19@wmemcmp

; 414  :                 }
; 415  :                 __count += 16;

  0004b	83 c1 10	 add	 ecx, 16			; 00000010H
  0004e	83 c0 10	 add	 eax, 16			; 00000010H

; 416  :                 __s1 += 16;

  00051	83 c2 20	 add	 edx, 32			; 00000020H

; 417  :                 __s2 += 16;

  00054	83 c6 20	 add	 esi, 32			; 00000020H
  00057	3b cf		 cmp	 ecx, edi
  00059	76 d5		 jbe	 SHORT $LL2@wmemcmp

; 474  :         {
; 475  :             if (_S1[__count] != _S2[__count])

  0005b	c5 f8 77	 vzeroupper
$LN17@wmemcmp:

; 418  :             }
; 419  :         }
; 420  :     #endif
; 421  : 
; 422  :         while (__count + 8 <= _N)

  0005e	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  00061	89 4d fc	 mov	 DWORD PTR tv396[ebp], ecx
  00064	3b cf		 cmp	 ecx, edi
  00066	77 35		 ja	 SHORT $LN5@wmemcmp
  00068	c7 45 f8 ff ff
	00 00		 mov	 DWORD PTR tv369[ebp], 65535 ; 0000ffffH
  0006f	90		 npad	 1
$LL4@wmemcmp:

; 423  :         {
; 424  :             __m128i __v1 = _mm_loadu_si128((__m128i const*)__s1);
; 425  :             __m128i __v2 = _mm_loadu_si128((__m128i const*)__s2);

  00070	0f 10 0e	 movups	 xmm1, XMMWORD PTR [esi]
  00073	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]

; 426  :             __v1 = _mm_cmpeq_epi16(__v1, __v2);

  00076	66 0f 75 c8	 pcmpeqw xmm1, xmm0

; 427  :             unsigned short __mask = (unsigned short)_mm_movemask_epi8(__v1);

  0007a	66 0f d7 c9	 pmovmskb ecx, xmm1
  0007e	0f b7 c9	 movzx	 ecx, cx

; 428  :             if (__mask != 0xffff)

  00081	66 3b 4d f8	 cmp	 cx, WORD PTR tv369[ebp]
  00085	75 38		 jne	 SHORT $LN20@wmemcmp

; 429  :             {
; 430  :                 _BitScanForward(&__index, (unsigned long)~__mask);
; 431  :                 __index >>= 1;
; 432  :                 return _S1[__count + __index] < _S2[__count + __index] ? -1 : 1;
; 433  :             }
; 434  :             __count += 8;

  00087	8b 4d fc	 mov	 ecx, DWORD PTR tv396[ebp]
  0008a	83 c0 08	 add	 eax, 8
  0008d	83 c1 08	 add	 ecx, 8

; 435  :             __s1 += 8;

  00090	83 c2 10	 add	 edx, 16			; 00000010H

; 436  :             __s2 += 8;

  00093	83 c6 10	 add	 esi, 16			; 00000010H
  00096	89 4d fc	 mov	 DWORD PTR tv396[ebp], ecx
  00099	3b cf		 cmp	 ecx, edi
  0009b	76 d3		 jbe	 SHORT $LL4@wmemcmp
$LN5@wmemcmp:

; 437  :         }
; 438  : 
; 439  :     #if defined(_M_IX86)
; 440  :         if (__count + 4 <= _N)

  0009d	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  000a0	3b cf		 cmp	 ecx, edi
  000a2	77 69		 ja	 SHORT $LN12@wmemcmp

; 441  :         {
; 442  :             __m128i __v1 = _mm_loadu_si64(__s1);

  000a4	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]

; 443  :             __m128i __v2 = _mm_loadu_si64(__s2);

  000a8	f3 0f 7e 0e	 movq	 xmm1, QWORD PTR [esi]

; 444  :             __v1 = _mm_cmpeq_epi16(__v1, __v2);

  000ac	66 0f 75 c8	 pcmpeqw xmm1, xmm0

; 445  :             unsigned char __mask = (unsigned char)_mm_movemask_epi8(__v1);

  000b0	66 0f d7 d1	 pmovmskb edx, xmm1

; 446  :             if (__mask != 0xff)

  000b4	80 fa ff	 cmp	 dl, 255			; 000000ffH
  000b7	74 52		 je	 SHORT $LN13@wmemcmp

; 447  :             {
; 448  :                 _BitScanForward(&__index, (unsigned long)~__mask);

  000b9	0f ae e8	 lfence
  000bc	0f b6 ca	 movzx	 ecx, dl
$LN20@wmemcmp:

; 482  :     }

  000bf	8b 55 0c	 mov	 edx, DWORD PTR __S2$[ebp]
  000c2	f7 d1		 not	 ecx
  000c4	0f bc c9	 bsf	 ecx, ecx
  000c7	5f		 pop	 edi
  000c8	d1 e9		 shr	 ecx, 1
  000ca	03 c8		 add	 ecx, eax
  000cc	8b 45 08	 mov	 eax, DWORD PTR __S1$[ebp]
  000cf	5e		 pop	 esi
  000d0	66 8b 04 48	 mov	 ax, WORD PTR [eax+ecx*2]
  000d4	66 3b 04 4a	 cmp	 ax, WORD PTR [edx+ecx*2]
  000d8	1b c0		 sbb	 eax, eax
  000da	83 e0 fe	 and	 eax, -2			; fffffffeH
  000dd	40		 inc	 eax
  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c3		 ret	 0
$LN19@wmemcmp:

; 410  :                 {
; 411  :                     _BitScanForward(&__index, ~__mask);

  000e2	8b 4d fc	 mov	 ecx, DWORD PTR ___mask$1$[ebp]

; 412  :                     __index >>= 1;
; 413  :                     return _S1[__count + __index] < _S2[__count + __index] ? -1 : 1;

  000e5	8b 55 0c	 mov	 edx, DWORD PTR __S2$[ebp]
  000e8	f7 d1		 not	 ecx
  000ea	0f bc c9	 bsf	 ecx, ecx
  000ed	d1 e9		 shr	 ecx, 1
  000ef	03 c8		 add	 ecx, eax
  000f1	8b 45 08	 mov	 eax, DWORD PTR __S1$[ebp]
  000f4	66 8b 04 48	 mov	 ax, WORD PTR [eax+ecx*2]
  000f8	66 3b 04 4a	 cmp	 ax, WORD PTR [edx+ecx*2]
  000fc	1b c0		 sbb	 eax, eax
  000fe	83 e0 fe	 and	 eax, -2			; fffffffeH
  00101	40		 inc	 eax
  00102	c5 f8 77	 vzeroupper
  00105	5f		 pop	 edi

; 482  :     }

  00106	5e		 pop	 esi
  00107	8b e5		 mov	 esp, ebp
  00109	5d		 pop	 ebp
  0010a	c3		 ret	 0
$LN13@wmemcmp:

; 449  :                 __index >>= 1;
; 450  :                 return _S1[__count + __index] < _S2[__count + __index] ? -1 : 1;
; 451  :             }
; 452  : 
; 453  :             __count += 4;

  0010b	8b c1		 mov	 eax, ecx
$LN12@wmemcmp:

; 454  :         }
; 455  :     #else
; 456  :         if (__count + 4 <= _N)
; 457  :         {
; 458  :             unsigned __int64 __v1 = *(unsigned __int64*)__s1;
; 459  :             unsigned __int64 __v2 = *(unsigned __int64*)__s2;
; 460  :             if (__v1 != __v2)
; 461  :             {
; 462  :                 _BitScanForward64(&__index, (__v1 ^ __v2));
; 463  :                 __index >>= 4;
; 464  :                 return _S1[__count + __index] < _S2[__count + __index] ? -1 : 1;
; 465  :             }
; 466  : 
; 467  :             __count += 4;
; 468  :         }
; 469  :     #endif // defined(_M_IX86)
; 470  :     #endif // (defined(_M_IX86) && _M_IX86_FP >= 2) || defined(_M_X64)
; 471  :     #endif // !defined(_M_CEE)
; 472  : 
; 473  :         for (; __count < _N; ++__count)

  0010d	3b c7		 cmp	 eax, edi
  0010f	73 33		 jae	 SHORT $LN7@wmemcmp
  00111	8b 55 0c	 mov	 edx, DWORD PTR __S2$[ebp]
  00114	8b 4d 08	 mov	 ecx, DWORD PTR __S1$[ebp]
  00117	2b ca		 sub	 ecx, edx
  00119	89 4d 08	 mov	 DWORD PTR __S1$[ebp], ecx
  0011c	8d 34 42	 lea	 esi, DWORD PTR [edx+eax*2]
  0011f	90		 npad	 1
$LL8@wmemcmp:

; 474  :         {
; 475  :             if (_S1[__count] != _S2[__count])

  00120	0f b7 14 31	 movzx	 edx, WORD PTR [ecx+esi]
  00124	8b ca		 mov	 ecx, edx
  00126	89 4d f8	 mov	 DWORD PTR tv393[ebp], ecx
  00129	0f b7 0e	 movzx	 ecx, WORD PTR [esi]
  0012c	8b f9		 mov	 edi, ecx
  0012e	89 7d 0c	 mov	 DWORD PTR tv391[ebp], edi
  00131	8b 7d 10	 mov	 edi, DWORD PTR __N$[ebp]
  00134	66 3b d1	 cmp	 dx, cx
  00137	75 13		 jne	 SHORT $LN21@wmemcmp

; 454  :         }
; 455  :     #else
; 456  :         if (__count + 4 <= _N)
; 457  :         {
; 458  :             unsigned __int64 __v1 = *(unsigned __int64*)__s1;
; 459  :             unsigned __int64 __v2 = *(unsigned __int64*)__s2;
; 460  :             if (__v1 != __v2)
; 461  :             {
; 462  :                 _BitScanForward64(&__index, (__v1 ^ __v2));
; 463  :                 __index >>= 4;
; 464  :                 return _S1[__count + __index] < _S2[__count + __index] ? -1 : 1;
; 465  :             }
; 466  : 
; 467  :             __count += 4;
; 468  :         }
; 469  :     #endif // defined(_M_IX86)
; 470  :     #endif // (defined(_M_IX86) && _M_IX86_FP >= 2) || defined(_M_X64)
; 471  :     #endif // !defined(_M_CEE)
; 472  : 
; 473  :         for (; __count < _N; ++__count)

  00139	8b 4d 08	 mov	 ecx, DWORD PTR __S1$[ebp]
  0013c	40		 inc	 eax
  0013d	83 c6 02	 add	 esi, 2
  00140	3b c7		 cmp	 eax, edi
  00142	72 dc		 jb	 SHORT $LL8@wmemcmp
$LN7@wmemcmp:
  00144	5f		 pop	 edi

; 478  :             }
; 479  :         }
; 480  : 
; 481  :         return 0;

  00145	33 c0		 xor	 eax, eax

; 482  :     }

  00147	5e		 pop	 esi
  00148	8b e5		 mov	 esp, ebp
  0014a	5d		 pop	 ebp
  0014b	c3		 ret	 0
$LN21@wmemcmp:

; 476  :             {
; 477  :                 return _S1[__count] < _S2[__count] ? -1 : 1;

  0014c	8b 45 0c	 mov	 eax, DWORD PTR tv391[ebp]
  0014f	66 39 45 f8	 cmp	 WORD PTR tv393[ebp], ax
  00153	5f		 pop	 edi
  00154	1b c0		 sbb	 eax, eax
  00156	83 e0 fe	 and	 eax, -2			; fffffffeH
  00159	40		 inc	 eax

; 482  :     }

  0015a	5e		 pop	 esi
  0015b	8b e5		 mov	 esp, ebp
  0015d	5d		 pop	 ebp
  0015e	c3		 ret	 0
_wmemcmp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _sprintf_s
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_sprintf_s PROC						; COMDAT

; 1823 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1491 :         int const _Result = __stdio_common_vsprintf_s(

  00003	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	ff 30		 push	 DWORD PTR [eax]
  0001c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf_s

; 1492 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1493 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1494 : 
; 1495 :         return _Result < 0 ? -1 : _Result;

  00021	83 c9 ff	 or	 ecx, -1
  00024	83 c4 1c	 add	 esp, 28			; 0000001cH
  00027	85 c0		 test	 eax, eax
  00029	0f 48 c1	 cmovs	 eax, ecx

; 1824 :             int _Result;
; 1825 :             va_list _ArgList;
; 1826 :             __crt_va_start(_ArgList, _Format);
; 1827 :             _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1828 :             __crt_va_end(_ArgList);
; 1829 :             return _Result;
; 1830 :         }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_sprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
